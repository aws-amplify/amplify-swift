//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoRoutesClientTypes {

    /// The input fails to satisfy the constraints specified by the Amazon Location service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the Validation Exception Field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such field is supported.
        case unknownField
        /// No such operation is supported.
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .missing,
                .other,
                .unknownField,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownField: return "UnknownField"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field where the invalid entry was detected.
        /// This member is required.
        public internal(set) var fieldList: [GeoRoutesClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public internal(set) var reason: GeoRoutesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GeoRoutesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GeoRoutesClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension GeoRoutesClientTypes {

    /// Features that are allowed while calculating. a route
    public struct IsolineAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes while calculating the route.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating the route.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
    public struct Corridor: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        /// This member is required.
        public var lineString: [[Swift.Double]]?
        /// Radius that defines the width of the corridor.
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            lineString: [[Swift.Double]]? = nil,
            radius: Swift.Int? = nil
        )
        {
            self.lineString = lineString
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.Corridor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.
    public struct PolylineCorridor: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        /// This member is required.
        public var polyline: Swift.String?
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        /// This member is required.
        public var radius: Swift.Int?

        public init(
            polyline: Swift.String? = nil,
            radius: Swift.Int? = nil
        )
        {
            self.polyline = polyline
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.PolylineCorridor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// The avoidance geometry, to be included while calculating the route.
    public struct IsolineAvoidanceAreaGeometry: Swift.Sendable {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public var corridor: GeoRoutesClientTypes.Corridor?
        /// A list of Polygon will be excluded for calculating isolines, the list can only contain 1 polygon.
        public var polygon: [[[Swift.Double]]]?
        /// Geometry defined as an encoded corridor â€“ a polyline with a radius that defines the width of the corridor. For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylineCorridor: GeoRoutesClientTypes.PolylineCorridor?
        /// A list of PolylinePolygon's that are excluded for calculating isolines, the list can only contain 1 polygon. For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            corridor: GeoRoutesClientTypes.Corridor? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylineCorridor: GeoRoutesClientTypes.PolylineCorridor? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", corridor: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylineCorridor: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The area to be avoided.
    public struct IsolineAvoidanceArea: Swift.Sendable {
        /// Exceptions to the provided avoidance geometry, to be included while calculating the route.
        public var except: [GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry]?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry?

        public init(
            except: [GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry]? = nil,
            geometry: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry? = nil
        )
        {
            self.except = except
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone category to be avoided.
    public struct IsolineAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        public var category: GeoRoutesClientTypes.IsolineZoneCategory?

        public init(
            category: GeoRoutesClientTypes.IsolineZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public struct IsolineAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.IsolineAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating the route.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways while calculating the route.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads while calculating the route.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries while calculating the route.
        public var ferries: Swift.Bool?
        /// Avoid roads that have seasonal closure while calculating the route.
        public var seasonalClosure: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollRoads: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels while calculating the route.
        public var tunnels: Swift.Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.IsolineAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.IsolineAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            seasonalClosure: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.IsolineAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    public enum MatchingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case matchAny
        case matchMostSignificantRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchingStrategy] {
            return [
                .matchAny,
                .matchMostSignificantRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .matchAny: return "MatchAny"
            case .matchMostSignificantRoad: return "MatchMostSignificantRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Isoline matching related options.
    public struct IsolineMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad. Unit: meters
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.IsolineMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum SideOfStreetMatchingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anyStreet
        case dividedStreetOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [SideOfStreetMatchingStrategy] {
            return [
                .anyStreet,
                .dividedStreetOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anyStreet: return "AnyStreet"
            case .dividedStreetOnly: return "DividedStreetOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct IsolineSideOfStreetOptions: Swift.Sendable {
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.IsolineSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Destination related options.
    public struct IsolineDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.IsolineMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    public enum GeometryFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case flexiblePolyline
        case simple
        case sdkUnknown(Swift.String)

        public static var allCases: [GeometryFormat] {
            return [
                .flexiblePolyline,
                .simple
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .flexiblePolyline: return "FlexiblePolyline"
            case .simple: return "Simple"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Isoline granularity related options.
    public struct IsolineGranularityOptions: Swift.Sendable {
        /// Maximum number of points of returned Isoline.
        public var maxPoints: Swift.Int?
        /// Maximum resolution of the returned isoline. Unit: centimeters
        public var maxResolution: Swift.Int

        public init(
            maxPoints: Swift.Int? = nil,
            maxResolution: Swift.Int = 0
        )
        {
            self.maxPoints = maxPoints
            self.maxResolution = maxResolution
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineOptimizationObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accurateCalculation
        case balancedCalculation
        case fastCalculation
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineOptimizationObjective] {
            return [
                .accurateCalculation,
                .balancedCalculation,
                .fastCalculation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accurateCalculation: return "AccurateCalculation"
            case .balancedCalculation: return "BalancedCalculation"
            case .fastCalculation: return "FastCalculation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutingObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastestRoute
        case shortestRoute
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingObjective] {
            return [
                .fastestRoute,
                .shortestRoute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastestRoute: return "FastestRoute"
            case .shortestRoute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for the property.
    public struct IsolineOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.IsolineMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.IsolineMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.IsolineSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.
    public struct IsolineThresholds: Swift.Sendable {
        /// Distance to be used for the isoline calculation.
        public var distance: [Swift.Int]?
        /// Time to be used for the isoline calculation.
        public var time: [Swift.Int]?

        public init(
            distance: [Swift.Int]? = nil,
            time: [Swift.Int]? = nil
        )
        {
            self.distance = distance
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum TrafficUsage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ignoreTrafficData
        case useTrafficData
        case sdkUnknown(Swift.String)

        public static var allCases: [TrafficUsage] {
            return [
                .ignoreTrafficData,
                .useTrafficData
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ignoreTrafficData: return "IgnoreTrafficData"
            case .useTrafficData: return "UseTrafficData"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to traffic.
    public struct IsolineTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data. Unit: seconds
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineEngineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case electric
        case internalCombustion
        case pluginHybrid
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineEngineType] {
            return [
                .electric,
                .internalCombustion,
                .pluginHybrid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .electric: return "Electric"
            case .internalCombustion: return "InternalCombustion"
            case .pluginHybrid: return "PluginHybrid"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The vehicle license plate.
    public struct IsolineVehicleLicensePlate: Swift.Sendable {
        /// The last character of the License Plate.
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for vehicles.
    public struct IsolineCarOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for the property.
    public struct IsolineScooterOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed specified. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct IsolineTrailerOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            axleCount: Swift.Int? = nil,
            trailerCount: Swift.Int? = nil
        )
        {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum IsolineTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [IsolineTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type. Unit: Kilograms
    public struct WeightPerAxleGroup: Swift.Sendable {
        /// Weight for quad axle group. Unit: Kilograms
        public var quad: Swift.Int
        /// Weight for quad quint group. Unit: Kilograms
        public var quint: Swift.Int
        /// Weight for single axle group. Unit: Kilograms
        public var single: Swift.Int
        /// Weight for tandem axle group. Unit: Kilograms
        public var tandem: Swift.Int
        /// Weight for triple axle group. Unit: Kilograms
        public var triple: Swift.Int

        public init(
            quad: Swift.Int = 0,
            quint: Swift.Int = 0,
            single: Swift.Int = 0,
            tandem: Swift.Int = 0,
            triple: Swift.Int = 0
        )
        {
            self.quad = quad
            self.quint = quint
            self.single = single
            self.tandem = tandem
            self.triple = triple
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct IsolineTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.IsolineEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity. Unit: Kilograms
        public var grossWeight: Swift.Int
        /// List of Hazardous cargo contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.IsolineHazardousCargoType]?
        /// Height of the vehicle. Unit: centimeters
        public var height: Swift.Int
        /// Height of the vehicle above its first axle. Unit: centimeters
        public var heightAboveFirstAxle: Swift.Int
        /// Kingpin to rear axle length of the vehicle. Unit: centimeters
        public var kpraLength: Swift.Int
        /// Length of the vehicle. Unit: centimeters
        public var length: Swift.Int
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate?
        /// Maximum speed specified. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached. Unit: kilograms
        public var payloadCapacity: Swift.Int
        /// Number of tires on the vehicle.
        public var tireCount: Swift.Int?
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.IsolineTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.IsolineTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type. Unit: Kilograms
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle. Unit: centimeters
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            engineType: GeoRoutesClientTypes.IsolineEngineType? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.IsolineHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            heightAboveFirstAxle: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.IsolineVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            tireCount: Swift.Int? = nil,
            trailer: GeoRoutesClientTypes.IsolineTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.IsolineTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct IsolineTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.IsolineCarOptions?
        /// Travel mode options when the provided travel mode is "Scooter"
        public var scooter: GeoRoutesClientTypes.IsolineScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.IsolineTruckOptions?

        public init(
            car: GeoRoutesClientTypes.IsolineCarOptions? = nil,
            scooter: GeoRoutesClientTypes.IsolineScooterOptions? = nil,
            truck: GeoRoutesClientTypes.IsolineTruckOptions? = nil
        )
        {
            self.car = car
            self.scooter = scooter
            self.truck = truck
        }
    }
}

public struct CalculateIsolinesInput: Swift.Sendable {
    /// Features that are allowed while calculating. a route
    public var allow: GeoRoutesClientTypes.IsolineAllowOptions?
    /// Time of arrival at the destination. Time format: YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.IsolineAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The final position for the route. In the World Geodetic System (WGS 84) format: [longitude, latitude].
    public var destination: [Swift.Double]?
    /// Destination related options.
    public var destinationOptions: GeoRoutesClientTypes.IsolineDestinationOptions?
    /// The format of the returned IsolineGeometry. Default Value:FlexiblePolyline
    public var isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Defines the granularity of the returned Isoline
    public var isolineGranularity: GeoRoutesClientTypes.IsolineGranularityOptions?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for when calculating an isoline. AccurateCalculation generates an isoline of higher granularity that is more precise. FastCalculation generates an isoline faster by reducing the granularity, and in turn the quality of the isoline. BalancedCalculation generates an isoline by balancing between quality and performance. Default Value: BalancedCalculation
    public var optimizeIsolineFor: GeoRoutesClientTypes.IsolineOptimizationObjective?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The start position for the route.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.IsolineOriginOptions?
    /// Threshold to be used for the isoline calculation. Up to 3 thresholds per provided type can be requested.
    /// This member is required.
    public var thresholds: GeoRoutesClientTypes.IsolineThresholds?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.IsolineTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. The mode Scooter also applies to motorcycles, set to Scooter when wanted to calculate options for motorcycles. Default Value: Car
    public var travelMode: GeoRoutesClientTypes.IsolineTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.IsolineTravelModeOptions?

    public init(
        allow: GeoRoutesClientTypes.IsolineAllowOptions? = nil,
        arrivalTime: Swift.String? = nil,
        avoid: GeoRoutesClientTypes.IsolineAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.IsolineDestinationOptions? = nil,
        isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        isolineGranularity: GeoRoutesClientTypes.IsolineGranularityOptions? = nil,
        key: Swift.String? = nil,
        optimizeIsolineFor: GeoRoutesClientTypes.IsolineOptimizationObjective? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.IsolineOriginOptions? = nil,
        thresholds: GeoRoutesClientTypes.IsolineThresholds? = nil,
        traffic: GeoRoutesClientTypes.IsolineTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.IsolineTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.IsolineTravelModeOptions? = nil
    )
    {
        self.allow = allow
        self.arrivalTime = arrivalTime
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.isolineGeometryFormat = isolineGeometryFormat
        self.isolineGranularity = isolineGranularity
        self.key = key
        self.optimizeIsolineFor = optimizeIsolineFor
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origin = origin
        self.originOptions = originOptions
        self.thresholds = thresholds
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension CalculateIsolinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateIsolinesInput(allow: \(Swift.String(describing: allow)), arrivalTime: \(Swift.String(describing: arrivalTime)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), isolineGeometryFormat: \(Swift.String(describing: isolineGeometryFormat)), isolineGranularity: \(Swift.String(describing: isolineGranularity)), optimizeIsolineFor: \(Swift.String(describing: optimizeIsolineFor)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), originOptions: \(Swift.String(describing: originOptions)), thresholds: \(Swift.String(describing: thresholds)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Geometry of the connection between different Isoline components.
    public struct IsolineConnectionGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.IsolineConnectionGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineConnectionGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
    public struct IsolineConnection: Swift.Sendable {
        /// Index of the polygon corresponding to the "from" component of the connection. The polygon is available from Isoline[].Geometries.
        /// This member is required.
        public var fromPolygonIndex: Swift.Int?
        /// The isoline geometry.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.IsolineConnectionGeometry?
        /// Index of the polygon corresponding to the "to" component of the connection. The polygon is available from Isoline[].Geometries.
        /// This member is required.
        public var toPolygonIndex: Swift.Int?

        public init(
            fromPolygonIndex: Swift.Int? = nil,
            geometry: GeoRoutesClientTypes.IsolineConnectionGeometry? = nil,
            toPolygonIndex: Swift.Int? = nil
        )
        {
            self.fromPolygonIndex = fromPolygonIndex
            self.geometry = geometry
            self.toPolygonIndex = toPolygonIndex
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the connection between different Isoline components.
    public struct IsolineShapeGeometry: Swift.Sendable {
        /// A list of Isoline Polygons, for each isoline polygon, it contains polygons of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings).
        public var polygon: [[[Swift.Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            polygon: [[[Swift.Double]]]? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.IsolineShapeGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsolineShapeGeometry(polygon: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Calculated isolines and associated properties.
    public struct Isoline: Swift.Sendable {
        /// Isolines may contain multiple components, if these components are connected by ferry links. These components are returned as separate polygons while the ferry links are returned as connections.
        /// This member is required.
        public var connections: [GeoRoutesClientTypes.IsolineConnection]?
        /// Distance threshold corresponding to the calculated Isoline.
        public var distanceThreshold: Swift.Int
        /// Geometries for the Calculated isolines.
        /// This member is required.
        public var geometries: [GeoRoutesClientTypes.IsolineShapeGeometry]?
        /// Time threshold corresponding to the calculated isoline.
        public var timeThreshold: Swift.Int

        public init(
            connections: [GeoRoutesClientTypes.IsolineConnection]? = nil,
            distanceThreshold: Swift.Int = 0,
            geometries: [GeoRoutesClientTypes.IsolineShapeGeometry]? = nil,
            timeThreshold: Swift.Int = 0
        )
        {
            self.connections = connections
            self.distanceThreshold = distanceThreshold
            self.geometries = geometries
            self.timeThreshold = timeThreshold
        }
    }
}

public struct CalculateIsolinesOutput: Swift.Sendable {
    /// Time of arrival at the destination. This parameter is returned only if the Destination parameters was provided in the request. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The format of the returned IsolineGeometry. Default Value:FlexiblePolyline
    /// This member is required.
    public var isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Calculated isolines and associated properties.
    /// This member is required.
    public var isolines: [GeoRoutesClientTypes.Isoline]?
    /// The pricing bucket for which the query is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// Snapped destination that was used for the Isoline calculation.
    public var snappedDestination: [Swift.Double]?
    /// Snapped origin that was used for the Isoline calculation.
    public var snappedOrigin: [Swift.Double]?

    public init(
        arrivalTime: Swift.String? = nil,
        departureTime: Swift.String? = nil,
        isolineGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        isolines: [GeoRoutesClientTypes.Isoline]? = nil,
        pricingBucket: Swift.String? = nil,
        snappedDestination: [Swift.Double]? = nil,
        snappedOrigin: [Swift.Double]? = nil
    )
    {
        self.arrivalTime = arrivalTime
        self.departureTime = departureTime
        self.isolineGeometryFormat = isolineGeometryFormat
        self.isolines = isolines
        self.pricingBucket = pricingBucket
        self.snappedDestination = snappedDestination
        self.snappedOrigin = snappedOrigin
    }
}

extension CalculateIsolinesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateIsolinesOutput(arrivalTime: \(Swift.String(describing: arrivalTime)), departureTime: \(Swift.String(describing: departureTime)), isolineGeometryFormat: \(Swift.String(describing: isolineGeometryFormat)), isolines: \(Swift.String(describing: isolines)), pricingBucket: \(Swift.String(describing: pricingBucket)), snappedDestination: \"CONTENT_REDACTED\", snappedOrigin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Allow Options related to the route matrix.
    public struct RouteMatrixAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes while calculating the route.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating the route.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct RouteMatrixAvoidanceAreaGeometry: Swift.Sendable {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from second item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.polygon = polygon
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Area to be avoided.
    public struct RouteMatrixAvoidanceArea: Swift.Sendable {
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry?

        public init(
            geometry: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry? = nil
        )
        {
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone categories to be avoided.
    public struct RouteMatrixAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        public var category: GeoRoutesClientTypes.RouteMatrixZoneCategory?

        public init(
            category: GeoRoutesClientTypes.RouteMatrixZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the route matrix.
    public struct RouteMatrixAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.RouteMatrixAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating the route.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways while calculating the route.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads while calculating the route.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries while calculating the route.
        public var ferries: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollRoads: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels while calculating the route.
        public var tunnels: Swift.Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.RouteMatrixAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    /// Matching options.
    public struct RouteMatrixMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad. Unit: meters
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct RouteMatrixSideOfStreetOptions: Swift.Sendable {
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options related to the destination.
    public struct RouteMatrixDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route destination.
    public struct RouteMatrixDestination: Swift.Sendable {
        /// Destination related options.
        public var options: GeoRoutesClientTypes.RouteMatrixDestinationOptions?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            options: GeoRoutesClientTypes.RouteMatrixDestinationOptions? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.options = options
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixDestination(options: \(Swift.String(describing: options)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Exclusion options.
    public struct RouteMatrixExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    /// Origin related options.
    public struct RouteMatrixOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatrixMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// The start position for the route.
    public struct RouteMatrixOrigin: Swift.Sendable {
        /// Origin related options.
        public var options: GeoRoutesClientTypes.RouteMatrixOriginOptions?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            options: GeoRoutesClientTypes.RouteMatrixOriginOptions? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.options = options
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixOrigin: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixOrigin(options: \(Swift.String(describing: options)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Provides the circle that was used while calculating the route.
    public struct RouteMatrixAutoCircle: Swift.Sendable {
        /// The margin provided for the calculation.
        public var margin: Swift.Int
        /// The maximum size of the radius provided for the calculation.
        public var maxRadius: Swift.Int

        public init(
            margin: Swift.Int = 0,
            maxRadius: Swift.Int = 0
        )
        {
            self.margin = margin
            self.maxRadius = maxRadius
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry defined as a circle. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
    public struct Circle: Swift.Sendable {
        /// Center of the Circle defined in longitude and latitude coordinates. Example: [-123.1174, 49.2847] represents the position with longitude -123.1174 and latitude 49.2847.
        /// This member is required.
        public var center: [Swift.Double]?
        /// Radius of the Circle. Unit: meters
        /// This member is required.
        public var radius: Swift.Double?

        public init(
            center: [Swift.Double]? = nil,
            radius: Swift.Double? = nil
        )
        {
            self.center = center
            self.radius = radius
        }
    }
}

extension GeoRoutesClientTypes.Circle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the routing boundary.
    public struct RouteMatrixBoundaryGeometry: Swift.Sendable {
        /// Provides the circle that was used while calculating the route.
        public var autoCircle: GeoRoutesClientTypes.RouteMatrixAutoCircle?
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a circle. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
        public var circle: GeoRoutesClientTypes.Circle?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?

        public init(
            autoCircle: GeoRoutesClientTypes.RouteMatrixAutoCircle? = nil,
            boundingBox: [Swift.Double]? = nil,
            circle: GeoRoutesClientTypes.Circle? = nil,
            polygon: [[[Swift.Double]]]? = nil
        )
        {
            self.autoCircle = autoCircle
            self.boundingBox = boundingBox
            self.circle = circle
            self.polygon = polygon
        }
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundaryGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatrixBoundaryGeometry(autoCircle: \(Swift.String(describing: autoCircle)), boundingBox: \"CONTENT_REDACTED\", circle: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid.
    public struct RouteMatrixBoundary: Swift.Sendable {
        /// Geometry of the area to be avoided.
        public var geometry: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry?
        /// No restrictions in terms of a routing boundary, and is typically used for longer routes.
        public var unbounded: Swift.Bool?

        public init(
            geometry: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry? = nil,
            unbounded: Swift.Bool? = nil
        )
        {
            self.geometry = geometry
            self.unbounded = unbounded
        }
    }
}

extension GeoRoutesClientTypes {

    /// Traffic related options.
    public struct RouteMatrixTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The vehicle License Plate.
    public struct RouteMatrixVehicleLicensePlate: Swift.Sendable {
        /// The last character of the License Plate.
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the car.
    public struct RouteMatrixCarOptions: Swift.Sendable {
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        /// Maximum speed Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Scooter"
    public struct RouteMatrixScooterOptions: Swift.Sendable {
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        /// Maximum speed. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct RouteMatrixTrailerOptions: Swift.Sendable {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct RouteMatrixTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Gross weight of the vehicle including trailers, and goods at capacity. Unit: Kilograms
        public var grossWeight: Swift.Int
        /// List of Hazardous cargo contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteMatrixHazardousCargoType]?
        /// Height of the vehicle. Unit: centimeters
        public var height: Swift.Int
        /// Kingpin to rear axle length of the vehicle Unit: centimeters
        public var kpraLength: Swift.Int
        /// Length of the vehicle. Unit: centimeters
        public var length: Swift.Int
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?
        /// Maximum speed Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached. Unit: kilograms
        public var payloadCapacity: Swift.Int
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.RouteMatrixTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteMatrixTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type.
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle. Unit: centimeters
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RouteMatrixHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.RouteMatrixTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.RouteMatrixTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct RouteMatrixTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.RouteMatrixCarOptions?
        /// Travel mode options when the provided travel mode is "Scooter"
        public var scooter: GeoRoutesClientTypes.RouteMatrixScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.RouteMatrixTruckOptions?

        public init(
            car: GeoRoutesClientTypes.RouteMatrixCarOptions? = nil,
            scooter: GeoRoutesClientTypes.RouteMatrixScooterOptions? = nil,
            truck: GeoRoutesClientTypes.RouteMatrixTruckOptions? = nil
        )
        {
            self.car = car
            self.scooter = scooter
            self.truck = truck
        }
    }
}

public struct CalculateRouteMatrixInput: Swift.Sendable {
    /// Features that are allowed while calculating. a route
    public var allow: GeoRoutesClientTypes.RouteMatrixAllowOptions?
    /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// List of destinations for the route.
    /// This member is required.
    public var destinations: [GeoRoutesClientTypes.RouteMatrixDestination]?
    /// Features to be strictly excluded while calculating the route.
    public var exclude: GeoRoutesClientTypes.RouteMatrixExclusionOptions?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The position in longitude and latitude for the origin.
    /// This member is required.
    public var origins: [GeoRoutesClientTypes.RouteMatrixOrigin]?
    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
    /// This member is required.
    public var routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.RouteMatrixTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
    public var travelMode: GeoRoutesClientTypes.RouteMatrixTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.RouteMatrixTravelModeOptions?

    public init(
        allow: GeoRoutesClientTypes.RouteMatrixAllowOptions? = nil,
        avoid: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destinations: [GeoRoutesClientTypes.RouteMatrixDestination]? = nil,
        exclude: GeoRoutesClientTypes.RouteMatrixExclusionOptions? = nil,
        key: Swift.String? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origins: [GeoRoutesClientTypes.RouteMatrixOrigin]? = nil,
        routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary? = nil,
        traffic: GeoRoutesClientTypes.RouteMatrixTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.RouteMatrixTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RouteMatrixTravelModeOptions? = nil
    )
    {
        self.allow = allow
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destinations = destinations
        self.exclude = exclude
        self.key = key
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origins = origins
        self.routingBoundary = routingBoundary
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension CalculateRouteMatrixInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRouteMatrixInput(allow: \(Swift.String(describing: allow)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinations: \(Swift.String(describing: destinations)), exclude: \(Swift.String(describing: exclude)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), origins: \(Swift.String(describing: origins)), routingBoundary: \(Swift.String(describing: routingBoundary)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RouteMatrixErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noMatch
        case noMatchDestination
        case noMatchOrigin
        case noRoute
        case other
        case outOfBounds
        case outOfBoundsDestination
        case outOfBoundsOrigin
        case violation
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteMatrixErrorCode] {
            return [
                .noMatch,
                .noMatchDestination,
                .noMatchOrigin,
                .noRoute,
                .other,
                .outOfBounds,
                .outOfBoundsDestination,
                .outOfBoundsOrigin,
                .violation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noMatch: return "NoMatch"
            case .noMatchDestination: return "NoMatchDestination"
            case .noMatchOrigin: return "NoMatchOrigin"
            case .noRoute: return "NoRoute"
            case .other: return "Other"
            case .outOfBounds: return "OutOfBounds"
            case .outOfBoundsDestination: return "OutOfBoundsDestination"
            case .outOfBoundsOrigin: return "OutOfBoundsOrigin"
            case .violation: return "Violation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.
    public struct RouteMatrixEntry: Swift.Sendable {
        /// The total distance of travel for the route.
        /// This member is required.
        public var distance: Swift.Int
        /// The expected duration of travel for the route. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Error code that occurred during calculation of the route.
        public var error: GeoRoutesClientTypes.RouteMatrixErrorCode?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            error: GeoRoutesClientTypes.RouteMatrixErrorCode? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.error = error
        }
    }
}

public struct CalculateRouteMatrixOutput: Swift.Sendable {
    /// The count of error results in the route matrix. If this number is 0, all routes were calculated successfully.
    /// This member is required.
    public var errorCount: Swift.Int?
    /// The pricing bucket for which the query is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The calculated route matrix containing the results for all pairs of Origins to Destination positions. Each row corresponds to one entry in Origins. Each entry in the row corresponds to the route from that entry in Origins to an entry in Destination positions.
    /// This member is required.
    public var routeMatrix: [[GeoRoutesClientTypes.RouteMatrixEntry]]?
    /// Boundary within which the matrix is to be calculated. All data, origins and destinations outside the boundary are considered invalid. When request routing boundary was set as AutoCircle, the response routing boundary will return Circle derived from the AutoCircle settings.
    /// This member is required.
    public var routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary?

    public init(
        errorCount: Swift.Int? = nil,
        pricingBucket: Swift.String? = nil,
        routeMatrix: [[GeoRoutesClientTypes.RouteMatrixEntry]]? = nil,
        routingBoundary: GeoRoutesClientTypes.RouteMatrixBoundary? = nil
    )
    {
        self.errorCount = errorCount
        self.pricingBucket = pricingBucket
        self.routeMatrix = routeMatrix
        self.routingBoundary = routingBoundary
    }
}

extension GeoRoutesClientTypes {

    /// Features that are allowed while calculating. a route
    public struct RouteAllowOptions: Swift.Sendable {
        /// Allow Hot (High Occupancy Toll) lanes while calculating the route.
        public var hot: Swift.Bool?
        /// Allow Hov (High Occupancy vehicle) lanes while calculating the route.
        public var hov: Swift.Bool?

        public init(
            hot: Swift.Bool? = nil,
            hov: Swift.Bool? = nil
        )
        {
            self.hot = hot
            self.hov = hov
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct RouteAvoidanceAreaGeometry: Swift.Sendable {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?
        /// Geometry defined as a corridor - a LineString with a radius that defines the width of the corridor.
        public var corridor: GeoRoutesClientTypes.Corridor?
        /// Geometry defined as a polygon with only one linear ring.
        public var polygon: [[[Swift.Double]]]?
        /// Geometry defined as an encoded corridor - an encoded polyline with a radius that defines the width of the corridor.
        public var polylineCorridor: GeoRoutesClientTypes.PolylineCorridor?
        /// A list of Isoline PolylinePolygon, for each isoline PolylinePolygon, it contains PolylinePolygon of the first linear ring (the outer ring) and from 2nd item to the last item (the inner rings). For more information on polyline encoding, see [https://github.com/heremaps/flexiblepolyline/blob/master/README.md](https://github.com/heremaps/flexiblepolyline/blob/master/README.md).
        public var polylinePolygon: [Swift.String]?

        public init(
            boundingBox: [Swift.Double]? = nil,
            corridor: GeoRoutesClientTypes.Corridor? = nil,
            polygon: [[[Swift.Double]]]? = nil,
            polylineCorridor: GeoRoutesClientTypes.PolylineCorridor? = nil,
            polylinePolygon: [Swift.String]? = nil
        )
        {
            self.boundingBox = boundingBox
            self.corridor = corridor
            self.polygon = polygon
            self.polylineCorridor = polylineCorridor
            self.polylinePolygon = polylinePolygon
        }
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\", corridor: \"CONTENT_REDACTED\", polygon: \"CONTENT_REDACTED\", polylineCorridor: \"CONTENT_REDACTED\", polylinePolygon: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Areas to be avoided.
    public struct RouteAvoidanceArea: Swift.Sendable {
        /// Exceptions to the provided avoidance geometry, to be included while calculating the route.
        public var except: [GeoRoutesClientTypes.RouteAvoidanceAreaGeometry]?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry?

        public init(
            except: [GeoRoutesClientTypes.RouteAvoidanceAreaGeometry]? = nil,
            geometry: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry? = nil
        )
        {
            self.except = except
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteZoneCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case congestionPricing
        case environmental
        case vignette
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteZoneCategory] {
            return [
                .congestionPricing,
                .environmental,
                .vignette
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .congestionPricing: return "CongestionPricing"
            case .environmental: return "Environmental"
            case .vignette: return "Vignette"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Zone categories to be avoided.
    public struct RouteAvoidanceZoneCategory: Swift.Sendable {
        /// Zone category to be avoided.
        /// This member is required.
        public var category: GeoRoutesClientTypes.RouteZoneCategory?

        public init(
            category: GeoRoutesClientTypes.RouteZoneCategory? = nil
        )
        {
            self.category = category
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to areas to be avoided.
    public struct RouteAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.RouteAvoidanceArea]?
        /// Avoid car-shuttle-trains while calculating the route.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways while calculating the route.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads while calculating the route.
        public var dirtRoads: Swift.Bool?
        /// Avoid ferries while calculating the route.
        public var ferries: Swift.Bool?
        /// Avoid roads that have seasonal closure while calculating the route.
        public var seasonalClosure: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollRoads: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollTransponders: Swift.Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.String]?
        /// Avoid tunnels while calculating the route.
        public var tunnels: Swift.Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?
        /// Zone categories to be avoided.
        public var zoneCategories: [GeoRoutesClientTypes.RouteAvoidanceZoneCategory]?

        public init(
            areas: [GeoRoutesClientTypes.RouteAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            seasonalClosure: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tollTransponders: Swift.Bool? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil,
            zoneCategories: [GeoRoutesClientTypes.RouteAvoidanceZoneCategory]? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.seasonalClosure = seasonalClosure
            self.tollRoads = tollRoads
            self.tollTransponders = tollTransponders
            self.truckRoadTypes = truckRoadTypes
            self.tunnels = tunnels
            self.uTurns = uTurns
            self.zoneCategories = zoneCategories
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to route matching.
    public struct RouteMatchingOptions: Swift.Sendable {
        /// Attempts to match the provided position to a road similar to the provided name.
        public var nameHint: Swift.String?
        /// If the distance to a highway/bridge/tunnel/sliproad is within threshold, the waypoint will be snapped to the highway/bridge/tunnel/sliproad. Unit: meters
        public var onRoadThreshold: Swift.Int
        /// Considers all roads within the provided radius to match the provided destination to. The roads that are considered are determined by the provided Strategy. Unit: Meters
        public var radius: Swift.Int
        /// Strategy that defines matching of the position onto the road network. MatchAny considers all roads possible, whereas MatchMostSignificantRoad matches to the most significant road.
        public var strategy: GeoRoutesClientTypes.MatchingStrategy?

        public init(
            nameHint: Swift.String? = nil,
            onRoadThreshold: Swift.Int = 0,
            radius: Swift.Int = 0,
            strategy: GeoRoutesClientTypes.MatchingStrategy? = nil
        )
        {
            self.nameHint = nameHint
            self.onRoadThreshold = onRoadThreshold
            self.radius = radius
            self.strategy = strategy
        }
    }
}

extension GeoRoutesClientTypes.RouteMatchingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteMatchingOptions(onRoadThreshold: \(Swift.String(describing: onRoadThreshold)), radius: \(Swift.String(describing: radius)), strategy: \(Swift.String(describing: strategy)), nameHint: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct RouteSideOfStreetOptions: Swift.Sendable {
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.RouteSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Options related to the destination.
    public struct RouteDestinationOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid U-turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?
        /// Duration of the stop. Unit: seconds
        public var stopDuration: Swift.Int

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil,
            stopDuration: Swift.Int = 0
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Interval of the driver work-rest schedule. Stops are added to fulfil the provided rest schedule.
    public struct RouteDriverScheduleInterval: Swift.Sendable {
        /// Maximum allowed driving time before stopping to rest. Unit: seconds
        /// This member is required.
        public var driveDuration: Swift.Int
        /// Resting time before the driver can continue driving. Unit: seconds
        /// This member is required.
        public var restDuration: Swift.Int

        public init(
            driveDuration: Swift.Int = 0,
            restDuration: Swift.Int = 0
        )
        {
            self.driveDuration = driveDuration
            self.restDuration = restDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver related options.
    public struct RouteDriverOptions: Swift.Sendable {
        /// Driver work-rest schedule. Stops are added to fulfil the provided rest schedule.
        public var schedule: [GeoRoutesClientTypes.RouteDriverScheduleInterval]?

        public init(
            schedule: [GeoRoutesClientTypes.RouteDriverScheduleInterval]? = nil
        )
        {
            self.schedule = schedule
        }
    }
}

extension GeoRoutesClientTypes {

    /// Exclusion options for the route.
    public struct RouteExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    public enum MeasurementSystem: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case imperial
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [MeasurementSystem] {
            return [
                .imperial,
                .metric
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .imperial: return "Imperial"
            case .metric: return "Metric"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case elevation
        case incidents
        case passThroughWaypoints
        case summary
        case tolls
        case travelStepInstructions
        case truckRoadTypes
        case typicalDuration
        case zones
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegAdditionalFeature] {
            return [
                .elevation,
                .incidents,
                .passThroughWaypoints,
                .summary,
                .tolls,
                .travelStepInstructions,
                .truckRoadTypes,
                .typicalDuration,
                .zones
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .elevation: return "Elevation"
            case .incidents: return "Incidents"
            case .passThroughWaypoints: return "PassThroughWaypoints"
            case .summary: return "Summary"
            case .tolls: return "Tolls"
            case .travelStepInstructions: return "TravelStepInstructions"
            case .truckRoadTypes: return "TruckRoadTypes"
            case .typicalDuration: return "TypicalDuration"
            case .zones: return "Zones"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Origin related options.
    public struct RouteOriginOptions: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid U-turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanAdditionalFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bestCaseDuration
        case carAccess
        case consumption
        case country
        case distance
        case duration
        case dynamicSpeed
        case functionalClassification
        case gates
        case incidents
        case names
        case notices
        case pedestrianAccess
        case railwayCrossings
        case region
        case roadAttributes
        case routeNumbers
        case scooterAccess
        case speedLimit
        case tollSystems
        case truckAccess
        case truckRoadTypes
        case typicalDuration
        case zones
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanAdditionalFeature] {
            return [
                .bestCaseDuration,
                .carAccess,
                .consumption,
                .country,
                .distance,
                .duration,
                .dynamicSpeed,
                .functionalClassification,
                .gates,
                .incidents,
                .names,
                .notices,
                .pedestrianAccess,
                .railwayCrossings,
                .region,
                .roadAttributes,
                .routeNumbers,
                .scooterAccess,
                .speedLimit,
                .tollSystems,
                .truckAccess,
                .truckRoadTypes,
                .typicalDuration,
                .zones
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bestCaseDuration: return "BestCaseDuration"
            case .carAccess: return "CarAccess"
            case .consumption: return "Consumption"
            case .country: return "Country"
            case .distance: return "Distance"
            case .duration: return "Duration"
            case .dynamicSpeed: return "DynamicSpeed"
            case .functionalClassification: return "FunctionalClassification"
            case .gates: return "Gates"
            case .incidents: return "Incidents"
            case .names: return "Names"
            case .notices: return "Notices"
            case .pedestrianAccess: return "PedestrianAccess"
            case .railwayCrossings: return "RailwayCrossings"
            case .region: return "Region"
            case .roadAttributes: return "RoadAttributes"
            case .routeNumbers: return "RouteNumbers"
            case .scooterAccess: return "ScooterAccess"
            case .speedLimit: return "SpeedLimit"
            case .tollSystems: return "TollSystems"
            case .truckAccess: return "TruckAccess"
            case .truckRoadTypes: return "TruckRoadTypes"
            case .typicalDuration: return "TypicalDuration"
            case .zones: return "Zones"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Type of the emission. Valid values: Euro1, Euro2, Euro3, Euro4, Euro5, Euro6, EuroEev
    public struct RouteEmissionType: Swift.Sendable {
        /// The CO 2 emission classes.
        public var co2EmissionClass: Swift.String?
        /// Type of the emission. Valid values: Euro1, Euro2, Euro3, Euro4, Euro5, Euro6, EuroEev
        /// This member is required.
        public var type: Swift.String?

        public init(
            co2EmissionClass: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.co2EmissionClass = co2EmissionClass
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollVehicleCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case minibus
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollVehicleCategory] {
            return [
                .minibus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .minibus: return "Minibus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to Tolls on a route.
    public struct RouteTollOptions: Swift.Sendable {
        /// Specifies if the user has valid transponder with access to all toll systems. This impacts toll calculation, and if true the price with transponders is used.
        public var allTransponders: Swift.Bool?
        /// Specifies if the user has valid vignettes with access for all toll roads. If a user has a vignette for a toll road, then toll cost for that road is omitted since no further payment is necessary.
        public var allVignettes: Swift.Bool?
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        public var currency: Swift.String?
        /// Emission type of the vehicle for toll cost calculation. Valid values: Euro1, Euro2, Euro3, Euro4, Euro5, Euro6, EuroEev
        public var emissionType: GeoRoutesClientTypes.RouteEmissionType?
        /// Vehicle category for toll cost calculation.
        public var vehicleCategory: GeoRoutesClientTypes.RouteTollVehicleCategory?

        public init(
            allTransponders: Swift.Bool? = nil,
            allVignettes: Swift.Bool? = nil,
            currency: Swift.String? = nil,
            emissionType: GeoRoutesClientTypes.RouteEmissionType? = nil,
            vehicleCategory: GeoRoutesClientTypes.RouteTollVehicleCategory? = nil
        )
        {
            self.allTransponders = allTransponders
            self.allVignettes = allVignettes
            self.currency = currency
            self.emissionType = emissionType
            self.vehicleCategory = vehicleCategory
        }
    }
}

extension GeoRoutesClientTypes {

    /// Traffic options for the route.
    public struct RouteTrafficOptions: Swift.Sendable {
        /// Duration for which flow traffic is considered valid. For this period, the flow traffic is used over historical traffic data. Flow traffic refers to congestion, which changes very quickly. Duration in seconds for which flow traffic event would be considered valid. While flow traffic event is valid it will be used over the historical traffic data.
        public var flowEventThresholdOverride: Swift.Int
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            flowEventThresholdOverride: Swift.Int = 0,
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.flowEventThresholdOverride = flowEventThresholdOverride
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteEngineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case electric
        case internalCombustion
        case pluginHybrid
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteEngineType] {
            return [
                .electric,
                .internalCombustion,
                .pluginHybrid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .electric: return "Electric"
            case .internalCombustion: return "InternalCombustion"
            case .pluginHybrid: return "PluginHybrid"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// License plate information of the vehicle. Currently, only the last character is used where license plate based controlled access is enforced.
    public struct RouteVehicleLicensePlate: Swift.Sendable {
        /// The last character of the License Plate.
        public var lastCharacter: Swift.String?

        public init(
            lastCharacter: Swift.String? = nil
        )
        {
            self.lastCharacter = lastCharacter
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Car"
    public struct RouteCarOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed specified. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the pedestrian.
    public struct RoutePedestrianOptions: Swift.Sendable {
        /// Walking speed in Kilometers per hour.
        public var speed: Swift.Double?

        public init(
            speed: Swift.Double? = 0.0
        )
        {
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Scooter"
    public struct RouteScooterOptions: Swift.Sendable {
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?

        public init(
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil
        )
        {
            self.engineType = engineType
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct RouteTrailerOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            axleCount: Swift.Int? = nil,
            trailerCount: Swift.Int? = nil
        )
        {
            self.axleCount = axleCount
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lightTruck
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTruckType] {
            return [
                .lightTruck,
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lightTruck: return "LightTruck"
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct RouteTruckOptions: Swift.Sendable {
        /// Total number of axles of the vehicle.
        public var axleCount: Swift.Int?
        /// Engine type of the vehicle.
        public var engineType: GeoRoutesClientTypes.RouteEngineType?
        /// Gross weight of the vehicle including trailers, and goods at capacity. Unit: Kilograms
        public var grossWeight: Swift.Int
        /// List of Hazardous cargo contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]?
        /// Height of the vehicle. Unit: centimeters
        public var height: Swift.Int
        /// Height of the vehicle above its first axle. Unit: centimeters
        public var heightAboveFirstAxle: Swift.Int
        /// Kingpin to rear axle length of the vehicle. Unit: centimeters
        public var kpraLength: Swift.Int
        /// Length of the vehicle. Unit: c
        public var length: Swift.Int
        /// The vehicle License Plate.
        public var licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate?
        /// Maximum speed Unit: KilometersPerHour
        public var maxSpeed: Swift.Double?
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: Swift.Int?
        /// Payload capacity of the vehicle and trailers attached. Unit: kilograms
        public var payloadCapacity: Swift.Int
        /// Number of tires on the vehicle.
        public var tireCount: Swift.Int?
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.RouteTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Specifies the total weight for the specified axle group. Meant for usage in countries that have different regulations based on the axle group type. Unit: Kilograms
        public var weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// Width of the vehicle. Unit: centimeters
        public var width: Swift.Int

        public init(
            axleCount: Swift.Int? = nil,
            engineType: GeoRoutesClientTypes.RouteEngineType? = nil,
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            heightAboveFirstAxle: Swift.Int = 0,
            kpraLength: Swift.Int = 0,
            length: Swift.Int = 0,
            licensePlate: GeoRoutesClientTypes.RouteVehicleLicensePlate? = nil,
            maxSpeed: Swift.Double? = 0.0,
            occupancy: Swift.Int? = nil,
            payloadCapacity: Swift.Int = 0,
            tireCount: Swift.Int? = nil,
            trailer: GeoRoutesClientTypes.RouteTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.RouteTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            weightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            width: Swift.Int = 0
        )
        {
            self.axleCount = axleCount
            self.engineType = engineType
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.heightAboveFirstAxle = heightAboveFirstAxle
            self.kpraLength = kpraLength
            self.length = length
            self.licensePlate = licensePlate
            self.maxSpeed = maxSpeed
            self.occupancy = occupancy
            self.payloadCapacity = payloadCapacity
            self.tireCount = tireCount
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.weightPerAxleGroup = weightPerAxleGroup
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct RouteTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Car"
        public var car: GeoRoutesClientTypes.RouteCarOptions?
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public var pedestrian: GeoRoutesClientTypes.RoutePedestrianOptions?
        /// Travel mode options when the provided travel mode is "Scooter"
        public var scooter: GeoRoutesClientTypes.RouteScooterOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.RouteTruckOptions?

        public init(
            car: GeoRoutesClientTypes.RouteCarOptions? = nil,
            pedestrian: GeoRoutesClientTypes.RoutePedestrianOptions? = nil,
            scooter: GeoRoutesClientTypes.RouteScooterOptions? = nil,
            truck: GeoRoutesClientTypes.RouteTruckOptions? = nil
        )
        {
            self.car = car
            self.pedestrian = pedestrian
            self.scooter = scooter
            self.truck = truck
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case turnByTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTravelStepType] {
            return [
                .default,
                .turnByTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case .turnByTurn: return "TurnByTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Waypoint between the Origin and Destination.
    public struct RouteWaypoint: Swift.Sendable {
        /// Avoids actions for the provided distance. This is typically to consider for users in moving vehicles who may not have sufficient time to make an action at an origin or a destination.
        public var avoidActionsForDistance: Swift.Int
        /// Avoid U-turns for calculation on highways and motorways.
        public var avoidUTurns: Swift.Bool?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Options to configure matching the provided position to the road network.
        public var matching: GeoRoutesClientTypes.RouteMatchingOptions?
        /// If the waypoint should not be treated as a stop. If yes, the waypoint is passed through and doesn't split the route into different legs.
        public var passThrough: Swift.Bool?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions?
        /// Duration of the stop. Unit: seconds
        public var stopDuration: Swift.Int

        public init(
            avoidActionsForDistance: Swift.Int = 0,
            avoidUTurns: Swift.Bool? = nil,
            heading: Swift.Double = 0.0,
            matching: GeoRoutesClientTypes.RouteMatchingOptions? = nil,
            passThrough: Swift.Bool? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreetOptions? = nil,
            stopDuration: Swift.Int = 0
        )
        {
            self.avoidActionsForDistance = avoidActionsForDistance
            self.avoidUTurns = avoidUTurns
            self.heading = heading
            self.matching = matching
            self.passThrough = passThrough
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.stopDuration = stopDuration
        }
    }
}

extension GeoRoutesClientTypes.RouteWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteWaypoint(avoidActionsForDistance: \(Swift.String(describing: avoidActionsForDistance)), avoidUTurns: \(Swift.String(describing: avoidUTurns)), heading: \(Swift.String(describing: heading)), matching: \(Swift.String(describing: matching)), passThrough: \(Swift.String(describing: passThrough)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), stopDuration: \(Swift.String(describing: stopDuration)), position: \"CONTENT_REDACTED\")"}
}

public struct CalculateRoutesInput: Swift.Sendable {
    /// Features that are allowed while calculating. a route
    public var allow: GeoRoutesClientTypes.RouteAllowOptions?
    /// Time of arrival at the destination. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var arrivalTime: Swift.String?
    /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, it violates the avoidance and the returned response produces a notice for the violation.
    public var avoid: GeoRoutesClientTypes.RouteAvoidanceOptions?
    /// Uses the current time as the time of departure.
    public var departNow: Swift.Bool?
    /// Time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The final position for the route. In the World Geodetic System (WGS 84) format: [longitude, latitude].
    /// This member is required.
    public var destination: [Swift.Double]?
    /// Destination related options.
    public var destinationOptions: GeoRoutesClientTypes.RouteDestinationOptions?
    /// Driver related options.
    public var driver: GeoRoutesClientTypes.RouteDriverOptions?
    /// Features to be strictly excluded while calculating the route.
    public var exclude: GeoRoutesClientTypes.RouteExclusionOptions?
    /// Measurement system to be used for instructions within steps in the response.
    public var instructionsMeasurementSystem: GeoRoutesClientTypes.MeasurementSystem?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// List of languages for instructions within steps in the response. Instructions in the requested language are returned only if they are available.
    public var languages: [Swift.String]?
    /// A list of optional additional parameters such as timezone that can be requested for each result.
    ///
    /// * Elevation: Retrieves the elevation information for each location.
    ///
    /// * Incidents: Provides information on traffic incidents along the route.
    ///
    /// * PassThroughWaypoints: Indicates waypoints that are passed through without stopping.
    ///
    /// * Summary: Returns a summary of the route, including distance and duration.
    ///
    /// * Tolls: Supplies toll cost information along the route.
    ///
    /// * TravelStepInstructions: Provides step-by-step instructions for travel along the route.
    ///
    /// * TruckRoadTypes: Returns information about road types suitable for trucks.
    ///
    /// * TypicalDuration: Gives typical travel duration based on historical data.
    ///
    /// * Zones: Specifies the time zone information for each waypoint.
    public var legAdditionalFeatures: [GeoRoutesClientTypes.RouteLegAdditionalFeature]?
    /// Specifies the format of the geometry returned for each leg of the route. You can choose between two different geometry encoding formats. FlexiblePolyline: A compact and precise encoding format for the leg geometry. For more information on the format, see the GitHub repository for [FlexiblePolyline](https://github.com/heremaps/flexible-polyline). Simple: A less compact encoding, which is easier to decode but may be less precise and result in larger payloads.
    public var legGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Maximum number of alternative routes to be provided in the response, if available.
    public var maxAlternatives: Swift.Int?
    /// Specifies the optimization criteria for calculating a route. Default Value: FastestRoute
    public var optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective?
    /// The start position for the route.
    /// This member is required.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.RouteOriginOptions?
    /// A list of optional features such as SpeedLimit that can be requested for a Span. A span is a section of a Leg for which the requested features have the same values.
    public var spanAdditionalFeatures: [GeoRoutesClientTypes.RouteSpanAdditionalFeature]?
    /// Toll related options.
    public var tolls: GeoRoutesClientTypes.RouteTollOptions?
    /// Traffic related options.
    public var traffic: GeoRoutesClientTypes.RouteTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
    public var travelMode: GeoRoutesClientTypes.RouteTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.RouteTravelModeOptions?
    /// Type of step returned by the response. Default provides basic steps intended for web based applications. TurnByTurn provides detailed instructions with more granularity intended for a turn based naviagtion system.
    public var travelStepType: GeoRoutesClientTypes.RouteTravelStepType?
    /// List of waypoints between the Origin and Destination.
    public var waypoints: [GeoRoutesClientTypes.RouteWaypoint]?

    public init(
        allow: GeoRoutesClientTypes.RouteAllowOptions? = nil,
        arrivalTime: Swift.String? = nil,
        avoid: GeoRoutesClientTypes.RouteAvoidanceOptions? = nil,
        departNow: Swift.Bool? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.RouteDestinationOptions? = nil,
        driver: GeoRoutesClientTypes.RouteDriverOptions? = nil,
        exclude: GeoRoutesClientTypes.RouteExclusionOptions? = nil,
        instructionsMeasurementSystem: GeoRoutesClientTypes.MeasurementSystem? = nil,
        key: Swift.String? = nil,
        languages: [Swift.String]? = nil,
        legAdditionalFeatures: [GeoRoutesClientTypes.RouteLegAdditionalFeature]? = nil,
        legGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        maxAlternatives: Swift.Int? = nil,
        optimizeRoutingFor: GeoRoutesClientTypes.RoutingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.RouteOriginOptions? = nil,
        spanAdditionalFeatures: [GeoRoutesClientTypes.RouteSpanAdditionalFeature]? = nil,
        tolls: GeoRoutesClientTypes.RouteTollOptions? = nil,
        traffic: GeoRoutesClientTypes.RouteTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.RouteTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RouteTravelModeOptions? = nil,
        travelStepType: GeoRoutesClientTypes.RouteTravelStepType? = nil,
        waypoints: [GeoRoutesClientTypes.RouteWaypoint]? = nil
    )
    {
        self.allow = allow
        self.arrivalTime = arrivalTime
        self.avoid = avoid
        self.departNow = departNow
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.driver = driver
        self.exclude = exclude
        self.instructionsMeasurementSystem = instructionsMeasurementSystem
        self.key = key
        self.languages = languages
        self.legAdditionalFeatures = legAdditionalFeatures
        self.legGeometryFormat = legGeometryFormat
        self.maxAlternatives = maxAlternatives
        self.optimizeRoutingFor = optimizeRoutingFor
        self.origin = origin
        self.originOptions = originOptions
        self.spanAdditionalFeatures = spanAdditionalFeatures
        self.tolls = tolls
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
        self.travelStepType = travelStepType
        self.waypoints = waypoints
    }
}

extension CalculateRoutesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculateRoutesInput(allow: \(Swift.String(describing: allow)), arrivalTime: \(Swift.String(describing: arrivalTime)), avoid: \(Swift.String(describing: avoid)), departNow: \(Swift.String(describing: departNow)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), driver: \(Swift.String(describing: driver)), exclude: \(Swift.String(describing: exclude)), instructionsMeasurementSystem: \(Swift.String(describing: instructionsMeasurementSystem)), languages: \(Swift.String(describing: languages)), legAdditionalFeatures: \(Swift.String(describing: legAdditionalFeatures)), legGeometryFormat: \(Swift.String(describing: legGeometryFormat)), maxAlternatives: \(Swift.String(describing: maxAlternatives)), optimizeRoutingFor: \(Swift.String(describing: optimizeRoutingFor)), originOptions: \(Swift.String(describing: originOptions)), spanAdditionalFeatures: \(Swift.String(describing: spanAdditionalFeatures)), tolls: \(Swift.String(describing: tolls)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), travelStepType: \(Swift.String(describing: travelStepType)), waypoints: \(Swift.String(describing: waypoints)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RouteResponseNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mainLanguageNotFound
        case other
        case travelTimeExceedsDriverWorkHours
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteResponseNoticeCode] {
            return [
                .mainLanguageNotFound,
                .other,
                .travelTimeExceedsDriverWorkHours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mainLanguageNotFound: return "MainLanguageNotFound"
            case .other: return "Other"
            case .travelTimeExceedsDriverWorkHours: return "TravelTimeExceedsDriverWorkHours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteNoticeImpact: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteNoticeImpact] {
            return [
                .high,
                .low
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .low: return "Low"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteResponseNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteResponseNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteResponseNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryAfterTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deboard
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryAfterTravelStepType] {
            return [
                .deboard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deboard: return "Deboard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed after the travel portion of the leg.
    public struct RouteFerryAfterTravelStep: Swift.Sendable {
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language. Only available when the TravelStepType is Default.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryAfterTravelStepType?

        public init(
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryAfterTravelStepType? = nil
        )
        {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// Position provided in the request.
    public struct RouteFerryPlace: Swift.Sendable {
        /// The name of the place.
        public var name: Swift.String?
        /// Position provided in the request.
        public var originalPosition: [Swift.Double]?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Index of the waypoint in the request.
        public var waypointIndex: Swift.Int?

        public init(
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RouteFerryPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteFerryPlace(name: \(Swift.String(describing: name)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the arrival for the leg.
    public struct RouteFerryArrival: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteFerryPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteFerryPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryBeforeTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case board
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryBeforeTravelStepType] {
            return [
                .board
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .board: return "Board"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed before the travel portion of the leg.
    public struct RouteFerryBeforeTravelStep: Swift.Sendable {
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Brief description of the step in the requested language. Only available when the TravelStepType is Default.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryBeforeTravelStepType?

        public init(
            duration: Swift.Int = 0,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryBeforeTravelStepType? = nil
        )
        {
            self.duration = duration
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the departure for the leg.
    public struct RouteFerryDeparture: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteFerryPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteFerryPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case noSchedule
        case other
        case violatedAvoidFerry
        case violatedAvoidRailFerry
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .noSchedule,
                .other,
                .violatedAvoidFerry,
                .violatedAvoidRailFerry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .noSchedule: return "NoSchedule"
            case .other: return "Other"
            case .violatedAvoidFerry: return "ViolatedAvoidFerry"
            case .violatedAvoidRailFerry: return "ViolatedAvoidRailFerry"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteFerryNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteFerryNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteFerryNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    /// The place where the waypoint is passed through and not treated as a stop.
    public struct RoutePassThroughPlace: Swift.Sendable {
        /// Position provided in the request.
        public var originalPosition: [Swift.Double]?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Index of the waypoint in the request.
        public var waypointIndex: Swift.Int?

        public init(
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.originalPosition = originalPosition
            self.position = position
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RoutePassThroughPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoutePassThroughPlace(waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// If the waypoint should be treated as a stop. If yes, the route is split up into different legs around the stop.
    public struct RoutePassThroughWaypoint: Swift.Sendable {
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePassThroughPlace?

        public init(
            geometryOffset: Swift.Int? = nil,
            place: GeoRoutesClientTypes.RoutePassThroughPlace? = nil
        )
        {
            self.geometryOffset = geometryOffset
            self.place = place
        }
    }
}

extension GeoRoutesClientTypes {

    /// The localized string.
    public struct LocalizedString: Swift.Sendable {
        /// A list of BCP 47 compliant language codes for the results to be rendered in. The request uses the regional default as the fallback if the requested language can't be provided.
        public var language: Swift.String?
        /// The value of the localized string.
        /// This member is required.
        public var value: Swift.String?

        public init(
            language: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.language = language
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// Span computed for the requested SpanAdditionalFeatures.
    public struct RouteFerrySpan: Swift.Sendable {
        /// 3 letter Country code corresponding to the Span.
        public var country: Swift.String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.
        public var distance: Swift.Int
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties. Unit: seconds
        public var duration: Swift.Int
        /// Offset in the leg geometry corresponding to the start of this span.
        public var geometryOffset: Swift.Int?
        /// Provides an array of names of the ferry span in available languages.
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public var region: Swift.String?

        public init(
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            geometryOffset: Swift.Int? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            region: Swift.String? = nil
        )
        {
            self.country = country
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.names = names
            self.region = region
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the leg.
    public struct RouteFerryOverviewSummary: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is the same as the Distance within the Overview summary.
    public struct RouteFerryTravelOnlySummary: Swift.Sendable {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int

        public init(
            duration: Swift.Int = 0
        )
        {
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is the same as the Distance within the Overview summary.
    public struct RouteFerrySummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RouteFerryOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RouteFerryTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RouteFerryOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RouteFerryTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteFerryTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case depart
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteFerryTravelStepType] {
            return [
                .arrive,
                .continue,
                .depart
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .depart: return "Depart"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed during the travel portion of the leg.
    public struct RouteFerryTravelStep: Swift.Sendable {
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language. Only available when the TravelStepType is Default.
        public var instruction: Swift.String?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteFerryTravelStepType?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteFerryTravelStepType? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// FerryLegDetails is populated when the Leg type is Ferry, and provides additional information that is specific
    public struct RouteFerryLegDetails: Swift.Sendable {
        /// Steps of a leg that must be performed after the travel portion of the leg.
        /// This member is required.
        public var afterTravelSteps: [GeoRoutesClientTypes.RouteFerryAfterTravelStep]?
        /// Details corresponding to the arrival for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RouteFerryArrival?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var beforeTravelSteps: [GeoRoutesClientTypes.RouteFerryBeforeTravelStep]?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RouteFerryDeparture?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RouteFerryNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// Route name of the ferry line.
        public var routeName: Swift.String?
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RouteFerrySpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteFerrySummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RouteFerryTravelStep]?

        public init(
            afterTravelSteps: [GeoRoutesClientTypes.RouteFerryAfterTravelStep]? = nil,
            arrival: GeoRoutesClientTypes.RouteFerryArrival? = nil,
            beforeTravelSteps: [GeoRoutesClientTypes.RouteFerryBeforeTravelStep]? = nil,
            departure: GeoRoutesClientTypes.RouteFerryDeparture? = nil,
            notices: [GeoRoutesClientTypes.RouteFerryNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            routeName: Swift.String? = nil,
            spans: [GeoRoutesClientTypes.RouteFerrySpan]? = nil,
            summary: GeoRoutesClientTypes.RouteFerrySummary? = nil,
            travelSteps: [GeoRoutesClientTypes.RouteFerryTravelStep]? = nil
        )
        {
            self.afterTravelSteps = afterTravelSteps
            self.arrival = arrival
            self.beforeTravelSteps = beforeTravelSteps
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.routeName = routeName
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }
    }
}

extension GeoRoutesClientTypes {

    /// The returned Route leg geometry.
    public struct RouteLegGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.RouteLegGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteLegGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RouteSideOfStreet: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSideOfStreet] {
            return [
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Place details corresponding to the arrival or departure.
    public struct RoutePedestrianPlace: Swift.Sendable {
        /// The name of the place.
        public var name: Swift.String?
        /// Position provided in the request.
        public var originalPosition: [Swift.Double]?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet?
        /// Index of the waypoint in the request.
        public var waypointIndex: Swift.Int?

        public init(
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RoutePedestrianPlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoutePedestrianPlace(name: \(Swift.String(describing: name)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the arrival for a leg. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public struct RoutePedestrianArrival: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePedestrianPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RoutePedestrianPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the departure for a leg. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public struct RoutePedestrianDeparture: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RoutePedestrianPlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RoutePedestrianPlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutePedestrianNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case other
        case violatedAvoidDirtRoad
        case violatedAvoidTunnel
        case violatedPedestrianOption
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutePedestrianNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .other,
                .violatedAvoidDirtRoad,
                .violatedAvoidTunnel,
                .violatedPedestrianOption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .other: return "Other"
            case .violatedAvoidDirtRoad: return "ViolatedAvoidDirtRoad"
            case .violatedAvoidTunnel: return "ViolatedAvoidTunnel"
            case .violatedPedestrianOption: return "ViolatedPedestrianOption"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RoutePedestrianNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RoutePedestrianNoticeCode?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RoutePedestrianNoticeCode? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the dynamic speed. Unit: KilometersPerHour
    public struct RouteSpanDynamicSpeedDetails: Swift.Sendable {
        /// Estimated speed while traversing the span without traffic congestion. Unit: KilometersPerHour
        public var bestCaseSpeed: Swift.Double
        /// Estimated time to turn from this span into the next. Unit: seconds
        public var turnDuration: Swift.Int
        /// Estimated speed while traversing the span under typical traffic congestion. Unit: KilometersPerHour
        public var typicalSpeed: Swift.Double

        public init(
            bestCaseSpeed: Swift.Double = 0.0,
            turnDuration: Swift.Int = 0,
            typicalSpeed: Swift.Double = 0.0
        )
        {
            self.bestCaseSpeed = bestCaseSpeed
            self.turnDuration = turnDuration
            self.typicalSpeed = typicalSpeed
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanPedestrianAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case indoors
        case noThroughTraffic
        case park
        case stairs
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanPedestrianAccessAttribute] {
            return [
                .allowed,
                .indoors,
                .noThroughTraffic,
                .park,
                .stairs,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .indoors: return "Indoors"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .park: return "Park"
            case .stairs: return "Stairs"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanRoadAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bridge
        case builtUpArea
        case controlledAccessHighway
        case dirtRoad
        case dividedRoad
        case motorway
        case privateRoad
        case ramp
        case rightHandTraffic
        case roundabout
        case tunnel
        case underConstruction
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanRoadAttribute] {
            return [
                .bridge,
                .builtUpArea,
                .controlledAccessHighway,
                .dirtRoad,
                .dividedRoad,
                .motorway,
                .privateRoad,
                .ramp,
                .rightHandTraffic,
                .roundabout,
                .tunnel,
                .underConstruction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bridge: return "Bridge"
            case .builtUpArea: return "BuiltUpArea"
            case .controlledAccessHighway: return "ControlledAccessHighway"
            case .dirtRoad: return "DirtRoad"
            case .dividedRoad: return "DividedRoad"
            case .motorway: return "Motorway"
            case .privateRoad: return "PrivateRoad"
            case .ramp: return "Ramp"
            case .rightHandTraffic: return "RightHandTraffic"
            case .roundabout: return "Roundabout"
            case .tunnel: return "Tunnel"
            case .underConstruction: return "UnderConstruction"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case east
        case north
        case south
        case west
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteDirection] {
            return [
                .east,
                .north,
                .south,
                .west
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .east: return "East"
            case .north: return "North"
            case .south: return "South"
            case .west: return "West"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route number.
    public struct RouteNumber: Swift.Sendable {
        /// Directional identifier of the route.
        public var direction: GeoRoutesClientTypes.RouteDirection?
        /// List of languages for instructions corresponding to the route number.
        public var language: Swift.String?
        /// The route number.
        /// This member is required.
        public var value: Swift.String?

        public init(
            direction: GeoRoutesClientTypes.RouteDirection? = nil,
            language: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.direction = direction
            self.language = language
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the speed limit corresponding to the span. Unit: KilometersPerHour
    public struct RouteSpanSpeedLimitDetails: Swift.Sendable {
        /// Maximum speed. Unit: KilometersPerHour
        public var maxSpeed: Swift.Double
        /// If the span doesn't have a speed limit like the Autobahn.
        public var unlimited: Swift.Bool?

        public init(
            maxSpeed: Swift.Double = 0.0,
            unlimited: Swift.Bool? = nil
        )
        {
            self.maxSpeed = maxSpeed
            self.unlimited = unlimited
        }
    }
}

extension GeoRoutesClientTypes {

    /// Span computed for the requested SpanAdditionalFeatures.
    public struct RoutePedestrianSpan: Swift.Sendable {
        /// Duration of the computed span without traffic congestion. Unit: seconds
        public var bestCaseDuration: Swift.Int
        /// 3 letter Country code corresponding to the Span.
        public var country: Swift.String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.
        public var distance: Swift.Int
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties. Unit: seconds
        public var duration: Swift.Int
        /// Dynamic speed details corresponding to the span. Unit: KilometersPerHour
        public var dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails?
        /// Functional classification of the road segment corresponding to the span.
        public var functionalClassification: Swift.Int?
        /// Offset in the leg geometry corresponding to the start of this span.
        public var geometryOffset: Swift.Int?
        /// Incidents corresponding to the span. These index into the Incidents in the parent Leg.
        public var incidents: [Swift.Int]?
        /// Provides an array of names of the pedestrian span in available languages.
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        /// Access attributes for a pedestrian corresponding to the span.
        public var pedestrianAccess: [GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute]?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public var region: Swift.String?
        /// Attributes for the road segment corresponding to the span.
        public var roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]?
        /// Designated route name or number corresponding to the span.
        public var routeNumbers: [GeoRoutesClientTypes.RouteNumber]?
        /// Speed limit details corresponding to the span. Unit: KilometersPerHour
        public var speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails?
        /// Duration of the computed span under typical traffic congestion. Unit: seconds
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails? = nil,
            functionalClassification: Swift.Int? = nil,
            geometryOffset: Swift.Int? = nil,
            incidents: [Swift.Int]? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            pedestrianAccess: [GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute]? = nil,
            region: Swift.String? = nil,
            roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]? = nil,
            routeNumbers: [GeoRoutesClientTypes.RouteNumber]? = nil,
            speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails? = nil,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.pedestrianAccess = pedestrianAccess
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.speedLimit = speedLimit
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Provides a summary of a pedestrian route step.
    public struct RoutePedestrianOverviewSummary: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step.
        /// This member is required.
        public var duration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps.
    public struct RoutePedestrianTravelOnlySummary: Swift.Sendable {
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int

        public init(
            duration: Swift.Int = 0
        )
        {
            self.duration = duration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including before travel, travel and after travel steps.
    public struct RoutePedestrianSummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RoutePedestrianOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RoutePedestrianOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the continue step.
    public struct RouteContinueStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil
        )
        {
            self.intersection = intersection
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteRoadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case highway
        case rural
        case urban
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteRoadType] {
            return [
                .highway,
                .rural,
                .urban
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .highway: return "Highway"
            case .rural: return "Rural"
            case .urban: return "Urban"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The road on the route.
    public struct RouteRoad: Swift.Sendable {
        /// Name of the road (localized).
        /// This member is required.
        public var roadName: [GeoRoutesClientTypes.LocalizedString]?
        /// Route number of the road.
        /// This member is required.
        public var routeNumber: [GeoRoutesClientTypes.RouteNumber]?
        /// Names of destinations that can be reached when traveling on the road.
        /// This member is required.
        public var towards: [GeoRoutesClientTypes.LocalizedString]?
        /// The type of road.
        public var type: GeoRoutesClientTypes.RouteRoadType?

        public init(
            roadName: [GeoRoutesClientTypes.LocalizedString]? = nil,
            routeNumber: [GeoRoutesClientTypes.RouteNumber]? = nil,
            towards: [GeoRoutesClientTypes.LocalizedString]? = nil,
            type: GeoRoutesClientTypes.RouteRoadType? = nil
        )
        {
            self.roadName = roadName
            self.routeNumber = routeNumber
            self.towards = towards
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSteeringDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `left`
        case `right`
        case straight
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSteeringDirection] {
            return [
                .left,
                .right,
                .straight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case .straight: return "Straight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTurnIntensity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sharp
        case slight
        case typical
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTurnIntensity] {
            return [
                .sharp,
                .slight,
                .typical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sharp: return "Sharp"
            case .slight: return "Slight"
            case .typical: return "Typical"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a Keep step.
    public struct RouteKeepStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the roundabout leg.
    public struct RouteRoundaboutEnterStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the roundabout step.
    public struct RouteRoundaboutExitStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Exit to be taken.
        public var relativeExit: Swift.Int?
        /// Angle of the roundabout.
        public var roundaboutAngle: Swift.Double
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            relativeExit: Swift.Int? = nil,
            roundaboutAngle: Swift.Double = 0.0,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil
        )
        {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.roundaboutAngle = roundaboutAngle
            self.steeringDirection = steeringDirection
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details about the step.
    public struct RouteRoundaboutPassStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Labels presented on the sign post.
    public struct RouteSignpostLabel: Swift.Sendable {
        /// Route number of the road.
        public var routeNumber: GeoRoutesClientTypes.RouteNumber?
        /// The Signpost text.
        public var text: GeoRoutesClientTypes.LocalizedString?

        public init(
            routeNumber: GeoRoutesClientTypes.RouteNumber? = nil,
            text: GeoRoutesClientTypes.LocalizedString? = nil
        )
        {
            self.routeNumber = routeNumber
            self.text = text
        }
    }
}

extension GeoRoutesClientTypes {

    /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
    public struct RouteSignpost: Swift.Sendable {
        /// Labels present on the sign post.
        /// This member is required.
        public var labels: [GeoRoutesClientTypes.RouteSignpostLabel]?

        public init(
            labels: [GeoRoutesClientTypes.RouteSignpostLabel]? = nil
        )
        {
            self.labels = labels
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the turn step.
    public struct RouteTurnStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoutePedestrianTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case depart
        case exit
        case keep
        case ramp
        case roundaboutEnter
        case roundaboutExit
        case roundaboutPass
        case turn
        case uTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutePedestrianTravelStepType] {
            return [
                .arrive,
                .continue,
                .depart,
                .exit,
                .keep,
                .ramp,
                .roundaboutEnter,
                .roundaboutExit,
                .roundaboutPass,
                .turn,
                .uTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .depart: return "Depart"
            case .exit: return "Exit"
            case .keep: return "Keep"
            case .ramp: return "Ramp"
            case .roundaboutEnter: return "RoundaboutEnter"
            case .roundaboutExit: return "RoundaboutExit"
            case .roundaboutPass: return "RoundaboutPass"
            case .turn: return "Turn"
            case .uTurn: return "UTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that must be performed during the travel portion of the leg.
    public struct RoutePedestrianTravelStep: Swift.Sendable {
        /// Details related to the continue step.
        public var continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails?
        /// Details of the current road. See RouteRoad for details of sub-attributes.
        public var currentRoad: GeoRoutesClientTypes.RouteRoad?
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Exit number of the road exit, if applicable.
        public var exitNumber: [GeoRoutesClientTypes.LocalizedString]?
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language. Only available when the TravelStepType is Default.
        public var instruction: Swift.String?
        /// Details that are specific to a Keep step.
        public var keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public var nextRoad: GeoRoutesClientTypes.RouteRoad?
        /// Details that are specific to a Roundabout Enter step.
        public var roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public var roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public var roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public var signpost: GeoRoutesClientTypes.RouteSignpost?
        /// Details that are specific to a turn step.
        public var turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RoutePedestrianTravelStepType?

        public init(
            continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails? = nil,
            currentRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            exitNumber: [GeoRoutesClientTypes.LocalizedString]? = nil,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails? = nil,
            nextRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails? = nil,
            roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails? = nil,
            roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails? = nil,
            signpost: GeoRoutesClientTypes.RouteSignpost? = nil,
            turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails? = nil,
            type: GeoRoutesClientTypes.RoutePedestrianTravelStepType? = nil
        )
        {
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.exitNumber = exitNumber
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a pedestrian leg.
    public struct RoutePedestrianLegDetails: Swift.Sendable {
        /// Details corresponding to the arrival for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RoutePedestrianArrival?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RoutePedestrianDeparture?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RoutePedestrianNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RoutePedestrianSpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RoutePedestrianSummary?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RoutePedestrianTravelStep]?

        public init(
            arrival: GeoRoutesClientTypes.RoutePedestrianArrival? = nil,
            departure: GeoRoutesClientTypes.RoutePedestrianDeparture? = nil,
            notices: [GeoRoutesClientTypes.RoutePedestrianNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            spans: [GeoRoutesClientTypes.RoutePedestrianSpan]? = nil,
            summary: GeoRoutesClientTypes.RoutePedestrianSummary? = nil,
            travelSteps: [GeoRoutesClientTypes.RoutePedestrianTravelStep]? = nil
        )
        {
            self.arrival = arrival
            self.departure = departure
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.travelSteps = travelSteps
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case ferry
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegTravelMode] {
            return [
                .car,
                .ferry,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .ferry: return "Ferry"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteLegType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ferry
        case pedestrian
        case vehicle
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteLegType] {
            return [
                .ferry,
                .pedestrian,
                .vehicle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ferry: return "Ferry"
            case .pedestrian: return "Pedestrian"
            case .vehicle: return "Vehicle"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Place details corresponding to the arrival or departure.
    public struct RouteVehiclePlace: Swift.Sendable {
        /// The name of the place.
        public var name: Swift.String?
        /// Position provided in the request.
        public var originalPosition: [Swift.Double]?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet?
        /// Index of the waypoint in the request.
        public var waypointIndex: Swift.Int?

        public init(
            name: Swift.String? = nil,
            originalPosition: [Swift.Double]? = nil,
            position: [Swift.Double]? = nil,
            sideOfStreet: GeoRoutesClientTypes.RouteSideOfStreet? = nil,
            waypointIndex: Swift.Int? = nil
        )
        {
            self.name = name
            self.originalPosition = originalPosition
            self.position = position
            self.sideOfStreet = sideOfStreet
            self.waypointIndex = waypointIndex
        }
    }
}

extension GeoRoutesClientTypes.RouteVehiclePlace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteVehiclePlace(name: \(Swift.String(describing: name)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), waypointIndex: \(Swift.String(describing: waypointIndex)), originalPosition: \"CONTENT_REDACTED\", position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the arrival for a leg.
    public struct RouteVehicleArrival: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteVehiclePlace?
        /// The time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteVehiclePlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details corresponding to the departure for the leg.
    public struct RouteVehicleDeparture: Swift.Sendable {
        /// The place details.
        /// This member is required.
        public var place: GeoRoutesClientTypes.RouteVehiclePlace?
        /// The departure time.
        public var time: Swift.String?

        public init(
            place: GeoRoutesClientTypes.RouteVehiclePlace? = nil,
            time: Swift.String? = nil
        )
        {
            self.place = place
            self.time = time
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleIncidentSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleIncidentSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "Critical"
            case .high: return "High"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleIncidentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accident
        case congestion
        case construction
        case disabledVehicle
        case laneRestriction
        case massTransit
        case other
        case plannedEvent
        case roadClosure
        case roadHazard
        case weather
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleIncidentType] {
            return [
                .accident,
                .congestion,
                .construction,
                .disabledVehicle,
                .laneRestriction,
                .massTransit,
                .other,
                .plannedEvent,
                .roadClosure,
                .roadHazard,
                .weather
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accident: return "Accident"
            case .congestion: return "Congestion"
            case .construction: return "Construction"
            case .disabledVehicle: return "DisabledVehicle"
            case .laneRestriction: return "LaneRestriction"
            case .massTransit: return "MassTransit"
            case .other: return "Other"
            case .plannedEvent: return "PlannedEvent"
            case .roadClosure: return "RoadClosure"
            case .roadHazard: return "RoadHazard"
            case .weather: return "Weather"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Incidents corresponding to this leg of the route.
    public struct RouteVehicleIncident: Swift.Sendable {
        /// Brief readable description of the incident.
        public var description: Swift.String?
        /// End timestamp of the incident.
        public var endTime: Swift.String?
        /// Severity of the incident Critical - The part of the route the incident affects is unusable. Major- Major impact on the leg duration, for example stop and go Minor- Minor impact on the leg duration, for example traffic jam Low - Low on duration, for example slightly increased traffic
        public var severity: GeoRoutesClientTypes.RouteVehicleIncidentSeverity?
        /// Start time of the incident.
        public var startTime: Swift.String?
        /// Type of the incident.
        public var type: GeoRoutesClientTypes.RouteVehicleIncidentType?

        public init(
            description: Swift.String? = nil,
            endTime: Swift.String? = nil,
            severity: GeoRoutesClientTypes.RouteVehicleIncidentSeverity? = nil,
            startTime: Swift.String? = nil,
            type: GeoRoutesClientTypes.RouteVehicleIncidentType? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.severity = severity
            self.startTime = startTime
            self.type = type
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accuratePolylineUnavailable
        case other
        case potentialViolatedAvoidTollRoadUsage
        case potentialViolatedCarpoolUsage
        case potentialViolatedTurnRestrictionUsage
        case potentialViolatedVehicleRestrictionUsage
        case potentialViolatedZoneRestrictionUsage
        case seasonalClosure
        case tollsDataTemporarilyUnavailable
        case tollsDataUnavailable
        case tollTransponder
        case violatedAvoidControlledAccessHighway
        case violatedAvoidDifficultTurns
        case violatedAvoidDirtRoad
        case violatedAvoidSeasonalClosure
        case violatedAvoidTollRoad
        case violatedAvoidTollTransponder
        case violatedAvoidTruckRoadType
        case violatedAvoidTunnel
        case violatedAvoidUTurns
        case violatedBlockedRoad
        case violatedCarpool
        case violatedEmergencyGate
        case violatedStartDirection
        case violatedTurnRestriction
        case violatedVehicleRestriction
        case violatedZoneRestriction
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleNoticeCode] {
            return [
                .accuratePolylineUnavailable,
                .other,
                .potentialViolatedAvoidTollRoadUsage,
                .potentialViolatedCarpoolUsage,
                .potentialViolatedTurnRestrictionUsage,
                .potentialViolatedVehicleRestrictionUsage,
                .potentialViolatedZoneRestrictionUsage,
                .seasonalClosure,
                .tollsDataTemporarilyUnavailable,
                .tollsDataUnavailable,
                .tollTransponder,
                .violatedAvoidControlledAccessHighway,
                .violatedAvoidDifficultTurns,
                .violatedAvoidDirtRoad,
                .violatedAvoidSeasonalClosure,
                .violatedAvoidTollRoad,
                .violatedAvoidTollTransponder,
                .violatedAvoidTruckRoadType,
                .violatedAvoidTunnel,
                .violatedAvoidUTurns,
                .violatedBlockedRoad,
                .violatedCarpool,
                .violatedEmergencyGate,
                .violatedStartDirection,
                .violatedTurnRestriction,
                .violatedVehicleRestriction,
                .violatedZoneRestriction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accuratePolylineUnavailable: return "AccuratePolylineUnavailable"
            case .other: return "Other"
            case .potentialViolatedAvoidTollRoadUsage: return "PotentialViolatedAvoidTollRoadUsage"
            case .potentialViolatedCarpoolUsage: return "PotentialViolatedCarpoolUsage"
            case .potentialViolatedTurnRestrictionUsage: return "PotentialViolatedTurnRestrictionUsage"
            case .potentialViolatedVehicleRestrictionUsage: return "PotentialViolatedVehicleRestrictionUsage"
            case .potentialViolatedZoneRestrictionUsage: return "PotentialViolatedZoneRestrictionUsage"
            case .seasonalClosure: return "SeasonalClosure"
            case .tollsDataTemporarilyUnavailable: return "TollsDataTemporarilyUnavailable"
            case .tollsDataUnavailable: return "TollsDataUnavailable"
            case .tollTransponder: return "TollTransponder"
            case .violatedAvoidControlledAccessHighway: return "ViolatedAvoidControlledAccessHighway"
            case .violatedAvoidDifficultTurns: return "ViolatedAvoidDifficultTurns"
            case .violatedAvoidDirtRoad: return "ViolatedAvoidDirtRoad"
            case .violatedAvoidSeasonalClosure: return "ViolatedAvoidSeasonalClosure"
            case .violatedAvoidTollRoad: return "ViolatedAvoidTollRoad"
            case .violatedAvoidTollTransponder: return "ViolatedAvoidTollTransponder"
            case .violatedAvoidTruckRoadType: return "ViolatedAvoidTruckRoadType"
            case .violatedAvoidTunnel: return "ViolatedAvoidTunnel"
            case .violatedAvoidUTurns: return "ViolatedAvoidUTurns"
            case .violatedBlockedRoad: return "ViolatedBlockedRoad"
            case .violatedCarpool: return "ViolatedCarpool"
            case .violatedEmergencyGate: return "ViolatedEmergencyGate"
            case .violatedStartDirection: return "ViolatedStartDirection"
            case .violatedTurnRestriction: return "ViolatedTurnRestriction"
            case .violatedVehicleRestriction: return "ViolatedVehicleRestriction"
            case .violatedZoneRestriction: return "ViolatedZoneRestriction"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notice Detail that is a range.
    public struct RouteNoticeDetailRange: Swift.Sendable {
        /// Maximum value for the range.
        public var max: Swift.Int?
        /// Minimum value for the range.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteWeightConstraintType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case current
        case gross
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteWeightConstraintType] {
            return [
                .current,
                .gross,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .current: return "Current"
            case .gross: return "Gross"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The weight constraint for the route. Unit: Kilograms
    public struct RouteWeightConstraint: Swift.Sendable {
        /// The type of constraint.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteWeightConstraintType?
        /// The constraint value. Unit: Kilograms
        /// This member is required.
        public var value: Swift.Int

        public init(
            type: GeoRoutesClientTypes.RouteWeightConstraintType? = nil,
            value: Swift.Int = 0
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// This property contains a summary of violated constraints.
    public struct RouteViolatedConstraints: Swift.Sendable {
        /// This restriction applies to truck cargo, where the resulting route excludes roads on which hazardous materials are prohibited from being transported.
        public var allHazardsRestricted: Swift.Bool?
        /// Total number of axles of the vehicle.
        public var axleCount: GeoRoutesClientTypes.RouteNoticeDetailRange?
        /// List of Hazardous cargo contained in the vehicle.
        /// This member is required.
        public var hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]?
        /// The maximum height of the vehicle.
        public var maxHeight: Swift.Int
        /// The maximum Kpra length of the vehicle. Unit: centimeters
        public var maxKpraLength: Swift.Int
        /// The maximum length of the vehicle.
        public var maxLength: Swift.Int
        /// The maximum load capacity of the vehicle. Unit: kilograms
        public var maxPayloadCapacity: Swift.Int
        /// The maximum weight of the route. Unit: Kilograms
        public var maxWeight: GeoRoutesClientTypes.RouteWeightConstraint?
        /// The maximum weight per axle of the vehicle. Unit: Kilograms
        public var maxWeightPerAxle: Swift.Int
        /// The maximum weight per axle group of the vehicle. Unit: Kilograms
        public var maxWeightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup?
        /// The maximum width of the vehicle.
        public var maxWidth: Swift.Int
        /// The number of occupants in the vehicle. Default Value: 1
        public var occupancy: GeoRoutesClientTypes.RouteNoticeDetailRange?
        /// Access radius restrictions based on time.
        public var restrictedTimes: Swift.String?
        /// The time dependent constraint.
        public var timeDependent: Swift.Bool?
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: GeoRoutesClientTypes.RouteNoticeDetailRange?
        /// Travel mode corresponding to the leg.
        public var travelMode: Swift.Bool?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadType: Swift.String?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.RouteTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?

        public init(
            allHazardsRestricted: Swift.Bool? = nil,
            axleCount: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            hazardousCargos: [GeoRoutesClientTypes.RouteHazardousCargoType]? = nil,
            maxHeight: Swift.Int = 0,
            maxKpraLength: Swift.Int = 0,
            maxLength: Swift.Int = 0,
            maxPayloadCapacity: Swift.Int = 0,
            maxWeight: GeoRoutesClientTypes.RouteWeightConstraint? = nil,
            maxWeightPerAxle: Swift.Int = 0,
            maxWeightPerAxleGroup: GeoRoutesClientTypes.WeightPerAxleGroup? = nil,
            maxWidth: Swift.Int = 0,
            occupancy: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            restrictedTimes: Swift.String? = nil,
            timeDependent: Swift.Bool? = nil,
            trailerCount: GeoRoutesClientTypes.RouteNoticeDetailRange? = nil,
            travelMode: Swift.Bool? = nil,
            truckRoadType: Swift.String? = nil,
            truckType: GeoRoutesClientTypes.RouteTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil
        )
        {
            self.allHazardsRestricted = allHazardsRestricted
            self.axleCount = axleCount
            self.hazardousCargos = hazardousCargos
            self.maxHeight = maxHeight
            self.maxKpraLength = maxKpraLength
            self.maxLength = maxLength
            self.maxPayloadCapacity = maxPayloadCapacity
            self.maxWeight = maxWeight
            self.maxWeightPerAxle = maxWeightPerAxle
            self.maxWeightPerAxleGroup = maxWeightPerAxleGroup
            self.maxWidth = maxWidth
            self.occupancy = occupancy
            self.restrictedTimes = restrictedTimes
            self.timeDependent = timeDependent
            self.trailerCount = trailerCount
            self.travelMode = travelMode
            self.truckRoadType = truckRoadType
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
        }
    }
}

extension GeoRoutesClientTypes {

    /// Additional details of the notice.
    public struct RouteVehicleNoticeDetail: Swift.Sendable {
        /// The notice title.
        public var title: Swift.String?
        /// Any violated constraints.
        public var violatedConstraints: GeoRoutesClientTypes.RouteViolatedConstraints?

        public init(
            title: Swift.String? = nil,
            violatedConstraints: GeoRoutesClientTypes.RouteViolatedConstraints? = nil
        )
        {
            self.title = title
            self.violatedConstraints = violatedConstraints
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    public struct RouteVehicleNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RouteVehicleNoticeCode?
        /// Additional details of the notice.
        /// This member is required.
        public var details: [GeoRoutesClientTypes.RouteVehicleNoticeDetail]?
        /// Impact corresponding to the issue. While Low impact notices can be safely ignored, High impact notices must be evaluated further to determine the impact.
        public var impact: GeoRoutesClientTypes.RouteNoticeImpact?

        public init(
            code: GeoRoutesClientTypes.RouteVehicleNoticeCode? = nil,
            details: [GeoRoutesClientTypes.RouteVehicleNoticeDetail]? = nil,
            impact: GeoRoutesClientTypes.RouteNoticeImpact? = nil
        )
        {
            self.code = code
            self.details = details
            self.impact = impact
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanCarAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanCarAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanGateAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emergency
        case keyAccess
        case permissionRequired
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanGateAttribute] {
            return [
                .emergency,
                .keyAccess,
                .permissionRequired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emergency: return "Emergency"
            case .keyAccess: return "KeyAccess"
            case .permissionRequired: return "PermissionRequired"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanRailwayCrossingAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case protected
        case unprotected
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanRailwayCrossingAttribute] {
            return [
                .protected,
                .unprotected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .protected: return "Protected"
            case .unprotected: return "Unprotected"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanScooterAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanScooterAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteSpanTruckAccessAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case noThroughTraffic
        case tollRoad
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteSpanTruckAccessAttribute] {
            return [
                .allowed,
                .noThroughTraffic,
                .tollRoad
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "Allowed"
            case .noThroughTraffic: return "NoThroughTraffic"
            case .tollRoad: return "TollRoad"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Span computed for the requested SpanAdditionalFeatures.
    public struct RouteVehicleSpan: Swift.Sendable {
        /// Duration of the computed span without traffic congestion. Unit: seconds
        public var bestCaseDuration: Swift.Int
        /// Access attributes for a car corresponding to the span.
        public var carAccess: [GeoRoutesClientTypes.RouteSpanCarAccessAttribute]?
        /// 3 letter Country code corresponding to the Span.
        public var country: Swift.String?
        /// Distance of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties.
        public var distance: Swift.Int
        /// Duration of the computed span. This feature doesn't split a span, but is always computed on a span split by other properties. Unit: seconds
        public var duration: Swift.Int
        /// Dynamic speed details corresponding to the span. Unit: KilometersPerHour
        public var dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails?
        /// Functional classification of the road segment corresponding to the span.
        public var functionalClassification: Swift.Int?
        /// Attributes corresponding to a gate. The gate is present at the end of the returned span.
        public var gate: GeoRoutesClientTypes.RouteSpanGateAttribute?
        /// Offset in the leg geometry corresponding to the start of this span.
        public var geometryOffset: Swift.Int?
        /// Incidents corresponding to the span. These index into the Incidents in the parent Leg.
        public var incidents: [Swift.Int]?
        /// Provides an array of names of the vehicle span in available languages.
        public var names: [GeoRoutesClientTypes.LocalizedString]?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        public var notices: [Swift.Int]?
        /// Attributes corresponding to a railway crossing. The gate is present at the end of the returned span.
        public var railwayCrossing: GeoRoutesClientTypes.RouteSpanRailwayCrossingAttribute?
        /// 2-3 letter Region code corresponding to the Span. This is either a province or a state.
        public var region: Swift.String?
        /// Attributes for the road segment corresponding to the span.
        public var roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]?
        /// Designated route name or number corresponding to the span.
        public var routeNumbers: [GeoRoutesClientTypes.RouteNumber]?
        /// Access attributes for a scooter corresponding to the span.
        public var scooterAccess: [GeoRoutesClientTypes.RouteSpanScooterAccessAttribute]?
        /// Speed limit details corresponding to the span. Unit: KilometersPerHour
        public var speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails?
        /// Toll systems are authorities that collect payments for the toll.
        public var tollSystems: [Swift.Int]?
        /// Access attributes for a truck corresponding to the span.
        public var truckAccess: [GeoRoutesClientTypes.RouteSpanTruckAccessAttribute]?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        public var truckRoadTypes: [Swift.Int]?
        /// Duration of the computed span under typical traffic congestion. Unit: seconds
        public var typicalDuration: Swift.Int
        /// Zones corresponding to this leg of the route.
        public var zones: [Swift.Int]?

        public init(
            bestCaseDuration: Swift.Int = 0,
            carAccess: [GeoRoutesClientTypes.RouteSpanCarAccessAttribute]? = nil,
            country: Swift.String? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            dynamicSpeed: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails? = nil,
            functionalClassification: Swift.Int? = nil,
            gate: GeoRoutesClientTypes.RouteSpanGateAttribute? = nil,
            geometryOffset: Swift.Int? = nil,
            incidents: [Swift.Int]? = nil,
            names: [GeoRoutesClientTypes.LocalizedString]? = nil,
            notices: [Swift.Int]? = nil,
            railwayCrossing: GeoRoutesClientTypes.RouteSpanRailwayCrossingAttribute? = nil,
            region: Swift.String? = nil,
            roadAttributes: [GeoRoutesClientTypes.RouteSpanRoadAttribute]? = nil,
            routeNumbers: [GeoRoutesClientTypes.RouteNumber]? = nil,
            scooterAccess: [GeoRoutesClientTypes.RouteSpanScooterAccessAttribute]? = nil,
            speedLimit: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails? = nil,
            tollSystems: [Swift.Int]? = nil,
            truckAccess: [GeoRoutesClientTypes.RouteSpanTruckAccessAttribute]? = nil,
            truckRoadTypes: [Swift.Int]? = nil,
            typicalDuration: Swift.Int = 0,
            zones: [Swift.Int]? = nil
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.carAccess = carAccess
            self.country = country
            self.distance = distance
            self.duration = duration
            self.dynamicSpeed = dynamicSpeed
            self.functionalClassification = functionalClassification
            self.gate = gate
            self.geometryOffset = geometryOffset
            self.incidents = incidents
            self.names = names
            self.notices = notices
            self.railwayCrossing = railwayCrossing
            self.region = region
            self.roadAttributes = roadAttributes
            self.routeNumbers = routeNumbers
            self.scooterAccess = scooterAccess
            self.speedLimit = speedLimit
            self.tollSystems = tollSystems
            self.truckAccess = truckAccess
            self.truckRoadTypes = truckRoadTypes
            self.typicalDuration = typicalDuration
            self.zones = zones
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the leg.
    public struct RouteVehicleOverviewSummary: Swift.Sendable {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg. Unit: seconds
        public var bestCaseDuration: Swift.Int
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Duration of the computed span under typical traffic congestion. Unit: seconds
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.distance = distance
            self.duration = duration
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the route.
    public struct RouteVehicleTravelOnlySummary: Swift.Sendable {
        /// Total duration in free flowing traffic, which is the best case or shortest duration possible to cover the leg. Unit: seconds
        public var bestCaseDuration: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Duration of the computed span under typical traffic congestion. Unit: seconds
        public var typicalDuration: Swift.Int

        public init(
            bestCaseDuration: Swift.Int = 0,
            duration: Swift.Int = 0,
            typicalDuration: Swift.Int = 0
        )
        {
            self.bestCaseDuration = bestCaseDuration
            self.duration = duration
            self.typicalDuration = typicalDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details of the route.
    public struct RouteVehicleSummary: Swift.Sendable {
        /// Summarized details for the leg including before travel, travel and after travel steps.
        public var overview: GeoRoutesClientTypes.RouteVehicleOverviewSummary?
        /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is in meters
        public var travelOnly: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary?

        public init(
            overview: GeoRoutesClientTypes.RouteVehicleOverviewSummary? = nil,
            travelOnly: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary? = nil
        )
        {
            self.overview = overview
            self.travelOnly = travelOnly
        }
    }
}

extension GeoRoutesClientTypes {

    /// Locations or sites where the toll fare is collected.
    public struct RouteTollPaymentSite: Swift.Sendable {
        /// Name of the payment site.
        public var name: Swift.String?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            name: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.name = name
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.RouteTollPaymentSite: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RouteTollPaymentSite(name: \(Swift.String(describing: name)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Price range with a minimum and maximum value, if a range.
    public struct RouteTollPriceValueRange: Swift.Sendable {
        /// Maximum price.
        /// This member is required.
        public var max: Swift.Double?
        /// Minimum price.
        /// This member is required.
        public var min: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll price.
    public struct RouteTollPrice: Swift.Sendable {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        /// This member is required.
        public var currency: Swift.String?
        /// If the price is an estimate or an exact value.
        /// This member is required.
        public var estimate: Swift.Bool?
        /// Duration for which the price corresponds to. Unit: seconds
        public var perDuration: Swift.Int
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        /// This member is required.
        public var range: Swift.Bool?
        /// Price range with a minimum and maximum value, if a range.
        public var rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange?
        /// Exact price, if not a range.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            currency: Swift.String? = nil,
            estimate: Swift.Bool? = nil,
            perDuration: Swift.Int = 0,
            range: Swift.Bool? = nil,
            rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange? = nil,
            value: Swift.Double? = nil
        )
        {
            self.currency = currency
            self.estimate = estimate
            self.perDuration = perDuration
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollPassValidityPeriodType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case annual
        case days
        case extendedAnnual
        case minutes
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollPassValidityPeriodType] {
            return [
                .annual,
                .days,
                .extendedAnnual,
                .minutes,
                .months
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .annual: return "Annual"
            case .days: return "Days"
            case .extendedAnnual: return "ExtendedAnnual"
            case .minutes: return "Minutes"
            case .months: return "Months"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Period for which the pass is valid.
    public struct RouteTollPassValidityPeriod: Swift.Sendable {
        /// Validity period.
        /// This member is required.
        public var period: GeoRoutesClientTypes.RouteTollPassValidityPeriodType?
        /// Counts for the validity period.
        public var periodCount: Swift.Int?

        public init(
            period: GeoRoutesClientTypes.RouteTollPassValidityPeriodType? = nil,
            periodCount: Swift.Int? = nil
        )
        {
            self.period = period
            self.periodCount = periodCount
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details if the toll rate can be a pass that supports multiple trips.
    public struct RouteTollPass: Swift.Sendable {
        /// If the pass includes the rate for the return leg of the trip.
        public var includesReturnTrip: Swift.Bool?
        /// If the pass is only valid for senior persons.
        public var seniorPass: Swift.Bool?
        /// If the toll pass can be transferred, and how many times.
        public var transferCount: Swift.Int?
        /// Number of trips the pass is valid for.
        public var tripCount: Swift.Int?
        /// Period for which the pass is valid.
        public var validityPeriod: GeoRoutesClientTypes.RouteTollPassValidityPeriod?

        public init(
            includesReturnTrip: Swift.Bool? = nil,
            seniorPass: Swift.Bool? = nil,
            transferCount: Swift.Int? = nil,
            tripCount: Swift.Int? = nil,
            validityPeriod: GeoRoutesClientTypes.RouteTollPassValidityPeriod? = nil
        )
        {
            self.includesReturnTrip = includesReturnTrip
            self.seniorPass = seniorPass
            self.transferCount = transferCount
            self.tripCount = tripCount
            self.validityPeriod = validityPeriod
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteTollPaymentMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bankCard
        case cash
        case cashExact
        case creditCard
        case passSubscription
        case transponder
        case travelCard
        case videoToll
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteTollPaymentMethod] {
            return [
                .bankCard,
                .cash,
                .cashExact,
                .creditCard,
                .passSubscription,
                .transponder,
                .travelCard,
                .videoToll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bankCard: return "BankCard"
            case .cash: return "Cash"
            case .cashExact: return "CashExact"
            case .creditCard: return "CreditCard"
            case .passSubscription: return "PassSubscription"
            case .transponder: return "Transponder"
            case .travelCard: return "TravelCard"
            case .videoToll: return "VideoToll"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Transponders for which this toll can be applied.
    public struct RouteTransponder: Swift.Sendable {
        /// Names of the toll system collecting the toll.
        public var systemName: Swift.String?

        public init(
            systemName: Swift.String? = nil
        )
        {
            self.systemName = systemName
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll rate.
    public struct RouteTollRate: Swift.Sendable {
        /// Time when the rate is valid.
        public var applicableTimes: Swift.String?
        /// Price in the converted currency as specified in the request.
        public var convertedPrice: GeoRoutesClientTypes.RouteTollPrice?
        /// The Toll rate Id.
        /// This member is required.
        public var id: Swift.String?
        /// Price in the local regional currency.
        /// This member is required.
        public var localPrice: GeoRoutesClientTypes.RouteTollPrice?
        /// The name of the toll.
        /// This member is required.
        public var name: Swift.String?
        /// Details if the toll rate can be a pass that supports multiple trips.
        public var pass: GeoRoutesClientTypes.RouteTollPass?
        /// Accepted payment methods at the toll.
        /// This member is required.
        public var paymentMethods: [GeoRoutesClientTypes.RouteTollPaymentMethod]?
        /// Transponders for which this toll can be applied.
        /// This member is required.
        public var transponders: [GeoRoutesClientTypes.RouteTransponder]?

        public init(
            applicableTimes: Swift.String? = nil,
            convertedPrice: GeoRoutesClientTypes.RouteTollPrice? = nil,
            id: Swift.String? = nil,
            localPrice: GeoRoutesClientTypes.RouteTollPrice? = nil,
            name: Swift.String? = nil,
            pass: GeoRoutesClientTypes.RouteTollPass? = nil,
            paymentMethods: [GeoRoutesClientTypes.RouteTollPaymentMethod]? = nil,
            transponders: [GeoRoutesClientTypes.RouteTransponder]? = nil
        )
        {
            self.applicableTimes = applicableTimes
            self.convertedPrice = convertedPrice
            self.id = id
            self.localPrice = localPrice
            self.name = name
            self.pass = pass
            self.paymentMethods = paymentMethods
            self.transponders = transponders
        }
    }
}

extension GeoRoutesClientTypes {

    /// Provides details about toll information along a route, including the payment sites, applicable toll rates, toll systems, and the country associated with the toll collection.
    public struct RouteToll: Swift.Sendable {
        /// The alpha-2 or alpha-3 character code for the country.
        public var country: Swift.String?
        /// Locations or sites where the toll fare is collected.
        /// This member is required.
        public var paymentSites: [GeoRoutesClientTypes.RouteTollPaymentSite]?
        /// Toll rates that need to be paid to travel this leg of the route.
        /// This member is required.
        public var rates: [GeoRoutesClientTypes.RouteTollRate]?
        /// Toll systems are authorities that collect payments for the toll.
        /// This member is required.
        public var systems: [Swift.Int]?

        public init(
            country: Swift.String? = nil,
            paymentSites: [GeoRoutesClientTypes.RouteTollPaymentSite]? = nil,
            rates: [GeoRoutesClientTypes.RouteTollRate]? = nil,
            systems: [Swift.Int]? = nil
        )
        {
            self.country = country
            self.paymentSites = paymentSites
            self.rates = rates
            self.systems = systems
        }
    }
}

extension GeoRoutesClientTypes {

    /// Toll systems are authorities that collect payments for the toll.
    public struct RouteTollSystem: Swift.Sendable {
        /// The toll system name.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the continue highway step.
    public struct RouteContinueHighwayStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the enter highway step.
    public struct RouteEnterHighwayStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the exit step.
    public struct RouteExitStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Exit to be taken.
        public var relativeExit: Swift.Int?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            relativeExit: Swift.Int? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.relativeExit = relativeExit
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details that are specific to a ramp step.
    public struct RouteRampStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RouteVehicleTravelStepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrive
        case `continue`
        case continueHighway
        case depart
        case enterHighway
        case exit
        case keep
        case ramp
        case roundaboutEnter
        case roundaboutExit
        case roundaboutPass
        case turn
        case uTurn
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteVehicleTravelStepType] {
            return [
                .arrive,
                .continue,
                .continueHighway,
                .depart,
                .enterHighway,
                .exit,
                .keep,
                .ramp,
                .roundaboutEnter,
                .roundaboutExit,
                .roundaboutPass,
                .turn,
                .uTurn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrive: return "Arrive"
            case .continue: return "Continue"
            case .continueHighway: return "ContinueHighway"
            case .depart: return "Depart"
            case .enterHighway: return "EnterHighway"
            case .exit: return "Exit"
            case .keep: return "Keep"
            case .ramp: return "Ramp"
            case .roundaboutEnter: return "RoundaboutEnter"
            case .roundaboutExit: return "RoundaboutExit"
            case .roundaboutPass: return "RoundaboutPass"
            case .turn: return "Turn"
            case .uTurn: return "UTurn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Details related to the U-turn step.
    public struct RouteUTurnStepDetails: Swift.Sendable {
        /// Name of the intersection, if applicable to the step.
        /// This member is required.
        public var intersection: [GeoRoutesClientTypes.LocalizedString]?
        /// Steering direction for the step.
        public var steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection?
        /// Angle of the turn.
        public var turnAngle: Swift.Double
        /// Intensity of the turn.
        public var turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity?

        public init(
            intersection: [GeoRoutesClientTypes.LocalizedString]? = nil,
            steeringDirection: GeoRoutesClientTypes.RouteSteeringDirection? = nil,
            turnAngle: Swift.Double = 0.0,
            turnIntensity: GeoRoutesClientTypes.RouteTurnIntensity? = nil
        )
        {
            self.intersection = intersection
            self.steeringDirection = steeringDirection
            self.turnAngle = turnAngle
            self.turnIntensity = turnIntensity
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that correspond to the travel portion of the leg.
    public struct RouteVehicleTravelStep: Swift.Sendable {
        /// Details that are specific to a Continue Highway step.
        public var continueHighwayStepDetails: GeoRoutesClientTypes.RouteContinueHighwayStepDetails?
        /// Details that are specific to a Continue step.
        public var continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails?
        /// Details of the current road.
        public var currentRoad: GeoRoutesClientTypes.RouteRoad?
        /// Distance of the step.
        public var distance: Swift.Int
        /// Duration of the step. Unit: seconds
        /// This member is required.
        public var duration: Swift.Int
        /// Details that are specific to a Enter Highway step.
        public var enterHighwayStepDetails: GeoRoutesClientTypes.RouteEnterHighwayStepDetails?
        /// Exit number of the road exit, if applicable.
        public var exitNumber: [GeoRoutesClientTypes.LocalizedString]?
        /// Details that are specific to a Roundabout Exit step.
        public var exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails?
        /// Offset in the leg geometry corresponding to the start of this step.
        public var geometryOffset: Swift.Int?
        /// Brief description of the step in the requested language. Only available when the TravelStepType is Default.
        public var instruction: Swift.String?
        /// Details that are specific to a Keep step.
        public var keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails?
        /// Details of the next road. See RouteRoad for details of sub-attributes.
        public var nextRoad: GeoRoutesClientTypes.RouteRoad?
        /// Details that are specific to a Ramp step.
        public var rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails?
        /// Details that are specific to a Roundabout Enter step.
        public var roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails?
        /// Details that are specific to a Roundabout Exit step.
        public var roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails?
        /// Details that are specific to a Roundabout Pass step.
        public var roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails?
        /// Sign post information of the action, applicable only for TurnByTurn steps. See RouteSignpost for details of sub-attributes.
        public var signpost: GeoRoutesClientTypes.RouteSignpost?
        /// Details that are specific to a Turn step.
        public var turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails?
        /// Type of the step.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteVehicleTravelStepType?
        /// Details that are specific to a Turn step.
        public var uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails?

        public init(
            continueHighwayStepDetails: GeoRoutesClientTypes.RouteContinueHighwayStepDetails? = nil,
            continueStepDetails: GeoRoutesClientTypes.RouteContinueStepDetails? = nil,
            currentRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            enterHighwayStepDetails: GeoRoutesClientTypes.RouteEnterHighwayStepDetails? = nil,
            exitNumber: [GeoRoutesClientTypes.LocalizedString]? = nil,
            exitStepDetails: GeoRoutesClientTypes.RouteExitStepDetails? = nil,
            geometryOffset: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            keepStepDetails: GeoRoutesClientTypes.RouteKeepStepDetails? = nil,
            nextRoad: GeoRoutesClientTypes.RouteRoad? = nil,
            rampStepDetails: GeoRoutesClientTypes.RouteRampStepDetails? = nil,
            roundaboutEnterStepDetails: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails? = nil,
            roundaboutExitStepDetails: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails? = nil,
            roundaboutPassStepDetails: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails? = nil,
            signpost: GeoRoutesClientTypes.RouteSignpost? = nil,
            turnStepDetails: GeoRoutesClientTypes.RouteTurnStepDetails? = nil,
            type: GeoRoutesClientTypes.RouteVehicleTravelStepType? = nil,
            uTurnStepDetails: GeoRoutesClientTypes.RouteUTurnStepDetails? = nil
        )
        {
            self.continueHighwayStepDetails = continueHighwayStepDetails
            self.continueStepDetails = continueStepDetails
            self.currentRoad = currentRoad
            self.distance = distance
            self.duration = duration
            self.enterHighwayStepDetails = enterHighwayStepDetails
            self.exitNumber = exitNumber
            self.exitStepDetails = exitStepDetails
            self.geometryOffset = geometryOffset
            self.instruction = instruction
            self.keepStepDetails = keepStepDetails
            self.nextRoad = nextRoad
            self.rampStepDetails = rampStepDetails
            self.roundaboutEnterStepDetails = roundaboutEnterStepDetails
            self.roundaboutExitStepDetails = roundaboutExitStepDetails
            self.roundaboutPassStepDetails = roundaboutPassStepDetails
            self.signpost = signpost
            self.turnStepDetails = turnStepDetails
            self.type = type
            self.uTurnStepDetails = uTurnStepDetails
        }
    }
}

extension GeoRoutesClientTypes {

    /// The zone.
    public struct RouteZone: Swift.Sendable {
        /// The zone category.
        public var category: GeoRoutesClientTypes.RouteZoneCategory?
        /// The name of the zone.
        public var name: Swift.String?

        public init(
            category: GeoRoutesClientTypes.RouteZoneCategory? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.name = name
        }
    }
}

extension GeoRoutesClientTypes {

    /// Steps of a leg that correspond to the travel portion of the leg.
    public struct RouteVehicleLegDetails: Swift.Sendable {
        /// Details corresponding to the arrival for the leg.
        /// This member is required.
        public var arrival: GeoRoutesClientTypes.RouteVehicleArrival?
        /// Details corresponding to the departure for the leg.
        /// This member is required.
        public var departure: GeoRoutesClientTypes.RouteVehicleDeparture?
        /// Incidents corresponding to this leg of the route.
        /// This member is required.
        public var incidents: [GeoRoutesClientTypes.RouteVehicleIncident]?
        /// Notices are additional information returned that indicate issues that occurred during route calculation.
        /// This member is required.
        public var notices: [GeoRoutesClientTypes.RouteVehicleNotice]?
        /// Waypoints that were passed through during the leg. This includes the waypoints that were configured with the PassThrough option.
        /// This member is required.
        public var passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]?
        /// Spans that were computed for the requested SpanAdditionalFeatures.
        /// This member is required.
        public var spans: [GeoRoutesClientTypes.RouteVehicleSpan]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteVehicleSummary?
        /// Toll systems are authorities that collect payments for the toll.
        /// This member is required.
        public var tollSystems: [GeoRoutesClientTypes.RouteTollSystem]?
        /// Toll related options.
        /// This member is required.
        public var tolls: [GeoRoutesClientTypes.RouteToll]?
        /// Steps of a leg that must be performed before the travel portion of the leg.
        /// This member is required.
        public var travelSteps: [GeoRoutesClientTypes.RouteVehicleTravelStep]?
        /// Truck road type identifiers. BK1 through BK4 apply only to Sweden. A2,A4,B2,B4,C,D,ET2,ET4 apply only to Mexico. There are currently no other supported values as of 26th April 2024.
        /// This member is required.
        public var truckRoadTypes: [Swift.String]?
        /// Zones corresponding to this leg of the route.
        /// This member is required.
        public var zones: [GeoRoutesClientTypes.RouteZone]?

        public init(
            arrival: GeoRoutesClientTypes.RouteVehicleArrival? = nil,
            departure: GeoRoutesClientTypes.RouteVehicleDeparture? = nil,
            incidents: [GeoRoutesClientTypes.RouteVehicleIncident]? = nil,
            notices: [GeoRoutesClientTypes.RouteVehicleNotice]? = nil,
            passThroughWaypoints: [GeoRoutesClientTypes.RoutePassThroughWaypoint]? = nil,
            spans: [GeoRoutesClientTypes.RouteVehicleSpan]? = nil,
            summary: GeoRoutesClientTypes.RouteVehicleSummary? = nil,
            tollSystems: [GeoRoutesClientTypes.RouteTollSystem]? = nil,
            tolls: [GeoRoutesClientTypes.RouteToll]? = nil,
            travelSteps: [GeoRoutesClientTypes.RouteVehicleTravelStep]? = nil,
            truckRoadTypes: [Swift.String]? = nil,
            zones: [GeoRoutesClientTypes.RouteZone]? = nil
        )
        {
            self.arrival = arrival
            self.departure = departure
            self.incidents = incidents
            self.notices = notices
            self.passThroughWaypoints = passThroughWaypoints
            self.spans = spans
            self.summary = summary
            self.tollSystems = tollSystems
            self.tolls = tolls
            self.travelSteps = travelSteps
            self.truckRoadTypes = truckRoadTypes
            self.zones = zones
        }
    }
}

extension GeoRoutesClientTypes {

    /// A leg is a section of a route from one waypoint to the next. A leg could be of type Vehicle, Pedestrian or Ferry. Legs of different types could occur together within a single route. For example, a car employing the use of a Ferry will contain Vehicle legs corresponding to journey on land, and Ferry legs corresponding to the journey via Ferry.
    public struct RouteLeg: Swift.Sendable {
        /// FerryLegDetails is populated when the Leg type is Ferry, and provides additional information that is specific
        public var ferryLegDetails: GeoRoutesClientTypes.RouteFerryLegDetails?
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.RouteLegGeometry?
        /// List of languages for instructions within steps in the response.
        public var language: Swift.String?
        /// Details related to the pedestrian leg.
        public var pedestrianLegDetails: GeoRoutesClientTypes.RoutePedestrianLegDetails?
        /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
        /// This member is required.
        public var travelMode: GeoRoutesClientTypes.RouteLegTravelMode?
        /// Type of the leg.
        /// This member is required.
        public var type: GeoRoutesClientTypes.RouteLegType?
        /// Details related to the vehicle leg.
        public var vehicleLegDetails: GeoRoutesClientTypes.RouteVehicleLegDetails?

        public init(
            ferryLegDetails: GeoRoutesClientTypes.RouteFerryLegDetails? = nil,
            geometry: GeoRoutesClientTypes.RouteLegGeometry? = nil,
            language: Swift.String? = nil,
            pedestrianLegDetails: GeoRoutesClientTypes.RoutePedestrianLegDetails? = nil,
            travelMode: GeoRoutesClientTypes.RouteLegTravelMode? = nil,
            type: GeoRoutesClientTypes.RouteLegType? = nil,
            vehicleLegDetails: GeoRoutesClientTypes.RouteVehicleLegDetails? = nil
        )
        {
            self.ferryLegDetails = ferryLegDetails
            self.geometry = geometry
            self.language = language
            self.pedestrianLegDetails = pedestrianLegDetails
            self.travelMode = travelMode
            self.type = type
            self.vehicleLegDetails = vehicleLegDetails
        }
    }
}

extension GeoRoutesClientTypes {

    /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
    public struct RouteMajorRoadLabel: Swift.Sendable {
        /// Name of the road (localized).
        public var roadName: GeoRoutesClientTypes.LocalizedString?
        /// Route number of the road.
        public var routeNumber: GeoRoutesClientTypes.RouteNumber?

        public init(
            roadName: GeoRoutesClientTypes.LocalizedString? = nil,
            routeNumber: GeoRoutesClientTypes.RouteNumber? = nil
        )
        {
            self.roadName = roadName
            self.routeNumber = routeNumber
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summary of the route and toll price.
    public struct RouteTollPriceSummary: Swift.Sendable {
        /// Currency code corresponding to the price. This is the same as Currency specified in the request.
        /// This member is required.
        public var currency: Swift.String?
        /// If the price is an estimate or an exact value.
        /// This member is required.
        public var estimate: Swift.Bool?
        /// If the price is a range or an exact value. If any of the toll fares making up the route is a range, the overall price is also a range.
        /// This member is required.
        public var range: Swift.Bool?
        /// Price range with a minimum and maximum value, if a range.
        public var rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange?
        /// Exact price, if not a range.
        /// This member is required.
        public var value: Swift.Double?

        public init(
            currency: Swift.String? = nil,
            estimate: Swift.Bool? = nil,
            range: Swift.Bool? = nil,
            rangeValue: GeoRoutesClientTypes.RouteTollPriceValueRange? = nil,
            value: Swift.Double? = nil
        )
        {
            self.currency = currency
            self.estimate = estimate
            self.range = range
            self.rangeValue = rangeValue
            self.value = value
        }
    }
}

extension GeoRoutesClientTypes {

    /// The toll summary for the complete route.
    public struct RouteTollSummary: Swift.Sendable {
        /// Total toll summary for the complete route. Total is the only summary available today.
        public var total: GeoRoutesClientTypes.RouteTollPriceSummary?

        public init(
            total: GeoRoutesClientTypes.RouteTollPriceSummary? = nil
        )
        {
            self.total = total
        }
    }
}

extension GeoRoutesClientTypes {

    /// Summarized details for the leg including travel steps only. The Distance for the travel only portion of the journey is the same as the Distance within the Overview summary.
    public struct RouteSummary: Swift.Sendable {
        /// Distance of the route.
        public var distance: Swift.Int
        /// Duration of the route. Unit: seconds
        public var duration: Swift.Int
        /// Toll summary for the complete route.
        public var tolls: GeoRoutesClientTypes.RouteTollSummary?

        public init(
            distance: Swift.Int = 0,
            duration: Swift.Int = 0,
            tolls: GeoRoutesClientTypes.RouteTollSummary? = nil
        )
        {
            self.distance = distance
            self.duration = duration
            self.tolls = tolls
        }
    }
}

extension GeoRoutesClientTypes {

    /// The route.
    public struct Route: Swift.Sendable {
        /// A leg is a section of a route from one waypoint to the next. A leg could be of type Vehicle, Pedestrian or Ferry. Legs of different types could occur together within a single route. For example, a car employing the use of a Ferry will contain Vehicle legs corresponding to journey on land, and Ferry legs corresponding to the journey via Ferry.
        /// This member is required.
        public var legs: [GeoRoutesClientTypes.RouteLeg]?
        /// Important labels including names and route numbers that differentiate the current route from the alternatives presented.
        /// This member is required.
        public var majorRoadLabels: [GeoRoutesClientTypes.RouteMajorRoadLabel]?
        /// Summarized details of the leg.
        public var summary: GeoRoutesClientTypes.RouteSummary?

        public init(
            legs: [GeoRoutesClientTypes.RouteLeg]? = nil,
            majorRoadLabels: [GeoRoutesClientTypes.RouteMajorRoadLabel]? = nil,
            summary: GeoRoutesClientTypes.RouteSummary? = nil
        )
        {
            self.legs = legs
            self.majorRoadLabels = majorRoadLabels
            self.summary = summary
        }
    }
}

public struct CalculateRoutesOutput: Swift.Sendable {
    /// Specifies the format of the geometry returned for each leg of the route.
    /// This member is required.
    public var legGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    /// This member is required.
    public var notices: [GeoRoutesClientTypes.RouteResponseNotice]?
    /// The pricing bucket for which the query is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The path from the origin to the destination.
    /// This member is required.
    public var routes: [GeoRoutesClientTypes.Route]?

    public init(
        legGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        notices: [GeoRoutesClientTypes.RouteResponseNotice]? = nil,
        pricingBucket: Swift.String? = nil,
        routes: [GeoRoutesClientTypes.Route]? = nil
    )
    {
        self.legGeometryFormat = legGeometryFormat
        self.notices = notices
        self.pricingBucket = pricingBucket
        self.routes = routes
    }
}

extension GeoRoutesClientTypes {

    public enum DayOfWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "Friday"
            case .monday: return "Monday"
            case .saturday: return "Saturday"
            case .sunday: return "Sunday"
            case .thursday: return "Thursday"
            case .tuesday: return "Tuesday"
            case .wednesday: return "Wednesday"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Geometry of the area to be avoided.
    public struct WaypointOptimizationAvoidanceAreaGeometry: Swift.Sendable {
        /// Geometry defined as a bounding box. The first pair represents the X and Y coordinates (longitude and latitude,) of the southwest corner of the bounding box; the second pair represents the X and Y coordinates (longitude and latitude) of the northeast corner.
        public var boundingBox: [Swift.Double]?

        public init(
            boundingBox: [Swift.Double]? = nil
        )
        {
            self.boundingBox = boundingBox
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationAvoidanceAreaGeometry(boundingBox: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The area to be avoided.
    public struct WaypointOptimizationAvoidanceArea: Swift.Sendable {
        /// Geometry of the area to be avoided.
        /// This member is required.
        public var geometry: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry?

        public init(
            geometry: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry? = nil
        )
        {
            self.geometry = geometry
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options for WaypointOptimizationAvoidance.
    public struct WaypointOptimizationAvoidanceOptions: Swift.Sendable {
        /// Areas to be avoided.
        public var areas: [GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea]?
        /// Avoidance options for cars-shuttles-trains.
        public var carShuttleTrains: Swift.Bool?
        /// Avoid controlled access highways while calculating the route.
        public var controlledAccessHighways: Swift.Bool?
        /// Avoid dirt roads while calculating the route.
        public var dirtRoads: Swift.Bool?
        /// Avoidance options for ferries.
        public var ferries: Swift.Bool?
        /// Avoids roads where the specified toll transponders are the only mode of payment.
        public var tollRoads: Swift.Bool?
        /// Avoid tunnels while calculating the route.
        public var tunnels: Swift.Bool?
        /// Avoid U-turns for calculation on highways and motorways.
        public var uTurns: Swift.Bool?

        public init(
            areas: [GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea]? = nil,
            carShuttleTrains: Swift.Bool? = nil,
            controlledAccessHighways: Swift.Bool? = nil,
            dirtRoads: Swift.Bool? = nil,
            ferries: Swift.Bool? = nil,
            tollRoads: Swift.Bool? = nil,
            tunnels: Swift.Bool? = nil,
            uTurns: Swift.Bool? = nil
        )
        {
            self.areas = areas
            self.carShuttleTrains = carShuttleTrains
            self.controlledAccessHighways = controlledAccessHighways
            self.dirtRoads = dirtRoads
            self.ferries = ferries
            self.tollRoads = tollRoads
            self.tunnels = tunnels
            self.uTurns = uTurns
        }
    }
}

extension GeoRoutesClientTypes {

    /// Hours of entry.
    public struct WaypointOptimizationAccessHoursEntry: Swift.Sendable {
        /// Day of the week.
        /// This member is required.
        public var dayOfWeek: GeoRoutesClientTypes.DayOfWeek?
        /// Time of the day.
        /// This member is required.
        public var timeOfDay: Swift.String?

        public init(
            dayOfWeek: GeoRoutesClientTypes.DayOfWeek? = nil,
            timeOfDay: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
        }
    }
}

extension GeoRoutesClientTypes {

    /// Access hours corresponding to when a destination can be visited.
    public struct WaypointOptimizationAccessHours: Swift.Sendable {
        /// Contains the ID of the starting waypoint in this connection.
        /// This member is required.
        public var from: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?
        /// Contains the ID of the ending waypoint in this connection.
        /// This member is required.
        public var to: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?

        public init(
            from: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry? = nil,
            to: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options to configure matching the provided position to a side of the street.
    public struct WaypointOptimizationSideOfStreetOptions: Swift.Sendable {
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Strategy that defines when the side of street position should be used. AnyStreet will always use the provided position. Default Value: DividedStreetOnly
        public var useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy?

        public init(
            position: [Swift.Double]? = nil,
            useWith: GeoRoutesClientTypes.SideOfStreetMatchingStrategy? = nil
        )
        {
            self.position = position
            self.useWith = useWith
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationSideOfStreetOptions(useWith: \(Swift.String(describing: useWith)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Destination related options.
    public struct WaypointOptimizationDestinationOptions: Swift.Sendable {
        /// Access hours corresponding to when a waypoint can be visited.
        public var accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours?
        /// Appointment time at the destination.
        public var appointmentTime: Swift.String?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// The waypoint Id.
        public var id: Swift.String?
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration. Unit: seconds
        public var serviceDuration: Swift.Int
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?

        public init(
            accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours? = nil,
            appointmentTime: Swift.String? = nil,
            heading: Swift.Double = 0.0,
            id: Swift.String? = nil,
            serviceDuration: Swift.Int = 0,
            sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions? = nil
        )
        {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.heading = heading
            self.id = id
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting. Unit: seconds
    public struct WaypointOptimizationRestCycleDurations: Swift.Sendable {
        /// Resting phase of the cycle. Unit: seconds
        /// This member is required.
        public var restDuration: Swift.Int
        /// Working phase of the cycle. Unit: seconds
        /// This member is required.
        public var workDuration: Swift.Int

        public init(
            restDuration: Swift.Int = 0,
            workDuration: Swift.Int = 0
        )
        {
            self.restDuration = restDuration
            self.workDuration = workDuration
        }
    }
}

extension GeoRoutesClientTypes {

    /// Resting phase of the cycle.
    public struct WaypointOptimizationRestCycles: Swift.Sendable {
        /// Long cycle for a driver work-rest schedule.
        /// This member is required.
        public var longCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?
        /// Short cycle for a driver work-rest schedule
        /// This member is required.
        public var shortCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?

        public init(
            longCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations? = nil,
            shortCycle: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations? = nil
        )
        {
            self.longCycle = longCycle
            self.shortCycle = shortCycle
        }
    }
}

extension GeoRoutesClientTypes {

    /// Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.
    public struct WaypointOptimizationRestProfile: Swift.Sendable {
        /// Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.
        /// This member is required.
        public var profile: Swift.String?

        public init(
            profile: Swift.String? = nil
        )
        {
            self.profile = profile
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationServiceTimeTreatment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rest
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationServiceTimeTreatment] {
            return [
                .rest,
                .work
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rest: return "Rest"
            case .work: return "Work"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Driver related options.
    public struct WaypointOptimizationDriverOptions: Swift.Sendable {
        /// Driver work-rest schedules defined by a short and long cycle. A rest needs to be taken after the short work duration. The short cycle can be repeated until you hit the long work duration, at which point the long rest duration should be taken before restarting.
        public var restCycles: GeoRoutesClientTypes.WaypointOptimizationRestCycles?
        /// Pre defined rest profiles for a driver schedule. The only currently supported profile is EU.
        public var restProfile: GeoRoutesClientTypes.WaypointOptimizationRestProfile?
        /// If the service time provided at a waypoint/destination should be considered as rest or work. This contributes to the total time breakdown returned within the response.
        public var treatServiceTimeAs: GeoRoutesClientTypes.WaypointOptimizationServiceTimeTreatment?

        public init(
            restCycles: GeoRoutesClientTypes.WaypointOptimizationRestCycles? = nil,
            restProfile: GeoRoutesClientTypes.WaypointOptimizationRestProfile? = nil,
            treatServiceTimeAs: GeoRoutesClientTypes.WaypointOptimizationServiceTimeTreatment? = nil
        )
        {
            self.restCycles = restCycles
            self.restProfile = restProfile
            self.treatServiceTimeAs = treatServiceTimeAs
        }
    }
}

extension GeoRoutesClientTypes {

    /// Exclusion options.
    public struct WaypointOptimizationExclusionOptions: Swift.Sendable {
        /// List of countries to be avoided defined by two-letter or three-letter country codes.
        /// This member is required.
        public var countries: [Swift.String]?

        public init(
            countries: [Swift.String]? = nil
        )
        {
            self.countries = countries
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationSequencingObjective: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fastestRoute
        case shortestRoute
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationSequencingObjective] {
            return [
                .fastestRoute,
                .shortestRoute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fastestRoute: return "FastestRoute"
            case .shortestRoute: return "ShortestRoute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to the origin.
    public struct WaypointOptimizationOriginOptions: Swift.Sendable {
        /// The Origin Id.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to traffic.
    public struct WaypointOptimizationTrafficOptions: Swift.Sendable {
        /// Determines if traffic should be used or ignored while calculating the route. Default Value: UseTrafficData
        public var usage: GeoRoutesClientTypes.TrafficUsage?

        public init(
            usage: GeoRoutesClientTypes.TrafficUsage? = nil
        )
        {
            self.usage = usage
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Options related to a pedestrian.
    public struct WaypointOptimizationPedestrianOptions: Swift.Sendable {
        /// Walking speed. Unit: KilometersPerHour
        public var speed: Swift.Double?

        public init(
            speed: Swift.Double? = 0.0
        )
        {
            self.speed = speed
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct WaypointOptimizationTrailerOptions: Swift.Sendable {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationTruckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case straightTruck
        case tractor
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationTruckType] {
            return [
                .straightTruck,
                .tractor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .straightTruck: return "StraightTruck"
            case .tractor: return "Tractor"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck"
    public struct WaypointOptimizationTruckOptions: Swift.Sendable {
        /// Gross weight of the vehicle including trailers, and goods at capacity. Unit: Kilograms
        public var grossWeight: Swift.Int
        /// List of Hazardous cargo contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType]?
        /// Height of the vehicle. Unit: centimeters
        public var height: Swift.Int
        /// Length of the vehicle. Unit: centimeters
        public var length: Swift.Int
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions?
        /// Type of the truck.
        public var truckType: GeoRoutesClientTypes.WaypointOptimizationTruckType?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?
        /// Heaviest weight per axle irrespective of the axle type or the axle group. Meant for usage in countries where the differences in axle types or axle groups are not distinguished. Unit: Kilograms
        public var weightPerAxle: Swift.Int
        /// Width of the vehicle. Unit: centimeters
        public var width: Swift.Int

        public init(
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            length: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions? = nil,
            truckType: GeoRoutesClientTypes.WaypointOptimizationTruckType? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            weightPerAxle: Swift.Int = 0,
            width: Swift.Int = 0
        )
        {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.truckType = truckType
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.weightPerAxle = weightPerAxle
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct WaypointOptimizationTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Pedestrian"
        public var pedestrian: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions?
        /// Travel mode options when the provided travel mode is "Truck"
        public var truck: GeoRoutesClientTypes.WaypointOptimizationTruckOptions?

        public init(
            pedestrian: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions? = nil,
            truck: GeoRoutesClientTypes.WaypointOptimizationTruckOptions? = nil
        )
        {
            self.pedestrian = pedestrian
            self.truck = truck
        }
    }
}

extension GeoRoutesClientTypes {

    /// Waypoint between the Origin and Destination.
    public struct WaypointOptimizationWaypoint: Swift.Sendable {
        /// Access hours corresponding to when a waypoint can be visited.
        public var accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours?
        /// Appointment time at the waypoint.
        public var appointmentTime: Swift.String?
        /// Constraint defining what waypoints are to be visited after this waypoint.
        public var before: [Swift.Int]?
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// The waypoint Id.
        public var id: Swift.String?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Service time spent at the waypoint. At an appointment, the service time should be the appointment duration. Unit: seconds
        public var serviceDuration: Swift.Int
        /// Options to configure matching the provided position to a side of the street.
        public var sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?

        public init(
            accessHours: GeoRoutesClientTypes.WaypointOptimizationAccessHours? = nil,
            appointmentTime: Swift.String? = nil,
            before: [Swift.Int]? = nil,
            heading: Swift.Double = 0.0,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil,
            serviceDuration: Swift.Int = 0,
            sideOfStreet: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions? = nil
        )
        {
            self.accessHours = accessHours
            self.appointmentTime = appointmentTime
            self.before = before
            self.heading = heading
            self.id = id
            self.position = position
            self.serviceDuration = serviceDuration
            self.sideOfStreet = sideOfStreet
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationWaypoint(accessHours: \(Swift.String(describing: accessHours)), appointmentTime: \(Swift.String(describing: appointmentTime)), before: \(Swift.String(describing: before)), heading: \(Swift.String(describing: heading)), id: \(Swift.String(describing: id)), serviceDuration: \(Swift.String(describing: serviceDuration)), sideOfStreet: \(Swift.String(describing: sideOfStreet)), position: \"CONTENT_REDACTED\")"}
}

public struct OptimizeWaypointsInput: Swift.Sendable {
    /// Features that are avoided while calculating a route. Avoidance is on a best-case basis. If an avoidance can't be satisfied for a particular case, this setting is ignored.
    public var avoid: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions?
    /// Departure time from the waypoint. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
    ///     2020-04-22T17:57:24+02:00
    public var departureTime: Swift.String?
    /// The final position for the route in the World Geodetic System (WGS 84) format: [longitude, latitude].
    public var destination: [Swift.Double]?
    /// Destination related options.
    public var destinationOptions: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions?
    /// Driver related options.
    public var driver: GeoRoutesClientTypes.WaypointOptimizationDriverOptions?
    /// Features to be strictly excluded while calculating the route.
    public var exclude: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the optimization criteria for the calculated sequence. Default Value: FastestRoute.
    public var optimizeSequencingFor: GeoRoutesClientTypes.WaypointOptimizationSequencingObjective?
    /// The start position for the route.
    /// This member is required.
    public var origin: [Swift.Double]?
    /// Origin related options.
    public var originOptions: GeoRoutesClientTypes.WaypointOptimizationOriginOptions?
    /// Traffic-related options.
    public var traffic: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
    public var travelMode: GeoRoutesClientTypes.WaypointOptimizationTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions?
    /// List of waypoints between the Origin and Destination.
    public var waypoints: [GeoRoutesClientTypes.WaypointOptimizationWaypoint]?

    public init(
        avoid: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions? = nil,
        departureTime: Swift.String? = nil,
        destination: [Swift.Double]? = nil,
        destinationOptions: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions? = nil,
        driver: GeoRoutesClientTypes.WaypointOptimizationDriverOptions? = nil,
        exclude: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions? = nil,
        key: Swift.String? = nil,
        optimizeSequencingFor: GeoRoutesClientTypes.WaypointOptimizationSequencingObjective? = nil,
        origin: [Swift.Double]? = nil,
        originOptions: GeoRoutesClientTypes.WaypointOptimizationOriginOptions? = nil,
        traffic: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions? = nil,
        travelMode: GeoRoutesClientTypes.WaypointOptimizationTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions? = nil,
        waypoints: [GeoRoutesClientTypes.WaypointOptimizationWaypoint]? = nil
    )
    {
        self.avoid = avoid
        self.departureTime = departureTime
        self.destination = destination
        self.destinationOptions = destinationOptions
        self.driver = driver
        self.exclude = exclude
        self.key = key
        self.optimizeSequencingFor = optimizeSequencingFor
        self.origin = origin
        self.originOptions = originOptions
        self.traffic = traffic
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
        self.waypoints = waypoints
    }
}

extension OptimizeWaypointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptimizeWaypointsInput(avoid: \(Swift.String(describing: avoid)), departureTime: \(Swift.String(describing: departureTime)), destinationOptions: \(Swift.String(describing: destinationOptions)), driver: \(Swift.String(describing: driver)), exclude: \(Swift.String(describing: exclude)), optimizeSequencingFor: \(Swift.String(describing: optimizeSequencingFor)), originOptions: \(Swift.String(describing: originOptions)), traffic: \(Swift.String(describing: traffic)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), waypoints: \(Swift.String(describing: waypoints)), destination: \"CONTENT_REDACTED\", key: \"CONTENT_REDACTED\", origin: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// This contains information such as distance and duration from one waypoint to the next waypoint in the sequence.
    public struct WaypointOptimizationConnection: Swift.Sendable {
        /// Distance of the step.
        /// This member is required.
        public var distance: Swift.Int
        /// contains the ID of the starting waypoint in this connection.
        /// This member is required.
        public var from: Swift.String?
        /// Resting time before the driver can continue driving.
        /// This member is required.
        public var restDuration: Swift.Int
        /// Contains the ID of the ending waypoint in this connection.
        /// This member is required.
        public var to: Swift.String?
        /// Total duration. Unit: seconds
        /// This member is required.
        public var travelDuration: Swift.Int
        /// Duration of a wait step. Unit: seconds
        /// This member is required.
        public var waitDuration: Swift.Int

        public init(
            distance: Swift.Int = 0,
            from: Swift.String? = nil,
            restDuration: Swift.Int = 0,
            to: Swift.String? = nil,
            travelDuration: Swift.Int = 0,
            waitDuration: Swift.Int = 0
        )
        {
            self.distance = distance
            self.from = from
            self.restDuration = restDuration
            self.to = to
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }
    }
}

extension GeoRoutesClientTypes {

    public enum WaypointOptimizationConstraint: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessHours
        case appointmentTime
        case before
        case heading
        case serviceDuration
        case sideOfStreet
        case sdkUnknown(Swift.String)

        public static var allCases: [WaypointOptimizationConstraint] {
            return [
                .accessHours,
                .appointmentTime,
                .before,
                .heading,
                .serviceDuration,
                .sideOfStreet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessHours: return "AccessHours"
            case .appointmentTime: return "AppointmentTime"
            case .before: return "Before"
            case .heading: return "Heading"
            case .serviceDuration: return "ServiceDuration"
            case .sideOfStreet: return "SideOfStreet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// The failed constraint.
    public struct WaypointOptimizationFailedConstraint: Swift.Sendable {
        /// The failed constraint.
        public var constraint: GeoRoutesClientTypes.WaypointOptimizationConstraint?
        /// Reason for the failed constraint.
        public var reason: Swift.String?

        public init(
            constraint: GeoRoutesClientTypes.WaypointOptimizationConstraint? = nil,
            reason: Swift.String? = nil
        )
        {
            self.constraint = constraint
            self.reason = reason
        }
    }
}

extension GeoRoutesClientTypes {

    /// The impeding waypoint.
    public struct WaypointOptimizationImpedingWaypoint: Swift.Sendable {
        /// Failed constraints for an impeding waypoint.
        /// This member is required.
        public var failedConstraints: [GeoRoutesClientTypes.WaypointOptimizationFailedConstraint]?
        /// The waypoint Id.
        /// This member is required.
        public var id: Swift.String?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            failedConstraints: [GeoRoutesClientTypes.WaypointOptimizationFailedConstraint]? = nil,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.failedConstraints = failedConstraints
            self.id = id
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationImpedingWaypoint(failedConstraints: \(Swift.String(describing: failedConstraints)), id: \(Swift.String(describing: id)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// The optimized waypoint.
    public struct WaypointOptimizationOptimizedWaypoint: Swift.Sendable {
        /// Estimated time of arrival at the destination. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
        ///     2020-04-22T17:57:24+02:00
        public var arrivalTime: Swift.String?
        /// Estimated time of departure from thr origin. Time format:YYYY-MM-DDThh:mm:ss.sssZ | YYYY-MM-DDThh:mm:ss.sss+hh:mm Examples: 2020-04-22T17:57:24Z
        ///     2020-04-22T17:57:24+02:00
        /// This member is required.
        public var departureTime: Swift.String?
        /// The waypoint Id.
        /// This member is required.
        public var id: Swift.String?
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?

        public init(
            arrivalTime: Swift.String? = nil,
            departureTime: Swift.String? = nil,
            id: Swift.String? = nil,
            position: [Swift.Double]? = nil
        )
        {
            self.arrivalTime = arrivalTime
            self.departureTime = departureTime
            self.id = id
            self.position = position
        }
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WaypointOptimizationOptimizedWaypoint(arrivalTime: \(Swift.String(describing: arrivalTime)), departureTime: \(Swift.String(describing: departureTime)), id: \(Swift.String(describing: id)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// Time breakdown for the sequence.
    public struct WaypointOptimizationTimeBreakdown: Swift.Sendable {
        /// Resting phase of the cycle. Unit: seconds
        /// This member is required.
        public var restDuration: Swift.Int
        /// Service time spent at the destination. At an appointment, the service time should be the appointment duration. Unit: seconds
        /// This member is required.
        public var serviceDuration: Swift.Int
        /// Traveling phase of the cycle. Unit: seconds
        /// This member is required.
        public var travelDuration: Swift.Int
        /// Waiting phase of the cycle. Unit: seconds
        /// This member is required.
        public var waitDuration: Swift.Int

        public init(
            restDuration: Swift.Int = 0,
            serviceDuration: Swift.Int = 0,
            travelDuration: Swift.Int = 0,
            waitDuration: Swift.Int = 0
        )
        {
            self.restDuration = restDuration
            self.serviceDuration = serviceDuration
            self.travelDuration = travelDuration
            self.waitDuration = waitDuration
        }
    }
}

public struct OptimizeWaypointsOutput: Swift.Sendable {
    /// Details about the connection from one waypoint to the next, within the optimized sequence.
    /// This member is required.
    public var connections: [GeoRoutesClientTypes.WaypointOptimizationConnection]?
    /// Overall distance to travel the whole sequence.
    /// This member is required.
    public var distance: Swift.Int
    /// Overall duration to travel the whole sequence. Unit: seconds
    /// This member is required.
    public var duration: Swift.Int
    /// Returns waypoints that caused the optimization problem to fail, and the constraints that were unsatisfied leading to the failure.
    /// This member is required.
    public var impedingWaypoints: [GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint]?
    /// Waypoints in the order of the optimized sequence.
    /// This member is required.
    public var optimizedWaypoints: [GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint]?
    /// The pricing bucket for which the query is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// Time breakdown for the sequence.
    /// This member is required.
    public var timeBreakdown: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown?

    public init(
        connections: [GeoRoutesClientTypes.WaypointOptimizationConnection]? = nil,
        distance: Swift.Int = 0,
        duration: Swift.Int = 0,
        impedingWaypoints: [GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint]? = nil,
        optimizedWaypoints: [GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint]? = nil,
        pricingBucket: Swift.String? = nil,
        timeBreakdown: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown? = nil
    )
    {
        self.connections = connections
        self.distance = distance
        self.duration = duration
        self.impedingWaypoints = impedingWaypoints
        self.optimizedWaypoints = optimizedWaypoints
        self.pricingBucket = pricingBucket
        self.timeBreakdown = timeBreakdown
    }
}

extension GeoRoutesClientTypes {

    /// TracePoint indices for which the provided notice code corresponds to.
    public struct RoadSnapTracePoint: Swift.Sendable {
        /// GPS Heading at the position.
        public var heading: Swift.Double
        /// Position defined as [longitude, latitude].
        /// This member is required.
        public var position: [Swift.Double]?
        /// Speed at the specified trace point . Unit: KilometersPerHour
        public var speed: Swift.Double
        /// Timestamp of the event.
        public var timestamp: Swift.String?

        public init(
            heading: Swift.Double = 0.0,
            position: [Swift.Double]? = nil,
            speed: Swift.Double = 0.0,
            timestamp: Swift.String? = nil
        )
        {
            self.heading = heading
            self.position = position
            self.speed = speed
            self.timestamp = timestamp
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapTracePoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapTracePoint(heading: \(Swift.String(describing: heading)), speed: \(Swift.String(describing: speed)), timestamp: \(Swift.String(describing: timestamp)), position: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RoadSnapTravelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case car
        case pedestrian
        case scooter
        case truck
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapTravelMode] {
            return [
                .car,
                .pedestrian,
                .scooter,
                .truck
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .car: return "Car"
            case .pedestrian: return "Pedestrian"
            case .scooter: return "Scooter"
            case .truck: return "Truck"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    public enum RoadSnapHazardousCargoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case combustible
        case corrosive
        case explosive
        case flammable
        case gas
        case harmfulToWater
        case organic
        case other
        case poison
        case poisonousInhalation
        case radioactive
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapHazardousCargoType] {
            return [
                .combustible,
                .corrosive,
                .explosive,
                .flammable,
                .gas,
                .harmfulToWater,
                .organic,
                .other,
                .poison,
                .poisonousInhalation,
                .radioactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .combustible: return "Combustible"
            case .corrosive: return "Corrosive"
            case .explosive: return "Explosive"
            case .flammable: return "Flammable"
            case .gas: return "Gas"
            case .harmfulToWater: return "HarmfulToWater"
            case .organic: return "Organic"
            case .other: return "Other"
            case .poison: return "Poison"
            case .poisonousInhalation: return "PoisonousInhalation"
            case .radioactive: return "Radioactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Trailer options corresponding to the vehicle.
    public struct RoadSnapTrailerOptions: Swift.Sendable {
        /// Number of trailers attached to the vehicle. Default Value: 0
        public var trailerCount: Swift.Int?

        public init(
            trailerCount: Swift.Int? = nil
        )
        {
            self.trailerCount = trailerCount
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode options when the provided travel mode is "Truck".
    public struct RoadSnapTruckOptions: Swift.Sendable {
        /// Gross weight of the vehicle including trailers, and goods at capacity. Unit: Kilograms
        public var grossWeight: Swift.Int
        /// List of Hazardous cargos contained in the vehicle.
        public var hazardousCargos: [GeoRoutesClientTypes.RoadSnapHazardousCargoType]?
        /// Height of the vehicle. Unit: centimeters
        public var height: Swift.Int
        /// Length of the vehicle. Unit: centimeters
        public var length: Swift.Int
        /// Trailer options corresponding to the vehicle.
        public var trailer: GeoRoutesClientTypes.RoadSnapTrailerOptions?
        /// The tunnel restriction code. Tunnel categories in this list indicate the restrictions which apply to certain tunnels in Great Britain. They relate to the types of dangerous goods that can be transported through them.
        ///
        /// * Tunnel Category B
        ///
        /// * Risk Level: Limited risk
        ///
        /// * Restrictions: Few restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category C
        ///
        /// * Risk Level: Medium risk
        ///
        /// * Restrictions: Some restrictions
        ///
        ///
        ///
        ///
        /// * Tunnel Category D
        ///
        /// * Risk Level: High risk
        ///
        /// * Restrictions: Many restrictions occur
        ///
        ///
        ///
        ///
        /// * Tunnel Category E
        ///
        /// * Risk Level: Very high risk
        ///
        /// * Restrictions: Restricted tunnel
        public var tunnelRestrictionCode: Swift.String?
        /// Width of the vehicle in centimenters.
        public var width: Swift.Int

        public init(
            grossWeight: Swift.Int = 0,
            hazardousCargos: [GeoRoutesClientTypes.RoadSnapHazardousCargoType]? = nil,
            height: Swift.Int = 0,
            length: Swift.Int = 0,
            trailer: GeoRoutesClientTypes.RoadSnapTrailerOptions? = nil,
            tunnelRestrictionCode: Swift.String? = nil,
            width: Swift.Int = 0
        )
        {
            self.grossWeight = grossWeight
            self.hazardousCargos = hazardousCargos
            self.height = height
            self.length = length
            self.trailer = trailer
            self.tunnelRestrictionCode = tunnelRestrictionCode
            self.width = width
        }
    }
}

extension GeoRoutesClientTypes {

    /// Travel mode related options for the provided travel mode.
    public struct RoadSnapTravelModeOptions: Swift.Sendable {
        /// Travel mode options when the provided travel mode is "Truck".
        public var truck: GeoRoutesClientTypes.RoadSnapTruckOptions?

        public init(
            truck: GeoRoutesClientTypes.RoadSnapTruckOptions? = nil
        )
        {
            self.truck = truck
        }
    }
}

public struct SnapToRoadsInput: Swift.Sendable {
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// The radius around the provided tracepoint that is considered for snapping. Unit: meters Default value: 300
    public var snapRadius: Swift.Int?
    /// Chooses what the returned SnappedGeometry format should be. Default Value: FlexiblePolyline
    public var snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// List of trace points to be snapped onto the road network.
    /// This member is required.
    public var tracePoints: [GeoRoutesClientTypes.RoadSnapTracePoint]?
    /// Specifies the mode of transport when calculating a route. Used in estimating the speed of travel and road compatibility. Default Value: Car
    public var travelMode: GeoRoutesClientTypes.RoadSnapTravelMode?
    /// Travel mode related options for the provided travel mode.
    public var travelModeOptions: GeoRoutesClientTypes.RoadSnapTravelModeOptions?

    public init(
        key: Swift.String? = nil,
        snapRadius: Swift.Int? = 0,
        snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        tracePoints: [GeoRoutesClientTypes.RoadSnapTracePoint]? = nil,
        travelMode: GeoRoutesClientTypes.RoadSnapTravelMode? = nil,
        travelModeOptions: GeoRoutesClientTypes.RoadSnapTravelModeOptions? = nil
    )
    {
        self.key = key
        self.snapRadius = snapRadius
        self.snappedGeometryFormat = snappedGeometryFormat
        self.tracePoints = tracePoints
        self.travelMode = travelMode
        self.travelModeOptions = travelModeOptions
    }
}

extension SnapToRoadsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapToRoadsInput(snapRadius: \(Swift.String(describing: snapRadius)), snappedGeometryFormat: \(Swift.String(describing: snappedGeometryFormat)), tracePoints: \(Swift.String(describing: tracePoints)), travelMode: \(Swift.String(describing: travelMode)), travelModeOptions: \(Swift.String(describing: travelModeOptions)), key: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    public enum RoadSnapNoticeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tracePointsHeadingIgnored
        case tracePointsIgnored
        case tracePointsMovedByLargeDistance
        case tracePointsNotMatched
        case tracePointsOutOfSequence
        case tracePointsSpeedEstimated
        case tracePointsSpeedIgnored
        case sdkUnknown(Swift.String)

        public static var allCases: [RoadSnapNoticeCode] {
            return [
                .tracePointsHeadingIgnored,
                .tracePointsIgnored,
                .tracePointsMovedByLargeDistance,
                .tracePointsNotMatched,
                .tracePointsOutOfSequence,
                .tracePointsSpeedEstimated,
                .tracePointsSpeedIgnored
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tracePointsHeadingIgnored: return "TracePointsHeadingIgnored"
            case .tracePointsIgnored: return "TracePointsIgnored"
            case .tracePointsMovedByLargeDistance: return "TracePointsMovedByLargeDistance"
            case .tracePointsNotMatched: return "TracePointsNotMatched"
            case .tracePointsOutOfSequence: return "TracePointsOutOfSequence"
            case .tracePointsSpeedEstimated: return "TracePointsSpeedEstimated"
            case .tracePointsSpeedIgnored: return "TracePointsSpeedIgnored"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoRoutesClientTypes {

    /// Notices provide information around factors that may have influenced snapping in a manner atypical to the standard use cases.
    public struct RoadSnapNotice: Swift.Sendable {
        /// Code corresponding to the issue.
        /// This member is required.
        public var code: GeoRoutesClientTypes.RoadSnapNoticeCode?
        /// The notice title.
        /// This member is required.
        public var title: Swift.String?
        /// TracePoint indices for which the provided notice code corresponds to.
        /// This member is required.
        public var tracePointIndexes: [Swift.Int]?

        public init(
            code: GeoRoutesClientTypes.RoadSnapNoticeCode? = nil,
            title: Swift.String? = nil,
            tracePointIndexes: [Swift.Int]? = nil
        )
        {
            self.code = code
            self.title = title
            self.tracePointIndexes = tracePointIndexes
        }
    }
}

extension GeoRoutesClientTypes {

    /// Interpolated geometry for the snapped route that is overlay-able onto a map.
    public struct RoadSnapSnappedGeometry: Swift.Sendable {
        /// An ordered list of positions used to plot a route on a map. LineString and Polyline are mutually exclusive properties.
        public var lineString: [[Swift.Double]]?
        /// An ordered list of positions used to plot a route on a map in a lossy compression format. LineString and Polyline are mutually exclusive properties.
        public var polyline: Swift.String?

        public init(
            lineString: [[Swift.Double]]? = nil,
            polyline: Swift.String? = nil
        )
        {
            self.lineString = lineString
            self.polyline = polyline
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedGeometry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapSnappedGeometry(lineString: \"CONTENT_REDACTED\", polyline: \"CONTENT_REDACTED\")"}
}

extension GeoRoutesClientTypes {

    /// TracePoints snapped onto the road network.
    public struct RoadSnapSnappedTracePoint: Swift.Sendable {
        /// Confidence value for the correctness of this point match.
        /// This member is required.
        public var confidence: Swift.Double?
        /// Position of the TracePoint provided within the request, at the same index.
        /// This member is required.
        public var originalPosition: [Swift.Double]?
        /// Snapped position of the TracePoint provided within the request, at the same index.
        /// This member is required.
        public var snappedPosition: [Swift.Double]?

        public init(
            confidence: Swift.Double? = nil,
            originalPosition: [Swift.Double]? = nil,
            snappedPosition: [Swift.Double]? = nil
        )
        {
            self.confidence = confidence
            self.originalPosition = originalPosition
            self.snappedPosition = snappedPosition
        }
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedTracePoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RoadSnapSnappedTracePoint(confidence: \(Swift.String(describing: confidence)), originalPosition: \"CONTENT_REDACTED\", snappedPosition: \"CONTENT_REDACTED\")"}
}

public struct SnapToRoadsOutput: Swift.Sendable {
    /// Notices are additional information returned that indicate issues that occurred during route calculation.
    /// This member is required.
    public var notices: [GeoRoutesClientTypes.RoadSnapNotice]?
    /// The pricing bucket for which the query is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?
    /// The interpolated geometry for the snapped route onto the road network.
    public var snappedGeometry: GeoRoutesClientTypes.RoadSnapSnappedGeometry?
    /// Specifies the format of the geometry returned for each leg of the route.
    /// This member is required.
    public var snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat?
    /// The trace points snapped onto the road network.
    /// This member is required.
    public var snappedTracePoints: [GeoRoutesClientTypes.RoadSnapSnappedTracePoint]?

    public init(
        notices: [GeoRoutesClientTypes.RoadSnapNotice]? = nil,
        pricingBucket: Swift.String? = nil,
        snappedGeometry: GeoRoutesClientTypes.RoadSnapSnappedGeometry? = nil,
        snappedGeometryFormat: GeoRoutesClientTypes.GeometryFormat? = nil,
        snappedTracePoints: [GeoRoutesClientTypes.RoadSnapSnappedTracePoint]? = nil
    )
    {
        self.notices = notices
        self.pricingBucket = pricingBucket
        self.snappedGeometry = snappedGeometry
        self.snappedGeometryFormat = snappedGeometryFormat
        self.snappedTracePoints = snappedTracePoints
    }
}

extension CalculateIsolinesInput {

    static func urlPathProvider(_ value: CalculateIsolinesInput) -> Swift.String? {
        return "/isolines"
    }
}

extension CalculateIsolinesInput {

    static func queryItemProvider(_ value: CalculateIsolinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRouteMatrixInput {

    static func urlPathProvider(_ value: CalculateRouteMatrixInput) -> Swift.String? {
        return "/route-matrix"
    }
}

extension CalculateRouteMatrixInput {

    static func queryItemProvider(_ value: CalculateRouteMatrixInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateRoutesInput {

    static func urlPathProvider(_ value: CalculateRoutesInput) -> Swift.String? {
        return "/routes"
    }
}

extension CalculateRoutesInput {

    static func queryItemProvider(_ value: CalculateRoutesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension OptimizeWaypointsInput {

    static func urlPathProvider(_ value: OptimizeWaypointsInput) -> Swift.String? {
        return "/optimize-waypoints"
    }
}

extension OptimizeWaypointsInput {

    static func queryItemProvider(_ value: OptimizeWaypointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension SnapToRoadsInput {

    static func urlPathProvider(_ value: SnapToRoadsInput) -> Swift.String? {
        return "/snap-to-roads"
    }
}

extension SnapToRoadsInput {

    static func queryItemProvider(_ value: SnapToRoadsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension CalculateIsolinesInput {

    static func write(value: CalculateIsolinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.IsolineAllowOptions.write(value:to:))
        try writer["ArrivalTime"].write(value.arrivalTime)
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.IsolineAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.IsolineDestinationOptions.write(value:to:))
        try writer["IsolineGeometryFormat"].write(value.isolineGeometryFormat)
        try writer["IsolineGranularity"].write(value.isolineGranularity, with: GeoRoutesClientTypes.IsolineGranularityOptions.write(value:to:))
        try writer["OptimizeIsolineFor"].write(value.optimizeIsolineFor)
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.IsolineOriginOptions.write(value:to:))
        try writer["Thresholds"].write(value.thresholds, with: GeoRoutesClientTypes.IsolineThresholds.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.IsolineTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.IsolineTravelModeOptions.write(value:to:))
    }
}

extension CalculateRouteMatrixInput {

    static func write(value: CalculateRouteMatrixInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.RouteMatrixAllowOptions.write(value:to:))
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixDestination.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.RouteMatrixExclusionOptions.write(value:to:))
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origins"].writeList(value.origins, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixOrigin.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoutingBoundary"].write(value.routingBoundary, with: GeoRoutesClientTypes.RouteMatrixBoundary.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.RouteMatrixTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RouteMatrixTravelModeOptions.write(value:to:))
    }
}

extension CalculateRoutesInput {

    static func write(value: CalculateRoutesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: GeoRoutesClientTypes.RouteAllowOptions.write(value:to:))
        try writer["ArrivalTime"].write(value.arrivalTime)
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.RouteAvoidanceOptions.write(value:to:))
        try writer["DepartNow"].write(value.departNow)
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.RouteDestinationOptions.write(value:to:))
        try writer["Driver"].write(value.driver, with: GeoRoutesClientTypes.RouteDriverOptions.write(value:to:))
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.RouteExclusionOptions.write(value:to:))
        try writer["InstructionsMeasurementSystem"].write(value.instructionsMeasurementSystem)
        try writer["Languages"].writeList(value.languages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LegAdditionalFeatures"].writeList(value.legAdditionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteLegAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LegGeometryFormat"].write(value.legGeometryFormat)
        try writer["MaxAlternatives"].write(value.maxAlternatives)
        try writer["OptimizeRoutingFor"].write(value.optimizeRoutingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.RouteOriginOptions.write(value:to:))
        try writer["SpanAdditionalFeatures"].writeList(value.spanAdditionalFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteSpanAdditionalFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tolls"].write(value.tolls, with: GeoRoutesClientTypes.RouteTollOptions.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.RouteTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RouteTravelModeOptions.write(value:to:))
        try writer["TravelStepType"].write(value.travelStepType)
        try writer["Waypoints"].writeList(value.waypoints, memberWritingClosure: GeoRoutesClientTypes.RouteWaypoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension OptimizeWaypointsInput {

    static func write(value: OptimizeWaypointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Avoid"].write(value.avoid, with: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions.write(value:to:))
        try writer["DepartureTime"].write(value.departureTime)
        try writer["Destination"].writeList(value.destination, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DestinationOptions"].write(value.destinationOptions, with: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions.write(value:to:))
        try writer["Driver"].write(value.driver, with: GeoRoutesClientTypes.WaypointOptimizationDriverOptions.write(value:to:))
        try writer["Exclude"].write(value.exclude, with: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions.write(value:to:))
        try writer["OptimizeSequencingFor"].write(value.optimizeSequencingFor)
        try writer["Origin"].writeList(value.origin, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OriginOptions"].write(value.originOptions, with: GeoRoutesClientTypes.WaypointOptimizationOriginOptions.write(value:to:))
        try writer["Traffic"].write(value.traffic, with: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions.write(value:to:))
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions.write(value:to:))
        try writer["Waypoints"].writeList(value.waypoints, memberWritingClosure: GeoRoutesClientTypes.WaypointOptimizationWaypoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SnapToRoadsInput {

    static func write(value: SnapToRoadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapRadius"].write(value.snapRadius)
        try writer["SnappedGeometryFormat"].write(value.snappedGeometryFormat)
        try writer["TracePoints"].writeList(value.tracePoints, memberWritingClosure: GeoRoutesClientTypes.RoadSnapTracePoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TravelMode"].write(value.travelMode)
        try writer["TravelModeOptions"].write(value.travelModeOptions, with: GeoRoutesClientTypes.RoadSnapTravelModeOptions.write(value:to:))
    }
}

extension CalculateIsolinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateIsolinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateIsolinesOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.arrivalTime = try reader["ArrivalTime"].readIfPresent()
        value.departureTime = try reader["DepartureTime"].readIfPresent()
        value.isolineGeometryFormat = try reader["IsolineGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.isolines = try reader["Isolines"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.Isoline.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedDestination = try reader["SnappedDestination"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.snappedOrigin = try reader["SnappedOrigin"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CalculateRouteMatrixOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateRouteMatrixOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRouteMatrixOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.errorCount = try reader["ErrorCount"].readIfPresent() ?? 0
        value.routeMatrix = try reader["RouteMatrix"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: GeoRoutesClientTypes.RouteMatrixEntry.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routingBoundary = try reader["RoutingBoundary"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixBoundary.read(from:))
        return value
    }
}

extension CalculateRoutesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CalculateRoutesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CalculateRoutesOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.legGeometryFormat = try reader["LegGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteResponseNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routes = try reader["Routes"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension OptimizeWaypointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OptimizeWaypointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = OptimizeWaypointsOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationConnection.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.impedingWaypoints = try reader["ImpedingWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.optimizedWaypoints = try reader["OptimizedWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeBreakdown = try reader["TimeBreakdown"].readIfPresent(with: GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown.read(from:))
        return value
    }
}

extension SnapToRoadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SnapToRoadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SnapToRoadsOutput()
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoadSnapNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedGeometry = try reader["SnappedGeometry"].readIfPresent(with: GeoRoutesClientTypes.RoadSnapSnappedGeometry.read(from:))
        value.snappedGeometryFormat = try reader["SnappedGeometryFormat"].readIfPresent() ?? .sdkUnknown("")
        value.snappedTracePoints = try reader["SnappedTracePoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoadSnapSnappedTracePoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum CalculateIsolinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CalculateRouteMatrixOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CalculateRoutesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OptimizeWaypointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SnapToRoadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GeoRoutesClientTypes.Isoline {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Isoline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Isoline()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.IsolineConnection.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.distanceThreshold = try reader["DistanceThreshold"].readIfPresent() ?? 0
        value.geometries = try reader["Geometries"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.IsolineShapeGeometry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeThreshold = try reader["TimeThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.IsolineShapeGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineShapeGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineShapeGeometry()
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polylinePolygon = try reader["PolylinePolygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.IsolineConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineConnection()
        value.fromPolygonIndex = try reader["FromPolygonIndex"].readIfPresent() ?? 0
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.IsolineConnectionGeometry.read(from:))
        value.toPolygonIndex = try reader["ToPolygonIndex"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.IsolineConnectionGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.IsolineConnectionGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.IsolineConnectionGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixEntry()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.error = try reader["Error"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundary {

    static func write(value: GeoRoutesClientTypes.RouteMatrixBoundary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry.write(value:to:))
        try writer["Unbounded"].write(value.unbounded)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixBoundary()
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry.read(from:))
        value.unbounded = try reader["Unbounded"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixBoundaryGeometry {

    static func write(value: GeoRoutesClientTypes.RouteMatrixBoundaryGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoCircle"].write(value.autoCircle, with: GeoRoutesClientTypes.RouteMatrixAutoCircle.write(value:to:))
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Circle"].write(value.circle, with: GeoRoutesClientTypes.Circle.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixBoundaryGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixBoundaryGeometry()
        value.autoCircle = try reader["AutoCircle"].readIfPresent(with: GeoRoutesClientTypes.RouteMatrixAutoCircle.read(from:))
        value.circle = try reader["Circle"].readIfPresent(with: GeoRoutesClientTypes.Circle.read(from:))
        value.boundingBox = try reader["BoundingBox"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.polygon = try reader["Polygon"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.Circle {

    static func write(value: GeoRoutesClientTypes.Circle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Center"].writeList(value.center, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Circle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Circle()
        value.center = try reader["Center"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.radius = try reader["Radius"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteMatrixAutoCircle {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAutoCircle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Margin"].write(value.margin)
        try writer["MaxRadius"].write(value.maxRadius)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMatrixAutoCircle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMatrixAutoCircle()
        value.margin = try reader["Margin"].readIfPresent() ?? 0
        value.maxRadius = try reader["MaxRadius"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteResponseNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteResponseNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteResponseNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.Route {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.Route {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.Route()
        value.legs = try reader["Legs"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteLeg.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.majorRoadLabels = try reader["MajorRoadLabels"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteMajorRoadLabel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteSummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSummary()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.tolls = try reader["Tolls"].readIfPresent(with: GeoRoutesClientTypes.RouteTollSummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollSummary()
        value.total = try reader["Total"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceSummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPriceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPriceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPriceSummary()
        value.currency = try reader["Currency"].readIfPresent() ?? ""
        value.estimate = try reader["Estimate"].readIfPresent() ?? false
        value.range = try reader["Range"].readIfPresent() ?? false
        value.rangeValue = try reader["RangeValue"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceValueRange.read(from:))
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPriceValueRange {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPriceValueRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPriceValueRange()
        value.min = try reader["Min"].readIfPresent() ?? 0.0
        value.max = try reader["Max"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteMajorRoadLabel {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteMajorRoadLabel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteMajorRoadLabel()
        value.roadName = try reader["RoadName"].readIfPresent(with: GeoRoutesClientTypes.LocalizedString.read(from:))
        value.routeNumber = try reader["RouteNumber"].readIfPresent(with: GeoRoutesClientTypes.RouteNumber.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteNumber {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteNumber()
        value.direction = try reader["Direction"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.LocalizedString {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.LocalizedString {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.LocalizedString()
        value.language = try reader["Language"].readIfPresent()
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.RouteLeg {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteLeg {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteLeg()
        value.ferryLegDetails = try reader["FerryLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryLegDetails.read(from:))
        value.geometry = try reader["Geometry"].readIfPresent(with: GeoRoutesClientTypes.RouteLegGeometry.read(from:))
        value.language = try reader["Language"].readIfPresent()
        value.pedestrianLegDetails = try reader["PedestrianLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianLegDetails.read(from:))
        value.travelMode = try reader["TravelMode"].readIfPresent() ?? .sdkUnknown("")
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.vehicleLegDetails = try reader["VehicleLegDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleLegDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleLegDetails()
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleArrival.read(from:))
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleDeparture.read(from:))
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleIncident.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleSpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleSummary.read(from:))
        value.tolls = try reader["Tolls"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteToll.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tollSystems = try reader["TollSystems"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollSystem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.truckRoadTypes = try reader["TruckRoadTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.zones = try reader["Zones"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteZone.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteZone {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteZone()
        value.category = try reader["Category"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleTravelStep()
        value.continueHighwayStepDetails = try reader["ContinueHighwayStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueHighwayStepDetails.read(from:))
        value.continueStepDetails = try reader["ContinueStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueStepDetails.read(from:))
        value.currentRoad = try reader["CurrentRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.enterHighwayStepDetails = try reader["EnterHighwayStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteEnterHighwayStepDetails.read(from:))
        value.exitNumber = try reader["ExitNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exitStepDetails = try reader["ExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteExitStepDetails.read(from:))
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.keepStepDetails = try reader["KeepStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteKeepStepDetails.read(from:))
        value.nextRoad = try reader["NextRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.rampStepDetails = try reader["RampStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRampStepDetails.read(from:))
        value.roundaboutEnterStepDetails = try reader["RoundaboutEnterStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails.read(from:))
        value.roundaboutExitStepDetails = try reader["RoundaboutExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails.read(from:))
        value.roundaboutPassStepDetails = try reader["RoundaboutPassStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails.read(from:))
        value.signpost = try reader["Signpost"].readIfPresent(with: GeoRoutesClientTypes.RouteSignpost.read(from:))
        value.turnStepDetails = try reader["TurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteTurnStepDetails.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.uTurnStepDetails = try reader["UTurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteUTurnStepDetails.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteUTurnStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteUTurnStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteUTurnStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTurnStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTurnStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTurnStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteSignpost {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSignpost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSignpost()
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteSignpostLabel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteSignpostLabel {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSignpostLabel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSignpostLabel()
        value.routeNumber = try reader["RouteNumber"].readIfPresent(with: GeoRoutesClientTypes.RouteNumber.read(from:))
        value.text = try reader["Text"].readIfPresent(with: GeoRoutesClientTypes.LocalizedString.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutPassStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutPassStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutPassStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutExitStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutExitStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutExitStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.relativeExit = try reader["RelativeExit"].readIfPresent()
        value.roundaboutAngle = try reader["RoundaboutAngle"].readIfPresent() ?? 0
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRampStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRampStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRampStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteRoad {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteRoad {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteRoad()
        value.roadName = try reader["RoadName"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routeNumber = try reader["RouteNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.towards = try reader["Towards"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteKeepStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteKeepStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteKeepStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteExitStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteExitStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteExitStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.relativeExit = try reader["RelativeExit"].readIfPresent()
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteEnterHighwayStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteEnterHighwayStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteEnterHighwayStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteContinueStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteContinueStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteContinueStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteContinueHighwayStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteContinueHighwayStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteContinueHighwayStepDetails()
        value.intersection = try reader["Intersection"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.steeringDirection = try reader["SteeringDirection"].readIfPresent()
        value.turnAngle = try reader["TurnAngle"].readIfPresent() ?? 0
        value.turnIntensity = try reader["TurnIntensity"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollSystem {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollSystem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollSystem()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteToll {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteToll {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteToll()
        value.country = try reader["Country"].readIfPresent()
        value.paymentSites = try reader["PaymentSites"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollPaymentSite.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.rates = try reader["Rates"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTollRate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.systems = try reader["Systems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollRate {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollRate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollRate()
        value.applicableTimes = try reader["ApplicableTimes"].readIfPresent()
        value.convertedPrice = try reader["ConvertedPrice"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPrice.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.localPrice = try reader["LocalPrice"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPrice.read(from:))
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.pass = try reader["Pass"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPass.read(from:))
        value.paymentMethods = try reader["PaymentMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteTollPaymentMethod>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.transponders = try reader["Transponders"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteTransponder.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteTransponder {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTransponder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTransponder()
        value.systemName = try reader["SystemName"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPass {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPass {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPass()
        value.includesReturnTrip = try reader["IncludesReturnTrip"].readIfPresent()
        value.seniorPass = try reader["SeniorPass"].readIfPresent()
        value.transferCount = try reader["TransferCount"].readIfPresent()
        value.tripCount = try reader["TripCount"].readIfPresent()
        value.validityPeriod = try reader["ValidityPeriod"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPassValidityPeriod.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPassValidityPeriod {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPassValidityPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPassValidityPeriod()
        value.period = try reader["Period"].readIfPresent() ?? .sdkUnknown("")
        value.periodCount = try reader["PeriodCount"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPrice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPrice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPrice()
        value.currency = try reader["Currency"].readIfPresent() ?? ""
        value.estimate = try reader["Estimate"].readIfPresent() ?? false
        value.perDuration = try reader["PerDuration"].readIfPresent() ?? 0
        value.range = try reader["Range"].readIfPresent() ?? false
        value.rangeValue = try reader["RangeValue"].readIfPresent(with: GeoRoutesClientTypes.RouteTollPriceValueRange.read(from:))
        value.value = try reader["Value"].readIfPresent() ?? 0.0
        return value
    }
}

extension GeoRoutesClientTypes.RouteTollPaymentSite {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteTollPaymentSite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteTollPaymentSite()
        value.name = try reader["Name"].readIfPresent()
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleSummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RouteVehicleTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleTravelOnlySummary()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleOverviewSummary()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleSpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleSpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleSpan()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.carAccess = try reader["CarAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanCarAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.dynamicSpeed = try reader["DynamicSpeed"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails.read(from:))
        value.functionalClassification = try reader["FunctionalClassification"].readIfPresent()
        value.gate = try reader["Gate"].readIfPresent()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.railwayCrossing = try reader["RailwayCrossing"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.roadAttributes = try reader["RoadAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanRoadAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeNumbers = try reader["RouteNumbers"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scooterAccess = try reader["ScooterAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanScooterAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.speedLimit = try reader["SpeedLimit"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails.read(from:))
        value.tollSystems = try reader["TollSystems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.truckAccess = try reader["TruckAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanTruckAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.truckRoadTypes = try reader["TruckRoadTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        value.zones = try reader["Zones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GeoRoutesClientTypes.RouteSpanSpeedLimitDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSpanSpeedLimitDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSpanSpeedLimitDetails()
        value.maxSpeed = try reader["MaxSpeed"].readIfPresent() ?? 0
        value.unlimited = try reader["Unlimited"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails()
        value.bestCaseSpeed = try reader["BestCaseSpeed"].readIfPresent() ?? 0
        value.turnDuration = try reader["TurnDuration"].readIfPresent() ?? 0
        value.typicalSpeed = try reader["TypicalSpeed"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePassThroughWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePassThroughWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePassThroughWaypoint()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePassThroughPlace.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RoutePassThroughPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePassThroughPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePassThroughPlace()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.details = try reader["Details"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteVehicleNoticeDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleNoticeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleNoticeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleNoticeDetail()
        value.title = try reader["Title"].readIfPresent()
        value.violatedConstraints = try reader["ViolatedConstraints"].readIfPresent(with: GeoRoutesClientTypes.RouteViolatedConstraints.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteViolatedConstraints {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteViolatedConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteViolatedConstraints()
        value.allHazardsRestricted = try reader["AllHazardsRestricted"].readIfPresent()
        value.axleCount = try reader["AxleCount"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.hazardousCargos = try reader["HazardousCargos"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteHazardousCargoType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxHeight = try reader["MaxHeight"].readIfPresent() ?? 0
        value.maxKpraLength = try reader["MaxKpraLength"].readIfPresent() ?? 0
        value.maxLength = try reader["MaxLength"].readIfPresent() ?? 0
        value.maxPayloadCapacity = try reader["MaxPayloadCapacity"].readIfPresent() ?? 0
        value.maxWeight = try reader["MaxWeight"].readIfPresent(with: GeoRoutesClientTypes.RouteWeightConstraint.read(from:))
        value.maxWeightPerAxle = try reader["MaxWeightPerAxle"].readIfPresent() ?? 0
        value.maxWeightPerAxleGroup = try reader["MaxWeightPerAxleGroup"].readIfPresent(with: GeoRoutesClientTypes.WeightPerAxleGroup.read(from:))
        value.maxWidth = try reader["MaxWidth"].readIfPresent() ?? 0
        value.occupancy = try reader["Occupancy"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.restrictedTimes = try reader["RestrictedTimes"].readIfPresent()
        value.timeDependent = try reader["TimeDependent"].readIfPresent()
        value.trailerCount = try reader["TrailerCount"].readIfPresent(with: GeoRoutesClientTypes.RouteNoticeDetailRange.read(from:))
        value.travelMode = try reader["TravelMode"].readIfPresent()
        value.truckRoadType = try reader["TruckRoadType"].readIfPresent()
        value.truckType = try reader["TruckType"].readIfPresent()
        value.tunnelRestrictionCode = try reader["TunnelRestrictionCode"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteNoticeDetailRange {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteNoticeDetailRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteNoticeDetailRange()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.WeightPerAxleGroup {

    static func write(value: GeoRoutesClientTypes.WeightPerAxleGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Quad"].write(value.quad)
        try writer["Quint"].write(value.quint)
        try writer["Single"].write(value.single)
        try writer["Tandem"].write(value.tandem)
        try writer["Triple"].write(value.triple)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WeightPerAxleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WeightPerAxleGroup()
        value.single = try reader["Single"].readIfPresent() ?? 0
        value.tandem = try reader["Tandem"].readIfPresent() ?? 0
        value.triple = try reader["Triple"].readIfPresent() ?? 0
        value.quad = try reader["Quad"].readIfPresent() ?? 0
        value.quint = try reader["Quint"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteWeightConstraint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteWeightConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteWeightConstraint()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleIncident {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleIncident {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleIncident()
        value.description = try reader["Description"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleDeparture()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteVehiclePlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehiclePlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehiclePlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehiclePlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sideOfStreet = try reader["SideOfStreet"].readIfPresent()
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteVehicleArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteVehicleArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteVehicleArrival()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteVehiclePlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianLegDetails()
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianArrival.read(from:))
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianDeparture.read(from:))
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianSpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianSummary.read(from:))
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePedestrianTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianTravelStep()
        value.continueStepDetails = try reader["ContinueStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteContinueStepDetails.read(from:))
        value.currentRoad = try reader["CurrentRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.exitNumber = try reader["ExitNumber"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.keepStepDetails = try reader["KeepStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteKeepStepDetails.read(from:))
        value.nextRoad = try reader["NextRoad"].readIfPresent(with: GeoRoutesClientTypes.RouteRoad.read(from:))
        value.roundaboutEnterStepDetails = try reader["RoundaboutEnterStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutEnterStepDetails.read(from:))
        value.roundaboutExitStepDetails = try reader["RoundaboutExitStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutExitStepDetails.read(from:))
        value.roundaboutPassStepDetails = try reader["RoundaboutPassStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteRoundaboutPassStepDetails.read(from:))
        value.signpost = try reader["Signpost"].readIfPresent(with: GeoRoutesClientTypes.RouteSignpost.read(from:))
        value.turnStepDetails = try reader["TurnStepDetails"].readIfPresent(with: GeoRoutesClientTypes.RouteTurnStepDetails.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianSummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianTravelOnlySummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianOverviewSummary()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianSpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianSpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianSpan()
        value.bestCaseDuration = try reader["BestCaseDuration"].readIfPresent() ?? 0
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.dynamicSpeed = try reader["DynamicSpeed"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanDynamicSpeedDetails.read(from:))
        value.functionalClassification = try reader["FunctionalClassification"].readIfPresent()
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.incidents = try reader["Incidents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pedestrianAccess = try reader["PedestrianAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanPedestrianAccessAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readIfPresent()
        value.roadAttributes = try reader["RoadAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<GeoRoutesClientTypes.RouteSpanRoadAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeNumbers = try reader["RouteNumbers"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteNumber.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.speedLimit = try reader["SpeedLimit"].readIfPresent(with: GeoRoutesClientTypes.RouteSpanSpeedLimitDetails.read(from:))
        value.typicalDuration = try reader["TypicalDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianDeparture()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianPlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sideOfStreet = try reader["SideOfStreet"].readIfPresent()
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoutePedestrianArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoutePedestrianArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoutePedestrianArrival()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RoutePedestrianPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteLegGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteLegGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteLegGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryLegDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryLegDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryLegDetails()
        value.afterTravelSteps = try reader["AfterTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryAfterTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.arrival = try reader["Arrival"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryArrival.read(from:))
        value.beforeTravelSteps = try reader["BeforeTravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryBeforeTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.departure = try reader["Departure"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryDeparture.read(from:))
        value.notices = try reader["Notices"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryNotice.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.passThroughWaypoints = try reader["PassThroughWaypoints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RoutePassThroughWaypoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.routeName = try reader["RouteName"].readIfPresent()
        value.spans = try reader["Spans"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerrySpan.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.summary = try reader["Summary"].readIfPresent(with: GeoRoutesClientTypes.RouteFerrySummary.read(from:))
        value.travelSteps = try reader["TravelSteps"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.RouteFerryTravelStep.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryTravelStep()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerrySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerrySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerrySummary()
        value.overview = try reader["Overview"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryOverviewSummary.read(from:))
        value.travelOnly = try reader["TravelOnly"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryTravelOnlySummary.read(from:))
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryTravelOnlySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryTravelOnlySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryTravelOnlySummary()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryOverviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryOverviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryOverviewSummary()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerrySpan {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerrySpan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerrySpan()
        value.country = try reader["Country"].readIfPresent()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.geometryOffset = try reader["GeometryOffset"].readIfPresent()
        value.names = try reader["Names"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.LocalizedString.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.impact = try reader["Impact"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryDeparture {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryDeparture {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryDeparture()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryPlace {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryPlace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryPlace()
        value.name = try reader["Name"].readIfPresent()
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.waypointIndex = try reader["WaypointIndex"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryBeforeTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryBeforeTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryBeforeTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryArrival {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryArrival {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryArrival()
        value.place = try reader["Place"].readIfPresent(with: GeoRoutesClientTypes.RouteFerryPlace.read(from:))
        value.time = try reader["Time"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RouteFerryAfterTravelStep {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RouteFerryAfterTravelStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RouteFerryAfterTravelStep()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.instruction = try reader["Instruction"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationConnection()
        value.distance = try reader["Distance"].readIfPresent() ?? 0
        value.from = try reader["From"].readIfPresent() ?? ""
        value.restDuration = try reader["RestDuration"].readIfPresent() ?? 0
        value.to = try reader["To"].readIfPresent() ?? ""
        value.travelDuration = try reader["TravelDuration"].readIfPresent() ?? 0
        value.waitDuration = try reader["WaitDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationImpedingWaypoint()
        value.failedConstraints = try reader["FailedConstraints"].readListIfPresent(memberReadingClosure: GeoRoutesClientTypes.WaypointOptimizationFailedConstraint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationFailedConstraint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationFailedConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationFailedConstraint()
        value.constraint = try reader["Constraint"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationOptimizedWaypoint()
        value.arrivalTime = try reader["ArrivalTime"].readIfPresent()
        value.departureTime = try reader["DepartureTime"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.position = try reader["Position"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.WaypointOptimizationTimeBreakdown()
        value.restDuration = try reader["RestDuration"].readIfPresent() ?? 0
        value.serviceDuration = try reader["ServiceDuration"].readIfPresent() ?? 0
        value.travelDuration = try reader["TravelDuration"].readIfPresent() ?? 0
        value.waitDuration = try reader["WaitDuration"].readIfPresent() ?? 0
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapNotice {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapNotice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapNotice()
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.tracePointIndexes = try reader["TracePointIndexes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedGeometry {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapSnappedGeometry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapSnappedGeometry()
        value.lineString = try reader["LineString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.polyline = try reader["Polyline"].readIfPresent()
        return value
    }
}

extension GeoRoutesClientTypes.RoadSnapSnappedTracePoint {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.RoadSnapSnappedTracePoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.RoadSnapSnappedTracePoint()
        value.confidence = try reader["Confidence"].readIfPresent() ?? 0.0
        value.originalPosition = try reader["OriginalPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.snappedPosition = try reader["SnappedPosition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GeoRoutesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoRoutesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoRoutesClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension GeoRoutesClientTypes.IsolineAllowOptions {

    static func write(value: GeoRoutesClientTypes.IsolineAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["SeasonalClosure"].write(value.seasonalClosure)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Except"].writeList(value.except, memberWritingClosure: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.IsolineAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Corridor"].write(value.corridor, with: GeoRoutesClientTypes.Corridor.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylineCorridor"].write(value.polylineCorridor, with: GeoRoutesClientTypes.PolylineCorridor.write(value:to:))
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.PolylineCorridor {

    static func write(value: GeoRoutesClientTypes.PolylineCorridor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Polyline"].write(value.polyline)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoRoutesClientTypes.Corridor {

    static func write(value: GeoRoutesClientTypes.Corridor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineString"].writeList(value.lineString, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Radius"].write(value.radius)
    }
}

extension GeoRoutesClientTypes.IsolineDestinationOptions {

    static func write(value: GeoRoutesClientTypes.IsolineDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.IsolineMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.IsolineSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.IsolineSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.IsolineMatchingOptions {

    static func write(value: GeoRoutesClientTypes.IsolineMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.IsolineGranularityOptions {

    static func write(value: GeoRoutesClientTypes.IsolineGranularityOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxPoints"].write(value.maxPoints)
        try writer["MaxResolution"].write(value.maxResolution)
    }
}

extension GeoRoutesClientTypes.IsolineOriginOptions {

    static func write(value: GeoRoutesClientTypes.IsolineOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.IsolineMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.IsolineSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineThresholds {

    static func write(value: GeoRoutesClientTypes.IsolineThresholds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Distance"].writeList(value.distance, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Time"].writeList(value.time, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.IsolineTrafficOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.IsolineTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.IsolineCarOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.IsolineScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.IsolineTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.IsolineTruckOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["EngineType"].write(value.engineType)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.IsolineHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["HeightAboveFirstAxle"].write(value.heightAboveFirstAxle)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["TireCount"].write(value.tireCount)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.IsolineTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.IsolineTrailerOptions {

    static func write(value: GeoRoutesClientTypes.IsolineTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.IsolineVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.IsolineVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.IsolineScooterOptions {

    static func write(value: GeoRoutesClientTypes.IsolineScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.IsolineCarOptions {

    static func write(value: GeoRoutesClientTypes.IsolineCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.IsolineVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAllowOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.RouteMatrixAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestination {

    static func write(value: GeoRoutesClientTypes.RouteMatrixDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Options"].write(value.options, with: GeoRoutesClientTypes.RouteMatrixDestinationOptions.write(value:to:))
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixDestinationOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatrixMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.RouteMatrixMatchingOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixExclusionOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixOrigin {

    static func write(value: GeoRoutesClientTypes.RouteMatrixOrigin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Options"].write(value.options, with: GeoRoutesClientTypes.RouteMatrixOriginOptions.write(value:to:))
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteMatrixOriginOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatrixMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteMatrixSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixTrafficOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.RouteMatrixTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.RouteMatrixCarOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.RouteMatrixScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RouteMatrixTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteMatrixTruckOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteMatrixHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RouteMatrixTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RouteMatrixTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.RouteMatrixScooterOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteMatrixCarOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatrixCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteMatrixVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteAllowOptions {

    static func write(value: GeoRoutesClientTypes.RouteAllowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hot"].write(value.hot)
        try writer["Hov"].write(value.hov)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["SeasonalClosure"].write(value.seasonalClosure)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["TollTransponders"].write(value.tollTransponders)
        try writer["TruckRoadTypes"].writeList(value.truckRoadTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
        try writer["ZoneCategories"].writeList(value.zoneCategories, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceZoneCategory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceZoneCategory {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceZoneCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Except"].writeList(value.except, memberWritingClosure: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.RouteAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Corridor"].write(value.corridor, with: GeoRoutesClientTypes.Corridor.write(value:to:))
        try writer["Polygon"].writeList(value.polygon, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["PolylineCorridor"].write(value.polylineCorridor, with: GeoRoutesClientTypes.PolylineCorridor.write(value:to:))
        try writer["PolylinePolygon"].writeList(value.polylinePolygon, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteDestinationOptions {

    static func write(value: GeoRoutesClientTypes.RouteDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
        try writer["StopDuration"].write(value.stopDuration)
    }
}

extension GeoRoutesClientTypes.RouteSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.RouteSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.RouteMatchingOptions {

    static func write(value: GeoRoutesClientTypes.RouteMatchingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NameHint"].write(value.nameHint)
        try writer["OnRoadThreshold"].write(value.onRoadThreshold)
        try writer["Radius"].write(value.radius)
        try writer["Strategy"].write(value.strategy)
    }
}

extension GeoRoutesClientTypes.RouteDriverOptions {

    static func write(value: GeoRoutesClientTypes.RouteDriverOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Schedule"].writeList(value.schedule, memberWritingClosure: GeoRoutesClientTypes.RouteDriverScheduleInterval.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteDriverScheduleInterval {

    static func write(value: GeoRoutesClientTypes.RouteDriverScheduleInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DriveDuration"].write(value.driveDuration)
        try writer["RestDuration"].write(value.restDuration)
    }
}

extension GeoRoutesClientTypes.RouteExclusionOptions {

    static func write(value: GeoRoutesClientTypes.RouteExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.RouteOriginOptions {

    static func write(value: GeoRoutesClientTypes.RouteOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteTollOptions {

    static func write(value: GeoRoutesClientTypes.RouteTollOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllTransponders"].write(value.allTransponders)
        try writer["AllVignettes"].write(value.allVignettes)
        try writer["Currency"].write(value.currency)
        try writer["EmissionType"].write(value.emissionType, with: GeoRoutesClientTypes.RouteEmissionType.write(value:to:))
        try writer["VehicleCategory"].write(value.vehicleCategory)
    }
}

extension GeoRoutesClientTypes.RouteEmissionType {

    static func write(value: GeoRoutesClientTypes.RouteEmissionType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Co2EmissionClass"].write(value.co2EmissionClass)
        try writer["Type"].write(value.type)
    }
}

extension GeoRoutesClientTypes.RouteTrafficOptions {

    static func write(value: GeoRoutesClientTypes.RouteTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FlowEventThresholdOverride"].write(value.flowEventThresholdOverride)
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.RouteTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RouteTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Car"].write(value.car, with: GeoRoutesClientTypes.RouteCarOptions.write(value:to:))
        try writer["Pedestrian"].write(value.pedestrian, with: GeoRoutesClientTypes.RoutePedestrianOptions.write(value:to:))
        try writer["Scooter"].write(value.scooter, with: GeoRoutesClientTypes.RouteScooterOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RouteTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RouteTruckOptions {

    static func write(value: GeoRoutesClientTypes.RouteTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["EngineType"].write(value.engineType)
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RouteHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["HeightAboveFirstAxle"].write(value.heightAboveFirstAxle)
        try writer["KpraLength"].write(value.kpraLength)
        try writer["Length"].write(value.length)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
        try writer["PayloadCapacity"].write(value.payloadCapacity)
        try writer["TireCount"].write(value.tireCount)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RouteTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["WeightPerAxleGroup"].write(value.weightPerAxleGroup, with: GeoRoutesClientTypes.WeightPerAxleGroup.write(value:to:))
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RouteTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RouteTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxleCount"].write(value.axleCount)
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.RouteVehicleLicensePlate {

    static func write(value: GeoRoutesClientTypes.RouteVehicleLicensePlate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastCharacter"].write(value.lastCharacter)
    }
}

extension GeoRoutesClientTypes.RouteScooterOptions {

    static func write(value: GeoRoutesClientTypes.RouteScooterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RoutePedestrianOptions {

    static func write(value: GeoRoutesClientTypes.RoutePedestrianOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.RouteCarOptions {

    static func write(value: GeoRoutesClientTypes.RouteCarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngineType"].write(value.engineType)
        try writer["LicensePlate"].write(value.licensePlate, with: GeoRoutesClientTypes.RouteVehicleLicensePlate.write(value:to:))
        try writer["MaxSpeed"].write(value.maxSpeed)
        try writer["Occupancy"].write(value.occupancy)
    }
}

extension GeoRoutesClientTypes.RouteWaypoint {

    static func write(value: GeoRoutesClientTypes.RouteWaypoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvoidActionsForDistance"].write(value.avoidActionsForDistance)
        try writer["AvoidUTurns"].write(value.avoidUTurns)
        try writer["Heading"].write(value.heading)
        try writer["Matching"].write(value.matching, with: GeoRoutesClientTypes.RouteMatchingOptions.write(value:to:))
        try writer["PassThrough"].write(value.passThrough)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.RouteSideOfStreetOptions.write(value:to:))
        try writer["StopDuration"].write(value.stopDuration)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Areas"].writeList(value.areas, memberWritingClosure: GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CarShuttleTrains"].write(value.carShuttleTrains)
        try writer["ControlledAccessHighways"].write(value.controlledAccessHighways)
        try writer["DirtRoads"].write(value.dirtRoads)
        try writer["Ferries"].write(value.ferries)
        try writer["TollRoads"].write(value.tollRoads)
        try writer["Tunnels"].write(value.tunnels)
        try writer["UTurns"].write(value.uTurns)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceArea?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geometry"].write(value.geometry, with: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAvoidanceAreaGeometry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoundingBox"].writeList(value.boundingBox, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationDestinationOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationDestinationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessHours"].write(value.accessHours, with: GeoRoutesClientTypes.WaypointOptimizationAccessHours.write(value:to:))
        try writer["AppointmentTime"].write(value.appointmentTime)
        try writer["Heading"].write(value.heading)
        try writer["Id"].write(value.id)
        try writer["ServiceDuration"].write(value.serviceDuration)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseWith"].write(value.useWith)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAccessHours {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAccessHours?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from, with: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry.write(value:to:))
        try writer["To"].write(value.to, with: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationAccessHoursEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["TimeOfDay"].write(value.timeOfDay)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationDriverOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationDriverOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestCycles"].write(value.restCycles, with: GeoRoutesClientTypes.WaypointOptimizationRestCycles.write(value:to:))
        try writer["RestProfile"].write(value.restProfile, with: GeoRoutesClientTypes.WaypointOptimizationRestProfile.write(value:to:))
        try writer["TreatServiceTimeAs"].write(value.treatServiceTimeAs)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestProfile {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Profile"].write(value.profile)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestCycles {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestCycles?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LongCycle"].write(value.longCycle, with: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations.write(value:to:))
        try writer["ShortCycle"].write(value.shortCycle, with: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationRestCycleDurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestDuration"].write(value.restDuration)
        try writer["WorkDuration"].write(value.workDuration)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationExclusionOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationExclusionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Countries"].writeList(value.countries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationOriginOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationOriginOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTrafficOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTrafficOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Usage"].write(value.usage)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Pedestrian"].write(value.pedestrian, with: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions.write(value:to:))
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.WaypointOptimizationTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTruckOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.WaypointOptimizationHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["Length"].write(value.length)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions.write(value:to:))
        try writer["TruckType"].write(value.truckType)
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["WeightPerAxle"].write(value.weightPerAxle)
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationTrailerOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationPedestrianOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Speed"].write(value.speed)
    }
}

extension GeoRoutesClientTypes.WaypointOptimizationWaypoint {

    static func write(value: GeoRoutesClientTypes.WaypointOptimizationWaypoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessHours"].write(value.accessHours, with: GeoRoutesClientTypes.WaypointOptimizationAccessHours.write(value:to:))
        try writer["AppointmentTime"].write(value.appointmentTime)
        try writer["Before"].writeList(value.before, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Heading"].write(value.heading)
        try writer["Id"].write(value.id)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceDuration"].write(value.serviceDuration)
        try writer["SideOfStreet"].write(value.sideOfStreet, with: GeoRoutesClientTypes.WaypointOptimizationSideOfStreetOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RoadSnapTracePoint {

    static func write(value: GeoRoutesClientTypes.RoadSnapTracePoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Heading"].write(value.heading)
        try writer["Position"].writeList(value.position, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Speed"].write(value.speed)
        try writer["Timestamp"].write(value.timestamp)
    }
}

extension GeoRoutesClientTypes.RoadSnapTravelModeOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTravelModeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Truck"].write(value.truck, with: GeoRoutesClientTypes.RoadSnapTruckOptions.write(value:to:))
    }
}

extension GeoRoutesClientTypes.RoadSnapTruckOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTruckOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrossWeight"].write(value.grossWeight)
        try writer["HazardousCargos"].writeList(value.hazardousCargos, memberWritingClosure: SmithyReadWrite.WritingClosureBox<GeoRoutesClientTypes.RoadSnapHazardousCargoType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Height"].write(value.height)
        try writer["Length"].write(value.length)
        try writer["Trailer"].write(value.trailer, with: GeoRoutesClientTypes.RoadSnapTrailerOptions.write(value:to:))
        try writer["TunnelRestrictionCode"].write(value.tunnelRestrictionCode)
        try writer["Width"].write(value.width)
    }
}

extension GeoRoutesClientTypes.RoadSnapTrailerOptions {

    static func write(value: GeoRoutesClientTypes.RoadSnapTrailerOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrailerCount"].write(value.trailerCount)
    }
}

public enum GeoRoutesClientTypes {}
