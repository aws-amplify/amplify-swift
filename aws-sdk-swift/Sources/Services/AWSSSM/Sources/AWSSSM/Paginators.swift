//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension SSMClient {
    /// Paginate over `[DescribeActivationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeActivationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeActivationsOutput`
    public func describeActivationsPaginated(input: DescribeActivationsInput) -> ClientRuntime.PaginatorSequence<DescribeActivationsInput, DescribeActivationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeActivationsInput, DescribeActivationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeActivations(input:))
    }
}

extension DescribeActivationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeActivationsInput {
        return DescribeActivationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeActivationsInput, OperationStackOutput == DescribeActivationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeActivationsPaginated`
    /// to access the nested member `[SSMClientTypes.Activation]`
    /// - Returns: `[SSMClientTypes.Activation]`
    public func activationList() async throws -> [SSMClientTypes.Activation] {
        return try await self.asyncCompactMap { item in item.activationList }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeAssociationExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAssociationExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAssociationExecutionsOutput`
    public func describeAssociationExecutionsPaginated(input: DescribeAssociationExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAssociationExecutionsInput, DescribeAssociationExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAssociationExecutionsInput, DescribeAssociationExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAssociationExecutions(input:))
    }
}

extension DescribeAssociationExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAssociationExecutionsInput {
        return DescribeAssociationExecutionsInput(
            associationId: self.associationId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAssociationExecutionsInput, OperationStackOutput == DescribeAssociationExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAssociationExecutionsPaginated`
    /// to access the nested member `[SSMClientTypes.AssociationExecution]`
    /// - Returns: `[SSMClientTypes.AssociationExecution]`
    public func associationExecutions() async throws -> [SSMClientTypes.AssociationExecution] {
        return try await self.asyncCompactMap { item in item.associationExecutions }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeAssociationExecutionTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAssociationExecutionTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAssociationExecutionTargetsOutput`
    public func describeAssociationExecutionTargetsPaginated(input: DescribeAssociationExecutionTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeAssociationExecutionTargetsInput, DescribeAssociationExecutionTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAssociationExecutionTargetsInput, DescribeAssociationExecutionTargetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAssociationExecutionTargets(input:))
    }
}

extension DescribeAssociationExecutionTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAssociationExecutionTargetsInput {
        return DescribeAssociationExecutionTargetsInput(
            associationId: self.associationId,
            executionId: self.executionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAssociationExecutionTargetsInput, OperationStackOutput == DescribeAssociationExecutionTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAssociationExecutionTargetsPaginated`
    /// to access the nested member `[SSMClientTypes.AssociationExecutionTarget]`
    /// - Returns: `[SSMClientTypes.AssociationExecutionTarget]`
    public func associationExecutionTargets() async throws -> [SSMClientTypes.AssociationExecutionTarget] {
        return try await self.asyncCompactMap { item in item.associationExecutionTargets }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeAutomationExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAutomationExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAutomationExecutionsOutput`
    public func describeAutomationExecutionsPaginated(input: DescribeAutomationExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAutomationExecutionsInput, DescribeAutomationExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAutomationExecutionsInput, DescribeAutomationExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAutomationExecutions(input:))
    }
}

extension DescribeAutomationExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutomationExecutionsInput {
        return DescribeAutomationExecutionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAutomationExecutionsInput, OperationStackOutput == DescribeAutomationExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAutomationExecutionsPaginated`
    /// to access the nested member `[SSMClientTypes.AutomationExecutionMetadata]`
    /// - Returns: `[SSMClientTypes.AutomationExecutionMetadata]`
    public func automationExecutionMetadataList() async throws -> [SSMClientTypes.AutomationExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.automationExecutionMetadataList }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeAutomationStepExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAutomationStepExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAutomationStepExecutionsOutput`
    public func describeAutomationStepExecutionsPaginated(input: DescribeAutomationStepExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeAutomationStepExecutionsInput, DescribeAutomationStepExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAutomationStepExecutionsInput, DescribeAutomationStepExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAutomationStepExecutions(input:))
    }
}

extension DescribeAutomationStepExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutomationStepExecutionsInput {
        return DescribeAutomationStepExecutionsInput(
            automationExecutionId: self.automationExecutionId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            reverseOrder: self.reverseOrder
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAutomationStepExecutionsInput, OperationStackOutput == DescribeAutomationStepExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAutomationStepExecutionsPaginated`
    /// to access the nested member `[SSMClientTypes.StepExecution]`
    /// - Returns: `[SSMClientTypes.StepExecution]`
    public func stepExecutions() async throws -> [SSMClientTypes.StepExecution] {
        return try await self.asyncCompactMap { item in item.stepExecutions }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeAvailablePatchesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAvailablePatchesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAvailablePatchesOutput`
    public func describeAvailablePatchesPaginated(input: DescribeAvailablePatchesInput) -> ClientRuntime.PaginatorSequence<DescribeAvailablePatchesInput, DescribeAvailablePatchesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAvailablePatchesInput, DescribeAvailablePatchesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAvailablePatches(input:))
    }
}

extension DescribeAvailablePatchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAvailablePatchesInput {
        return DescribeAvailablePatchesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAvailablePatchesInput, OperationStackOutput == DescribeAvailablePatchesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAvailablePatchesPaginated`
    /// to access the nested member `[SSMClientTypes.Patch]`
    /// - Returns: `[SSMClientTypes.Patch]`
    public func patches() async throws -> [SSMClientTypes.Patch] {
        return try await self.asyncCompactMap { item in item.patches }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeEffectiveInstanceAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEffectiveInstanceAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEffectiveInstanceAssociationsOutput`
    public func describeEffectiveInstanceAssociationsPaginated(input: DescribeEffectiveInstanceAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeEffectiveInstanceAssociationsInput, DescribeEffectiveInstanceAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEffectiveInstanceAssociationsInput, DescribeEffectiveInstanceAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEffectiveInstanceAssociations(input:))
    }
}

extension DescribeEffectiveInstanceAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEffectiveInstanceAssociationsInput {
        return DescribeEffectiveInstanceAssociationsInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEffectiveInstanceAssociationsInput, OperationStackOutput == DescribeEffectiveInstanceAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEffectiveInstanceAssociationsPaginated`
    /// to access the nested member `[SSMClientTypes.InstanceAssociation]`
    /// - Returns: `[SSMClientTypes.InstanceAssociation]`
    public func associations() async throws -> [SSMClientTypes.InstanceAssociation] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeEffectivePatchesForPatchBaselineOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEffectivePatchesForPatchBaselineInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEffectivePatchesForPatchBaselineOutput`
    public func describeEffectivePatchesForPatchBaselinePaginated(input: DescribeEffectivePatchesForPatchBaselineInput) -> ClientRuntime.PaginatorSequence<DescribeEffectivePatchesForPatchBaselineInput, DescribeEffectivePatchesForPatchBaselineOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEffectivePatchesForPatchBaselineInput, DescribeEffectivePatchesForPatchBaselineOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEffectivePatchesForPatchBaseline(input:))
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEffectivePatchesForPatchBaselineInput {
        return DescribeEffectivePatchesForPatchBaselineInput(
            baselineId: self.baselineId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEffectivePatchesForPatchBaselineInput, OperationStackOutput == DescribeEffectivePatchesForPatchBaselineOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEffectivePatchesForPatchBaselinePaginated`
    /// to access the nested member `[SSMClientTypes.EffectivePatch]`
    /// - Returns: `[SSMClientTypes.EffectivePatch]`
    public func effectivePatches() async throws -> [SSMClientTypes.EffectivePatch] {
        return try await self.asyncCompactMap { item in item.effectivePatches }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstanceAssociationsStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstanceAssociationsStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceAssociationsStatusOutput`
    public func describeInstanceAssociationsStatusPaginated(input: DescribeInstanceAssociationsStatusInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceAssociationsStatusInput, DescribeInstanceAssociationsStatusOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceAssociationsStatusInput, DescribeInstanceAssociationsStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstanceAssociationsStatus(input:))
    }
}

extension DescribeInstanceAssociationsStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceAssociationsStatusInput {
        return DescribeInstanceAssociationsStatusInput(
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstanceAssociationsStatusInput, OperationStackOutput == DescribeInstanceAssociationsStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstanceAssociationsStatusPaginated`
    /// to access the nested member `[SSMClientTypes.InstanceAssociationStatusInfo]`
    /// - Returns: `[SSMClientTypes.InstanceAssociationStatusInfo]`
    public func instanceAssociationStatusInfos() async throws -> [SSMClientTypes.InstanceAssociationStatusInfo] {
        return try await self.asyncCompactMap { item in item.instanceAssociationStatusInfos }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstanceInformationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstanceInformationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceInformationOutput`
    public func describeInstanceInformationPaginated(input: DescribeInstanceInformationInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceInformationInput, DescribeInstanceInformationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceInformationInput, DescribeInstanceInformationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstanceInformation(input:))
    }
}

extension DescribeInstanceInformationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceInformationInput {
        return DescribeInstanceInformationInput(
            filters: self.filters,
            instanceInformationFilterList: self.instanceInformationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstanceInformationInput, OperationStackOutput == DescribeInstanceInformationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstanceInformationPaginated`
    /// to access the nested member `[SSMClientTypes.InstanceInformation]`
    /// - Returns: `[SSMClientTypes.InstanceInformation]`
    public func instanceInformationList() async throws -> [SSMClientTypes.InstanceInformation] {
        return try await self.asyncCompactMap { item in item.instanceInformationList }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstancePatchesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstancePatchesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchesOutput`
    public func describeInstancePatchesPaginated(input: DescribeInstancePatchesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchesInput, DescribeInstancePatchesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchesInput, DescribeInstancePatchesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstancePatches(input:))
    }
}

extension DescribeInstancePatchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchesInput {
        return DescribeInstancePatchesInput(
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstancePatchesInput, OperationStackOutput == DescribeInstancePatchesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchesPaginated`
    /// to access the nested member `[SSMClientTypes.PatchComplianceData]`
    /// - Returns: `[SSMClientTypes.PatchComplianceData]`
    public func patches() async throws -> [SSMClientTypes.PatchComplianceData] {
        return try await self.asyncCompactMap { item in item.patches }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstancePatchStatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstancePatchStatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchStatesOutput`
    public func describeInstancePatchStatesPaginated(input: DescribeInstancePatchStatesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesInput, DescribeInstancePatchStatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesInput, DescribeInstancePatchStatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstancePatchStates(input:))
    }
}

extension DescribeInstancePatchStatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchStatesInput {
        return DescribeInstancePatchStatesInput(
            instanceIds: self.instanceIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstancePatchStatesInput, OperationStackOutput == DescribeInstancePatchStatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchStatesPaginated`
    /// to access the nested member `[SSMClientTypes.InstancePatchState]`
    /// - Returns: `[SSMClientTypes.InstancePatchState]`
    public func instancePatchStates() async throws -> [SSMClientTypes.InstancePatchState] {
        return try await self.asyncCompactMap { item in item.instancePatchStates }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstancePatchStatesForPatchGroupOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstancePatchStatesForPatchGroupInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePatchStatesForPatchGroupOutput`
    public func describeInstancePatchStatesForPatchGroupPaginated(input: DescribeInstancePatchStatesForPatchGroupInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesForPatchGroupInput, DescribeInstancePatchStatesForPatchGroupOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePatchStatesForPatchGroupInput, DescribeInstancePatchStatesForPatchGroupOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstancePatchStatesForPatchGroup(input:))
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePatchStatesForPatchGroupInput {
        return DescribeInstancePatchStatesForPatchGroupInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            patchGroup: self.patchGroup
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstancePatchStatesForPatchGroupInput, OperationStackOutput == DescribeInstancePatchStatesForPatchGroupOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstancePatchStatesForPatchGroupPaginated`
    /// to access the nested member `[SSMClientTypes.InstancePatchState]`
    /// - Returns: `[SSMClientTypes.InstancePatchState]`
    public func instancePatchStates() async throws -> [SSMClientTypes.InstancePatchState] {
        return try await self.asyncCompactMap { item in item.instancePatchStates }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInstancePropertiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstancePropertiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancePropertiesOutput`
    public func describeInstancePropertiesPaginated(input: DescribeInstancePropertiesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancePropertiesInput, DescribeInstancePropertiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstancePropertiesInput, DescribeInstancePropertiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstanceProperties(input:))
    }
}

extension DescribeInstancePropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancePropertiesInput {
        return DescribeInstancePropertiesInput(
            filtersWithOperator: self.filtersWithOperator,
            instancePropertyFilterList: self.instancePropertyFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstancePropertiesInput, OperationStackOutput == DescribeInstancePropertiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstancePropertiesPaginated`
    /// to access the nested member `[SSMClientTypes.InstanceProperty]`
    /// - Returns: `[SSMClientTypes.InstanceProperty]`
    public func instanceProperties() async throws -> [SSMClientTypes.InstanceProperty] {
        return try await self.asyncCompactMap { item in item.instanceProperties }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeInventoryDeletionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInventoryDeletionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInventoryDeletionsOutput`
    public func describeInventoryDeletionsPaginated(input: DescribeInventoryDeletionsInput) -> ClientRuntime.PaginatorSequence<DescribeInventoryDeletionsInput, DescribeInventoryDeletionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInventoryDeletionsInput, DescribeInventoryDeletionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInventoryDeletions(input:))
    }
}

extension DescribeInventoryDeletionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInventoryDeletionsInput {
        return DescribeInventoryDeletionsInput(
            deletionId: self.deletionId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInventoryDeletionsInput, OperationStackOutput == DescribeInventoryDeletionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInventoryDeletionsPaginated`
    /// to access the nested member `[SSMClientTypes.InventoryDeletionStatusItem]`
    /// - Returns: `[SSMClientTypes.InventoryDeletionStatusItem]`
    public func inventoryDeletions() async throws -> [SSMClientTypes.InventoryDeletionStatusItem] {
        return try await self.asyncCompactMap { item in item.inventoryDeletions }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionsOutput`
    public func describeMaintenanceWindowExecutionsPaginated(input: DescribeMaintenanceWindowExecutionsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionsInput, DescribeMaintenanceWindowExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionsInput, DescribeMaintenanceWindowExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowExecutions(input:))
    }
}

extension DescribeMaintenanceWindowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionsInput {
        return DescribeMaintenanceWindowExecutionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowExecutionsInput, OperationStackOutput == DescribeMaintenanceWindowExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionsPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowExecution]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowExecution]`
    public func windowExecutions() async throws -> [SSMClientTypes.MaintenanceWindowExecution] {
        return try await self.asyncCompactMap { item in item.windowExecutions }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowExecutionTaskInvocationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowExecutionTaskInvocationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionTaskInvocationsOutput`
    public func describeMaintenanceWindowExecutionTaskInvocationsPaginated(input: DescribeMaintenanceWindowExecutionTaskInvocationsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTaskInvocationsInput, DescribeMaintenanceWindowExecutionTaskInvocationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTaskInvocationsInput, DescribeMaintenanceWindowExecutionTaskInvocationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowExecutionTaskInvocations(input:))
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionTaskInvocationsInput {
        return DescribeMaintenanceWindowExecutionTaskInvocationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId,
            windowExecutionId: self.windowExecutionId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowExecutionTaskInvocationsInput, OperationStackOutput == DescribeMaintenanceWindowExecutionTaskInvocationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionTaskInvocationsPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]`
    public func windowExecutionTaskInvocationIdentities() async throws -> [SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity] {
        return try await self.asyncCompactMap { item in item.windowExecutionTaskInvocationIdentities }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowExecutionTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowExecutionTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowExecutionTasksOutput`
    public func describeMaintenanceWindowExecutionTasksPaginated(input: DescribeMaintenanceWindowExecutionTasksInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTasksInput, DescribeMaintenanceWindowExecutionTasksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowExecutionTasksInput, DescribeMaintenanceWindowExecutionTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowExecutionTasks(input:))
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowExecutionTasksInput {
        return DescribeMaintenanceWindowExecutionTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowExecutionId: self.windowExecutionId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowExecutionTasksInput, OperationStackOutput == DescribeMaintenanceWindowExecutionTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowExecutionTasksPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowExecutionTaskIdentity]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowExecutionTaskIdentity]`
    public func windowExecutionTaskIdentities() async throws -> [SSMClientTypes.MaintenanceWindowExecutionTaskIdentity] {
        return try await self.asyncCompactMap { item in item.windowExecutionTaskIdentities }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowsOutput`
    public func describeMaintenanceWindowsPaginated(input: DescribeMaintenanceWindowsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsInput, DescribeMaintenanceWindowsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsInput, DescribeMaintenanceWindowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindows(input:))
    }
}

extension DescribeMaintenanceWindowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowsInput {
        return DescribeMaintenanceWindowsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowsInput, OperationStackOutput == DescribeMaintenanceWindowsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowsPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowIdentity]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowIdentity]`
    public func windowIdentities() async throws -> [SSMClientTypes.MaintenanceWindowIdentity] {
        return try await self.asyncCompactMap { item in item.windowIdentities }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowScheduleOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowScheduleInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowScheduleOutput`
    public func describeMaintenanceWindowSchedulePaginated(input: DescribeMaintenanceWindowScheduleInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowScheduleInput, DescribeMaintenanceWindowScheduleOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowScheduleInput, DescribeMaintenanceWindowScheduleOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowSchedule(input:))
    }
}

extension DescribeMaintenanceWindowScheduleInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowScheduleInput {
        return DescribeMaintenanceWindowScheduleInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets,
            windowId: self.windowId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowScheduleInput, OperationStackOutput == DescribeMaintenanceWindowScheduleOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowSchedulePaginated`
    /// to access the nested member `[SSMClientTypes.ScheduledWindowExecution]`
    /// - Returns: `[SSMClientTypes.ScheduledWindowExecution]`
    public func scheduledWindowExecutions() async throws -> [SSMClientTypes.ScheduledWindowExecution] {
        return try await self.asyncCompactMap { item in item.scheduledWindowExecutions }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowsForTargetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowsForTargetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowsForTargetOutput`
    public func describeMaintenanceWindowsForTargetPaginated(input: DescribeMaintenanceWindowsForTargetInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsForTargetInput, DescribeMaintenanceWindowsForTargetOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowsForTargetInput, DescribeMaintenanceWindowsForTargetOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowsForTarget(input:))
    }
}

extension DescribeMaintenanceWindowsForTargetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowsForTargetInput {
        return DescribeMaintenanceWindowsForTargetInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            targets: self.targets
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowsForTargetInput, OperationStackOutput == DescribeMaintenanceWindowsForTargetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowsForTargetPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowIdentityForTarget]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowIdentityForTarget]`
    public func windowIdentities() async throws -> [SSMClientTypes.MaintenanceWindowIdentityForTarget] {
        return try await self.asyncCompactMap { item in item.windowIdentities }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowTargetsOutput`
    public func describeMaintenanceWindowTargetsPaginated(input: DescribeMaintenanceWindowTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTargetsInput, DescribeMaintenanceWindowTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTargetsInput, DescribeMaintenanceWindowTargetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowTargets(input:))
    }
}

extension DescribeMaintenanceWindowTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowTargetsInput {
        return DescribeMaintenanceWindowTargetsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowTargetsInput, OperationStackOutput == DescribeMaintenanceWindowTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowTargetsPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowTarget]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowTarget]`
    public func targets() async throws -> [SSMClientTypes.MaintenanceWindowTarget] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeMaintenanceWindowTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMaintenanceWindowTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMaintenanceWindowTasksOutput`
    public func describeMaintenanceWindowTasksPaginated(input: DescribeMaintenanceWindowTasksInput) -> ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTasksInput, DescribeMaintenanceWindowTasksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMaintenanceWindowTasksInput, DescribeMaintenanceWindowTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMaintenanceWindowTasks(input:))
    }
}

extension DescribeMaintenanceWindowTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMaintenanceWindowTasksInput {
        return DescribeMaintenanceWindowTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            windowId: self.windowId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMaintenanceWindowTasksInput, OperationStackOutput == DescribeMaintenanceWindowTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMaintenanceWindowTasksPaginated`
    /// to access the nested member `[SSMClientTypes.MaintenanceWindowTask]`
    /// - Returns: `[SSMClientTypes.MaintenanceWindowTask]`
    public func tasks() async throws -> [SSMClientTypes.MaintenanceWindowTask] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeOpsItemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOpsItemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOpsItemsOutput`
    public func describeOpsItemsPaginated(input: DescribeOpsItemsInput) -> ClientRuntime.PaginatorSequence<DescribeOpsItemsInput, DescribeOpsItemsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOpsItemsInput, DescribeOpsItemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeOpsItems(input:))
    }
}

extension DescribeOpsItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOpsItemsInput {
        return DescribeOpsItemsInput(
            maxResults: self.maxResults,
            nextToken: token,
            opsItemFilters: self.opsItemFilters
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOpsItemsInput, OperationStackOutput == DescribeOpsItemsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOpsItemsPaginated`
    /// to access the nested member `[SSMClientTypes.OpsItemSummary]`
    /// - Returns: `[SSMClientTypes.OpsItemSummary]`
    public func opsItemSummaries() async throws -> [SSMClientTypes.OpsItemSummary] {
        return try await self.asyncCompactMap { item in item.opsItemSummaries }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeParametersOutput`
    public func describeParametersPaginated(input: DescribeParametersInput) -> ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeParameters(input:))
    }
}

extension DescribeParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParametersInput {
        return DescribeParametersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters,
            shared: self.shared
        )}
}
extension SSMClient {
    /// Paginate over `[DescribePatchBaselinesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePatchBaselinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePatchBaselinesOutput`
    public func describePatchBaselinesPaginated(input: DescribePatchBaselinesInput) -> ClientRuntime.PaginatorSequence<DescribePatchBaselinesInput, DescribePatchBaselinesOutput> {
        return ClientRuntime.PaginatorSequence<DescribePatchBaselinesInput, DescribePatchBaselinesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePatchBaselines(input:))
    }
}

extension DescribePatchBaselinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchBaselinesInput {
        return DescribePatchBaselinesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePatchBaselinesInput, OperationStackOutput == DescribePatchBaselinesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePatchBaselinesPaginated`
    /// to access the nested member `[SSMClientTypes.PatchBaselineIdentity]`
    /// - Returns: `[SSMClientTypes.PatchBaselineIdentity]`
    public func baselineIdentities() async throws -> [SSMClientTypes.PatchBaselineIdentity] {
        return try await self.asyncCompactMap { item in item.baselineIdentities }
    }
}
extension SSMClient {
    /// Paginate over `[DescribePatchGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePatchGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePatchGroupsOutput`
    public func describePatchGroupsPaginated(input: DescribePatchGroupsInput) -> ClientRuntime.PaginatorSequence<DescribePatchGroupsInput, DescribePatchGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribePatchGroupsInput, DescribePatchGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePatchGroups(input:))
    }
}

extension DescribePatchGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchGroupsInput {
        return DescribePatchGroupsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePatchGroupsInput, OperationStackOutput == DescribePatchGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePatchGroupsPaginated`
    /// to access the nested member `[SSMClientTypes.PatchGroupPatchBaselineMapping]`
    /// - Returns: `[SSMClientTypes.PatchGroupPatchBaselineMapping]`
    public func mappings() async throws -> [SSMClientTypes.PatchGroupPatchBaselineMapping] {
        return try await self.asyncCompactMap { item in item.mappings }
    }
}
extension SSMClient {
    /// Paginate over `[DescribePatchPropertiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePatchPropertiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePatchPropertiesOutput`
    public func describePatchPropertiesPaginated(input: DescribePatchPropertiesInput) -> ClientRuntime.PaginatorSequence<DescribePatchPropertiesInput, DescribePatchPropertiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribePatchPropertiesInput, DescribePatchPropertiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePatchProperties(input:))
    }
}

extension DescribePatchPropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePatchPropertiesInput {
        return DescribePatchPropertiesInput(
            maxResults: self.maxResults,
            nextToken: token,
            operatingSystem: self.operatingSystem,
            patchSet: self.patchSet,
            property: self.property
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePatchPropertiesInput, OperationStackOutput == DescribePatchPropertiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePatchPropertiesPaginated`
    /// to access the nested member `[[Swift.String: Swift.String]]`
    /// - Returns: `[[Swift.String: Swift.String]]`
    public func properties() async throws -> [[Swift.String: Swift.String]] {
        return try await self.asyncCompactMap { item in item.properties }
    }
}
extension SSMClient {
    /// Paginate over `[DescribeSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSessionsOutput`
    public func describeSessionsPaginated(input: DescribeSessionsInput) -> ClientRuntime.PaginatorSequence<DescribeSessionsInput, DescribeSessionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSessionsInput, DescribeSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSessions(input:))
    }
}

extension DescribeSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSessionsInput {
        return DescribeSessionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSessionsInput, OperationStackOutput == DescribeSessionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSessionsPaginated`
    /// to access the nested member `[SSMClientTypes.Session]`
    /// - Returns: `[SSMClientTypes.Session]`
    public func sessions() async throws -> [SSMClientTypes.Session] {
        return try await self.asyncCompactMap { item in item.sessions }
    }
}
extension SSMClient {
    /// Paginate over `[GetInventoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetInventoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetInventoryOutput`
    public func getInventoryPaginated(input: GetInventoryInput) -> ClientRuntime.PaginatorSequence<GetInventoryInput, GetInventoryOutput> {
        return ClientRuntime.PaginatorSequence<GetInventoryInput, GetInventoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getInventory(input:))
    }
}

extension GetInventoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInventoryInput {
        return GetInventoryInput(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes
        )}
}

extension PaginatorSequence where OperationStackInput == GetInventoryInput, OperationStackOutput == GetInventoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getInventoryPaginated`
    /// to access the nested member `[SSMClientTypes.InventoryResultEntity]`
    /// - Returns: `[SSMClientTypes.InventoryResultEntity]`
    public func entities() async throws -> [SSMClientTypes.InventoryResultEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}
extension SSMClient {
    /// Paginate over `[GetInventorySchemaOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetInventorySchemaInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetInventorySchemaOutput`
    public func getInventorySchemaPaginated(input: GetInventorySchemaInput) -> ClientRuntime.PaginatorSequence<GetInventorySchemaInput, GetInventorySchemaOutput> {
        return ClientRuntime.PaginatorSequence<GetInventorySchemaInput, GetInventorySchemaOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getInventorySchema(input:))
    }
}

extension GetInventorySchemaInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInventorySchemaInput {
        return GetInventorySchemaInput(
            aggregator: self.aggregator,
            maxResults: self.maxResults,
            nextToken: token,
            subType: self.subType,
            typeName: self.typeName
        )}
}

extension PaginatorSequence where OperationStackInput == GetInventorySchemaInput, OperationStackOutput == GetInventorySchemaOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getInventorySchemaPaginated`
    /// to access the nested member `[SSMClientTypes.InventoryItemSchema]`
    /// - Returns: `[SSMClientTypes.InventoryItemSchema]`
    public func schemas() async throws -> [SSMClientTypes.InventoryItemSchema] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension SSMClient {
    /// Paginate over `[GetOpsSummaryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetOpsSummaryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetOpsSummaryOutput`
    public func getOpsSummaryPaginated(input: GetOpsSummaryInput) -> ClientRuntime.PaginatorSequence<GetOpsSummaryInput, GetOpsSummaryOutput> {
        return ClientRuntime.PaginatorSequence<GetOpsSummaryInput, GetOpsSummaryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getOpsSummary(input:))
    }
}

extension GetOpsSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOpsSummaryInput {
        return GetOpsSummaryInput(
            aggregators: self.aggregators,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resultAttributes: self.resultAttributes,
            syncName: self.syncName
        )}
}

extension PaginatorSequence where OperationStackInput == GetOpsSummaryInput, OperationStackOutput == GetOpsSummaryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getOpsSummaryPaginated`
    /// to access the nested member `[SSMClientTypes.OpsEntity]`
    /// - Returns: `[SSMClientTypes.OpsEntity]`
    public func entities() async throws -> [SSMClientTypes.OpsEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}
extension SSMClient {
    /// Paginate over `[GetParameterHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetParameterHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetParameterHistoryOutput`
    public func getParameterHistoryPaginated(input: GetParameterHistoryInput) -> ClientRuntime.PaginatorSequence<GetParameterHistoryInput, GetParameterHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetParameterHistoryInput, GetParameterHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getParameterHistory(input:))
    }
}

extension GetParameterHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetParameterHistoryInput {
        return GetParameterHistoryInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            withDecryption: self.withDecryption
        )}
}
extension SSMClient {
    /// Paginate over `[GetParametersByPathOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetParametersByPathInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetParametersByPathOutput`
    public func getParametersByPathPaginated(input: GetParametersByPathInput) -> ClientRuntime.PaginatorSequence<GetParametersByPathInput, GetParametersByPathOutput> {
        return ClientRuntime.PaginatorSequence<GetParametersByPathInput, GetParametersByPathOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getParametersByPath(input:))
    }
}

extension GetParametersByPathInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetParametersByPathInput {
        return GetParametersByPathInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterFilters: self.parameterFilters,
            path: self.path,
            recursive: self.recursive,
            withDecryption: self.withDecryption
        )}
}
extension SSMClient {
    /// Paginate over `[GetResourcePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourcePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutput`
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == GetResourcePoliciesInput, OperationStackOutput == GetResourcePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
    /// to access the nested member `[SSMClientTypes.GetResourcePoliciesResponseEntry]`
    /// - Returns: `[SSMClientTypes.GetResourcePoliciesResponseEntry]`
    public func policies() async throws -> [SSMClientTypes.GetResourcePoliciesResponseEntry] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}
extension SSMClient {
    /// Paginate over `[ListAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssociationsOutput`
    public func listAssociationsPaginated(input: ListAssociationsInput) -> ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssociationsInput, ListAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssociations(input:))
    }
}

extension ListAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationsInput {
        return ListAssociationsInput(
            associationFilterList: self.associationFilterList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssociationsInput, OperationStackOutput == ListAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssociationsPaginated`
    /// to access the nested member `[SSMClientTypes.Association]`
    /// - Returns: `[SSMClientTypes.Association]`
    public func associations() async throws -> [SSMClientTypes.Association] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}
extension SSMClient {
    /// Paginate over `[ListAssociationVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssociationVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssociationVersionsOutput`
    public func listAssociationVersionsPaginated(input: ListAssociationVersionsInput) -> ClientRuntime.PaginatorSequence<ListAssociationVersionsInput, ListAssociationVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssociationVersionsInput, ListAssociationVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssociationVersions(input:))
    }
}

extension ListAssociationVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociationVersionsInput {
        return ListAssociationVersionsInput(
            associationId: self.associationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssociationVersionsInput, OperationStackOutput == ListAssociationVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssociationVersionsPaginated`
    /// to access the nested member `[SSMClientTypes.AssociationVersionInfo]`
    /// - Returns: `[SSMClientTypes.AssociationVersionInfo]`
    public func associationVersions() async throws -> [SSMClientTypes.AssociationVersionInfo] {
        return try await self.asyncCompactMap { item in item.associationVersions }
    }
}
extension SSMClient {
    /// Paginate over `[ListCommandInvocationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCommandInvocationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCommandInvocationsOutput`
    public func listCommandInvocationsPaginated(input: ListCommandInvocationsInput) -> ClientRuntime.PaginatorSequence<ListCommandInvocationsInput, ListCommandInvocationsOutput> {
        return ClientRuntime.PaginatorSequence<ListCommandInvocationsInput, ListCommandInvocationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCommandInvocations(input:))
    }
}

extension ListCommandInvocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCommandInvocationsInput {
        return ListCommandInvocationsInput(
            commandId: self.commandId,
            details: self.details,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCommandInvocationsInput, OperationStackOutput == ListCommandInvocationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCommandInvocationsPaginated`
    /// to access the nested member `[SSMClientTypes.CommandInvocation]`
    /// - Returns: `[SSMClientTypes.CommandInvocation]`
    public func commandInvocations() async throws -> [SSMClientTypes.CommandInvocation] {
        return try await self.asyncCompactMap { item in item.commandInvocations }
    }
}
extension SSMClient {
    /// Paginate over `[ListCommandsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCommandsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCommandsOutput`
    public func listCommandsPaginated(input: ListCommandsInput) -> ClientRuntime.PaginatorSequence<ListCommandsInput, ListCommandsOutput> {
        return ClientRuntime.PaginatorSequence<ListCommandsInput, ListCommandsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCommands(input:))
    }
}

extension ListCommandsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCommandsInput {
        return ListCommandsInput(
            commandId: self.commandId,
            filters: self.filters,
            instanceId: self.instanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCommandsInput, OperationStackOutput == ListCommandsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCommandsPaginated`
    /// to access the nested member `[SSMClientTypes.Command]`
    /// - Returns: `[SSMClientTypes.Command]`
    public func commands() async throws -> [SSMClientTypes.Command] {
        return try await self.asyncCompactMap { item in item.commands }
    }
}
extension SSMClient {
    /// Paginate over `[ListComplianceItemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComplianceItemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComplianceItemsOutput`
    public func listComplianceItemsPaginated(input: ListComplianceItemsInput) -> ClientRuntime.PaginatorSequence<ListComplianceItemsInput, ListComplianceItemsOutput> {
        return ClientRuntime.PaginatorSequence<ListComplianceItemsInput, ListComplianceItemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComplianceItems(input:))
    }
}

extension ListComplianceItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceItemsInput {
        return ListComplianceItemsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIds: self.resourceIds,
            resourceTypes: self.resourceTypes
        )}
}

extension PaginatorSequence where OperationStackInput == ListComplianceItemsInput, OperationStackOutput == ListComplianceItemsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComplianceItemsPaginated`
    /// to access the nested member `[SSMClientTypes.ComplianceItem]`
    /// - Returns: `[SSMClientTypes.ComplianceItem]`
    public func complianceItems() async throws -> [SSMClientTypes.ComplianceItem] {
        return try await self.asyncCompactMap { item in item.complianceItems }
    }
}
extension SSMClient {
    /// Paginate over `[ListComplianceSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComplianceSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComplianceSummariesOutput`
    public func listComplianceSummariesPaginated(input: ListComplianceSummariesInput) -> ClientRuntime.PaginatorSequence<ListComplianceSummariesInput, ListComplianceSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListComplianceSummariesInput, ListComplianceSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComplianceSummaries(input:))
    }
}

extension ListComplianceSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceSummariesInput {
        return ListComplianceSummariesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListComplianceSummariesInput, OperationStackOutput == ListComplianceSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComplianceSummariesPaginated`
    /// to access the nested member `[SSMClientTypes.ComplianceSummaryItem]`
    /// - Returns: `[SSMClientTypes.ComplianceSummaryItem]`
    public func complianceSummaryItems() async throws -> [SSMClientTypes.ComplianceSummaryItem] {
        return try await self.asyncCompactMap { item in item.complianceSummaryItems }
    }
}
extension SSMClient {
    /// Paginate over `[ListDocumentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDocumentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDocumentsOutput`
    public func listDocumentsPaginated(input: ListDocumentsInput) -> ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutput> {
        return ClientRuntime.PaginatorSequence<ListDocumentsInput, ListDocumentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDocuments(input:))
    }
}

extension ListDocumentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDocumentsInput {
        return ListDocumentsInput(
            documentFilterList: self.documentFilterList,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDocumentsInput, OperationStackOutput == ListDocumentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDocumentsPaginated`
    /// to access the nested member `[SSMClientTypes.DocumentIdentifier]`
    /// - Returns: `[SSMClientTypes.DocumentIdentifier]`
    public func documentIdentifiers() async throws -> [SSMClientTypes.DocumentIdentifier] {
        return try await self.asyncCompactMap { item in item.documentIdentifiers }
    }
}
extension SSMClient {
    /// Paginate over `[ListDocumentVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDocumentVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDocumentVersionsOutput`
    public func listDocumentVersionsPaginated(input: ListDocumentVersionsInput) -> ClientRuntime.PaginatorSequence<ListDocumentVersionsInput, ListDocumentVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListDocumentVersionsInput, ListDocumentVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDocumentVersions(input:))
    }
}

extension ListDocumentVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDocumentVersionsInput {
        return ListDocumentVersionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDocumentVersionsInput, OperationStackOutput == ListDocumentVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDocumentVersionsPaginated`
    /// to access the nested member `[SSMClientTypes.DocumentVersionInfo]`
    /// - Returns: `[SSMClientTypes.DocumentVersionInfo]`
    public func documentVersions() async throws -> [SSMClientTypes.DocumentVersionInfo] {
        return try await self.asyncCompactMap { item in item.documentVersions }
    }
}
extension SSMClient {
    /// Paginate over `[ListOpsItemEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOpsItemEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOpsItemEventsOutput`
    public func listOpsItemEventsPaginated(input: ListOpsItemEventsInput) -> ClientRuntime.PaginatorSequence<ListOpsItemEventsInput, ListOpsItemEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListOpsItemEventsInput, ListOpsItemEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOpsItemEvents(input:))
    }
}

extension ListOpsItemEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsItemEventsInput {
        return ListOpsItemEventsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOpsItemEventsInput, OperationStackOutput == ListOpsItemEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOpsItemEventsPaginated`
    /// to access the nested member `[SSMClientTypes.OpsItemEventSummary]`
    /// - Returns: `[SSMClientTypes.OpsItemEventSummary]`
    public func summaries() async throws -> [SSMClientTypes.OpsItemEventSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}
extension SSMClient {
    /// Paginate over `[ListOpsItemRelatedItemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOpsItemRelatedItemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOpsItemRelatedItemsOutput`
    public func listOpsItemRelatedItemsPaginated(input: ListOpsItemRelatedItemsInput) -> ClientRuntime.PaginatorSequence<ListOpsItemRelatedItemsInput, ListOpsItemRelatedItemsOutput> {
        return ClientRuntime.PaginatorSequence<ListOpsItemRelatedItemsInput, ListOpsItemRelatedItemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOpsItemRelatedItems(input:))
    }
}

extension ListOpsItemRelatedItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsItemRelatedItemsInput {
        return ListOpsItemRelatedItemsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            opsItemId: self.opsItemId
        )}
}

extension PaginatorSequence where OperationStackInput == ListOpsItemRelatedItemsInput, OperationStackOutput == ListOpsItemRelatedItemsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOpsItemRelatedItemsPaginated`
    /// to access the nested member `[SSMClientTypes.OpsItemRelatedItemSummary]`
    /// - Returns: `[SSMClientTypes.OpsItemRelatedItemSummary]`
    public func summaries() async throws -> [SSMClientTypes.OpsItemRelatedItemSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}
extension SSMClient {
    /// Paginate over `[ListOpsMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOpsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOpsMetadataOutput`
    public func listOpsMetadataPaginated(input: ListOpsMetadataInput) -> ClientRuntime.PaginatorSequence<ListOpsMetadataInput, ListOpsMetadataOutput> {
        return ClientRuntime.PaginatorSequence<ListOpsMetadataInput, ListOpsMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOpsMetadata(input:))
    }
}

extension ListOpsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOpsMetadataInput {
        return ListOpsMetadataInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOpsMetadataInput, OperationStackOutput == ListOpsMetadataOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOpsMetadataPaginated`
    /// to access the nested member `[SSMClientTypes.OpsMetadata]`
    /// - Returns: `[SSMClientTypes.OpsMetadata]`
    public func opsMetadataList() async throws -> [SSMClientTypes.OpsMetadata] {
        return try await self.asyncCompactMap { item in item.opsMetadataList }
    }
}
extension SSMClient {
    /// Paginate over `[ListResourceComplianceSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceComplianceSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceComplianceSummariesOutput`
    public func listResourceComplianceSummariesPaginated(input: ListResourceComplianceSummariesInput) -> ClientRuntime.PaginatorSequence<ListResourceComplianceSummariesInput, ListResourceComplianceSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceComplianceSummariesInput, ListResourceComplianceSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceComplianceSummaries(input:))
    }
}

extension ListResourceComplianceSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceComplianceSummariesInput {
        return ListResourceComplianceSummariesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceComplianceSummariesInput, OperationStackOutput == ListResourceComplianceSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceComplianceSummariesPaginated`
    /// to access the nested member `[SSMClientTypes.ResourceComplianceSummaryItem]`
    /// - Returns: `[SSMClientTypes.ResourceComplianceSummaryItem]`
    public func resourceComplianceSummaryItems() async throws -> [SSMClientTypes.ResourceComplianceSummaryItem] {
        return try await self.asyncCompactMap { item in item.resourceComplianceSummaryItems }
    }
}
extension SSMClient {
    /// Paginate over `[ListResourceDataSyncOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceDataSyncInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceDataSyncOutput`
    public func listResourceDataSyncPaginated(input: ListResourceDataSyncInput) -> ClientRuntime.PaginatorSequence<ListResourceDataSyncInput, ListResourceDataSyncOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceDataSyncInput, ListResourceDataSyncOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceDataSync(input:))
    }
}

extension ListResourceDataSyncInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceDataSyncInput {
        return ListResourceDataSyncInput(
            maxResults: self.maxResults,
            nextToken: token,
            syncType: self.syncType
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceDataSyncInput, OperationStackOutput == ListResourceDataSyncOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceDataSyncPaginated`
    /// to access the nested member `[SSMClientTypes.ResourceDataSyncItem]`
    /// - Returns: `[SSMClientTypes.ResourceDataSyncItem]`
    public func resourceDataSyncItems() async throws -> [SSMClientTypes.ResourceDataSyncItem] {
        return try await self.asyncCompactMap { item in item.resourceDataSyncItems }
    }
}
