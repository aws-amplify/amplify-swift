//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension SSMClientTypes {

    /// Information includes the Amazon Web Services account ID where the current document is shared and the version shared with that account.
    public struct AccountSharingInfo: Swift.Sendable {
        /// The Amazon Web Services account ID where the current document is shared.
        public var accountId: Swift.String?
        /// The version of the current document shared with the account.
        public var sharedDocumentVersion: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            sharedDocumentVersion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.sharedDocumentVersion = sharedDocumentVersion
        }
    }
}

extension SSMClientTypes {

    /// Metadata that you assign to your Amazon Web Services resources. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment. In Amazon Web Services Systems Manager, you can apply tags to Systems Manager documents (SSM documents), managed nodes, maintenance windows, parameters, patch baselines, OpsItems, and OpsMetadata.
    public struct Tag: Swift.Sendable {
        /// The name of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension SSMClientTypes {

    /// An activation registers one or more on-premises servers or virtual machines (VMs) with Amazon Web Services so that you can configure those servers or VMs using Run Command. A server or VM that has been registered with Amazon Web Services Systems Manager is called a managed node.
    public struct Activation: Swift.Sendable {
        /// The ID created by Systems Manager when you submitted the activation.
        public var activationId: Swift.String?
        /// The date the activation was created.
        public var createdDate: Foundation.Date?
        /// A name for the managed node when it is created.
        public var defaultInstanceName: Swift.String?
        /// A user defined description of the activation.
        public var description: Swift.String?
        /// The date when this activation can no longer be used to register managed nodes.
        public var expirationDate: Foundation.Date?
        /// Whether or not the activation is expired.
        public var expired: Swift.Bool
        /// The Identity and Access Management (IAM) role to assign to the managed node.
        public var iamRole: Swift.String?
        /// The maximum number of managed nodes that can be registered using this activation.
        public var registrationLimit: Swift.Int?
        /// The number of managed nodes already registered with this activation.
        public var registrationsCount: Swift.Int?
        /// Tags assigned to the activation.
        public var tags: [SSMClientTypes.Tag]?

        public init(
            activationId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            defaultInstanceName: Swift.String? = nil,
            description: Swift.String? = nil,
            expirationDate: Foundation.Date? = nil,
            expired: Swift.Bool = false,
            iamRole: Swift.String? = nil,
            registrationLimit: Swift.Int? = nil,
            registrationsCount: Swift.Int? = nil,
            tags: [SSMClientTypes.Tag]? = nil
        )
        {
            self.activationId = activationId
            self.createdDate = createdDate
            self.defaultInstanceName = defaultInstanceName
            self.description = description
            self.expirationDate = expirationDate
            self.expired = expired
            self.iamRole = iamRole
            self.registrationLimit = registrationLimit
            self.registrationsCount = registrationsCount
            self.tags = tags
        }
    }
}

/// An error occurred on the server side.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource ID isn't valid. Verify that you entered the correct ID and try again.
public struct InvalidResourceId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidResourceId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The resource type isn't valid. For example, if you are attempting to tag an EC2 instance, the instance must be a registered managed node.
public struct InvalidResourceType: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidResourceType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The Targets parameter includes too many tags. Remove one or more tags and try the command again.
public struct TooManyTagsError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "TooManyTagsError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// There are concurrent updates for a resource that supports one update at a time.
public struct TooManyUpdates: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyUpdates" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum ResourceTypeForTagging: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case association
        case automation
        case document
        case maintenanceWindow
        case managedInstance
        case opsmetadata
        case opsItem
        case parameter
        case patchBaseline
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeForTagging] {
            return [
                .association,
                .automation,
                .document,
                .maintenanceWindow,
                .managedInstance,
                .opsmetadata,
                .opsItem,
                .parameter,
                .patchBaseline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .association: return "Association"
            case .automation: return "Automation"
            case .document: return "Document"
            case .maintenanceWindow: return "MaintenanceWindow"
            case .managedInstance: return "ManagedInstance"
            case .opsmetadata: return "OpsMetadata"
            case .opsItem: return "OpsItem"
            case .parameter: return "Parameter"
            case .patchBaseline: return "PatchBaseline"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AddTagsToResourceInput: Swift.Sendable {
    /// The resource ID you want to tag. Use the ID of the resource. Here are some examples: MaintenanceWindow: mw-012345abcdePatchBaseline: pb-012345abcdeAutomation: example-c160-4567-8519-012345abcdeOpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. If you're tagging a shared document, you must use the full ARN of the document. ManagedInstance: mi-012345abcde The ManagedInstance type for this API operation is only for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the type of resource you are tagging. The ManagedInstance type for this API operation is for on-premises managed nodes. You must specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SSMClientTypes.ResourceTypeForTagging?
    /// One or more tags. The value parameter is required. Don't enter personally identifiable information in this field.
    /// This member is required.
    public var tags: [SSMClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        resourceType: SSMClientTypes.ResourceTypeForTagging? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tags = tags
    }
}

public struct AddTagsToResourceOutput: Swift.Sendable {

    public init() { }
}

extension SSMClientTypes {

    /// A CloudWatch alarm you apply to an automation or command.
    public struct Alarm: Swift.Sendable {
        /// The name of your CloudWatch alarm.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension SSMClientTypes {

    /// The details for the CloudWatch alarm you want to apply to an automation or command.
    public struct AlarmConfiguration: Swift.Sendable {
        /// The name of the CloudWatch alarm specified in the configuration.
        /// This member is required.
        public var alarms: [SSMClientTypes.Alarm]?
        /// When this value is true, your automation or command continues to run in cases where we canâ€™t retrieve alarm status information from CloudWatch. In cases where we successfully retrieve an alarm status of OK or INSUFFICIENT_DATA, the automation or command continues to run, regardless of this value. Default is false.
        public var ignorePollAlarmFailure: Swift.Bool

        public init(
            alarms: [SSMClientTypes.Alarm]? = nil,
            ignorePollAlarmFailure: Swift.Bool = false
        )
        {
            self.alarms = alarms
            self.ignorePollAlarmFailure = ignorePollAlarmFailure
        }
    }
}

extension SSMClientTypes {

    public enum ExternalAlarmState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alarm
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalAlarmState] {
            return [
                .alarm,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "ALARM"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// The details about the state of your CloudWatch alarm.
    public struct AlarmStateInformation: Swift.Sendable {
        /// The name of your CloudWatch alarm.
        /// This member is required.
        public var name: Swift.String?
        /// The state of your CloudWatch alarm.
        /// This member is required.
        public var state: SSMClientTypes.ExternalAlarmState?

        public init(
            name: Swift.String? = nil,
            state: SSMClientTypes.ExternalAlarmState? = nil
        )
        {
            self.name = name
            self.state = state
        }
    }
}

/// Error returned if an attempt is made to register a patch group with a patch baseline that is already registered with a different patch baseline.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified OpsItem is in the process of being deleted.
public struct OpsItemConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A specified parameter argument isn't valid. Verify the available arguments and try again.
public struct OpsItemInvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var parameterNames: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemInvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterNames = parameterNames
    }
}

/// The request caused OpsItems to exceed one or more quotas.
public struct OpsItemLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var limit: Swift.Int = 0
        public internal(set) var limitType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceTypes: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        limitType: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.properties.limit = limit
        self.properties.limitType = limitType
        self.properties.message = message
        self.properties.resourceTypes = resourceTypes
    }
}

/// The specified OpsItem ID doesn't exist. Verify the ID and try again.
public struct OpsItemNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Resource Name (ARN) is already associated with the OpsItem.
public struct OpsItemRelatedItemAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var opsItemId: Swift.String? = nil
        public internal(set) var resourceUri: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemRelatedItemAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.opsItemId = opsItemId
        self.properties.resourceUri = resourceUri
    }
}

public struct AssociateOpsItemRelatedItemInput: Swift.Sendable {
    /// The type of association that you want to create between an OpsItem and a resource. OpsCenter supports IsParentOf and RelatesTo association types.
    /// This member is required.
    public var associationType: Swift.String?
    /// The ID of the OpsItem to which you want to associate a resource as a related item.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The type of resource that you want to associate with an OpsItem. OpsCenter supports the following types: AWS::SSMIncidents::IncidentRecord: an Incident Manager incident. AWS::SSM::Document: a Systems Manager (SSM) document.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services resource that you want to associate with the OpsItem.
    /// This member is required.
    public var resourceUri: Swift.String?

    public init(
        associationType: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        resourceUri: Swift.String? = nil
    )
    {
        self.associationType = associationType
        self.opsItemId = opsItemId
        self.resourceType = resourceType
        self.resourceUri = resourceUri
    }
}

public struct AssociateOpsItemRelatedItemOutput: Swift.Sendable {
    /// The association ID.
    public var associationId: Swift.String?

    public init(
        associationId: Swift.String? = nil
    )
    {
        self.associationId = associationId
    }
}

/// You can't specify a managed node ID in more than one association.
public struct DuplicateInstanceId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "DuplicateInstanceId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The specified command ID isn't valid. Verify the ID and try again.
public struct InvalidCommandId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidCommandId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The following problems can cause this exception:
///
/// * You don't have permission to access the managed node.
///
/// * Amazon Web Services Systems Manager Agent (SSM Agent) isn't running. Verify that SSM Agent is running.
///
/// * SSM Agent isn't registered with the SSM endpoint. Try reinstalling SSM Agent.
///
/// * The managed node isn't in a valid state. Valid states are: Running, Pending, Stopped, and Stopping. Invalid states are: Shutting-down and Terminated.
public struct InvalidInstanceId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInstanceId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct CancelCommandInput: Swift.Sendable {
    /// The ID of the command you want to cancel.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Optional) A list of managed node IDs on which you want to cancel the command. If not provided, the command is canceled on every node on which it was requested.
    public var instanceIds: [Swift.String]?

    public init(
        commandId: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil
    )
    {
        self.commandId = commandId
        self.instanceIds = instanceIds
    }
}

/// Whether or not the command was successfully canceled. There is no guarantee that a request can be canceled.
public struct CancelCommandOutput: Swift.Sendable {

    public init() { }
}

/// Error returned when the ID specified for a resource, such as a maintenance window or patch baseline, doesn't exist. For information about resource quotas in Amazon Web Services Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct DoesNotExistException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DoesNotExistException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelMaintenanceWindowExecutionInput: Swift.Sendable {
    /// The ID of the maintenance window execution to stop.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

public struct CancelMaintenanceWindowExecutionOutput: Swift.Sendable {
    /// The ID of the maintenance window execution that has been stopped.
    public var windowExecutionId: Swift.String?

    public init(
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

/// You must specify values for all required parameters in the Amazon Web Services Systems Manager document (SSM document). You can only supply values to parameters defined in the SSM document.
public struct InvalidParameters: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameters" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Reserved for internal use.
    public struct RegistrationMetadataItem: Swift.Sendable {
        /// Reserved for internal use.
        /// This member is required.
        public var key: Swift.String?
        /// Reserved for internal use.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateActivationInput: Swift.Sendable {
    /// The name of the registered, managed node as it will appear in the Amazon Web Services Systems Manager console or when you use the Amazon Web Services command line tools to list Systems Manager resources. Don't enter personally identifiable information in this field.
    public var defaultInstanceName: Swift.String?
    /// A user-defined description of the resource that you want to register with Systems Manager. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The date by which this activation request should expire, in timestamp format, such as "2024-07-07T00:00:00". You can specify a date up to 30 days in advance. If you don't provide an expiration date, the activation code expires in 24 hours.
    public var expirationDate: Foundation.Date?
    /// The name of the Identity and Access Management (IAM) role that you want to assign to the managed node. This IAM role must provide AssumeRole permissions for the Amazon Web Services Systems Manager service principal ssm.amazonaws.com. For more information, see [Create the IAM service role required for Systems Manager in a hybrid and multicloud environments](https://docs.aws.amazon.com/systems-manager/latest/userguide/hybrid-multicloud-service-role.html) in the Amazon Web Services Systems Manager User Guide. You can't specify an IAM service-linked role for this parameter. You must create a unique role.
    /// This member is required.
    public var iamRole: Swift.String?
    /// Specify the maximum number of managed nodes you want to register. The default value is 1.
    public var registrationLimit: Swift.Int?
    /// Reserved for internal use.
    public var registrationMetadata: [SSMClientTypes.RegistrationMetadataItem]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an activation to identify which servers or virtual machines (VMs) in your on-premises environment you intend to activate. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// When you install SSM Agent on your on-premises servers and VMs, you specify an activation ID and code. When you specify the activation ID and code, tags assigned to the activation are automatically applied to the on-premises servers or VMs. You can't add tags to or delete tags from an existing activation. You can tag your on-premises servers, edge devices, and VMs after they connect to Systems Manager for the first time and are assigned a managed node ID. This means they are listed in the Amazon Web Services Systems Manager console with an ID that is prefixed with "mi-". For information about how to add tags to your managed nodes, see [AddTagsToResource]. For information about how to remove tags from your managed nodes, see [RemoveTagsFromResource].
    public var tags: [SSMClientTypes.Tag]?

    public init(
        defaultInstanceName: Swift.String? = nil,
        description: Swift.String? = nil,
        expirationDate: Foundation.Date? = nil,
        iamRole: Swift.String? = nil,
        registrationLimit: Swift.Int? = nil,
        registrationMetadata: [SSMClientTypes.RegistrationMetadataItem]? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.defaultInstanceName = defaultInstanceName
        self.description = description
        self.expirationDate = expirationDate
        self.iamRole = iamRole
        self.registrationLimit = registrationLimit
        self.registrationMetadata = registrationMetadata
        self.tags = tags
    }
}

public struct CreateActivationOutput: Swift.Sendable {
    /// The code the system generates when it processes the activation. The activation code functions like a password to validate the activation ID.
    public var activationCode: Swift.String?
    /// The ID number generated by the system when it processed the activation. The activation ID functions like a user name.
    public var activationId: Swift.String?

    public init(
        activationCode: Swift.String? = nil,
        activationId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.activationId = activationId
    }
}

/// The specified association already exists.
public struct AssociationAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "AssociationAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// You can have at most 2,000 active associations.
public struct AssociationLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "AssociationLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The specified SSM document doesn't exist.
public struct InvalidDocument: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The SSM document doesn't exist or the document isn't available to the user. This exception can be issued by various API operations.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocument" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The document version isn't valid or doesn't exist.
public struct InvalidDocumentVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocumentVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The output location isn't valid or doesn't exist.
public struct InvalidOutputLocation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidOutputLocation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The schedule is invalid. Verify your cron or rate expression and try again.
public struct InvalidSchedule: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSchedule" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified tag key or value isn't valid.
public struct InvalidTag: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTag" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The target isn't valid or doesn't exist. It might not be configured for Systems Manager or you might not have permission to perform the operation.
public struct InvalidTarget: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTarget" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// TargetMap parameter isn't valid.
public struct InvalidTargetMaps: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTargetMaps" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The document doesn't support the platform type of the given managed node IDs. For example, you sent an document for a Windows managed node to a Linux node.
public struct UnsupportedPlatformType: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPlatformType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum AssociationComplianceSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationComplianceSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// An S3 bucket where you want to store the results of this request.
    public struct S3OutputLocation: Swift.Sendable {
        /// The name of the S3 bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?

        public init(
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil
        )
        {
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
        }
    }
}

extension SSMClientTypes {

    /// An S3 bucket where you want to store the results of this request. For the minimal permissions required to enable Amazon S3 output for an association, see [Create an association (console)](https://docs.aws.amazon.com/systems-manager/latest/userguide/state-manager-associations-creating.html#state-manager-associations-console) in the Systems Manager User Guide.
    public struct InstanceAssociationOutputLocation: Swift.Sendable {
        /// An S3 bucket where you want to store the results of this request.
        public var s3Location: SSMClientTypes.S3OutputLocation?

        public init(
            s3Location: SSMClientTypes.S3OutputLocation? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension SSMClientTypes {

    public enum AssociationSyncCompliance: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationSyncCompliance] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// An array of search criteria that targets managed nodes using a key-value pair that you specify. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Supported formats include the following. For all Systems Manager capabilities:
    ///
    /// * Key=tag-key,Values=tag-value-1,tag-value-2
    ///
    ///
    /// For Automation and Change Manager:
    ///
    /// * Key=tag:tag-key,Values=tag-value
    ///
    /// * Key=ResourceGroup,Values=resource-group-name
    ///
    /// * Key=ParameterValues,Values=value-1,value-2,value-3
    ///
    /// * To target all instances in the Amazon Web Services Region:
    ///
    /// * Key=AWS::EC2::Instance,Values=*
    ///
    /// * Key=InstanceIds,Values=*
    ///
    ///
    ///
    ///
    ///
    /// For Run Command and Maintenance Windows:
    ///
    /// * Key=InstanceIds,Values=instance-id-1,instance-id-2,instance-id-3
    ///
    /// * Key=tag:tag-key,Values=tag-value-1,tag-value-2
    ///
    /// * Key=resource-groups:Name,Values=resource-group-name
    ///
    /// * Additionally, Maintenance Windows support targeting resource types:
    ///
    /// * Key=resource-groups:ResourceTypeFilters,Values=resource-type-1,resource-type-2
    ///
    ///
    ///
    ///
    ///
    /// For State Manager:
    ///
    /// * Key=InstanceIds,Values=instance-id-1,instance-id-2,instance-id-3
    ///
    /// * Key=tag:tag-key,Values=tag-value-1,tag-value-2
    ///
    /// * To target all instances in the Amazon Web Services Region:
    ///
    /// * Key=InstanceIds,Values=*
    ///
    ///
    ///
    ///
    ///
    /// For more information about how to send commands that target managed nodes using Key,Value parameters, see [Targeting multiple managed nodes](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting) in the Amazon Web Services Systems Manager User Guide.
    public struct Target: Swift.Sendable {
        /// User-defined criteria for sending commands that target managed nodes that meet the criteria.
        public var key: Swift.String?
        /// User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to run a command on instances that include EC2 tags of ServerRole,WebServer. Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

extension SSMClientTypes {

    /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
    public struct TargetLocation: Swift.Sendable {
        /// The Amazon Web Services accounts targeted by the current Automation execution.
        public var accounts: [Swift.String]?
        /// Amazon Web Services accounts or organizational units to exclude as expanded targets.
        public var excludeAccounts: [Swift.String]?
        /// The Automation execution role used by the currently running Automation. If not specified, the default value is AWS-SystemsManager-AutomationExecutionRole.
        public var executionRoleName: Swift.String?
        /// Indicates whether to include child organizational units (OUs) that are children of the targeted OUs. The default is false.
        public var includeChildOrganizationUnits: Swift.Bool
        /// The Amazon Web Services Regions targeted by the current Automation execution.
        public var regions: [Swift.String]?
        /// The details for the CloudWatch alarm you want to apply to an automation or command.
        public var targetLocationAlarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The maximum number of Amazon Web Services Regions and Amazon Web Services accounts allowed to run the Automation concurrently.
        public var targetLocationMaxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops queueing additional Automation executions for the currently running Automation.
        public var targetLocationMaxErrors: Swift.String?
        /// A list of key-value mappings to target resources. If you specify values for this data type, you must also specify a value for TargetParameterName. This Targets parameter takes precedence over the StartAutomationExecution:Targets parameter if both are supplied.
        public var targets: [SSMClientTypes.Target]?
        /// The maximum number of targets allowed to run this task in parallel. This TargetsMaxConcurrency takes precedence over the StartAutomationExecution:MaxConcurrency parameter if both are supplied.
        public var targetsMaxConcurrency: Swift.String?
        /// The maximum number of errors that are allowed before the system stops running the automation on additional targets. This TargetsMaxErrors parameter takes precedence over the StartAutomationExecution:MaxErrors parameter if both are supplied.
        public var targetsMaxErrors: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            excludeAccounts: [Swift.String]? = nil,
            executionRoleName: Swift.String? = nil,
            includeChildOrganizationUnits: Swift.Bool = false,
            regions: [Swift.String]? = nil,
            targetLocationAlarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            targetLocationMaxConcurrency: Swift.String? = nil,
            targetLocationMaxErrors: Swift.String? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            targetsMaxConcurrency: Swift.String? = nil,
            targetsMaxErrors: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.excludeAccounts = excludeAccounts
            self.executionRoleName = executionRoleName
            self.includeChildOrganizationUnits = includeChildOrganizationUnits
            self.regions = regions
            self.targetLocationAlarmConfiguration = targetLocationAlarmConfiguration
            self.targetLocationMaxConcurrency = targetLocationMaxConcurrency
            self.targetLocationMaxErrors = targetLocationMaxErrors
            self.targets = targets
            self.targetsMaxConcurrency = targetsMaxConcurrency
            self.targetsMaxErrors = targetsMaxErrors
        }
    }
}

public struct CreateAssociationInput: Swift.Sendable {
    /// The details for the CloudWatch alarm you want to apply to an automation or command.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// By default, when you create a new association, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
    public var applyOnlyAtCronInterval: Swift.Bool?
    /// Specify a descriptive name for the association.
    public var associationName: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SSMClientTypes.AssociationComplianceSeverity?
    /// The document version you want to associate with the targets. Can be a specific version or the default version. State Manager doesn't support running associations that use a new version of a document if that document is shared from another account. State Manager always runs the default version of a document if shared from another account, even though the Systems Manager console shows that a new version was processed. If you want to run an association using a new version of a document shared form another account, you must set the document version to default.
    public var documentVersion: Swift.String?
    /// The number of hours the association can run before it is canceled. Duration applies to associations that are currently running, and any pending and in progress commands on all targets. If a target was taken offline for the association to run, it is made available again immediately, without a reboot. The Duration parameter applies only when both these conditions are true:
    ///
    /// * The association for which you specify a duration is cancelable according to the parameters of the SSM command document or Automation runbook associated with this execution.
    ///
    /// * The command specifies the [ApplyOnlyAtCronInterval](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_CreateAssociation.html#systemsmanager-CreateAssociation-request-ApplyOnlyAtCronInterval) parameter, which means that the association doesn't run immediately after it is created, but only according to the specified schedule.
    public var duration: Swift.Int?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another Amazon Web Services account. For Systems Manager documents (SSM documents) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:partition:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    /// This member is required.
    public var name: Swift.String?
    /// An Amazon Simple Storage Service (Amazon S3) bucket where you want to store the output details of the request.
    public var outputLocation: SSMClientTypes.InstanceAssociationOutputLocation?
    /// The parameters for the runtime configuration of the document.
    public var parameters: [Swift.String: [Swift.String]]?
    /// A cron expression when the association will be applied to the targets.
    public var scheduleExpression: Swift.String?
    /// Number of days to wait after the scheduled day to run an association. For example, if you specified a cron schedule of cron(0 0 ? * THU#2 *), you could specify an offset of 3 to run the association each Sunday after the second Thursday of the month. For more information about cron schedules for associations, see [Reference: Cron and rate expressions for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/reference-cron-and-rate-expressions.html) in the Amazon Web Services Systems Manager User Guide. To use offsets, you must specify the ApplyOnlyAtCronInterval parameter. This option tells the system not to run an association immediately after you create it.
    public var scheduleOffset: Swift.Int?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SSMClientTypes.AssociationSyncCompliance?
    /// Adds or overwrites one or more tags for a State Manager association. Tags are metadata that you can assign to your Amazon Web Services resources. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [SSMClientTypes.Tag]?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to create an association in multiple Regions and multiple accounts.
    public var targetLocations: [SSMClientTypes.TargetLocation]?
    /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
    public var targetMaps: [[Swift.String: [Swift.String]]]?
    /// The targets for the association. You can target managed nodes by using tags, Amazon Web Services resource groups, all managed nodes in an Amazon Web Services account, or individual managed node IDs. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *. For more information about choosing targets for an association, see [Understanding targets and rate controls in State Manager associations](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-state-manager-targets-and-rate-controls.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SSMClientTypes.Target]?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        applyOnlyAtCronInterval: Swift.Bool? = false,
        associationName: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SSMClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        duration: Swift.Int? = nil,
        instanceId: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SSMClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        syncCompliance: SSMClientTypes.AssociationSyncCompliance? = nil,
        tags: [SSMClientTypes.Tag]? = nil,
        targetLocations: [SSMClientTypes.TargetLocation]? = nil,
        targetMaps: [[Swift.String: [Swift.String]]]? = nil,
        targets: [SSMClientTypes.Target]? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationName = associationName
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.duration = duration
        self.instanceId = instanceId
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.scheduleOffset = scheduleOffset
        self.syncCompliance = syncCompliance
        self.tags = tags
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targets = targets
    }
}

extension CreateAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationInput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationName: \(Swift.String(describing: associationName)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), duration: \(Swift.String(describing: duration)), instanceId: \(Swift.String(describing: instanceId)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), syncCompliance: \(Swift.String(describing: syncCompliance)), tags: \(Swift.String(describing: tags)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targets: \(Swift.String(describing: targets)), parameters: \"CONTENT_REDACTED\")"}
}

extension SSMClientTypes {

    /// Information about the association.
    public struct AssociationOverview: Swift.Sendable {
        /// Returns the number of targets for the association status. For example, if you created an association with two managed nodes, and one of them was successful, this would return the count of managed nodes by status.
        public var associationStatusAggregatedCount: [Swift.String: Swift.Int]?
        /// A detailed status of the association.
        public var detailedStatus: Swift.String?
        /// The status of the association. Status can be: Pending, Success, or Failed.
        public var status: Swift.String?

        public init(
            associationStatusAggregatedCount: [Swift.String: Swift.Int]? = nil,
            detailedStatus: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationStatusAggregatedCount = associationStatusAggregatedCount
            self.detailedStatus = detailedStatus
            self.status = status
        }
    }
}

extension SSMClientTypes {

    public enum AssociationStatusName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatusName] {
            return [
                .failed,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes an association status.
    public struct AssociationStatus: Swift.Sendable {
        /// A user-defined string.
        public var additionalInfo: Swift.String?
        /// The date when the status changed.
        /// This member is required.
        public var date: Foundation.Date?
        /// The reason for the status.
        /// This member is required.
        public var message: Swift.String?
        /// The status.
        /// This member is required.
        public var name: SSMClientTypes.AssociationStatusName?

        public init(
            additionalInfo: Swift.String? = nil,
            date: Foundation.Date? = nil,
            message: Swift.String? = nil,
            name: SSMClientTypes.AssociationStatusName? = nil
        )
        {
            self.additionalInfo = additionalInfo
            self.date = date
            self.message = message
            self.name = name
        }
    }
}

extension SSMClientTypes {

    /// Describes the parameters for a document.
    public struct AssociationDescription: Swift.Sendable {
        /// The details for the CloudWatch alarm you want to apply to an automation or command.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The association ID.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SSMClientTypes.AssociationComplianceSeverity?
        /// The date when the association was made.
        public var date: Foundation.Date?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The number of hours that an association can run on specified targets. After the resulting cutoff time passes, associations that are currently running are cancelled, and no pending executions are started on remaining targets.
        public var duration: Swift.Int?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: Foundation.Date?
        /// The last date on which the association was successfully run.
        public var lastSuccessfulExecutionDate: Foundation.Date?
        /// The date when the association was last updated.
        public var lastUpdateAssociationDate: Foundation.Date?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the output details of the request.
        public var outputLocation: SSMClientTypes.InstanceAssociationOutputLocation?
        /// Information about the association.
        public var overview: SSMClientTypes.AssociationOverview?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String: [Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// Number of days to wait after the scheduled day to run an association.
        public var scheduleOffset: Swift.Int?
        /// The association status.
        public var status: SSMClientTypes.AssociationStatus?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SSMClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association.
        public var targetLocations: [SSMClientTypes.TargetLocation]?
        /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The managed nodes targeted by the request.
        public var targets: [SSMClientTypes.Target]?
        /// The CloudWatch alarm that was invoked during the association.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SSMClientTypes.AssociationComplianceSeverity? = nil,
            date: Foundation.Date? = nil,
            documentVersion: Swift.String? = nil,
            duration: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: Foundation.Date? = nil,
            lastSuccessfulExecutionDate: Foundation.Date? = nil,
            lastUpdateAssociationDate: Foundation.Date? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SSMClientTypes.InstanceAssociationOutputLocation? = nil,
            overview: SSMClientTypes.AssociationOverview? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            status: SSMClientTypes.AssociationStatus? = nil,
            syncCompliance: SSMClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SSMClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.date = date
            self.documentVersion = documentVersion
            self.duration = duration
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.lastSuccessfulExecutionDate = lastSuccessfulExecutionDate
            self.lastUpdateAssociationDate = lastUpdateAssociationDate
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.overview = overview
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.status = status
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targets = targets
            self.triggeredAlarms = triggeredAlarms
        }
    }
}

extension SSMClientTypes.AssociationDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationDescription(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), date: \(Swift.String(describing: date)), documentVersion: \(Swift.String(describing: documentVersion)), duration: \(Swift.String(describing: duration)), instanceId: \(Swift.String(describing: instanceId)), lastExecutionDate: \(Swift.String(describing: lastExecutionDate)), lastSuccessfulExecutionDate: \(Swift.String(describing: lastSuccessfulExecutionDate)), lastUpdateAssociationDate: \(Swift.String(describing: lastUpdateAssociationDate)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), overview: \(Swift.String(describing: overview)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), status: \(Swift.String(describing: status)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targets: \(Swift.String(describing: targets)), triggeredAlarms: \(Swift.String(describing: triggeredAlarms)), parameters: \"CONTENT_REDACTED\")"}
}

public struct CreateAssociationOutput: Swift.Sendable {
    /// Information about the association.
    public var associationDescription: SSMClientTypes.AssociationDescription?

    public init(
        associationDescription: SSMClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

extension SSMClientTypes {

    /// Describes the association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct CreateAssociationBatchRequestEntry: Swift.Sendable {
        /// The details for the CloudWatch alarm you want to apply to an automation or command.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// Specify a descriptive name for the association.
        public var associationName: Swift.String?
        /// Specify the target for the association. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
        public var automationTargetParameterName: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level to assign to the association.
        public var complianceSeverity: SSMClientTypes.AssociationComplianceSeverity?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The number of hours the association can run before it is canceled. Duration applies to associations that are currently running, and any pending and in progress commands on all targets. If a target was taken offline for the association to run, it is made available again immediately, without a reboot. The Duration parameter applies only when both these conditions are true:
        ///
        /// * The association for which you specify a duration is cancelable according to the parameters of the SSM command document or Automation runbook associated with this execution.
        ///
        /// * The command specifies the [ApplyOnlyAtCronInterval](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_CreateAssociationBatchRequestEntry.html#systemsmanager-Type-CreateAssociationBatchRequestEntry-ApplyOnlyAtCronInterval) parameter, which means that the association doesn't run immediately after it is created, but only according to the specified schedule.
        public var duration: Swift.Int?
        /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
        public var instanceId: Swift.String?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name of the SSM document that contains the configuration information for the managed node. You can specify Command or Automation runbooks. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For SSM documents that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
        /// This member is required.
        public var name: Swift.String?
        /// An S3 bucket where you want to store the results of this request.
        public var outputLocation: SSMClientTypes.InstanceAssociationOutputLocation?
        /// A description of the parameters for a document.
        public var parameters: [Swift.String: [Swift.String]]?
        /// A cron expression that specifies a schedule when the association runs.
        public var scheduleExpression: Swift.String?
        /// Number of days to wait after the scheduled day to run an association.
        public var scheduleOffset: Swift.Int?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SSMClientTypes.AssociationSyncCompliance?
        /// Use this action to create an association in multiple Regions and multiple accounts.
        public var targetLocations: [SSMClientTypes.TargetLocation]?
        /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The managed nodes targeted by the request.
        public var targets: [SSMClientTypes.Target]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationName: Swift.String? = nil,
            automationTargetParameterName: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SSMClientTypes.AssociationComplianceSeverity? = nil,
            documentVersion: Swift.String? = nil,
            duration: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SSMClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            syncCompliance: SSMClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SSMClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targets: [SSMClientTypes.Target]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationName = associationName
            self.automationTargetParameterName = automationTargetParameterName
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.documentVersion = documentVersion
            self.duration = duration
            self.instanceId = instanceId
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targets = targets
        }
    }
}

extension SSMClientTypes.CreateAssociationBatchRequestEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssociationBatchRequestEntry(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationName: \(Swift.String(describing: associationName)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), duration: \(Swift.String(describing: duration)), instanceId: \(Swift.String(describing: instanceId)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targets: \(Swift.String(describing: targets)), parameters: \"CONTENT_REDACTED\")"}
}

public struct CreateAssociationBatchInput: Swift.Sendable {
    /// One or more associations.
    /// This member is required.
    public var entries: [SSMClientTypes.CreateAssociationBatchRequestEntry]?

    public init(
        entries: [SSMClientTypes.CreateAssociationBatchRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

extension SSMClientTypes {

    public enum Fault: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case client
        case server
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [Fault] {
            return [
                .client,
                .server,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .client: return "Client"
            case .server: return "Server"
            case .unknown: return "Unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a failed association.
    public struct FailedCreateAssociation: Swift.Sendable {
        /// The association.
        public var entry: SSMClientTypes.CreateAssociationBatchRequestEntry?
        /// The source of the failure.
        public var fault: SSMClientTypes.Fault?
        /// A description of the failure.
        public var message: Swift.String?

        public init(
            entry: SSMClientTypes.CreateAssociationBatchRequestEntry? = nil,
            fault: SSMClientTypes.Fault? = nil,
            message: Swift.String? = nil
        )
        {
            self.entry = entry
            self.fault = fault
            self.message = message
        }
    }
}

public struct CreateAssociationBatchOutput: Swift.Sendable {
    /// Information about the associations that failed.
    public var failed: [SSMClientTypes.FailedCreateAssociation]?
    /// Information about the associations that succeeded.
    public var successful: [SSMClientTypes.AssociationDescription]?

    public init(
        failed: [SSMClientTypes.FailedCreateAssociation]? = nil,
        successful: [SSMClientTypes.AssociationDescription]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

/// The specified document already exists.
public struct DocumentAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can have at most 500 active SSM documents.
public struct DocumentLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The content for the document isn't valid.
public struct InvalidDocumentContent: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the validation error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocumentContent" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The version of the document schema isn't supported.
public struct InvalidDocumentSchemaVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocumentSchemaVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The size limit of a document is 64 KB.
public struct MaxDocumentSizeExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxDocumentSizeExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum AttachmentsSourceKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachmentreference
        case s3fileurl
        case sourceurl
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentsSourceKey] {
            return [
                .attachmentreference,
                .s3fileurl,
                .sourceurl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachmentreference: return "AttachmentReference"
            case .s3fileurl: return "S3FileUrl"
            case .sourceurl: return "SourceUrl"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Identifying information about a document attachment, including the file name and a key-value pair that identifies the location of an attachment to a document.
    public struct AttachmentsSource: Swift.Sendable {
        /// The key of a key-value pair that identifies the location of an attachment to a document.
        public var key: SSMClientTypes.AttachmentsSourceKey?
        /// The name of the document attachment file.
        public var name: Swift.String?
        /// The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        ///
        /// * For the key SourceUrl, the value is an S3 bucket location. For example: "Values": [ "s3://amzn-s3-demo-bucket/my-prefix" ]
        ///
        /// * For the key S3FileUrl, the value is a file in an S3 bucket. For example: "Values": [ "s3://amzn-s3-demo-bucket/my-prefix/my-file.py" ]
        ///
        /// * For the key AttachmentReference, the value is constructed from the name of another SSM document in your account, a version number of that document, and a file attached to that document version that you want to reuse. For example: "Values": [ "MyOtherDocument/3/my-other-file.py" ] However, if the SSM document is shared with you from another account, the full SSM document ARN must be specified instead of the document name only. For example: "Values": [ "arn:aws:ssm:us-east-2:111122223333:document/OtherAccountDocument/3/their-file.py" ]
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.AttachmentsSourceKey? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.name = name
            self.values = values
        }
    }
}

extension SSMClientTypes {

    public enum DocumentFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case text
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFormat] {
            return [
                .json,
                .text,
                .yaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .text: return "TEXT"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum DocumentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applicationconfiguration
        case applicationconfigurationschema
        case automation
        case changecalendar
        case changetemplate
        case cloudformation
        case command
        case conformancepacktemplate
        case deploymentstrategy
        case package
        case policy
        case problemanalysis
        case problemanalysistemplate
        case quicksetup
        case session
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentType] {
            return [
                .applicationconfiguration,
                .applicationconfigurationschema,
                .automation,
                .changecalendar,
                .changetemplate,
                .cloudformation,
                .command,
                .conformancepacktemplate,
                .deploymentstrategy,
                .package,
                .policy,
                .problemanalysis,
                .problemanalysistemplate,
                .quicksetup,
                .session
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applicationconfiguration: return "ApplicationConfiguration"
            case .applicationconfigurationschema: return "ApplicationConfigurationSchema"
            case .automation: return "Automation"
            case .changecalendar: return "ChangeCalendar"
            case .changetemplate: return "Automation.ChangeTemplate"
            case .cloudformation: return "CloudFormation"
            case .command: return "Command"
            case .conformancepacktemplate: return "ConformancePackTemplate"
            case .deploymentstrategy: return "DeploymentStrategy"
            case .package: return "Package"
            case .policy: return "Policy"
            case .problemanalysis: return "ProblemAnalysis"
            case .problemanalysistemplate: return "ProblemAnalysisTemplate"
            case .quicksetup: return "QuickSetup"
            case .session: return "Session"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// An SSM document required by the current document.
    public struct DocumentRequires: Swift.Sendable {
        /// The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        /// This member is required.
        public var name: Swift.String?
        /// The document type of the required SSM document.
        public var requireType: Swift.String?
        /// The document version required by the current document.
        public var version: Swift.String?
        /// An optional field specifying the version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init(
            name: Swift.String? = nil,
            requireType: Swift.String? = nil,
            version: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.name = name
            self.requireType = requireType
            self.version = version
            self.versionName = versionName
        }
    }
}

public struct CreateDocumentInput: Swift.Sendable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SSMClientTypes.AttachmentsSource]?
    /// The content for the new SSM document in JSON or YAML format. The content of the document must not exceed 64KB. This quota also includes the content specified for input parameters at runtime. We recommend storing the contents for your new document in an external JSON or YAML file and referencing the file in a command. For examples, see the following topics in the Amazon Web Services Systems Manager User Guide.
    ///
    /// * [Create an SSM document (console)](https://docs.aws.amazon.com/systems-manager/latest/userguide/documents-using.html#create-ssm-console)
    ///
    /// * [Create an SSM document (command line)](https://docs.aws.amazon.com/systems-manager/latest/userguide/documents-using.html#create-ssm-document-cli)
    ///
    /// * [Create an SSM document (API)](https://docs.aws.amazon.com/systems-manager/latest/userguide/documents-using.html#create-ssm-document-api)
    /// This member is required.
    public var content: Swift.String?
    /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. You can update this value at a later time using the [UpdateDocument] operation.
    public var displayName: Swift.String?
    /// Specify the document format for the request. The document format can be JSON, YAML, or TEXT. JSON is the default format.
    public var documentFormat: SSMClientTypes.DocumentFormat?
    /// The type of document to create. The DeploymentStrategy document type is an internal-use-only document type reserved for AppConfig.
    public var documentType: SSMClientTypes.DocumentType?
    /// A name for the SSM document. You can't use the following strings as document name prefixes. These are reserved by Amazon Web Services for use as document name prefixes:
    ///
    /// * aws
    ///
    /// * amazon
    ///
    /// * amzn
    ///
    /// * AWSEC2
    ///
    /// * AWSConfigRemediation
    ///
    /// * AWSSupport
    /// This member is required.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. This parameter is used exclusively by AppConfig. When a user creates an AppConfig configuration in an SSM document, the user must also specify a required document for validation purposes. In this case, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document for validation purposes. For more information, see [What is AppConfig?](https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html) in the AppConfig User Guide.
    public var requires: [SSMClientTypes.DocumentRequires]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an SSM document to identify the types of targets or the environment where it will run. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing SSM document, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?
    /// Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are creating with the document. For example, Release12.1. This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init(
        attachments: [SSMClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SSMClientTypes.DocumentFormat? = nil,
        documentType: SSMClientTypes.DocumentType? = nil,
        name: Swift.String? = nil,
        requires: [SSMClientTypes.DocumentRequires]? = nil,
        tags: [SSMClientTypes.Tag]? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.name = name
        self.requires = requires
        self.tags = tags
        self.targetType = targetType
        self.versionName = versionName
    }
}

extension SSMClientTypes {

    /// An attribute of an attachment, such as the attachment name.
    public struct AttachmentInformation: Swift.Sendable {
        /// The name of the attachment.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension SSMClientTypes {

    public enum DocumentHashType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentHashType] {
            return [
                .sha1,
                .sha256
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "Sha1"
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum DocumentParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case string
        case stringlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentParameterType] {
            return [
                .string,
                .stringlist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .string: return "String"
            case .stringlist: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Parameters specified in a Systems Manager document that run on the server when the command is run.
    public struct DocumentParameter: Swift.Sendable {
        /// If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.
        public var defaultValue: Swift.String?
        /// A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.
        public var description: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// The type of parameter. The type can be either String or StringList.
        public var type: SSMClientTypes.DocumentParameterType?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: SSMClientTypes.DocumentParameterType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension SSMClientTypes {

    public enum PlatformType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .linux,
                .macos,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .macos: return "MacOS"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum ReviewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case notReviewed
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewStatus] {
            return [
                .approved,
                .notReviewed,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .notReviewed: return "NOT_REVIEWED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the result of a document review request.
    public struct ReviewInformation: Swift.Sendable {
        /// The time that the reviewer took action on the document review request.
        public var reviewedTime: Foundation.Date?
        /// The reviewer assigned to take action on the document review request.
        public var reviewer: Swift.String?
        /// The current status of the document review request.
        public var status: SSMClientTypes.ReviewStatus?

        public init(
            reviewedTime: Foundation.Date? = nil,
            reviewer: Swift.String? = nil,
            status: SSMClientTypes.ReviewStatus? = nil
        )
        {
            self.reviewedTime = reviewedTime
            self.reviewer = reviewer
            self.status = status
        }
    }
}

extension SSMClientTypes {

    /// The status of a document.
    public enum DocumentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes an Amazon Web Services Systems Manager document (SSM document).
    public struct DocumentDescription: Swift.Sendable {
        /// The version of the document currently approved for use in the organization.
        public var approvedVersion: Swift.String?
        /// Details about the document attachments, including names, locations, sizes, and so on.
        public var attachmentsInformation: [SSMClientTypes.AttachmentInformation]?
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The classification of a document to help you identify and categorize its use.
        public var category: [Swift.String]?
        /// The value that identifies a document's category.
        public var categoryEnum: [Swift.String]?
        /// The date when the document was created.
        public var createdDate: Foundation.Date?
        /// The default version.
        public var defaultVersion: Swift.String?
        /// A description of the document.
        public var description: Swift.String?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SSMClientTypes.DocumentFormat?
        /// The type of document.
        public var documentType: SSMClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
        public var hash: Swift.String?
        /// The hash type of the document. Valid values include Sha256 or Sha1. Sha1 hashes have been deprecated.
        public var hashType: SSMClientTypes.DocumentHashType?
        /// The latest version of the document.
        public var latestVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user that created the document.
        public var owner: Swift.String?
        /// A description of the parameters for a document.
        public var parameters: [SSMClientTypes.DocumentParameter]?
        /// The version of the document that is currently under review.
        public var pendingReviewVersion: Swift.String?
        /// The list of operating system (OS) platforms compatible with this SSM document.
        public var platformTypes: [SSMClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SSMClientTypes.DocumentRequires]?
        /// Details about the review of a document.
        public var reviewInformation: [SSMClientTypes.ReviewInformation]?
        /// The current status of the review.
        public var reviewStatus: SSMClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The SHA1 hash of the document, which you can use for verification.
        public var sha1: Swift.String?
        /// The status of the SSM document.
        public var status: SSMClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SSMClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// The version of the artifact associated with the document.
        public var versionName: Swift.String?

        public init(
            approvedVersion: Swift.String? = nil,
            attachmentsInformation: [SSMClientTypes.AttachmentInformation]? = nil,
            author: Swift.String? = nil,
            category: [Swift.String]? = nil,
            categoryEnum: [Swift.String]? = nil,
            createdDate: Foundation.Date? = nil,
            defaultVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SSMClientTypes.DocumentFormat? = nil,
            documentType: SSMClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            hash: Swift.String? = nil,
            hashType: SSMClientTypes.DocumentHashType? = nil,
            latestVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [SSMClientTypes.DocumentParameter]? = nil,
            pendingReviewVersion: Swift.String? = nil,
            platformTypes: [SSMClientTypes.PlatformType]? = nil,
            requires: [SSMClientTypes.DocumentRequires]? = nil,
            reviewInformation: [SSMClientTypes.ReviewInformation]? = nil,
            reviewStatus: SSMClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            sha1: Swift.String? = nil,
            status: SSMClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            tags: [SSMClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.approvedVersion = approvedVersion
            self.attachmentsInformation = attachmentsInformation
            self.author = author
            self.category = category
            self.categoryEnum = categoryEnum
            self.createdDate = createdDate
            self.defaultVersion = defaultVersion
            self.description = description
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.hash = hash
            self.hashType = hashType
            self.latestVersion = latestVersion
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.pendingReviewVersion = pendingReviewVersion
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewInformation = reviewInformation
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.sha1 = sha1
            self.status = status
            self.statusInformation = statusInformation
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }
}

public struct CreateDocumentOutput: Swift.Sendable {
    /// Information about the SSM document.
    public var documentDescription: SSMClientTypes.DocumentDescription?

    public init(
        documentDescription: SSMClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

/// Error returned when an idempotent operation is retried and the parameters don't match the original call to the API with the same idempotency token.
public struct IdempotentParameterMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatch" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Error returned when the caller has exceeded the default resource quotas. For example, too many maintenance windows or patch baselines have been created. For information about resource quotas in Systems Manager, see [Systems Manager service quotas](https://docs.aws.amazon.com/general/latest/gr/ssm.html#limits_ssm) in the Amazon Web Services General Reference.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateMaintenanceWindowInput: Swift.Sendable {
    /// Enables a maintenance window task to run on managed nodes, even if you haven't registered those nodes as targets. If enabled, then you must specify the unregistered managed nodes (by node ID) when you register a task with the maintenance window. If you don't enable this option, then you must specify previously-registered targets when you register a task with the maintenance window.
    /// This member is required.
    public var allowUnassociatedTargets: Swift.Bool?
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    /// This member is required.
    public var cutoff: Swift.Int?
    /// An optional description for the maintenance window. We recommend specifying a description to help you organize your maintenance windows.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    /// This member is required.
    public var duration: Swift.Int?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    /// This member is required.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run on the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become active. StartDate allows you to delay activation of the maintenance window until the specified future date. When using a rate schedule, if you provide a start date that occurs in the past, the current date and time are used as the start date.
    public var startDate: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a maintenance window to identify the type of tasks it will run, the types of targets, and the environment it will run in. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=TaskType,Value=AgentUpdate
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=Environment,Value=Production
    ///
    ///
    /// To add tags to an existing maintenance window, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?

    public init(
        allowUnassociatedTargets: Swift.Bool? = false,
        clientToken: Swift.String? = nil,
        cutoff: Swift.Int? = 0,
        description: Swift.String? = nil,
        duration: Swift.Int? = nil,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.clientToken = clientToken
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.tags = tags
    }
}

extension CreateMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMaintenanceWindowInput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), clientToken: \(Swift.String(describing: clientToken)), cutoff: \(Swift.String(describing: cutoff)), duration: \(Swift.String(describing: duration)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init(
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

/// You don't have permission to view OpsItems in the specified account. Verify that your account is configured either as a Systems Manager delegated administrator or that you are logged into the Organizations management account.
public struct OpsItemAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The OpsItem already exists.
public struct OpsItemAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var opsItemId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.opsItemId = opsItemId
    }
}

extension SSMClientTypes {

    /// A notification about the OpsItem.
    public struct OpsItemNotification: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension SSMClientTypes {

    public enum OpsItemDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case searchableString
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemDataType] {
            return [
                .searchableString,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .searchableString: return "SearchableString"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// An object that defines the value of the key and its type in the OperationalData map.
    public struct OpsItemDataValue: Swift.Sendable {
        /// The type of key-value pair. Valid types include SearchableString and String.
        public var type: SSMClientTypes.OpsItemDataType?
        /// The value of the OperationalData key.
        public var value: Swift.String?

        public init(
            type: SSMClientTypes.OpsItemDataType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension SSMClientTypes {

    /// An OpsItems that shares something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public struct RelatedOpsItem: Swift.Sendable {
        /// The ID of an OpsItem related to the current OpsItem.
        /// This member is required.
        public var opsItemId: Swift.String?

        public init(
            opsItemId: Swift.String? = nil
        )
        {
            self.opsItemId = opsItemId
        }
    }
}

public struct CreateOpsItemInput: Swift.Sendable {
    /// The target Amazon Web Services account where you want to create an OpsItem. To make this call, your account must be configured to work with OpsItems across accounts. For more information, see [Set up OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-setup.html) in the Amazon Web Services Systems Manager User Guide.
    public var accountId: Swift.String?
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: Foundation.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: Foundation.Date?
    /// Specify a category to assign to an OpsItem.
    public var category: Swift.String?
    /// User-defined text that contains information about the OpsItem, in Markdown format. Provide enough information so that users viewing this OpsItem for the first time understand the issue.
    /// This member is required.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SSMClientTypes.OpsItemNotification]?
    /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Create OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-manually-create-OpsItems.html) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]?
    /// The type of OpsItem to create. Systems Manager supports the following types of OpsItems:
    ///
    /// * /aws/issue This type of OpsItem is used for default OpsItems created by OpsCenter.
    ///
    /// * /aws/changerequest This type of OpsItem is used by Change Manager for reviewing and approving or rejecting change requests.
    ///
    /// * /aws/insight This type of OpsItem is used by OpsCenter for aggregating and reporting on duplicate OpsItems.
    public var opsItemType: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: Foundation.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: Foundation.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SSMClientTypes.RelatedOpsItem]?
    /// Specify a severity to assign to an OpsItem.
    public var severity: Swift.String?
    /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The source name can't contain the following strings: aws, amazon, and amzn.
    /// This member is required.
    public var source: Swift.String?
    /// Optional metadata that you assign to a resource. Tags use a key-value pair. For example: Key=Department,Value=Finance To add tags to a new OpsItem, a user must have IAM permissions for both the ssm:CreateOpsItems operation and the ssm:AddTagsToResource operation. To add tags to an existing OpsItem, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    /// This member is required.
    public var title: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actualEndTime: Foundation.Date? = nil,
        actualStartTime: Foundation.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SSMClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]? = nil,
        opsItemType: Swift.String? = nil,
        plannedEndTime: Foundation.Date? = nil,
        plannedStartTime: Foundation.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SSMClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        source: Swift.String? = nil,
        tags: [SSMClientTypes.Tag]? = nil,
        title: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.opsItemType = opsItemType
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.source = source
        self.tags = tags
        self.title = title
    }
}

public struct CreateOpsItemOutput: Swift.Sendable {
    /// The OpsItem Amazon Resource Name (ARN).
    public var opsItemArn: Swift.String?
    /// The ID of the OpsItem.
    public var opsItemId: Swift.String?

    public init(
        opsItemArn: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemArn = opsItemArn
        self.opsItemId = opsItemId
    }
}

/// An OpsMetadata object already exists for the selected resource.
public struct OpsMetadataAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One of the arguments passed is invalid.
public struct OpsMetadataInvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataInvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your account reached the maximum number of OpsMetadata objects allowed by Application Manager. The maximum is 200 OpsMetadata objects. Delete one or more OpsMetadata object and try again.
public struct OpsMetadataLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The system is processing too many concurrent updates. Wait a few moments and try again.
public struct OpsMetadataTooManyUpdatesException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataTooManyUpdatesException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Metadata to assign to an Application Manager application.
    public struct MetadataValue: Swift.Sendable {
        /// Metadata value to assign to an Application Manager application.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }
}

public struct CreateOpsMetadataInput: Swift.Sendable {
    /// Metadata for a new Application Manager application.
    public var metadata: [Swift.String: SSMClientTypes.MetadataValue]?
    /// A resource ID for a new Application Manager application.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an OpsMetadata object. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an OpsMetadata object to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SSMClientTypes.Tag]?

    public init(
        metadata: [Swift.String: SSMClientTypes.MetadataValue]? = nil,
        resourceId: Swift.String? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.metadata = metadata
        self.resourceId = resourceId
        self.tags = tags
    }
}

public struct CreateOpsMetadataOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob created by the call.
    public var opsMetadataArn: Swift.String?

    public init(
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

extension SSMClientTypes {

    public enum PatchComplianceLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceLevel] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum PatchFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case advisoryid
        case arch
        case bugzillaid
        case cveid
        case classification
        case epoch
        case msrcseverity
        case name
        case patchid
        case patchset
        case priority
        case product
        case productfamily
        case release
        case repository
        case section
        case security
        case severity
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchFilterKey] {
            return [
                .advisoryid,
                .arch,
                .bugzillaid,
                .cveid,
                .classification,
                .epoch,
                .msrcseverity,
                .name,
                .patchid,
                .patchset,
                .priority,
                .product,
                .productfamily,
                .release,
                .repository,
                .section,
                .security,
                .severity,
                .version
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .advisoryid: return "ADVISORY_ID"
            case .arch: return "ARCH"
            case .bugzillaid: return "BUGZILLA_ID"
            case .cveid: return "CVE_ID"
            case .classification: return "CLASSIFICATION"
            case .epoch: return "EPOCH"
            case .msrcseverity: return "MSRC_SEVERITY"
            case .name: return "NAME"
            case .patchid: return "PATCH_ID"
            case .patchset: return "PATCH_SET"
            case .priority: return "PRIORITY"
            case .product: return "PRODUCT"
            case .productfamily: return "PRODUCT_FAMILY"
            case .release: return "RELEASE"
            case .repository: return "REPOSITORY"
            case .section: return "SECTION"
            case .security: return "SECURITY"
            case .severity: return "SEVERITY"
            case .version: return "VERSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Defines which patches should be included in a patch baseline. A patch filter consists of a key and a set of values. The filter key is a patch property. For example, the available filter keys for WINDOWS are PATCH_SET, PRODUCT, PRODUCT_FAMILY, CLASSIFICATION, and MSRC_SEVERITY. The filter values define a matching criterion for the patch property indicated by the key. For example, if the filter key is PRODUCT and the filter values are ["Office 2013", "Office 2016"], then the filter accepts all patches where product name is either "Office 2013" or "Office 2016". The filter values can be exact values for the patch property given as a key, or a wildcard (*), which matches all values. You can view lists of valid values for the patch properties by running the DescribePatchProperties command. For information about which patch properties can be used with each major operating system, see [DescribePatchProperties].
    public struct PatchFilter: Swift.Sendable {
        /// The key for the filter. Run the [DescribePatchProperties] command to view lists of valid keys for each operating system type.
        /// This member is required.
        public var key: SSMClientTypes.PatchFilterKey?
        /// The value for the filter key. Run the [DescribePatchProperties] command to view lists of valid values for each key based on operating system type.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.PatchFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

extension SSMClientTypes {

    /// A set of patch filters, typically used for approval rules.
    public struct PatchFilterGroup: Swift.Sendable {
        /// The set of patch filters that make up the group.
        /// This member is required.
        public var patchFilters: [SSMClientTypes.PatchFilter]?

        public init(
            patchFilters: [SSMClientTypes.PatchFilter]? = nil
        )
        {
            self.patchFilters = patchFilters
        }
    }
}

extension SSMClientTypes {

    /// Defines an approval rule for a patch baseline.
    public struct PatchRule: Swift.Sendable {
        /// The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of 7 means that patches are approved seven days after they are released. This parameter is marked as Required: No, but your request must include a value for either ApproveAfterDays or ApproveUntilDate. Not supported for Debian Server or Ubuntu Server. Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the Windows Server tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the Amazon Web Services Systems Manager User Guide.
        public var approveAfterDays: Swift.Int?
        /// The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Enter dates in the format YYYY-MM-DD. For example, 2024-12-31. This parameter is marked as Required: No, but your request must include a value for either ApproveUntilDate or ApproveAfterDays. Not supported for Debian Server or Ubuntu Server. Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the Windows Server tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the Amazon Web Services Systems Manager User Guide.
        public var approveUntilDate: Swift.String?
        /// A compliance severity level for all approved patches in a patch baseline.
        public var complianceLevel: SSMClientTypes.PatchComplianceLevel?
        /// For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is false. Applies to Linux managed nodes only.
        public var enableNonSecurity: Swift.Bool?
        /// The patch filter group that defines the criteria for the rule.
        /// This member is required.
        public var patchFilterGroup: SSMClientTypes.PatchFilterGroup?

        public init(
            approveAfterDays: Swift.Int? = 0,
            approveUntilDate: Swift.String? = nil,
            complianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
            enableNonSecurity: Swift.Bool? = false,
            patchFilterGroup: SSMClientTypes.PatchFilterGroup? = nil
        )
        {
            self.approveAfterDays = approveAfterDays
            self.approveUntilDate = approveUntilDate
            self.complianceLevel = complianceLevel
            self.enableNonSecurity = enableNonSecurity
            self.patchFilterGroup = patchFilterGroup
        }
    }
}

extension SSMClientTypes {

    /// A set of rules defining the approval rules for a patch baseline.
    public struct PatchRuleGroup: Swift.Sendable {
        /// The rules that make up the rule group.
        /// This member is required.
        public var patchRules: [SSMClientTypes.PatchRule]?

        public init(
            patchRules: [SSMClientTypes.PatchRule]? = nil
        )
        {
            self.patchRules = patchRules
        }
    }
}

extension SSMClientTypes {

    public enum OperatingSystem: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case almalinux
        case amazonlinux
        case amazonlinux2
        case amazonlinux2022
        case amazonlinux2023
        case centos
        case debian
        case macos
        case oraclelinux
        case raspbian
        case redhatenterpriselinux
        case rockyLinux
        case suse
        case ubuntu
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatingSystem] {
            return [
                .almalinux,
                .amazonlinux,
                .amazonlinux2,
                .amazonlinux2022,
                .amazonlinux2023,
                .centos,
                .debian,
                .macos,
                .oraclelinux,
                .raspbian,
                .redhatenterpriselinux,
                .rockyLinux,
                .suse,
                .ubuntu,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .almalinux: return "ALMA_LINUX"
            case .amazonlinux: return "AMAZON_LINUX"
            case .amazonlinux2: return "AMAZON_LINUX_2"
            case .amazonlinux2022: return "AMAZON_LINUX_2022"
            case .amazonlinux2023: return "AMAZON_LINUX_2023"
            case .centos: return "CENTOS"
            case .debian: return "DEBIAN"
            case .macos: return "MACOS"
            case .oraclelinux: return "ORACLE_LINUX"
            case .raspbian: return "RASPBIAN"
            case .redhatenterpriselinux: return "REDHAT_ENTERPRISE_LINUX"
            case .rockyLinux: return "ROCKY_LINUX"
            case .suse: return "SUSE"
            case .ubuntu: return "UBUNTU"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum PatchAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowasdependency
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchAction] {
            return [
                .allowasdependency,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowasdependency: return "ALLOW_AS_DEPENDENCY"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the patches to use to update the managed nodes, including target operating systems and source repository. Applies to Linux managed nodes only.
    public struct PatchSource: Swift.Sendable {
        /// The value of the yum repo configuration. For example: [main]
        ///     name=MyCustomRepository
        ///
        ///
        ///     baseurl=https://my-custom-repository
        ///
        /// enabled=1 For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://man7.org/linux/man-pages/man5/dnf.conf.5.html).
        /// This member is required.
        public var configuration: Swift.String?
        /// The name specified to identify the patch source.
        /// This member is required.
        public var name: Swift.String?
        /// The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter].
        /// This member is required.
        public var products: [Swift.String]?

        public init(
            configuration: Swift.String? = nil,
            name: Swift.String? = nil,
            products: [Swift.String]? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.products = products
        }
    }
}

extension SSMClientTypes.PatchSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatchSource(name: \(Swift.String(describing: name)), products: \(Swift.String(describing: products)), configuration: \"CONTENT_REDACTED\")"}
}

public struct CreatePatchBaselineInput: Swift.Sendable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SSMClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation. The default value is UNSPECIFIED.
    public var approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool?
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SSMClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    /// This member is required.
    public var name: Swift.String?
    /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list. ALLOW_AS_DEPENDENCY Linux and macOS: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as INSTALLED_OTHER. This is the default action if no option is specified. Windows Server: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as INSTALLED_OTHER. Any package not already installed on the node is skipped. This is the default action if no option is specified. BLOCK All OSs: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances. If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as INSTALLED_REJECTED.
    public var rejectedPatchesAction: SSMClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SSMClientTypes.PatchSource]?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a patch baseline to identify the severity level of patches it specifies and the operating system family it applies to. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=PatchSeverity,Value=Critical
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing patch baseline, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?

    public init(
        approvalRules: SSMClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool? = false,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SSMClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SSMClientTypes.PatchAction? = nil,
        sources: [SSMClientTypes.PatchSource]? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.clientToken = clientToken
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
        self.tags = tags
    }
}

public struct CreatePatchBaselineOutput: Swift.Sendable {
    /// The ID of the created patch baseline.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

/// A sync configuration with the same name already exists.
public struct ResourceDataSyncAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var syncName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDataSyncAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        syncName: Swift.String? = nil
    )
    {
        self.properties.syncName = syncName
    }
}

/// You have exceeded the allowed maximum sync configurations.
public struct ResourceDataSyncCountExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDataSyncCountExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified sync configuration is invalid.
public struct ResourceDataSyncInvalidConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDataSyncInvalidConfiguration" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Synchronize Amazon Web Services Systems Manager Inventory data from multiple Amazon Web Services accounts defined in Organizations to a centralized Amazon S3 bucket. Data is synchronized to individual key prefixes in the central bucket. Each key prefix represents a different Amazon Web Services account ID.
    public struct ResourceDataSyncDestinationDataSharing: Swift.Sendable {
        /// The sharing data type. Only Organization is supported.
        public var destinationDataSharingType: Swift.String?

        public init(
            destinationDataSharingType: Swift.String? = nil
        )
        {
            self.destinationDataSharingType = destinationDataSharingType
        }
    }
}

extension SSMClientTypes {

    public enum ResourceDataSyncS3Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonSerde
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceDataSyncS3Format] {
            return [
                .jsonSerde
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonSerde: return "JsonSerDe"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the target S3 bucket for the resource data sync.
    public struct ResourceDataSyncS3Destination: Swift.Sendable {
        /// The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        public var awskmsKeyARN: Swift.String?
        /// The name of the S3 bucket where the aggregated data is stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Enables destination data sharing. By default, this field is null.
        public var destinationDataSharing: SSMClientTypes.ResourceDataSyncDestinationDataSharing?
        /// An Amazon S3 prefix for the bucket.
        public var `prefix`: Swift.String?
        /// The Amazon Web Services Region with the S3 bucket targeted by the resource data sync.
        /// This member is required.
        public var region: Swift.String?
        /// A supported sync format. The following format is currently supported: JsonSerDe
        /// This member is required.
        public var syncFormat: SSMClientTypes.ResourceDataSyncS3Format?

        public init(
            awskmsKeyARN: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            destinationDataSharing: SSMClientTypes.ResourceDataSyncDestinationDataSharing? = nil,
            `prefix`: Swift.String? = nil,
            region: Swift.String? = nil,
            syncFormat: SSMClientTypes.ResourceDataSyncS3Format? = nil
        )
        {
            self.awskmsKeyARN = awskmsKeyARN
            self.bucketName = bucketName
            self.destinationDataSharing = destinationDataSharing
            self.`prefix` = `prefix`
            self.region = region
            self.syncFormat = syncFormat
        }
    }
}

extension SSMClientTypes {

    /// The Organizations organizational unit data source for the sync.
    public struct ResourceDataSyncOrganizationalUnit: Swift.Sendable {
        /// The Organizations unit ID data source for the sync.
        public var organizationalUnitId: Swift.String?

        public init(
            organizationalUnitId: Swift.String? = nil
        )
        {
            self.organizationalUnitId = organizationalUnitId
        }
    }
}

extension SSMClientTypes {

    /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations or, if an Amazon Web Services organization isn't present, from multiple Amazon Web Services Regions.
    public struct ResourceDataSyncAwsOrganizationsSource: Swift.Sendable {
        /// If an Amazon Web Services organization is present, this is either OrganizationalUnits or EntireOrganization. For OrganizationalUnits, the data is aggregated from a set of organization units. For EntireOrganization, the data is aggregated from the entire Amazon Web Services organization.
        /// This member is required.
        public var organizationSourceType: Swift.String?
        /// The Organizations organization units included in the sync.
        public var organizationalUnits: [SSMClientTypes.ResourceDataSyncOrganizationalUnit]?

        public init(
            organizationSourceType: Swift.String? = nil,
            organizationalUnits: [SSMClientTypes.ResourceDataSyncOrganizationalUnit]? = nil
        )
        {
            self.organizationSourceType = organizationSourceType
            self.organizationalUnits = organizationalUnits
        }
    }
}

extension SSMClientTypes {

    /// Information about the source of the data included in the resource data sync.
    public struct ResourceDataSyncSource: Swift.Sendable {
        /// Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from Organizations.
        public var awsOrganizationsSource: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [Setting up Systems Manager Explorer to display data from multiple accounts and Regions](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resource-data-sync.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        /// This member is required.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or SingleAccountMultiRegions.
        /// This member is required.
        public var sourceType: Swift.String?

        public init(
            awsOrganizationsSource: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
        }
    }
}

public struct CreateResourceDataSyncInput: Swift.Sendable {
    /// Amazon S3 configuration details for the sync. This parameter is required if the SyncType value is SyncToDestination.
    public var s3Destination: SSMClientTypes.ResourceDataSyncS3Destination?
    /// A name for the configuration.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize. This parameter is required if the SyncType value is SyncFromSource.
    public var syncSource: SSMClientTypes.ResourceDataSyncSource?
    /// Specify SyncToDestination to create a resource data sync that synchronizes data to an S3 bucket for Inventory. If you specify SyncToDestination, you must provide a value for S3Destination. Specify SyncFromSource to synchronize data from a single account and multiple Regions, or multiple Amazon Web Services accounts and Amazon Web Services Regions, as listed in Organizations for Explorer. If you specify SyncFromSource, you must provide a value for SyncSource. The default value is SyncToDestination.
    public var syncType: Swift.String?

    public init(
        s3Destination: SSMClientTypes.ResourceDataSyncS3Destination? = nil,
        syncName: Swift.String? = nil,
        syncSource: SSMClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.s3Destination = s3Destination
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

public struct CreateResourceDataSyncOutput: Swift.Sendable {

    public init() { }
}

/// The activation isn't valid. The activation might have been deleted, or the ActivationId and the ActivationCode don't match.
public struct InvalidActivation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidActivation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The activation ID isn't valid. Verify the you entered the correct ActivationId or ActivationCode and try again.
public struct InvalidActivationId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidActivationId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteActivationInput: Swift.Sendable {
    /// The ID of the activation that you want to delete.
    /// This member is required.
    public var activationId: Swift.String?

    public init(
        activationId: Swift.String? = nil
    )
    {
        self.activationId = activationId
    }
}

public struct DeleteActivationOutput: Swift.Sendable {

    public init() { }
}

/// The specified association doesn't exist.
public struct AssociationDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociationDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAssociationInput: Swift.Sendable {
    /// The association ID that you want to delete.
    public var associationId: Swift.String?
    /// The managed node ID. InstanceId has been deprecated. To specify a managed node ID for an association, use the Targets parameter. Requests that include the parameter InstanceID with Systems Manager documents (SSM documents) that use schema version 2.0 or later will fail. In addition, if you use the parameter InstanceId, you can't use the parameters AssociationName, DocumentVersion, MaxErrors, MaxConcurrency, OutputLocation, or ScheduleExpression. To use these parameters, you must use the Targets parameter.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.instanceId = instanceId
        self.name = name
    }
}

public struct DeleteAssociationOutput: Swift.Sendable {

    public init() { }
}

/// You must disassociate a document from all managed nodes before you can delete it.
public struct AssociatedInstances: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "AssociatedInstances" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// You attempted to delete a document while it is still shared. You must stop sharing the document before you can delete it.
public struct InvalidDocumentOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocumentOperation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteDocumentInput: Swift.Sendable {
    /// The version of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var documentVersion: Swift.String?
    /// Some SSM document types require that you specify a Force flag before you can delete the document. For example, you must specify a Force flag to delete a document of type ApplicationConfigurationSchema. You can restrict access to the Force flag in an Identity and Access Management (IAM) policy.
    public var force: Swift.Bool?
    /// The name of the document.
    /// This member is required.
    public var name: Swift.String?
    /// The version name of the document that you want to delete. If not provided, all versions of the document are deleted.
    public var versionName: Swift.String?

    public init(
        documentVersion: Swift.String? = nil,
        force: Swift.Bool? = false,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.force = force
        self.name = name
        self.versionName = versionName
    }
}

public struct DeleteDocumentOutput: Swift.Sendable {

    public init() { }
}

/// One or more of the parameters specified for the delete operation isn't valid. Verify all parameters and try again.
public struct InvalidDeleteInventoryParametersException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeleteInventoryParameters" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request isn't valid.
public struct InvalidInventoryRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInventoryRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The delete inventory option specified isn't valid. Verify the option and try again.
public struct InvalidOptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOption" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameter type name isn't valid.
public struct InvalidTypeNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTypeName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum InventorySchemaDeleteOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteSchema
        case disableSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [InventorySchemaDeleteOption] {
            return [
                .deleteSchema,
                .disableSchema
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteSchema: return "DeleteSchema"
            case .disableSchema: return "DisableSchema"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteInventoryInput: Swift.Sendable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Use this option to view a summary of the deletion request without deleting any data or the data type. This option is useful when you only want to understand what will be deleted. Once you validate that the data to be deleted is what you intend to delete, you can run the same command without specifying the DryRun option.
    public var dryRun: Swift.Bool?
    /// Use the SchemaDeleteOption to delete a custom inventory type (schema). If you don't choose this option, the system only deletes existing inventory data associated with the custom inventory type. Choose one of the following options: DisableSchema: If you choose this option, the system ignores all inventory data for the specified version, and any earlier versions. To enable this schema again, you must call the PutInventory operation for a version greater than the disabled version. DeleteSchema: This option deletes the specified custom type from the Inventory service. You can recreate the schema later, if you want.
    public var schemaDeleteOption: SSMClientTypes.InventorySchemaDeleteOption?
    /// The name of the custom inventory type for which you want to delete either all previously collected data or the inventory type itself.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        schemaDeleteOption: SSMClientTypes.InventorySchemaDeleteOption? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dryRun = dryRun
        self.schemaDeleteOption = schemaDeleteOption
        self.typeName = typeName
    }
}

extension SSMClientTypes {

    /// Either a count, remaining count, or a version number in a delete inventory summary.
    public struct InventoryDeletionSummaryItem: Swift.Sendable {
        /// A count of the number of deleted items.
        public var count: Swift.Int
        /// The remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// The inventory type version.
        public var version: Swift.String?

        public init(
            count: Swift.Int = 0,
            remainingCount: Swift.Int = 0,
            version: Swift.String? = nil
        )
        {
            self.count = count
            self.remainingCount = remainingCount
            self.version = version
        }
    }
}

extension SSMClientTypes {

    /// Information about the delete operation.
    public struct InventoryDeletionSummary: Swift.Sendable {
        /// Remaining number of items to delete.
        public var remainingCount: Swift.Int
        /// A list of counts and versions for deleted items.
        public var summaryItems: [SSMClientTypes.InventoryDeletionSummaryItem]?
        /// The total number of items to delete. This count doesn't change during the delete operation.
        public var totalCount: Swift.Int

        public init(
            remainingCount: Swift.Int = 0,
            summaryItems: [SSMClientTypes.InventoryDeletionSummaryItem]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.remainingCount = remainingCount
            self.summaryItems = summaryItems
            self.totalCount = totalCount
        }
    }
}

public struct DeleteInventoryOutput: Swift.Sendable {
    /// Every DeleteInventory operation is assigned a unique ID. This option returns a unique ID. You can use this ID to query the status of a delete operation. This option is useful for ensuring that a delete operation has completed before you begin other operations.
    public var deletionId: Swift.String?
    /// A summary of the delete operation. For more information about this summary, see [Deleting custom inventory](https://docs.aws.amazon.com/systems-manager/latest/userguide/inventory-custom.html#delete-custom-inventory-summary) in the Amazon Web Services Systems Manager User Guide.
    public var deletionSummary: SSMClientTypes.InventoryDeletionSummary?
    /// The name of the inventory data type specified in the request.
    public var typeName: Swift.String?

    public init(
        deletionId: Swift.String? = nil,
        deletionSummary: SSMClientTypes.InventoryDeletionSummary? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.deletionSummary = deletionSummary
        self.typeName = typeName
    }
}

public struct DeleteMaintenanceWindowInput: Swift.Sendable {
    /// The ID of the maintenance window to delete.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

public struct DeleteMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the deleted maintenance window.
    public var windowId: Swift.String?

    public init(
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

public struct DeleteOpsItemInput: Swift.Sendable {
    /// The ID of the OpsItem that you want to delete.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init(
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemId = opsItemId
    }
}

public struct DeleteOpsItemOutput: Swift.Sendable {

    public init() { }
}

/// The OpsMetadata object doesn't exist.
public struct OpsMetadataNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteOpsMetadataInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to delete.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init(
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

public struct DeleteOpsMetadataOutput: Swift.Sendable {

    public init() { }
}

/// The parameter couldn't be found. Verify the name and try again.
public struct ParameterNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteParameterInput: Swift.Sendable {
    /// The name of the parameter to delete. You can't enter the Amazon Resource Name (ARN) for a parameter, only the parameter name itself.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteParameterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteParametersInput: Swift.Sendable {
    /// The names of the parameters to delete. After deleting a parameter, wait for at least 30 seconds to create a parameter with the same name. You can't enter the Amazon Resource Name (ARN) for a parameter, only the parameter name itself.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

public struct DeleteParametersOutput: Swift.Sendable {
    /// The names of the deleted parameters.
    public var deletedParameters: [Swift.String]?
    /// The names of parameters that weren't deleted because the parameters aren't valid.
    public var invalidParameters: [Swift.String]?

    public init(
        deletedParameters: [Swift.String]? = nil,
        invalidParameters: [Swift.String]? = nil
    )
    {
        self.deletedParameters = deletedParameters
        self.invalidParameters = invalidParameters
    }
}

/// Error returned if an attempt is made to delete a patch baseline that is registered for a patch group.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeletePatchBaselineInput: Swift.Sendable {
    /// The ID of the patch baseline to delete.
    /// This member is required.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

public struct DeletePatchBaselineOutput: Swift.Sendable {
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

/// The specified sync name wasn't found.
public struct ResourceDataSyncNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var syncName: Swift.String? = nil
        public internal(set) var syncType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDataSyncNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.syncName = syncName
        self.properties.syncType = syncType
    }
}

public struct DeleteResourceDataSyncInput: Swift.Sendable {
    /// The name of the configuration to delete.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify the type of resource data sync to delete.
    public var syncType: Swift.String?

    public init(
        syncName: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncType = syncType
    }
}

public struct DeleteResourceDataSyncOutput: Swift.Sendable {

    public init() { }
}

/// The specified policy document is malformed or invalid, or excessive PutResourcePolicy or DeleteResourcePolicy calls have been made.
public struct MalformedResourcePolicyDocumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedResourcePolicyDocumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified parameter to be shared could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The hash provided in the call doesn't match the stored hash. This exception is thrown when trying to update an obsolete policy version or when multiple requests to update a policy are sent.
public struct ResourcePolicyConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more parameters specified for the call aren't valid. Verify the parameters and their values and try again.
public struct ResourcePolicyInvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var parameterNames: [Swift.String]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyInvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterNames: [Swift.String]? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterNames = parameterNames
    }
}

/// No policies with the specified policy ID and hash could be found.
public struct ResourcePolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// ID of the current policy version. The hash helps to prevent multiple calls from attempting to overwrite a policy.
    /// This member is required.
    public var policyHash: Swift.String?
    /// The policy ID.
    /// This member is required.
    public var policyId: Swift.String?
    /// Amazon Resource Name (ARN) of the resource to which the policies are attached.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyHash: Swift.String? = nil,
        policyId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policyHash = policyHash
        self.policyId = policyId
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterManagedInstanceInput: Swift.Sendable {
    /// The ID assigned to the managed node when you registered it using the activation process.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
    }
}

public struct DeregisterManagedInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterPatchBaselineForPatchGroupInput: Swift.Sendable {
    /// The ID of the patch baseline to deregister the patch group from.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group that should be deregistered from the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

public struct DeregisterPatchBaselineForPatchGroupOutput: Swift.Sendable {
    /// The ID of the patch baseline the patch group was deregistered from.
    public var baselineId: Swift.String?
    /// The name of the patch group deregistered from the patch baseline.
    public var patchGroup: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

/// You specified the Safe option for the DeregisterTargetFromMaintenanceWindow operation, but the target is still referenced in a task.
public struct TargetInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterTargetFromMaintenanceWindowInput: Swift.Sendable {
    /// The system checks if the target is being referenced by a task. If the target is being referenced, the system returns an error and doesn't deregister the target from the maintenance window.
    public var safe: Swift.Bool?
    /// The ID of the maintenance window the target should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the target definition to remove.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init(
        safe: Swift.Bool? = false,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.safe = safe
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

public struct DeregisterTargetFromMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the maintenance window the target was removed from.
    public var windowId: Swift.String?
    /// The ID of the removed target definition.
    public var windowTargetId: Swift.String?

    public init(
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

public struct DeregisterTaskFromMaintenanceWindowInput: Swift.Sendable {
    /// The ID of the maintenance window the task should be removed from.
    /// This member is required.
    public var windowId: Swift.String?
    /// The ID of the task to remove from the maintenance window.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init(
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

public struct DeregisterTaskFromMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the maintenance window the task was removed from.
    public var windowId: Swift.String?
    /// The ID of the task removed from the maintenance window.
    public var windowTaskId: Swift.String?

    public init(
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

/// The filter name isn't valid. Verify the you entered the correct name and try again.
public struct InvalidFilter: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFilter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified token isn't valid.
public struct InvalidNextToken: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextToken" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum DescribeActivationsFilterKeys: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activationIds
        case defaultInstanceName
        case iamRole
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribeActivationsFilterKeys] {
            return [
                .activationIds,
                .defaultInstanceName,
                .iamRole
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .defaultInstanceName: return "DefaultInstanceName"
            case .iamRole: return "IamRole"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Filter for the DescribeActivation API.
    public struct DescribeActivationsFilter: Swift.Sendable {
        /// The name of the filter.
        public var filterKey: SSMClientTypes.DescribeActivationsFilterKeys?
        /// The filter values.
        public var filterValues: [Swift.String]?

        public init(
            filterKey: SSMClientTypes.DescribeActivationsFilterKeys? = nil,
            filterValues: [Swift.String]? = nil
        )
        {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }
    }
}

public struct DescribeActivationsInput: Swift.Sendable {
    /// A filter to view information about your activations.
    public var filters: [SSMClientTypes.DescribeActivationsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.DescribeActivationsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeActivationsOutput: Swift.Sendable {
    /// A list of activations for your Amazon Web Services account.
    public var activationList: [SSMClientTypes.Activation]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        activationList: [SSMClientTypes.Activation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationList = activationList
        self.nextToken = nextToken
    }
}

/// The version you specified isn't valid. Use ListAssociationVersions to view all versions of an association according to the association ID. Or, use the $LATEST parameter to view the latest version of the association.
public struct InvalidAssociationVersion: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAssociationVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAssociationInput: Swift.Sendable {
    /// The association ID for which you want information.
    public var associationId: Swift.String?
    /// Specify the association version to retrieve. To view the latest version, either specify $LATEST for this parameter, or omit this parameter. To view a list of all associations for a managed node, use [ListAssociations]. To get a list of versions for a specific association, use [ListAssociationVersions].
    public var associationVersion: Swift.String?
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.associationVersion = associationVersion
        self.instanceId = instanceId
        self.name = name
    }
}

public struct DescribeAssociationOutput: Swift.Sendable {
    /// Information about the association.
    public var associationDescription: SSMClientTypes.AssociationDescription?

    public init(
        associationDescription: SSMClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

extension SSMClientTypes {

    public enum AssociationExecutionFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdtime
        case executionid
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionFilterKey] {
            return [
                .createdtime,
                .executionid,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdtime: return "CreatedTime"
            case .executionid: return "ExecutionId"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum AssociationFilterOperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greaterthan
        case lessthan
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterOperatorType] {
            return [
                .equal,
                .greaterthan,
                .lessthan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Filters used in the request.
    public struct AssociationExecutionFilter: Swift.Sendable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SSMClientTypes.AssociationExecutionFilterKey?
        /// The filter type specified in the request.
        /// This member is required.
        public var type: SSMClientTypes.AssociationFilterOperatorType?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.AssociationExecutionFilterKey? = nil,
            type: SSMClientTypes.AssociationFilterOperatorType? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.type = type
            self.value = value
        }
    }
}

public struct DescribeAssociationExecutionsInput: Swift.Sendable {
    /// The association ID for which you want to view execution history details.
    /// This member is required.
    public var associationId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. ExecutionId (EQUAL) Status (EQUAL) CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)
    public var filters: [SSMClientTypes.AssociationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        filters: [SSMClientTypes.AssociationExecutionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Includes information about the specified association.
    public struct AssociationExecution: Swift.Sendable {
        /// The details for the CloudWatch alarm you want to apply to an automation or command.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The time the execution started.
        public var createdTime: Foundation.Date?
        /// Detailed status information about the execution.
        public var detailedStatus: Swift.String?
        /// The execution ID for the association.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: Foundation.Date?
        /// An aggregate status of the resources in the execution based on the status type.
        public var resourceCountByStatus: Swift.String?
        /// The status of the association execution.
        public var status: Swift.String?
        /// The CloudWatch alarms that were invoked by the association.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: Foundation.Date? = nil,
            resourceCountByStatus: Swift.String? = nil,
            status: Swift.String? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.createdTime = createdTime
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.resourceCountByStatus = resourceCountByStatus
            self.status = status
            self.triggeredAlarms = triggeredAlarms
        }
    }
}

public struct DescribeAssociationExecutionsOutput: Swift.Sendable {
    /// A list of the executions for the specified association ID.
    public var associationExecutions: [SSMClientTypes.AssociationExecution]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationExecutions: [SSMClientTypes.AssociationExecution]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutions = associationExecutions
        self.nextToken = nextToken
    }
}

/// The specified execution ID doesn't exist. Verify the ID number and try again.
public struct AssociationExecutionDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociationExecutionDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum AssociationExecutionTargetsFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resourceid
        case resourcetype
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationExecutionTargetsFilterKey] {
            return [
                .resourceid,
                .resourcetype,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resourceid: return "ResourceId"
            case .resourcetype: return "ResourceType"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Filters for the association execution.
    public struct AssociationExecutionTargetsFilter: Swift.Sendable {
        /// The key value used in the request.
        /// This member is required.
        public var key: SSMClientTypes.AssociationExecutionTargetsFilterKey?
        /// The value specified for the key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.AssociationExecutionTargetsFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct DescribeAssociationExecutionTargetsInput: Swift.Sendable {
    /// The association ID that includes the execution for which you want to view details.
    /// This member is required.
    public var associationId: Swift.String?
    /// The execution ID for which you want to view details.
    /// This member is required.
    public var executionId: Swift.String?
    /// Filters for the request. You can specify the following filters and values. Status (EQUAL) ResourceId (EQUAL) ResourceType (EQUAL)
    public var filters: [SSMClientTypes.AssociationExecutionTargetsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        executionId: Swift.String? = nil,
        filters: [SSMClientTypes.AssociationExecutionTargetsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.executionId = executionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Information about the source where the association execution details are stored.
    public struct OutputSource: Swift.Sendable {
        /// The ID of the output source, for example the URL of an S3 bucket.
        public var outputSourceId: Swift.String?
        /// The type of source where the association execution details are stored, for example, Amazon S3.
        public var outputSourceType: Swift.String?

        public init(
            outputSourceId: Swift.String? = nil,
            outputSourceType: Swift.String? = nil
        )
        {
            self.outputSourceId = outputSourceId
            self.outputSourceType = outputSourceType
        }
    }
}

extension SSMClientTypes {

    /// Includes information about the specified association execution.
    public struct AssociationExecutionTarget: Swift.Sendable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// Detailed information about the execution status.
        public var detailedStatus: Swift.String?
        /// The execution ID.
        public var executionId: Swift.String?
        /// The date of the last execution.
        public var lastExecutionDate: Foundation.Date?
        /// The location where the association details are saved.
        public var outputSource: SSMClientTypes.OutputSource?
        /// The resource ID, for example, the managed node ID where the association ran.
        public var resourceId: Swift.String?
        /// The resource type, for example, EC2.
        public var resourceType: Swift.String?
        /// The association execution status.
        public var status: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            executionId: Swift.String? = nil,
            lastExecutionDate: Foundation.Date? = nil,
            outputSource: SSMClientTypes.OutputSource? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.executionId = executionId
            self.lastExecutionDate = lastExecutionDate
            self.outputSource = outputSource
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }
}

public struct DescribeAssociationExecutionTargetsOutput: Swift.Sendable {
    /// Information about the execution.
    public var associationExecutionTargets: [SSMClientTypes.AssociationExecutionTarget]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationExecutionTargets: [SSMClientTypes.AssociationExecutionTarget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationExecutionTargets = associationExecutionTargets
        self.nextToken = nextToken
    }
}

/// The specified key isn't valid.
public struct InvalidFilterKey: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidFilterKey" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The filter value isn't valid. Verify the value and try again.
public struct InvalidFilterValue: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFilterValue" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum AutomationExecutionFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automationSubtype
        case automationType
        case currentAction
        case documentNamePrefix
        case executionId
        case executionStatus
        case opsItemId
        case parentExecutionId
        case startTimeAfter
        case startTimeBefore
        case tagKey
        case targetResourceGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionFilterKey] {
            return [
                .automationSubtype,
                .automationType,
                .currentAction,
                .documentNamePrefix,
                .executionId,
                .executionStatus,
                .opsItemId,
                .parentExecutionId,
                .startTimeAfter,
                .startTimeBefore,
                .tagKey,
                .targetResourceGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automationSubtype: return "AutomationSubtype"
            case .automationType: return "AutomationType"
            case .currentAction: return "CurrentAction"
            case .documentNamePrefix: return "DocumentNamePrefix"
            case .executionId: return "ExecutionId"
            case .executionStatus: return "ExecutionStatus"
            case .opsItemId: return "OpsItemId"
            case .parentExecutionId: return "ParentExecutionId"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .tagKey: return "TagKey"
            case .targetResourceGroup: return "TargetResourceGroup"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// A filter used to match specific automation executions. This is used to limit the scope of Automation execution information returned.
    public struct AutomationExecutionFilter: Swift.Sendable {
        /// One or more keys to limit the results.
        /// This member is required.
        public var key: SSMClientTypes.AutomationExecutionFilterKey?
        /// The values used to limit the execution information associated with the filter's key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.AutomationExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct DescribeAutomationExecutionsInput: Swift.Sendable {
    /// Filters used to limit the scope of executions that are requested.
    public var filters: [SSMClientTypes.AutomationExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.AutomationExecutionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum AutomationExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case completedWithFailure
        case completedWithSuccess
        case exited
        case failed
        case inprogress
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case runbookInprogress
        case scheduled
        case success
        case timedout
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationExecutionStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .completedWithFailure,
                .completedWithSuccess,
                .exited,
                .failed,
                .inprogress,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .runbookInprogress,
                .scheduled,
                .success,
                .timedout,
                .waiting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .exited: return "Exited"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .runbookInprogress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .success: return "Success"
            case .timedout: return "TimedOut"
            case .waiting: return "Waiting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum AutomationSubtype: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case changerequest
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationSubtype] {
            return [
                .changerequest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .changerequest: return "ChangeRequest"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum AutomationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crossaccount
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationType] {
            return [
                .crossaccount,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crossaccount: return "CrossAccount"
            case .local: return "Local"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum ExecutionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case interactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionMode] {
            return [
                .auto,
                .interactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "Auto"
            case .interactive: return "Interactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about targets that resolved during the Automation execution.
    public struct ResolvedTargets: Swift.Sendable {
        /// A list of parameter values sent to targets that resolved during the Automation execution.
        public var parameterValues: [Swift.String]?
        /// A boolean value indicating whether the resolved target list is truncated.
        public var truncated: Swift.Bool

        public init(
            parameterValues: [Swift.String]? = nil,
            truncated: Swift.Bool = false
        )
        {
            self.parameterValues = parameterValues
            self.truncated = truncated
        }
    }
}

extension SSMClientTypes {

    /// Information about an Automation runbook used in a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public struct Runbook: Swift.Sendable {
        /// The name of the Automation runbook used in a runbook workflow.
        /// This member is required.
        public var documentName: Swift.String?
        /// The version of the Automation runbook used in a runbook workflow.
        public var documentVersion: Swift.String?
        /// The MaxConcurrency value specified by the user when the operation started, indicating the maximum number of resources that the runbook operation can run on at the same time.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started, indicating the maximum number of errors that can occur during the operation before the updates are stopped or rolled back.
        public var maxErrors: Swift.String?
        /// The key-value map of execution parameters, which were supplied when calling StartChangeRequestExecution.
        public var parameters: [Swift.String: [Swift.String]]?
        /// Information about the Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Runbook operation.
        public var targetLocations: [SSMClientTypes.TargetLocation]?
        /// A key-value mapping of runbook parameters to target resources. Both Targets and TargetMaps can't be specified together.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The name of the parameter used as the target resource for the rate-controlled runbook workflow. Required if you specify Targets.
        public var targetParameterName: Swift.String?
        /// A key-value mapping to target resources that the runbook operation performs tasks on. Required if you specify TargetParameterName.
        public var targets: [SSMClientTypes.Target]?

        public init(
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            targetLocations: [SSMClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SSMClientTypes.Target]? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.parameters = parameters
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
        }
    }
}

extension SSMClientTypes {

    /// Details about a specific Automation execution.
    public struct AutomationExecutionMetadata: Swift.Sendable {
        /// The details for the CloudWatch alarm applied to your automation.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The status of the execution.
        public var automationExecutionStatus: SSMClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SSMClientTypes.AutomationSubtype?
        /// Use this filter with [DescribeAutomationExecutions]. Specify either Local or CrossAccount. CrossAccount is an Automation that runs in multiple Amazon Web Services Regions and Amazon Web Services accounts. For more information, see [Running automations in multiple Amazon Web Services Regions and accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
        public var automationType: SSMClientTypes.AutomationType?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during execution.
        public var documentName: Swift.String?
        /// The document version used during the execution.
        public var documentVersion: Swift.String?
        /// The IAM role ARN of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished. This isn't populated if the execution is still in progress.
        public var executionEndTime: Foundation.Date?
        /// The time the execution started.
        public var executionStartTime: Foundation.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var failureMessage: Swift.String?
        /// An S3 bucket where execution information is stored.
        public var logFile: Swift.String?
        /// The MaxConcurrency value specified by the user when starting the automation.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when starting the automation.
        public var maxErrors: Swift.String?
        /// The Automation execution mode.
        public var mode: SSMClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String: [Swift.String]]?
        /// The execution ID of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// A list of targets that resolved during the execution.
        public var resolvedTargets: SSMClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run during a runbook workflow in Change Manager. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SSMClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: Foundation.Date?
        /// The list of execution outputs as defined in the Automation runbook.
        public var target: Swift.String?
        /// A publicly accessible URL for a file that contains the TargetLocations body. Currently, only files in presigned Amazon S3 buckets are supported
        public var targetLocationsURL: Swift.String?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The list of execution outputs as defined in the Automation runbook.
        public var targetParameterName: Swift.String?
        /// The targets defined by the user when starting the automation.
        public var targets: [SSMClientTypes.Target]?
        /// The CloudWatch alarm that was invoked by the automation.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SSMClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SSMClientTypes.AutomationSubtype? = nil,
            automationType: SSMClientTypes.AutomationType? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: Foundation.Date? = nil,
            executionStartTime: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            logFile: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SSMClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String: [Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            resolvedTargets: SSMClientTypes.ResolvedTargets? = nil,
            runbooks: [SSMClientTypes.Runbook]? = nil,
            scheduledTime: Foundation.Date? = nil,
            target: Swift.String? = nil,
            targetLocationsURL: Swift.String? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.automationType = automationType
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.logFile = logFile
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.target = target
            self.targetLocationsURL = targetLocationsURL
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
            self.triggeredAlarms = triggeredAlarms
        }
    }
}

public struct DescribeAutomationExecutionsOutput: Swift.Sendable {
    /// The list of details about each automation execution which has occurred which matches the filter specification, if any.
    public var automationExecutionMetadataList: [SSMClientTypes.AutomationExecutionMetadata]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        automationExecutionMetadataList: [SSMClientTypes.AutomationExecutionMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.automationExecutionMetadataList = automationExecutionMetadataList
        self.nextToken = nextToken
    }
}

/// There is no automation execution information for the requested automation execution ID.
public struct AutomationExecutionNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationExecutionNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum StepExecutionFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case action
        case parentStepExecutionId
        case parentStepIteration
        case parentStepIteratorValue
        case startTimeAfter
        case startTimeBefore
        case stepExecutionId
        case stepExecutionStatus
        case stepName
        case sdkUnknown(Swift.String)

        public static var allCases: [StepExecutionFilterKey] {
            return [
                .action,
                .parentStepExecutionId,
                .parentStepIteration,
                .parentStepIteratorValue,
                .startTimeAfter,
                .startTimeBefore,
                .stepExecutionId,
                .stepExecutionStatus,
                .stepName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .action: return "Action"
            case .parentStepExecutionId: return "ParentStepExecutionId"
            case .parentStepIteration: return "ParentStepIteration"
            case .parentStepIteratorValue: return "ParentStepIteratorValue"
            case .startTimeAfter: return "StartTimeAfter"
            case .startTimeBefore: return "StartTimeBefore"
            case .stepExecutionId: return "StepExecutionId"
            case .stepExecutionStatus: return "StepExecutionStatus"
            case .stepName: return "StepName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// A filter to limit the amount of step execution information returned by the call.
    public struct StepExecutionFilter: Swift.Sendable {
        /// One or more keys to limit the results.
        /// This member is required.
        public var key: SSMClientTypes.StepExecutionFilterKey?
        /// The values of the filter key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.StepExecutionFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct DescribeAutomationStepExecutionsInput: Swift.Sendable {
    /// The Automation execution ID for which you want step execution descriptions.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// One or more filters to limit the number of step executions returned by the request.
    public var filters: [SSMClientTypes.StepExecutionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Indicates whether to list step executions in reverse order by start time. The default value is 'false'.
    public var reverseOrder: Swift.Bool?

    public init(
        automationExecutionId: Swift.String? = nil,
        filters: [SSMClientTypes.StepExecutionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool? = false
    )
    {
        self.automationExecutionId = automationExecutionId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

extension SSMClientTypes {

    /// Information about an Automation failure.
    public struct FailureDetails: Swift.Sendable {
        /// Detailed information about the Automation step failure.
        public var details: [Swift.String: [Swift.String]]?
        /// The stage of the Automation execution when the failure occurred. The stages include the following: InputValidation, PreVerification, Invocation, PostVerification.
        public var failureStage: Swift.String?
        /// The type of Automation failure. Failure types include the following: Action, Permission, Throttling, Verification, Internal.
        public var failureType: Swift.String?

        public init(
            details: [Swift.String: [Swift.String]]? = nil,
            failureStage: Swift.String? = nil,
            failureType: Swift.String? = nil
        )
        {
            self.details = details
            self.failureStage = failureStage
            self.failureType = failureType
        }
    }
}

extension SSMClientTypes {

    /// A detailed status of the parent step.
    public struct ParentStepDetails: Swift.Sendable {
        /// The name of the automation action.
        public var action: Swift.String?
        /// The current repetition of the loop represented by an integer.
        public var iteration: Swift.Int?
        /// The current value of the specified iterator in the loop.
        public var iteratorValue: Swift.String?
        /// The unique ID of a step execution.
        public var stepExecutionId: Swift.String?
        /// The name of the step.
        public var stepName: Swift.String?

        public init(
            action: Swift.String? = nil,
            iteration: Swift.Int? = 0,
            iteratorValue: Swift.String? = nil,
            stepExecutionId: Swift.String? = nil,
            stepName: Swift.String? = nil
        )
        {
            self.action = action
            self.iteration = iteration
            self.iteratorValue = iteratorValue
            self.stepExecutionId = stepExecutionId
            self.stepName = stepName
        }
    }
}

extension SSMClientTypes {

    /// Detailed information about an the execution state of an Automation step.
    public struct StepExecution: Swift.Sendable {
        /// The action this step performs. The action determines the behavior of the step.
        public var action: Swift.String?
        /// If a step has finished execution, this contains the time the execution ended. If the step hasn't yet concluded, this field isn't populated.
        public var executionEndTime: Foundation.Date?
        /// If a step has begun execution, this contains the time the step started. If the step is in Pending status, this field isn't populated.
        public var executionStartTime: Foundation.Date?
        /// Information about the Automation failure.
        public var failureDetails: SSMClientTypes.FailureDetails?
        /// If a step failed, this message explains why the execution failed.
        public var failureMessage: Swift.String?
        /// Fully-resolved values passed into the step before execution.
        public var inputs: [Swift.String: Swift.String]?
        /// The flag which can be used to help decide whether the failure of current step leads to the Automation failure.
        public var isCritical: Swift.Bool?
        /// The flag which can be used to end automation no matter whether the step succeeds or fails.
        public var isEnd: Swift.Bool?
        /// The maximum number of tries to run the action of the step. The default value is 1.
        public var maxAttempts: Swift.Int?
        /// The next step after the step succeeds.
        public var nextStep: Swift.String?
        /// The action to take if the step fails. The default value is Abort.
        public var onFailure: Swift.String?
        /// Returned values from the execution of the step.
        public var outputs: [Swift.String: [Swift.String]]?
        /// A user-specified list of parameters to override when running a step.
        public var overriddenParameters: [Swift.String: [Swift.String]]?
        /// Information about the parent step.
        public var parentStepDetails: SSMClientTypes.ParentStepDetails?
        /// A message associated with the response code for an execution.
        public var response: Swift.String?
        /// The response code returned by the execution of the step.
        public var responseCode: Swift.String?
        /// The unique ID of a step execution.
        public var stepExecutionId: Swift.String?
        /// The name of this execution step.
        public var stepName: Swift.String?
        /// The execution status for this step.
        public var stepStatus: SSMClientTypes.AutomationExecutionStatus?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts targeted by the current Automation execution.
        public var targetLocation: SSMClientTypes.TargetLocation?
        /// The targets for the step execution.
        public var targets: [SSMClientTypes.Target]?
        /// The timeout seconds of the step.
        public var timeoutSeconds: Swift.Int?
        /// The CloudWatch alarms that were invoked by the automation.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?
        /// Strategies used when step fails, we support Continue and Abort. Abort will fail the automation when the step fails. Continue will ignore the failure of current step and allow automation to run the next step. With conditional branching, we add step:stepName to support the automation to go to another specific step.
        public var validNextSteps: [Swift.String]?

        public init(
            action: Swift.String? = nil,
            executionEndTime: Foundation.Date? = nil,
            executionStartTime: Foundation.Date? = nil,
            failureDetails: SSMClientTypes.FailureDetails? = nil,
            failureMessage: Swift.String? = nil,
            inputs: [Swift.String: Swift.String]? = nil,
            isCritical: Swift.Bool? = false,
            isEnd: Swift.Bool? = false,
            maxAttempts: Swift.Int? = 0,
            nextStep: Swift.String? = nil,
            onFailure: Swift.String? = nil,
            outputs: [Swift.String: [Swift.String]]? = nil,
            overriddenParameters: [Swift.String: [Swift.String]]? = nil,
            parentStepDetails: SSMClientTypes.ParentStepDetails? = nil,
            response: Swift.String? = nil,
            responseCode: Swift.String? = nil,
            stepExecutionId: Swift.String? = nil,
            stepName: Swift.String? = nil,
            stepStatus: SSMClientTypes.AutomationExecutionStatus? = nil,
            targetLocation: SSMClientTypes.TargetLocation? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int? = 0,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil,
            validNextSteps: [Swift.String]? = nil
        )
        {
            self.action = action
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureDetails = failureDetails
            self.failureMessage = failureMessage
            self.inputs = inputs
            self.isCritical = isCritical
            self.isEnd = isEnd
            self.maxAttempts = maxAttempts
            self.nextStep = nextStep
            self.onFailure = onFailure
            self.outputs = outputs
            self.overriddenParameters = overriddenParameters
            self.parentStepDetails = parentStepDetails
            self.response = response
            self.responseCode = responseCode
            self.stepExecutionId = stepExecutionId
            self.stepName = stepName
            self.stepStatus = stepStatus
            self.targetLocation = targetLocation
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
            self.triggeredAlarms = triggeredAlarms
            self.validNextSteps = validNextSteps
        }
    }
}

public struct DescribeAutomationStepExecutionsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of details about the current state of all steps that make up an execution.
    public var stepExecutions: [SSMClientTypes.StepExecution]?

    public init(
        nextToken: Swift.String? = nil,
        stepExecutions: [SSMClientTypes.StepExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.stepExecutions = stepExecutions
    }
}

extension SSMClientTypes {

    /// Defines a filter used in Patch Manager APIs. Supported filter keys depend on the API operation that includes the filter. Patch Manager API operations that use PatchOrchestratorFilter include the following:
    ///
    /// * [DescribeAvailablePatches]
    ///
    /// * [DescribeInstancePatches]
    ///
    /// * [DescribePatchBaselines]
    ///
    /// * [DescribePatchGroups]
    public struct PatchOrchestratorFilter: Swift.Sendable {
        /// The key for the filter.
        public var key: Swift.String?
        /// The value for the filter.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct DescribeAvailablePatchesInput: Swift.Sendable {
    /// Each element in the array is a structure containing a key-value pair. Windows Server Supported keys for Windows Server managed node patches include the following:
    ///
    /// * PATCH_SET Sample values: OS | APPLICATION
    ///
    /// * PRODUCT Sample values: WindowsServer2012 | Office 2010 | MicrosoftDefenderAntivirus
    ///
    /// * PRODUCT_FAMILY Sample values: Windows | Office
    ///
    /// * MSRC_SEVERITY Sample values: ServicePacks | Important | Moderate
    ///
    /// * CLASSIFICATION Sample values: ServicePacks | SecurityUpdates | DefinitionUpdates
    ///
    /// * PATCH_ID Sample values: KB123456 | KB4516046
    ///
    ///
    /// Linux When specifying filters for Linux patches, you must specify a key-pair for PRODUCT. For example, using the Command Line Interface (CLI), the following command fails: aws ssm describe-available-patches --filters Key=CVE_ID,Values=CVE-2018-3615 However, the following command succeeds: aws ssm describe-available-patches --filters Key=PRODUCT,Values=AmazonLinux2018.03 Key=CVE_ID,Values=CVE-2018-3615 Supported keys for Linux managed node patches include the following:
    ///
    /// * PRODUCT Sample values: AmazonLinux2018.03 | AmazonLinux2.0
    ///
    /// * NAME Sample values: kernel-headers | samba-python | php
    ///
    /// * SEVERITY Sample values: Critical | Important | Medium | Low
    ///
    /// * EPOCH Sample values: 0 | 1
    ///
    /// * VERSION Sample values: 78.6.1 | 4.10.16
    ///
    /// * RELEASE Sample values: 9.56.amzn1 | 1.amzn2
    ///
    /// * ARCH Sample values: i686 | x86_64
    ///
    /// * REPOSITORY Sample values: Core | Updates
    ///
    /// * ADVISORY_ID Sample values: ALAS-2018-1058 | ALAS2-2021-1594
    ///
    /// * CVE_ID Sample values: CVE-2018-3615 | CVE-2020-1472
    ///
    /// * BUGZILLA_ID Sample values: 1463241
    public var filters: [SSMClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Represents metadata about a patch.
    public struct Patch: Swift.Sendable {
        /// The Advisory ID of the patch. For example, RHSA-2020:3779. Applies to Linux-based managed nodes only.
        public var advisoryIds: [Swift.String]?
        /// The architecture of the patch. For example, in example-pkg-0.710.10-2.7.abcd.x86_64, the architecture is indicated by x86_64. Applies to Linux-based managed nodes only.
        public var arch: Swift.String?
        /// The Bugzilla ID of the patch. For example, 1600646. Applies to Linux-based managed nodes only.
        public var bugzillaIds: [Swift.String]?
        /// The classification of the patch. For example, SecurityUpdates, Updates, or CriticalUpdates.
        public var classification: Swift.String?
        /// The URL where more information can be obtained about the patch.
        public var contentUrl: Swift.String?
        /// The Common Vulnerabilities and Exposures (CVE) ID of the patch. For example, CVE-2011-3192. Applies to Linux-based managed nodes only.
        public var cveIds: [Swift.String]?
        /// The description of the patch.
        public var description: Swift.String?
        /// The epoch of the patch. For example in pkg-example-EE-20180914-2.2.amzn1.noarch, the epoch value is 20180914-2. Applies to Linux-based managed nodes only.
        public var epoch: Swift.Int
        /// The ID of the patch. Applies to Windows patches only. This ID isn't the same as the Microsoft Knowledge Base ID.
        public var id: Swift.String?
        /// The Microsoft Knowledge Base ID of the patch. Applies to Windows patches only.
        public var kbNumber: Swift.String?
        /// The language of the patch if it's language-specific.
        public var language: Swift.String?
        /// The ID of the Microsoft Security Response Center (MSRC) bulletin the patch is related to. For example, MS14-045. Applies to Windows patches only.
        public var msrcNumber: Swift.String?
        /// The severity of the patch, such as Critical, Important, or Moderate. Applies to Windows patches only.
        public var msrcSeverity: Swift.String?
        /// The name of the patch. Applies to Linux-based managed nodes only.
        public var name: Swift.String?
        /// The specific product the patch is applicable for. For example, WindowsServer2016 or AmazonLinux2018.03.
        public var product: Swift.String?
        /// The product family the patch is applicable for. For example, Windows or Amazon Linux 2.
        public var productFamily: Swift.String?
        /// The particular release of a patch. For example, in pkg-example-EE-20180914-2.2.amzn1.noarch, the release is 2.amaz1. Applies to Linux-based managed nodes only.
        public var release: Swift.String?
        /// The date the patch was released.
        public var releaseDate: Foundation.Date?
        /// The source patch repository for the operating system and version, such as trusty-security for Ubuntu Server 14.04 LTE and focal-security for Ubuntu Server 20.04 LTE. Applies to Linux-based managed nodes only.
        public var repository: Swift.String?
        /// The severity level of the patch. For example, CRITICAL or MODERATE.
        public var severity: Swift.String?
        /// The title of the patch.
        public var title: Swift.String?
        /// The name of the vendor providing the patch.
        public var vendor: Swift.String?
        /// The version number of the patch. For example, in example-pkg-1.710.10-2.7.abcd.x86_64, the version number is indicated by -1. Applies to Linux-based managed nodes only.
        public var version: Swift.String?

        public init(
            advisoryIds: [Swift.String]? = nil,
            arch: Swift.String? = nil,
            bugzillaIds: [Swift.String]? = nil,
            classification: Swift.String? = nil,
            contentUrl: Swift.String? = nil,
            cveIds: [Swift.String]? = nil,
            description: Swift.String? = nil,
            epoch: Swift.Int = 0,
            id: Swift.String? = nil,
            kbNumber: Swift.String? = nil,
            language: Swift.String? = nil,
            msrcNumber: Swift.String? = nil,
            msrcSeverity: Swift.String? = nil,
            name: Swift.String? = nil,
            product: Swift.String? = nil,
            productFamily: Swift.String? = nil,
            release: Swift.String? = nil,
            releaseDate: Foundation.Date? = nil,
            repository: Swift.String? = nil,
            severity: Swift.String? = nil,
            title: Swift.String? = nil,
            vendor: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.advisoryIds = advisoryIds
            self.arch = arch
            self.bugzillaIds = bugzillaIds
            self.classification = classification
            self.contentUrl = contentUrl
            self.cveIds = cveIds
            self.description = description
            self.epoch = epoch
            self.id = id
            self.kbNumber = kbNumber
            self.language = language
            self.msrcNumber = msrcNumber
            self.msrcSeverity = msrcSeverity
            self.name = name
            self.product = product
            self.productFamily = productFamily
            self.release = release
            self.releaseDate = releaseDate
            self.repository = repository
            self.severity = severity
            self.title = title
            self.vendor = vendor
            self.version = version
        }
    }
}

public struct DescribeAvailablePatchesOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// An array of patches. Each entry in the array is a patch structure.
    public var patches: [SSMClientTypes.Patch]?

    public init(
        nextToken: Swift.String? = nil,
        patches: [SSMClientTypes.Patch]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

public struct DescribeDocumentInput: Swift.Sendable {
    /// The document version for which you want information. Can be a specific version or the default version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init(
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

public struct DescribeDocumentOutput: Swift.Sendable {
    /// Information about the SSM document.
    public var document: SSMClientTypes.DocumentDescription?

    public init(
        document: SSMClientTypes.DocumentDescription? = nil
    )
    {
        self.document = document
    }
}

/// The permission type isn't supported. Share is the only supported permission type.
public struct InvalidPermissionType: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPermissionType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum DocumentPermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case share
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentPermissionType] {
            return [
                .share
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .share: return "Share"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeDocumentPermissionInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The name of the document for which you are the owner.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SSMClientTypes.DocumentPermissionType?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionType: SSMClientTypes.DocumentPermissionType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionType = permissionType
    }
}

public struct DescribeDocumentPermissionOutput: Swift.Sendable {
    /// The account IDs that have permission to use this document. The ID can be either an Amazon Web Services account or All.
    public var accountIds: [Swift.String]?
    /// A list of Amazon Web Services accounts where the current document is shared and the version shared with each account.
    public var accountSharingInfoList: [SSMClientTypes.AccountSharingInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        accountSharingInfoList: [SSMClientTypes.AccountSharingInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.accountSharingInfoList = accountSharingInfoList
        self.nextToken = nextToken
    }
}

public struct DescribeEffectiveInstanceAssociationsInput: Swift.Sendable {
    /// The managed node ID for which you want to view all associations.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// One or more association documents on the managed node.
    public struct InstanceAssociation: Swift.Sendable {
        /// The association ID.
        public var associationId: Swift.String?
        /// Version information for the association on the managed node.
        public var associationVersion: Swift.String?
        /// The content of the association document for the managed nodes.
        public var content: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            content: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationVersion = associationVersion
            self.content = content
            self.instanceId = instanceId
        }
    }
}

public struct DescribeEffectiveInstanceAssociationsOutput: Swift.Sendable {
    /// The associations for the requested managed node.
    public var associations: [SSMClientTypes.InstanceAssociation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        associations: [SSMClientTypes.InstanceAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

/// The operating systems you specified isn't supported, or the operation isn't supported for the operating system.
public struct UnsupportedOperatingSystem: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperatingSystem" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeEffectivePatchesForPatchBaselineInput: Swift.Sendable {
    /// The ID of the patch baseline to retrieve the effective patches for.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum PatchDeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case explicitapproved
        case explicitrejected
        case pendingapproval
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchDeploymentStatus] {
            return [
                .approved,
                .explicitapproved,
                .explicitrejected,
                .pendingapproval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .explicitapproved: return "EXPLICIT_APPROVED"
            case .explicitrejected: return "EXPLICIT_REJECTED"
            case .pendingapproval: return "PENDING_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the approval status of a patch.
    public struct PatchStatus: Swift.Sendable {
        /// The date the patch was approved (or will be approved if the status is PENDING_APPROVAL).
        public var approvalDate: Foundation.Date?
        /// The compliance severity level for a patch.
        public var complianceLevel: SSMClientTypes.PatchComplianceLevel?
        /// The approval status of a patch.
        public var deploymentStatus: SSMClientTypes.PatchDeploymentStatus?

        public init(
            approvalDate: Foundation.Date? = nil,
            complianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
            deploymentStatus: SSMClientTypes.PatchDeploymentStatus? = nil
        )
        {
            self.approvalDate = approvalDate
            self.complianceLevel = complianceLevel
            self.deploymentStatus = deploymentStatus
        }
    }
}

extension SSMClientTypes {

    /// The EffectivePatch structure defines metadata about a patch along with the approval state of the patch in a particular patch baseline. The approval state includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
    public struct EffectivePatch: Swift.Sendable {
        /// Provides metadata for a patch, including information such as the KB ID, severity, classification and a URL for where more information can be obtained about the patch.
        public var patch: SSMClientTypes.Patch?
        /// The status of the patch in a patch baseline. This includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.
        public var patchStatus: SSMClientTypes.PatchStatus?

        public init(
            patch: SSMClientTypes.Patch? = nil,
            patchStatus: SSMClientTypes.PatchStatus? = nil
        )
        {
            self.patch = patch
            self.patchStatus = patchStatus
        }
    }
}

public struct DescribeEffectivePatchesForPatchBaselineOutput: Swift.Sendable {
    /// An array of patches and patch status.
    public var effectivePatches: [SSMClientTypes.EffectivePatch]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        effectivePatches: [SSMClientTypes.EffectivePatch]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectivePatches = effectivePatches
        self.nextToken = nextToken
    }
}

public struct DescribeInstanceAssociationsStatusInput: Swift.Sendable {
    /// The managed node IDs for which you want association status information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// A URL for the Amazon Web Services Systems Manager (Systems Manager) bucket where you want to store the results of this request.
    public struct S3OutputUrl: Swift.Sendable {
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: Swift.String?

        public init(
            outputUrl: Swift.String? = nil
        )
        {
            self.outputUrl = outputUrl
        }
    }
}

extension SSMClientTypes {

    /// The URL of S3 bucket where you want to store the results of this request.
    public struct InstanceAssociationOutputUrl: Swift.Sendable {
        /// The URL of S3 bucket where you want to store the results of this request.
        public var s3OutputUrl: SSMClientTypes.S3OutputUrl?

        public init(
            s3OutputUrl: SSMClientTypes.S3OutputUrl? = nil
        )
        {
            self.s3OutputUrl = s3OutputUrl
        }
    }
}

extension SSMClientTypes {

    /// Status information about the association.
    public struct InstanceAssociationStatusInfo: Swift.Sendable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The name of the association applied to the managed node.
        public var associationName: Swift.String?
        /// The version of the association applied to the managed node.
        public var associationVersion: Swift.String?
        /// Detailed status information about the association.
        public var detailedStatus: Swift.String?
        /// The association document versions.
        public var documentVersion: Swift.String?
        /// An error code returned by the request to create the association.
        public var errorCode: Swift.String?
        /// The date the association ran.
        public var executionDate: Foundation.Date?
        /// Summary information about association execution.
        public var executionSummary: Swift.String?
        /// The managed node ID where the association was created.
        public var instanceId: Swift.String?
        /// The name of the association.
        public var name: Swift.String?
        /// A URL for an S3 bucket where you want to store the results of this request.
        public var outputUrl: SSMClientTypes.InstanceAssociationOutputUrl?
        /// Status information about the association.
        public var status: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            detailedStatus: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            executionDate: Foundation.Date? = nil,
            executionSummary: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            name: Swift.String? = nil,
            outputUrl: SSMClientTypes.InstanceAssociationOutputUrl? = nil,
            status: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.detailedStatus = detailedStatus
            self.documentVersion = documentVersion
            self.errorCode = errorCode
            self.executionDate = executionDate
            self.executionSummary = executionSummary
            self.instanceId = instanceId
            self.name = name
            self.outputUrl = outputUrl
            self.status = status
        }
    }
}

public struct DescribeInstanceAssociationsStatusOutput: Swift.Sendable {
    /// Status information about the association.
    public var instanceAssociationStatusInfos: [SSMClientTypes.InstanceAssociationStatusInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        instanceAssociationStatusInfos: [SSMClientTypes.InstanceAssociationStatusInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceAssociationStatusInfos = instanceAssociationStatusInfos
        self.nextToken = nextToken
    }
}

/// The specified filter value isn't valid.
public struct InvalidInstanceInformationFilterValue: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInstanceInformationFilterValue" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// The filters to describe or get information about your managed nodes.
    public struct InstanceInformationStringFilter: Swift.Sendable {
        /// The filter key name to describe your managed nodes. Valid filter key values: ActivationIds | AgentVersion | AssociationStatus | IamRole | InstanceIds | PingStatus | PlatformTypes | ResourceType | SourceIds | SourceTypes | "tag-key" | "tag:{keyname}
        ///
        /// * Valid values for the AssociationStatus filter key: Success | Pending | Failed
        ///
        /// * Valid values for the PingStatus filter key: Online | ConnectionLost | Inactive (deprecated)
        ///
        /// * Valid values for the PlatformType filter key: Windows | Linux | MacOS
        ///
        /// * Valid values for the ResourceType filter key: EC2Instance | ManagedInstance
        ///
        /// * Valid values for the SourceType filter key: AWS::EC2::Instance | AWS::SSM::ManagedInstance | AWS::IoT::Thing
        ///
        /// * Valid tag examples: Key=tag-key,Values=Purpose | Key=tag:Purpose,Values=Test.
        /// This member is required.
        public var key: Swift.String?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

extension SSMClientTypes {

    public enum InstanceInformationFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activationIds
        case agentVersion
        case associationStatus
        case iamRole
        case instanceIds
        case pingStatus
        case platformTypes
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceInformationFilterKey] {
            return [
                .activationIds,
                .agentVersion,
                .associationStatus,
                .iamRole,
                .instanceIds,
                .pingStatus,
                .platformTypes,
                .resourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .agentVersion: return "AgentVersion"
            case .associationStatus: return "AssociationStatus"
            case .iamRole: return "IamRole"
            case .instanceIds: return "InstanceIds"
            case .pingStatus: return "PingStatus"
            case .platformTypes: return "PlatformTypes"
            case .resourceType: return "ResourceType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for a specific list of managed nodes. You can filter node information by using tags. You specify tags by using a key-value mapping. Use this operation instead of the [DescribeInstanceInformationRequest$InstanceInformationFilterList] method. The InstanceInformationFilterList method is a legacy method and doesn't support tags.
    public struct InstanceInformationFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.InstanceInformationFilterKey?
        /// The filter values.
        /// This member is required.
        public var valueSet: [Swift.String]?

        public init(
            key: SSMClientTypes.InstanceInformationFilterKey? = nil,
            valueSet: [Swift.String]? = nil
        )
        {
            self.key = key
            self.valueSet = valueSet
        }
    }
}

public struct DescribeInstanceInformationInput: Swift.Sendable {
    /// One or more filters. Use a filter to return a more specific list of managed nodes. You can filter based on tags applied to your managed nodes. Tag filters can't be combined with other filter types. Use this Filters data type instead of InstanceInformationFilterList, which is deprecated.
    public var filters: [SSMClientTypes.InstanceInformationStringFilter]?
    /// This is a legacy method. We recommend that you don't use this method. Instead, use the Filters data type. Filters enables you to return node information by filtering based on tags applied to managed nodes. Attempting to use InstanceInformationFilterList and Filters leads to an exception error.
    public var instanceInformationFilterList: [SSMClientTypes.InstanceInformationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results. The default value is 10 items.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.InstanceInformationStringFilter]? = nil,
        instanceInformationFilterList: [SSMClientTypes.InstanceInformationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceInformationFilterList = instanceInformationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Status information about the aggregated associations.
    public struct InstanceAggregatedAssociationOverview: Swift.Sendable {
        /// Detailed status information about the aggregated associations.
        public var detailedStatus: Swift.String?
        /// The number of associations for the managed nodes.
        public var instanceAssociationStatusAggregatedCount: [Swift.String: Swift.Int]?

        public init(
            detailedStatus: Swift.String? = nil,
            instanceAssociationStatusAggregatedCount: [Swift.String: Swift.Int]? = nil
        )
        {
            self.detailedStatus = detailedStatus
            self.instanceAssociationStatusAggregatedCount = instanceAssociationStatusAggregatedCount
        }
    }
}

extension SSMClientTypes {

    public enum PingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectionLost
        case inactive
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [PingStatus] {
            return [
                .connectionLost,
                .inactive,
                .online
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectionLost: return "ConnectionLost"
            case .inactive: return "Inactive"
            case .online: return "Online"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ec2Instance
        case managedInstance
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .ec2Instance,
                .managedInstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ec2Instance: return "EC2Instance"
            case .managedInstance: return "ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEc2Instance
        case awsIotThing
        case awsSsmManagedinstance
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .awsEc2Instance,
                .awsIotThing,
                .awsSsmManagedinstance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS::EC2::Instance"
            case .awsIotThing: return "AWS::IoT::Thing"
            case .awsSsmManagedinstance: return "AWS::SSM::ManagedInstance"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for a specific list of managed nodes.
    public struct InstanceInformation: Swift.Sendable {
        /// The activation ID created by Amazon Web Services Systems Manager when the server or virtual machine (VM) was registered.
        public var activationId: Swift.String?
        /// The version of SSM Agent running on your Linux managed node.
        public var agentVersion: Swift.String?
        /// Information about the association.
        public var associationOverview: SSMClientTypes.InstanceAggregatedAssociationOverview?
        /// The status of the association.
        public var associationStatus: Swift.String?
        /// The fully qualified host name of the managed node.
        public var computerName: Swift.String?
        /// The role assigned to an Amazon EC2 instance configured with a Systems Manager Quick Setup host management configuration or the role assigned to an on-premises managed node. This call doesn't return the IAM role for unmanaged Amazon EC2 instances (instances not configured for Systems Manager). To retrieve the role for an unmanaged instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var iamRole: Swift.String?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The IP address of the managed node.
        public var ipAddress: Swift.String?
        /// Indicates whether the latest version of SSM Agent is running on your Linux managed node. This field doesn't indicate whether or not the latest version is installed on Windows managed nodes, because some older versions of Windows Server use the EC2Config service to process Systems Manager requests.
        public var isLatestVersion: Swift.Bool?
        /// The date the association was last run.
        public var lastAssociationExecutionDate: Foundation.Date?
        /// The date and time when the agent last pinged the Systems Manager service.
        public var lastPingDateTime: Foundation.Date?
        /// The last date the association was successfully run.
        public var lastSuccessfulAssociationExecutionDate: Foundation.Date?
        /// The name assigned to an on-premises server, edge device, or virtual machine (VM) when it is activated as a Systems Manager managed node. The name is specified as the DefaultInstanceName property using the [CreateActivation] command. It is applied to the managed node by specifying the Activation Code and Activation ID when you install SSM Agent on the node, as explained in [How to install SSM Agent on hybrid Linux nodes](https://docs.aws.amazon.com/systems-manager/latest/userguide/hybrid-multicloud-ssm-agent-install-linux.html) and [How to install SSM Agent on hybrid Windows Server nodes](https://docs.aws.amazon.com/systems-manager/latest/userguide/hybrid-multicloud-ssm-agent-install-windows.html). To retrieve the Name tag of an EC2 instance, use the Amazon EC2 DescribeInstances operation. For information, see [DescribeInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html) in the Amazon EC2 API Reference or [describe-instances](https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html) in the Amazon Web Services CLI Command Reference.
        public var name: Swift.String?
        /// Connection status of SSM Agent. The status Inactive has been deprecated and is no longer in use.
        public var pingStatus: SSMClientTypes.PingStatus?
        /// The name of the operating system platform running on your managed node.
        public var platformName: Swift.String?
        /// The operating system platform type.
        public var platformType: SSMClientTypes.PlatformType?
        /// The version of the OS platform running on your managed node.
        public var platformVersion: Swift.String?
        /// The date the server or VM was registered with Amazon Web Services as a managed node.
        public var registrationDate: Foundation.Date?
        /// The type of instance. Instances are either EC2 instances or managed instances.
        public var resourceType: SSMClientTypes.ResourceType?
        /// The ID of the source resource. For IoT Greengrass devices, SourceId is the Thing name.
        public var sourceId: Swift.String?
        /// The type of the source resource. For IoT Greengrass devices, SourceType is AWS::IoT::Thing.
        public var sourceType: SSMClientTypes.SourceType?

        public init(
            activationId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            associationOverview: SSMClientTypes.InstanceAggregatedAssociationOverview? = nil,
            associationStatus: Swift.String? = nil,
            computerName: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            isLatestVersion: Swift.Bool? = false,
            lastAssociationExecutionDate: Foundation.Date? = nil,
            lastPingDateTime: Foundation.Date? = nil,
            lastSuccessfulAssociationExecutionDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            pingStatus: SSMClientTypes.PingStatus? = nil,
            platformName: Swift.String? = nil,
            platformType: SSMClientTypes.PlatformType? = nil,
            platformVersion: Swift.String? = nil,
            registrationDate: Foundation.Date? = nil,
            resourceType: SSMClientTypes.ResourceType? = nil,
            sourceId: Swift.String? = nil,
            sourceType: SSMClientTypes.SourceType? = nil
        )
        {
            self.activationId = activationId
            self.agentVersion = agentVersion
            self.associationOverview = associationOverview
            self.associationStatus = associationStatus
            self.computerName = computerName
            self.iamRole = iamRole
            self.instanceId = instanceId
            self.ipAddress = ipAddress
            self.isLatestVersion = isLatestVersion
            self.lastAssociationExecutionDate = lastAssociationExecutionDate
            self.lastPingDateTime = lastPingDateTime
            self.lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate
            self.name = name
            self.pingStatus = pingStatus
            self.platformName = platformName
            self.platformType = platformType
            self.platformVersion = platformVersion
            self.registrationDate = registrationDate
            self.resourceType = resourceType
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }
}

extension SSMClientTypes.InstanceInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceInformation(activationId: \(Swift.String(describing: activationId)), agentVersion: \(Swift.String(describing: agentVersion)), associationOverview: \(Swift.String(describing: associationOverview)), associationStatus: \(Swift.String(describing: associationStatus)), computerName: \(Swift.String(describing: computerName)), iamRole: \(Swift.String(describing: iamRole)), instanceId: \(Swift.String(describing: instanceId)), isLatestVersion: \(Swift.String(describing: isLatestVersion)), lastAssociationExecutionDate: \(Swift.String(describing: lastAssociationExecutionDate)), lastPingDateTime: \(Swift.String(describing: lastPingDateTime)), lastSuccessfulAssociationExecutionDate: \(Swift.String(describing: lastSuccessfulAssociationExecutionDate)), name: \(Swift.String(describing: name)), pingStatus: \(Swift.String(describing: pingStatus)), platformName: \(Swift.String(describing: platformName)), platformType: \(Swift.String(describing: platformType)), platformVersion: \(Swift.String(describing: platformVersion)), registrationDate: \(Swift.String(describing: registrationDate)), resourceType: \(Swift.String(describing: resourceType)), sourceId: \(Swift.String(describing: sourceId)), sourceType: \(Swift.String(describing: sourceType)), ipAddress: \"CONTENT_REDACTED\")"}
}

public struct DescribeInstanceInformationOutput: Swift.Sendable {
    /// The managed node information list.
    public var instanceInformationList: [SSMClientTypes.InstanceInformation]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        instanceInformationList: [SSMClientTypes.InstanceInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceInformationList = instanceInformationList
        self.nextToken = nextToken
    }
}

public struct DescribeInstancePatchesInput: Swift.Sendable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribeInstancePatchesinclude the following:
    ///
    /// * Classification Sample values: Security | SecurityUpdates
    ///
    /// * KBId Sample values: KB4480056 | java-1.7.0-openjdk.x86_64
    ///
    /// * Severity Sample values: Important | Medium | Low
    ///
    /// * State Sample values: Installed | InstalledOther | InstalledPendingReboot For lists of all State values, see [Patch compliance state values](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-compliance-states.html) in the Amazon Web Services Systems Manager User Guide.
    public var filters: [SSMClientTypes.PatchOrchestratorFilter]?
    /// The ID of the managed node whose patch state information should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.PatchOrchestratorFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum PatchComplianceDataState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case installed
        case installedother
        case installedpendingreboot
        case installedrejected
        case missing
        case notapplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchComplianceDataState] {
            return [
                .failed,
                .installed,
                .installedother,
                .installedpendingreboot,
                .installedrejected,
                .missing,
                .notapplicable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .installed: return "INSTALLED"
            case .installedother: return "INSTALLED_OTHER"
            case .installedpendingreboot: return "INSTALLED_PENDING_REBOOT"
            case .installedrejected: return "INSTALLED_REJECTED"
            case .missing: return "MISSING"
            case .notapplicable: return "NOT_APPLICABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the state of a patch on a particular managed node as it relates to the patch baseline used to patch the node.
    public struct PatchComplianceData: Swift.Sendable {
        /// The classification of the patch, such as SecurityUpdates, Updates, and CriticalUpdates.
        /// This member is required.
        public var classification: Swift.String?
        /// The IDs of one or more Common Vulnerabilities and Exposure (CVE) issues that are resolved by the patch. Currently, CVE ID values are reported only for patches with a status of Missing or Failed.
        public var cveIds: Swift.String?
        /// The date/time the patch was installed on the managed node. Not all operating systems provide this level of information.
        /// This member is required.
        public var installedTime: Foundation.Date?
        /// The operating system-specific ID of the patch.
        /// This member is required.
        public var kbId: Swift.String?
        /// The severity of the patch such as Critical, Important, and Moderate.
        /// This member is required.
        public var severity: Swift.String?
        /// The state of the patch on the managed node, such as INSTALLED or FAILED. For descriptions of each patch state, see [About patch compliance](https://docs.aws.amazon.com/systems-manager/latest/userguide/compliance-about.html#compliance-monitor-patch) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var state: SSMClientTypes.PatchComplianceDataState?
        /// The title of the patch.
        /// This member is required.
        public var title: Swift.String?

        public init(
            classification: Swift.String? = nil,
            cveIds: Swift.String? = nil,
            installedTime: Foundation.Date? = nil,
            kbId: Swift.String? = nil,
            severity: Swift.String? = nil,
            state: SSMClientTypes.PatchComplianceDataState? = nil,
            title: Swift.String? = nil
        )
        {
            self.classification = classification
            self.cveIds = cveIds
            self.installedTime = installedTime
            self.kbId = kbId
            self.severity = severity
            self.state = state
            self.title = title
        }
    }
}

public struct DescribeInstancePatchesOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Each entry in the array is a structure containing:
    ///
    /// * Title (string)
    ///
    /// * KBId (string)
    ///
    /// * Classification (string)
    ///
    /// * Severity (string)
    ///
    /// * State (string, such as "INSTALLED" or "FAILED")
    ///
    /// * InstalledTime (DateTime)
    ///
    /// * InstalledBy (string)
    public var patches: [SSMClientTypes.PatchComplianceData]?

    public init(
        nextToken: Swift.String? = nil,
        patches: [SSMClientTypes.PatchComplianceData]? = nil
    )
    {
        self.nextToken = nextToken
        self.patches = patches
    }
}

public struct DescribeInstancePatchStatesInput: Swift.Sendable {
    /// The ID of the managed node for which patch state information should be retrieved.
    /// This member is required.
    public var instanceIds: [Swift.String]?
    /// The maximum number of managed nodes to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        instanceIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum PatchOperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case install
        case scan
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchOperationType] {
            return [
                .install,
                .scan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .install: return "Install"
            case .scan: return "Scan"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum RebootOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noReboot
        case rebootIfNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RebootOption] {
            return [
                .noReboot,
                .rebootIfNeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noReboot: return "NoReboot"
            case .rebootIfNeeded: return "RebootIfNeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Defines the high-level patch compliance state for a managed node, providing information about the number of installed, missing, not applicable, and failed patches along with metadata about the operation when this information was gathered for the managed node.
    public struct InstancePatchState: Swift.Sendable {
        /// The ID of the patch baseline used to patch the managed node.
        /// This member is required.
        public var baselineId: Swift.String?
        /// The number of patches per node that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var criticalNonCompliantCount: Swift.Int?
        /// The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.
        public var failedCount: Swift.Int
        /// An https URL or an Amazon Simple Storage Service (Amazon S3) path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an S3 bucket in YAML format and specify in the SSM document AWS-RunPatchBaseline, overrides the patches specified by the default patch baseline. For more information about the InstallOverrideList parameter, see [SSM Command document for patching: ]AWS-RunPatchBaseline(https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html) in the Amazon Web Services Systems Manager User Guide.
        public var installOverrideList: Swift.String?
        /// The number of patches from the patch baseline that are installed on the managed node.
        public var installedCount: Swift.Int
        /// The number of patches not specified in the patch baseline that are installed on the managed node.
        public var installedOtherCount: Swift.Int
        /// The number of patches installed by Patch Manager since the last time the managed node was rebooted.
        public var installedPendingRebootCount: Swift.Int?
        /// The number of patches installed on a managed node that are specified in a RejectedPatches list. Patches with a status of InstalledRejected were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstalledRejectedCount will always be 0 (zero).
        public var installedRejectedCount: Swift.Int?
        /// The ID of the managed node the high-level patch compliance information was collected for.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The time of the last attempt to patch the managed node with NoReboot specified as the reboot option.
        public var lastNoRebootInstallOperationTime: Foundation.Date?
        /// The number of patches from the patch baseline that are applicable for the managed node but aren't currently installed.
        public var missingCount: Swift.Int
        /// The number of patches from the patch baseline that aren't applicable for the managed node and therefore aren't installed on the node. This number may be truncated if the list of patch names is very large. The number of patches beyond this limit are reported in UnreportedNotApplicableCount.
        public var notApplicableCount: Swift.Int
        /// The type of patching operation that was performed: or
        ///
        /// * SCAN assesses the patch compliance state.
        ///
        /// * INSTALL installs missing patches.
        /// This member is required.
        public var operation: SSMClientTypes.PatchOperationType?
        /// The time the most recent patching operation completed on the managed node.
        /// This member is required.
        public var operationEndTime: Foundation.Date?
        /// The time the most recent patching operation was started on the managed node.
        /// This member is required.
        public var operationStartTime: Foundation.Date?
        /// The number of patches per node that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
        public var otherNonCompliantCount: Swift.Int?
        /// Placeholder information. This field will always be empty in the current release of the service.
        public var ownerInformation: Swift.String?
        /// The name of the patch group the managed node belongs to.
        /// This member is required.
        public var patchGroup: Swift.String?
        /// Indicates the reboot option specified in the patch baseline. Reboot options apply to Install operations only. Reboots aren't attempted for Patch Manager Scan operations.
        ///
        /// * RebootIfNeeded: Patch Manager tries to reboot the managed node if it installed any patches, or if any patches are detected with a status of InstalledPendingReboot.
        ///
        /// * NoReboot: Patch Manager attempts to install missing packages without trying to reboot the system. Patches installed with this option are assigned a status of InstalledPendingReboot. These patches might not be in effect until a reboot is performed.
        public var rebootOption: SSMClientTypes.RebootOption?
        /// The number of patches per node that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
        public var securityNonCompliantCount: Swift.Int?
        /// The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.
        public var snapshotId: Swift.String?
        /// The number of patches beyond the supported limit of NotApplicableCount that aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
        public var unreportedNotApplicableCount: Swift.Int?

        public init(
            baselineId: Swift.String? = nil,
            criticalNonCompliantCount: Swift.Int? = 0,
            failedCount: Swift.Int = 0,
            installOverrideList: Swift.String? = nil,
            installedCount: Swift.Int = 0,
            installedOtherCount: Swift.Int = 0,
            installedPendingRebootCount: Swift.Int? = 0,
            installedRejectedCount: Swift.Int? = 0,
            instanceId: Swift.String? = nil,
            lastNoRebootInstallOperationTime: Foundation.Date? = nil,
            missingCount: Swift.Int = 0,
            notApplicableCount: Swift.Int = 0,
            operation: SSMClientTypes.PatchOperationType? = nil,
            operationEndTime: Foundation.Date? = nil,
            operationStartTime: Foundation.Date? = nil,
            otherNonCompliantCount: Swift.Int? = 0,
            ownerInformation: Swift.String? = nil,
            patchGroup: Swift.String? = nil,
            rebootOption: SSMClientTypes.RebootOption? = nil,
            securityNonCompliantCount: Swift.Int? = 0,
            snapshotId: Swift.String? = nil,
            unreportedNotApplicableCount: Swift.Int? = 0
        )
        {
            self.baselineId = baselineId
            self.criticalNonCompliantCount = criticalNonCompliantCount
            self.failedCount = failedCount
            self.installOverrideList = installOverrideList
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingRebootCount = installedPendingRebootCount
            self.installedRejectedCount = installedRejectedCount
            self.instanceId = instanceId
            self.lastNoRebootInstallOperationTime = lastNoRebootInstallOperationTime
            self.missingCount = missingCount
            self.notApplicableCount = notApplicableCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.otherNonCompliantCount = otherNonCompliantCount
            self.ownerInformation = ownerInformation
            self.patchGroup = patchGroup
            self.rebootOption = rebootOption
            self.securityNonCompliantCount = securityNonCompliantCount
            self.snapshotId = snapshotId
            self.unreportedNotApplicableCount = unreportedNotApplicableCount
        }
    }
}

extension SSMClientTypes.InstancePatchState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstancePatchState(baselineId: \(Swift.String(describing: baselineId)), criticalNonCompliantCount: \(Swift.String(describing: criticalNonCompliantCount)), failedCount: \(Swift.String(describing: failedCount)), installOverrideList: \(Swift.String(describing: installOverrideList)), installedCount: \(Swift.String(describing: installedCount)), installedOtherCount: \(Swift.String(describing: installedOtherCount)), installedPendingRebootCount: \(Swift.String(describing: installedPendingRebootCount)), installedRejectedCount: \(Swift.String(describing: installedRejectedCount)), instanceId: \(Swift.String(describing: instanceId)), lastNoRebootInstallOperationTime: \(Swift.String(describing: lastNoRebootInstallOperationTime)), missingCount: \(Swift.String(describing: missingCount)), notApplicableCount: \(Swift.String(describing: notApplicableCount)), operation: \(Swift.String(describing: operation)), operationEndTime: \(Swift.String(describing: operationEndTime)), operationStartTime: \(Swift.String(describing: operationStartTime)), otherNonCompliantCount: \(Swift.String(describing: otherNonCompliantCount)), patchGroup: \(Swift.String(describing: patchGroup)), rebootOption: \(Swift.String(describing: rebootOption)), securityNonCompliantCount: \(Swift.String(describing: securityNonCompliantCount)), snapshotId: \(Swift.String(describing: snapshotId)), unreportedNotApplicableCount: \(Swift.String(describing: unreportedNotApplicableCount)), ownerInformation: \"CONTENT_REDACTED\")"}
}

public struct DescribeInstancePatchStatesOutput: Swift.Sendable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SSMClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        instancePatchStates: [SSMClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum InstancePatchStateOperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InstancePatchStateOperatorType] {
            return [
                .equal,
                .greaterThan,
                .lessThan,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Defines a filter used in [DescribeInstancePatchStatesForPatchGroup] to scope down the information returned by the API. Example: To filter for all managed nodes in a patch group having more than three patches with a FailedCount status, use the following for the filter:
    ///
    /// * Value for Key: FailedCount
    ///
    /// * Value for Type: GreaterThan
    ///
    /// * Value for Values: 3
    public struct InstancePatchStateFilter: Swift.Sendable {
        /// The key for the filter. Supported values include the following:
        ///
        /// * InstalledCount
        ///
        /// * InstalledOtherCount
        ///
        /// * InstalledPendingRebootCount
        ///
        /// * InstalledRejectedCount
        ///
        /// * MissingCount
        ///
        /// * FailedCount
        ///
        /// * UnreportedNotApplicableCount
        ///
        /// * NotApplicableCount
        /// This member is required.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value.
        /// This member is required.
        public var type: SSMClientTypes.InstancePatchStateOperatorType?
        /// The value for the filter. Must be an integer greater than or equal to 0.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            type: SSMClientTypes.InstancePatchStateOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }
}

public struct DescribeInstancePatchStatesForPatchGroupInput: Swift.Sendable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key (string between 1 and 200 characters)
    ///
    /// * Values (array containing a single string)
    ///
    /// * Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")
    public var filters: [SSMClientTypes.InstancePatchStateFilter]?
    /// The maximum number of patches to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The name of the patch group for which the patch state information should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init(
        filters: [SSMClientTypes.InstancePatchStateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patchGroup = patchGroup
    }
}

public struct DescribeInstancePatchStatesForPatchGroupOutput: Swift.Sendable {
    /// The high-level patch state for the requested managed nodes.
    public var instancePatchStates: [SSMClientTypes.InstancePatchState]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        instancePatchStates: [SSMClientTypes.InstancePatchState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instancePatchStates = instancePatchStates
        self.nextToken = nextToken
    }
}

/// The specified filter value isn't valid.
public struct InvalidInstancePropertyFilterValue: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInstancePropertyFilterValue" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum InstancePropertyFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginWith
        case equal
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InstancePropertyFilterOperator] {
            return [
                .beginWith,
                .equal,
                .greaterThan,
                .lessThan,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// The filters to describe or get information about your managed nodes.
    public struct InstancePropertyStringFilter: Swift.Sendable {
        /// The filter key name to describe your managed nodes.
        /// This member is required.
        public var key: Swift.String?
        /// The operator used by the filter call.
        public var `operator`: SSMClientTypes.InstancePropertyFilterOperator?
        /// The filter key name to describe your managed nodes.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            `operator`: SSMClientTypes.InstancePropertyFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }
}

extension SSMClientTypes {

    public enum InstancePropertyFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activationIds
        case agentVersion
        case associationStatus
        case documentName
        case iamRole
        case instanceIds
        case pingStatus
        case platformTypes
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [InstancePropertyFilterKey] {
            return [
                .activationIds,
                .agentVersion,
                .associationStatus,
                .documentName,
                .iamRole,
                .instanceIds,
                .pingStatus,
                .platformTypes,
                .resourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activationIds: return "ActivationIds"
            case .agentVersion: return "AgentVersion"
            case .associationStatus: return "AssociationStatus"
            case .documentName: return "DocumentName"
            case .iamRole: return "IamRole"
            case .instanceIds: return "InstanceIds"
            case .pingStatus: return "PingStatus"
            case .platformTypes: return "PlatformTypes"
            case .resourceType: return "ResourceType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for a specific list of managed nodes. You can filter node information by using tags. You specify tags by using a key-value mapping.
    public struct InstancePropertyFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.InstancePropertyFilterKey?
        /// The filter values.
        /// This member is required.
        public var valueSet: [Swift.String]?

        public init(
            key: SSMClientTypes.InstancePropertyFilterKey? = nil,
            valueSet: [Swift.String]? = nil
        )
        {
            self.key = key
            self.valueSet = valueSet
        }
    }
}

public struct DescribeInstancePropertiesInput: Swift.Sendable {
    /// The request filters to use with the operator.
    public var filtersWithOperator: [SSMClientTypes.InstancePropertyStringFilter]?
    /// An array of instance property filters.
    public var instancePropertyFilterList: [SSMClientTypes.InstancePropertyFilter]?
    /// The maximum number of items to return for the call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token provided by a previous request to use to return the next set of properties.
    public var nextToken: Swift.String?

    public init(
        filtersWithOperator: [SSMClientTypes.InstancePropertyStringFilter]? = nil,
        instancePropertyFilterList: [SSMClientTypes.InstancePropertyFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filtersWithOperator = filtersWithOperator
        self.instancePropertyFilterList = instancePropertyFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// An object containing various properties of a managed node.
    public struct InstanceProperty: Swift.Sendable {
        /// The activation ID created by Systems Manager when the server or virtual machine (VM) was registered
        public var activationId: Swift.String?
        /// The version of SSM Agent running on your managed node.
        public var agentVersion: Swift.String?
        /// The CPU architecture of the node. For example, x86_64.
        public var architecture: Swift.String?
        /// Status information about the aggregated associations.
        public var associationOverview: SSMClientTypes.InstanceAggregatedAssociationOverview?
        /// The status of the State Manager association applied to the managed node.
        public var associationStatus: Swift.String?
        /// The fully qualified host name of the managed node.
        public var computerName: Swift.String?
        /// The IAM role used in the hybrid activation to register the node with Systems Manager.
        public var iamRole: Swift.String?
        /// The ID of the managed node.
        public var instanceId: Swift.String?
        /// The instance profile attached to the node. If an instance profile isn't attached to the node, this value is blank.
        public var instanceRole: Swift.String?
        /// The current state of the node.
        public var instanceState: Swift.String?
        /// The instance type of the managed node. For example, t3.large.
        public var instanceType: Swift.String?
        /// The public IPv4 address assigned to the node. If a public IPv4 address isn't assigned to the node, this value is blank.
        public var ipAddress: Swift.String?
        /// The name of the key pair associated with the node. If a key pair isnt't associated with the node, this value is blank.
        public var keyName: Swift.String?
        /// The date the association was last run.
        public var lastAssociationExecutionDate: Foundation.Date?
        /// The date and time when the SSM Agent last pinged the Systems Manager service.
        public var lastPingDateTime: Foundation.Date?
        /// The last date the association was successfully run.
        public var lastSuccessfulAssociationExecutionDate: Foundation.Date?
        /// The timestamp for when the node was launched.
        public var launchTime: Foundation.Date?
        /// The value of the EC2 Name tag associated with the node. If a Name tag hasn't been applied to the node, this value is blank.
        public var name: Swift.String?
        /// Connection status of the SSM Agent on the managed node.
        public var pingStatus: SSMClientTypes.PingStatus?
        /// The name of the operating system platform running on your managed node.
        public var platformName: Swift.String?
        /// The operating system platform type of the managed node. For example, Windows.
        public var platformType: SSMClientTypes.PlatformType?
        /// The version of the OS platform running on your managed node.
        public var platformVersion: Swift.String?
        /// The date the node was registered with Systems Manager.
        public var registrationDate: Foundation.Date?
        /// The type of managed node.
        public var resourceType: Swift.String?
        /// The ID of the source resource.
        public var sourceId: Swift.String?
        /// The type of the source resource.
        public var sourceType: SSMClientTypes.SourceType?

        public init(
            activationId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            architecture: Swift.String? = nil,
            associationOverview: SSMClientTypes.InstanceAggregatedAssociationOverview? = nil,
            associationStatus: Swift.String? = nil,
            computerName: Swift.String? = nil,
            iamRole: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceRole: Swift.String? = nil,
            instanceState: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            keyName: Swift.String? = nil,
            lastAssociationExecutionDate: Foundation.Date? = nil,
            lastPingDateTime: Foundation.Date? = nil,
            lastSuccessfulAssociationExecutionDate: Foundation.Date? = nil,
            launchTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            pingStatus: SSMClientTypes.PingStatus? = nil,
            platformName: Swift.String? = nil,
            platformType: SSMClientTypes.PlatformType? = nil,
            platformVersion: Swift.String? = nil,
            registrationDate: Foundation.Date? = nil,
            resourceType: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            sourceType: SSMClientTypes.SourceType? = nil
        )
        {
            self.activationId = activationId
            self.agentVersion = agentVersion
            self.architecture = architecture
            self.associationOverview = associationOverview
            self.associationStatus = associationStatus
            self.computerName = computerName
            self.iamRole = iamRole
            self.instanceId = instanceId
            self.instanceRole = instanceRole
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.ipAddress = ipAddress
            self.keyName = keyName
            self.lastAssociationExecutionDate = lastAssociationExecutionDate
            self.lastPingDateTime = lastPingDateTime
            self.lastSuccessfulAssociationExecutionDate = lastSuccessfulAssociationExecutionDate
            self.launchTime = launchTime
            self.name = name
            self.pingStatus = pingStatus
            self.platformName = platformName
            self.platformType = platformType
            self.platformVersion = platformVersion
            self.registrationDate = registrationDate
            self.resourceType = resourceType
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }
}

extension SSMClientTypes.InstanceProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceProperty(activationId: \(Swift.String(describing: activationId)), agentVersion: \(Swift.String(describing: agentVersion)), architecture: \(Swift.String(describing: architecture)), associationOverview: \(Swift.String(describing: associationOverview)), associationStatus: \(Swift.String(describing: associationStatus)), computerName: \(Swift.String(describing: computerName)), iamRole: \(Swift.String(describing: iamRole)), instanceId: \(Swift.String(describing: instanceId)), instanceRole: \(Swift.String(describing: instanceRole)), instanceState: \(Swift.String(describing: instanceState)), instanceType: \(Swift.String(describing: instanceType)), keyName: \(Swift.String(describing: keyName)), lastAssociationExecutionDate: \(Swift.String(describing: lastAssociationExecutionDate)), lastPingDateTime: \(Swift.String(describing: lastPingDateTime)), lastSuccessfulAssociationExecutionDate: \(Swift.String(describing: lastSuccessfulAssociationExecutionDate)), launchTime: \(Swift.String(describing: launchTime)), name: \(Swift.String(describing: name)), pingStatus: \(Swift.String(describing: pingStatus)), platformName: \(Swift.String(describing: platformName)), platformType: \(Swift.String(describing: platformType)), platformVersion: \(Swift.String(describing: platformVersion)), registrationDate: \(Swift.String(describing: registrationDate)), resourceType: \(Swift.String(describing: resourceType)), sourceId: \(Swift.String(describing: sourceId)), sourceType: \(Swift.String(describing: sourceType)), ipAddress: \"CONTENT_REDACTED\")"}
}

public struct DescribeInstancePropertiesOutput: Swift.Sendable {
    /// Properties for the managed instances.
    public var instanceProperties: [SSMClientTypes.InstanceProperty]?
    /// The token for the next set of properties to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        instanceProperties: [SSMClientTypes.InstanceProperty]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceProperties = instanceProperties
        self.nextToken = nextToken
    }
}

/// The ID specified for the delete operation doesn't exist or isn't valid. Verify the ID and try again.
public struct InvalidDeletionIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeletionId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeInventoryDeletionsInput: Swift.Sendable {
    /// Specify the delete inventory ID for which you want information. This ID was returned by the DeleteInventory operation.
    public var deletionId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        deletionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deletionId = deletionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum InventoryDeletionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryDeletionStatus] {
            return [
                .complete,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Status information returned by the DeleteInventory operation.
    public struct InventoryDeletionStatusItem: Swift.Sendable {
        /// The deletion ID returned by the DeleteInventory operation.
        public var deletionId: Swift.String?
        /// The UTC timestamp when the delete operation started.
        public var deletionStartTime: Foundation.Date?
        /// Information about the delete operation. For more information about this summary, see [Understanding the delete inventory summary](https://docs.aws.amazon.com/systems-manager/latest/userguide/inventory-custom.html#delete-custom-inventory) in the Amazon Web Services Systems Manager User Guide.
        public var deletionSummary: SSMClientTypes.InventoryDeletionSummary?
        /// The status of the operation. Possible values are InProgress and Complete.
        public var lastStatus: SSMClientTypes.InventoryDeletionStatus?
        /// Information about the status.
        public var lastStatusMessage: Swift.String?
        /// The UTC timestamp of when the last status report.
        public var lastStatusUpdateTime: Foundation.Date?
        /// The name of the inventory data type.
        public var typeName: Swift.String?

        public init(
            deletionId: Swift.String? = nil,
            deletionStartTime: Foundation.Date? = nil,
            deletionSummary: SSMClientTypes.InventoryDeletionSummary? = nil,
            lastStatus: SSMClientTypes.InventoryDeletionStatus? = nil,
            lastStatusMessage: Swift.String? = nil,
            lastStatusUpdateTime: Foundation.Date? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.deletionId = deletionId
            self.deletionStartTime = deletionStartTime
            self.deletionSummary = deletionSummary
            self.lastStatus = lastStatus
            self.lastStatusMessage = lastStatusMessage
            self.lastStatusUpdateTime = lastStatusUpdateTime
            self.typeName = typeName
        }
    }
}

public struct DescribeInventoryDeletionsOutput: Swift.Sendable {
    /// A list of status items for deleted inventory.
    public var inventoryDeletions: [SSMClientTypes.InventoryDeletionStatusItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        inventoryDeletions: [SSMClientTypes.InventoryDeletionStatusItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inventoryDeletions = inventoryDeletions
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Filter used in the request. Supported filter keys depend on the API operation that includes the filter. API operations that use MaintenanceWindowFilter> include the following:
    ///
    /// * [DescribeMaintenanceWindowExecutions]
    ///
    /// * [DescribeMaintenanceWindowExecutionTaskInvocations]
    ///
    /// * [DescribeMaintenanceWindowExecutionTasks]
    ///
    /// * [DescribeMaintenanceWindows]
    ///
    /// * [DescribeMaintenanceWindowTargets]
    ///
    /// * [DescribeMaintenanceWindowTasks]
    public struct MaintenanceWindowFilter: Swift.Sendable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The filter values.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsInput: Swift.Sendable {
    /// Each entry in the array is a structure containing:
    ///
    /// * Key. A string between 1 and 128 characters. Supported keys include ExecutedBefore and ExecutedAfter.
    ///
    /// * Values. An array of strings, each between 1 and 256 characters. Supported values are date/time strings in a valid ISO 8601 date/time format, such as 2024-11-04T05:00:00Z.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose executions should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

extension SSMClientTypes {

    public enum MaintenanceWindowExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inprogress
        case pending
        case skippedoverlapping
        case success
        case timedout
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inprogress,
                .pending,
                .skippedoverlapping,
                .success,
                .timedout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .skippedoverlapping: return "SKIPPED_OVERLAPPING"
            case .success: return "SUCCESS"
            case .timedout: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes the information about an execution of a maintenance window.
    public struct MaintenanceWindowExecution: Swift.Sendable {
        /// The time the execution finished.
        public var endTime: Foundation.Date?
        /// The time the execution started.
        public var startTime: Foundation.Date?
        /// The status of the execution.
        public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the maintenance window execution.
        public var windowExecutionId: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            windowExecutionId: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.windowExecutionId = windowExecutionId
            self.windowId = windowId
        }
    }
}

public struct DescribeMaintenanceWindowExecutionsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance window executions.
    public var windowExecutions: [SSMClientTypes.MaintenanceWindowExecution]?

    public init(
        nextToken: Swift.String? = nil,
        windowExecutions: [SSMClientTypes.MaintenanceWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutions = windowExecutions
    }
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsInput: Swift.Sendable {
    /// Optional filters used to scope down the returned task invocations. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution the task is part of.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

extension SSMClientTypes {

    public enum MaintenanceWindowTaskType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automation
        case lambda
        case runcommand
        case stepfunctions
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskType] {
            return [
                .automation,
                .lambda,
                .runcommand,
                .stepfunctions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .lambda: return "LAMBDA"
            case .runcommand: return "RUN_COMMAND"
            case .stepfunctions: return "STEP_FUNCTIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes the information about a task invocation for a particular target as part of a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskInvocationIdentity: Swift.Sendable {
        /// The time the invocation finished.
        public var endTime: Foundation.Date?
        /// The ID of the action performed in the service that actually handled the task invocation. If the task type is RUN_COMMAND, this value is the command ID.
        public var executionId: Swift.String?
        /// The ID of the task invocation.
        public var invocationId: Swift.String?
        /// User-provided value that was specified when the target was registered with the maintenance window. This was also included in any Amazon CloudWatch Events events raised during the task invocation.
        public var ownerInformation: Swift.String?
        /// The parameters that were provided for the invocation when it was run.
        public var parameters: Swift.String?
        /// The time the invocation started.
        public var startTime: Foundation.Date?
        /// The status of the task invocation.
        public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task invocation. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The task type.
        public var taskType: SSMClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?
        /// The ID of the target definition in this maintenance window the invocation was performed for.
        public var windowTargetId: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            executionId: Swift.String? = nil,
            invocationId: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            parameters: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SSMClientTypes.MaintenanceWindowTaskType? = nil,
            windowExecutionId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.executionId = executionId
            self.invocationId = invocationId
            self.ownerInformation = ownerInformation
            self.parameters = parameters
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.windowExecutionId = windowExecutionId
            self.windowTargetId = windowTargetId
        }
    }
}

extension SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowExecutionTaskInvocationIdentity(endTime: \(Swift.String(describing: endTime)), executionId: \(Swift.String(describing: executionId)), invocationId: \(Swift.String(describing: invocationId)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskType: \(Swift.String(describing: taskType)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), windowTargetId: \(Swift.String(describing: windowTargetId)), ownerInformation: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\")"}
}

public struct DescribeMaintenanceWindowExecutionTaskInvocationsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task invocation results per invocation.
    public var windowExecutionTaskInvocationIdentities: [SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]?

    public init(
        nextToken: Swift.String? = nil,
        windowExecutionTaskInvocationIdentities: [SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskInvocationIdentities = windowExecutionTaskInvocationIdentities
    }
}

public struct DescribeMaintenanceWindowExecutionTasksInput: Swift.Sendable {
    /// Optional filters used to scope down the returned tasks. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window execution whose task executions should be retrieved.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowExecutionId = windowExecutionId
    }
}

extension SSMClientTypes {

    /// Information about a task execution performed as part of a maintenance window execution.
    public struct MaintenanceWindowExecutionTaskIdentity: Swift.Sendable {
        /// The details for the CloudWatch alarm applied to your maintenance window task.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The time the task execution finished.
        public var endTime: Foundation.Date?
        /// The time the task execution started.
        public var startTime: Foundation.Date?
        /// The status of the task execution.
        public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
        /// The details explaining the status of the task execution. Not available for all status values.
        public var statusDetails: Swift.String?
        /// The Amazon Resource Name (ARN) of the task that ran.
        public var taskArn: Swift.String?
        /// The ID of the specific task execution in the maintenance window execution.
        public var taskExecutionId: Swift.String?
        /// The type of task that ran.
        public var taskType: SSMClientTypes.MaintenanceWindowTaskType?
        /// The CloudWatch alarm that was invoked by the maintenance window task.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?
        /// The ID of the maintenance window execution that ran the task.
        public var windowExecutionId: Swift.String?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
            statusDetails: Swift.String? = nil,
            taskArn: Swift.String? = nil,
            taskExecutionId: Swift.String? = nil,
            taskType: SSMClientTypes.MaintenanceWindowTaskType? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil,
            windowExecutionId: Swift.String? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
            self.statusDetails = statusDetails
            self.taskArn = taskArn
            self.taskExecutionId = taskExecutionId
            self.taskType = taskType
            self.triggeredAlarms = triggeredAlarms
            self.windowExecutionId = windowExecutionId
        }
    }
}

public struct DescribeMaintenanceWindowExecutionTasksOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the task executions.
    public var windowExecutionTaskIdentities: [SSMClientTypes.MaintenanceWindowExecutionTaskIdentity]?

    public init(
        nextToken: Swift.String? = nil,
        windowExecutionTaskIdentities: [SSMClientTypes.MaintenanceWindowExecutionTaskIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowExecutionTaskIdentities = windowExecutionTaskIdentities
    }
}

public struct DescribeMaintenanceWindowsInput: Swift.Sendable {
    /// Optional filters used to narrow down the scope of the returned maintenance windows. Supported filter keys are Name and Enabled. For example, Name=MyMaintenanceWindow and Enabled=True.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Information about the maintenance window.
    public struct MaintenanceWindowIdentity: Swift.Sendable {
        /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
        public var cutoff: Swift.Int
        /// A description of the maintenance window.
        public var description: Swift.String?
        /// The duration of the maintenance window in hours.
        public var duration: Swift.Int?
        /// Indicates whether the maintenance window is enabled.
        public var enabled: Swift.Bool
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive.
        public var endDate: Swift.String?
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
        public var nextExecutionTime: Swift.String?
        /// The schedule of the maintenance window in the form of a cron or rate expression.
        public var schedule: Swift.String?
        /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
        public var scheduleOffset: Swift.Int?
        /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format.
        public var scheduleTimezone: Swift.String?
        /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active.
        public var startDate: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init(
            cutoff: Swift.Int = 0,
            description: Swift.String? = nil,
            duration: Swift.Int? = nil,
            enabled: Swift.Bool = false,
            endDate: Swift.String? = nil,
            name: Swift.String? = nil,
            nextExecutionTime: Swift.String? = nil,
            schedule: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            scheduleTimezone: Swift.String? = nil,
            startDate: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.cutoff = cutoff
            self.description = description
            self.duration = duration
            self.enabled = enabled
            self.endDate = endDate
            self.name = name
            self.nextExecutionTime = nextExecutionTime
            self.schedule = schedule
            self.scheduleOffset = scheduleOffset
            self.scheduleTimezone = scheduleTimezone
            self.startDate = startDate
            self.windowId = windowId
        }
    }
}

extension SSMClientTypes.MaintenanceWindowIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowIdentity(cutoff: \(Swift.String(describing: cutoff)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), nextExecutionTime: \(Swift.String(describing: nextExecutionTime)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\")"}
}

public struct DescribeMaintenanceWindowsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the maintenance windows.
    public var windowIdentities: [SSMClientTypes.MaintenanceWindowIdentity]?

    public init(
        nextToken: Swift.String? = nil,
        windowIdentities: [SSMClientTypes.MaintenanceWindowIdentity]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

extension SSMClientTypes {

    public enum MaintenanceWindowResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instance
        case resourcegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowResourceType] {
            return [
                .instance,
                .resourcegroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .resourcegroup: return "RESOURCE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeMaintenanceWindowScheduleInput: Swift.Sendable {
    /// Filters used to limit the range of results. For example, you can limit maintenance window executions to only those scheduled before or after a certain date and time.
    public var filters: [SSMClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    public var resourceType: SSMClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    public var targets: [SSMClientTypes.Target]?
    /// The ID of the maintenance window to retrieve information about.
    public var windowId: Swift.String?

    public init(
        filters: [SSMClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: SSMClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

extension SSMClientTypes {

    /// Information about a scheduled execution for a maintenance window.
    public struct ScheduledWindowExecution: Swift.Sendable {
        /// The time, in ISO-8601 Extended format, that the maintenance window is scheduled to be run.
        public var executionTime: Swift.String?
        /// The name of the maintenance window to be run.
        public var name: Swift.String?
        /// The ID of the maintenance window to be run.
        public var windowId: Swift.String?

        public init(
            executionTime: Swift.String? = nil,
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.executionTime = executionTime
            self.name = name
            self.windowId = windowId
        }
    }
}

public struct DescribeMaintenanceWindowScheduleOutput: Swift.Sendable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about maintenance window executions scheduled for the specified time range.
    public var scheduledWindowExecutions: [SSMClientTypes.ScheduledWindowExecution]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledWindowExecutions: [SSMClientTypes.ScheduledWindowExecution]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledWindowExecutions = scheduledWindowExecutions
    }
}

public struct DescribeMaintenanceWindowsForTargetInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of resource you want to retrieve information about. For example, INSTANCE.
    /// This member is required.
    public var resourceType: SSMClientTypes.MaintenanceWindowResourceType?
    /// The managed node ID or key-value pair to retrieve information about.
    /// This member is required.
    public var targets: [SSMClientTypes.Target]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: SSMClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SSMClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
        self.targets = targets
    }
}

extension SSMClientTypes {

    /// The maintenance window to which the specified target belongs.
    public struct MaintenanceWindowIdentityForTarget: Swift.Sendable {
        /// The name of the maintenance window.
        public var name: Swift.String?
        /// The ID of the maintenance window.
        public var windowId: Swift.String?

        public init(
            name: Swift.String? = nil,
            windowId: Swift.String? = nil
        )
        {
            self.name = name
            self.windowId = windowId
        }
    }
}

public struct DescribeMaintenanceWindowsForTargetOutput: Swift.Sendable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// Information about the maintenance window targets and tasks a managed node is associated with.
    public var windowIdentities: [SSMClientTypes.MaintenanceWindowIdentityForTarget]?

    public init(
        nextToken: Swift.String? = nil,
        windowIdentities: [SSMClientTypes.MaintenanceWindowIdentityForTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.windowIdentities = windowIdentities
    }
}

public struct DescribeMaintenanceWindowTargetsInput: Swift.Sendable {
    /// Optional filters that can be used to narrow down the scope of the returned window targets. The supported filter keys are Type, WindowTargetId, and OwnerInformation.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose targets should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

extension SSMClientTypes {

    /// The target registered with the maintenance window.
    public struct MaintenanceWindowTarget: Swift.Sendable {
        /// A description for the target.
        public var description: Swift.String?
        /// The name for the maintenance window target.
        public var name: Swift.String?
        /// A user-provided value that will be included in any Amazon CloudWatch Events events that are raised while running tasks for these targets in this maintenance window.
        public var ownerInformation: Swift.String?
        /// The type of target that is being registered with the maintenance window.
        public var resourceType: SSMClientTypes.MaintenanceWindowResourceType?
        /// The targets, either managed nodes or tags. Specify managed nodes using the following format: Key=instanceids,Values=, Tags are specified using the following format: Key=,Values=.
        public var targets: [SSMClientTypes.Target]?
        /// The ID of the maintenance window to register the target with.
        public var windowId: Swift.String?
        /// The ID of the target.
        public var windowTargetId: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerInformation: Swift.String? = nil,
            resourceType: SSMClientTypes.MaintenanceWindowResourceType? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            windowId: Swift.String? = nil,
            windowTargetId: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.ownerInformation = ownerInformation
            self.resourceType = resourceType
            self.targets = targets
            self.windowId = windowId
            self.windowTargetId = windowTargetId
        }
    }
}

extension SSMClientTypes.MaintenanceWindowTarget: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowTarget(name: \(Swift.String(describing: name)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)), description: \"CONTENT_REDACTED\", ownerInformation: \"CONTENT_REDACTED\")"}
}

public struct DescribeMaintenanceWindowTargetsOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the targets in the maintenance window.
    public var targets: [SSMClientTypes.MaintenanceWindowTarget]?

    public init(
        nextToken: Swift.String? = nil,
        targets: [SSMClientTypes.MaintenanceWindowTarget]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

public struct DescribeMaintenanceWindowTasksInput: Swift.Sendable {
    /// Optional filters used to narrow down the scope of the returned tasks. The supported filter keys are WindowTaskId, TaskArn, Priority, and TaskType.
    public var filters: [SSMClientTypes.MaintenanceWindowFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the maintenance window whose tasks should be retrieved.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        filters: [SSMClientTypes.MaintenanceWindowFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.windowId = windowId
    }
}

extension SSMClientTypes {

    public enum MaintenanceWindowTaskCutoffBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceltask
        case continuetask
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowTaskCutoffBehavior] {
            return [
                .canceltask,
                .continuetask
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceltask: return "CANCEL_TASK"
            case .continuetask: return "CONTINUE_TASK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public struct LoggingInfo: Swift.Sendable {
        /// The name of an S3 bucket where execution logs are stored.
        /// This member is required.
        public var s3BucketName: Swift.String?
        /// (Optional) The S3 bucket subfolder.
        public var s3KeyPrefix: Swift.String?
        /// The Amazon Web Services Region where the S3 bucket is located.
        /// This member is required.
        public var s3Region: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            s3Region: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3Region = s3Region
        }
    }
}

extension SSMClientTypes {

    /// Defines the values for a task parameter.
    public struct MaintenanceWindowTaskParameterValueExpression: Swift.Sendable {
        /// This field contains an array of 0 or more strings, each 1 to 255 characters in length.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }
}

extension SSMClientTypes.MaintenanceWindowTaskParameterValueExpression: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SSMClientTypes {

    /// Information about a task defined for a maintenance window.
    public struct MaintenanceWindowTask: Swift.Sendable {
        /// The details for the CloudWatch alarm applied to your maintenance window task.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
        public var cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior?
        /// A description of the task.
        public var description: Swift.String?
        /// Information about an S3 bucket to write task-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var loggingInfo: SSMClientTypes.LoggingInfo?
        /// The maximum number of targets this task can be run for, in parallel. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before this task stops being scheduled. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
        public var maxErrors: Swift.String?
        /// The task name.
        public var name: Swift.String?
        /// The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
        public var priority: Swift.Int
        /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
        public var serviceRoleArn: Swift.String?
        /// The targets (either managed nodes or tags). Managed nodes are specified using Key=instanceids,Values=,. Tags are specified using Key=,Values=.
        public var targets: [SSMClientTypes.Target]?
        /// The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types, TaskArn is the Amazon Web Services Systems Manager (SSM document) name or ARN. For LAMBDA tasks, it's the function name or ARN. For STEP_FUNCTIONS tasks, it's the state machine ARN.
        public var taskArn: Swift.String?
        /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
        public var taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]?
        /// The type of task.
        public var type: SSMClientTypes.MaintenanceWindowTaskType?
        /// The ID of the maintenance window where the task is registered.
        public var windowId: Swift.String?
        /// The task ID.
        public var windowTaskId: Swift.String?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
            description: Swift.String? = nil,
            loggingInfo: SSMClientTypes.LoggingInfo? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int = 0,
            serviceRoleArn: Swift.String? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            taskArn: Swift.String? = nil,
            taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
            type: SSMClientTypes.MaintenanceWindowTaskType? = nil,
            windowId: Swift.String? = nil,
            windowTaskId: Swift.String? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.cutoffBehavior = cutoffBehavior
            self.description = description
            self.loggingInfo = loggingInfo
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.priority = priority
            self.serviceRoleArn = serviceRoleArn
            self.targets = targets
            self.taskArn = taskArn
            self.taskParameters = taskParameters
            self.type = type
            self.windowId = windowId
            self.windowTaskId = windowTaskId
        }
    }
}

extension SSMClientTypes.MaintenanceWindowTask: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowTask(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), type: \(Swift.String(describing: type)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)), description: \"CONTENT_REDACTED\", taskParameters: \"CONTENT_REDACTED\")"}
}

public struct DescribeMaintenanceWindowTasksOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Information about the tasks in the maintenance window.
    public var tasks: [SSMClientTypes.MaintenanceWindowTask]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [SSMClientTypes.MaintenanceWindowTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

extension SSMClientTypes {

    public enum OpsItemFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case actualEndTime
        case actualStartTime
        case automationId
        case category
        case changeRequestApproverArn
        case changeRequestApproverName
        case changeRequestRequesterArn
        case changeRequestRequesterName
        case changeRequestTargetsResourceGroup
        case changeRequestTemplate
        case createdBy
        case createdTime
        case insightType
        case lastModifiedTime
        case operationalData
        case operationalDataKey
        case operationalDataValue
        case opsitemId
        case opsitemType
        case plannedEndTime
        case plannedStartTime
        case priority
        case resourceId
        case severity
        case source
        case status
        case title
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterKey] {
            return [
                .accountId,
                .actualEndTime,
                .actualStartTime,
                .automationId,
                .category,
                .changeRequestApproverArn,
                .changeRequestApproverName,
                .changeRequestRequesterArn,
                .changeRequestRequesterName,
                .changeRequestTargetsResourceGroup,
                .changeRequestTemplate,
                .createdBy,
                .createdTime,
                .insightType,
                .lastModifiedTime,
                .operationalData,
                .operationalDataKey,
                .operationalDataValue,
                .opsitemId,
                .opsitemType,
                .plannedEndTime,
                .plannedStartTime,
                .priority,
                .resourceId,
                .severity,
                .source,
                .status,
                .title
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "AccountId"
            case .actualEndTime: return "ActualEndTime"
            case .actualStartTime: return "ActualStartTime"
            case .automationId: return "AutomationId"
            case .category: return "Category"
            case .changeRequestApproverArn: return "ChangeRequestByApproverArn"
            case .changeRequestApproverName: return "ChangeRequestByApproverName"
            case .changeRequestRequesterArn: return "ChangeRequestByRequesterArn"
            case .changeRequestRequesterName: return "ChangeRequestByRequesterName"
            case .changeRequestTargetsResourceGroup: return "ChangeRequestByTargetsResourceGroup"
            case .changeRequestTemplate: return "ChangeRequestByTemplate"
            case .createdBy: return "CreatedBy"
            case .createdTime: return "CreatedTime"
            case .insightType: return "InsightByType"
            case .lastModifiedTime: return "LastModifiedTime"
            case .operationalData: return "OperationalData"
            case .operationalDataKey: return "OperationalDataKey"
            case .operationalDataValue: return "OperationalDataValue"
            case .opsitemId: return "OpsItemId"
            case .opsitemType: return "OpsItemType"
            case .plannedEndTime: return "PlannedEndTime"
            case .plannedStartTime: return "PlannedStartTime"
            case .priority: return "Priority"
            case .resourceId: return "ResourceId"
            case .severity: return "Severity"
            case .source: return "Source"
            case .status: return "Status"
            case .title: return "Title"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum OpsItemFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equal
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemFilterOperator] {
            return [
                .contains,
                .equal,
                .greaterThan,
                .lessThan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "Contains"
            case .equal: return "Equal"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes an OpsItem filter.
    public struct OpsItemFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.OpsItemFilterKey?
        /// The operator used by the filter call.
        /// This member is required.
        public var `operator`: SSMClientTypes.OpsItemFilterOperator?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.OpsItemFilterKey? = nil,
            `operator`: SSMClientTypes.OpsItemFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct DescribeOpsItemsInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// One or more filters to limit the response.
    ///
    /// * Key: CreatedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: LastModifiedBy Operations: Contains, Equals
    ///
    /// * Key: LastModifiedTime Operations: GreaterThan, LessThan
    ///
    /// * Key: Priority Operations: Equals
    ///
    /// * Key: Source Operations: Contains, Equals
    ///
    /// * Key: Status Operations: Equals
    ///
    /// * Key: Title* Operations: Equals,Contains
    ///
    /// * Key: OperationalData** Operations: Equals
    ///
    /// * Key: OperationalDataKey Operations: Equals
    ///
    /// * Key: OperationalDataValue Operations: Equals, Contains
    ///
    /// * Key: OpsItemId Operations: Equals
    ///
    /// * Key: ResourceId Operations: Contains
    ///
    /// * Key: AutomationId Operations: Equals
    ///
    /// * Key: AccountId Operations: Equals
    ///
    ///
    /// *The Equals operator for Title matches the first 100 characters. If you specify more than 100 characters, they system returns an error that the filter value exceeds the length limit. **If you filter the response by using the OperationalData operator, specify a key-value pair by using the following JSON format: {"key":"key_name","value":"a_value"}
    public var opsItemFilters: [SSMClientTypes.OpsItemFilter]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemFilters: [SSMClientTypes.OpsItemFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemFilters = opsItemFilters
    }
}

extension SSMClientTypes {

    public enum OpsItemStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case cancelled
        case cancelling
        case changeCalendarOverrideApproved
        case changeCalendarOverrideRejected
        case closed
        case completedWithFailure
        case completedWithSuccess
        case failed
        case inProgress
        case `open`
        case pending
        case pendingApproval
        case pendingChangeCalendarOverride
        case rejected
        case resolved
        case runbookInProgress
        case scheduled
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemStatus] {
            return [
                .approved,
                .cancelled,
                .cancelling,
                .changeCalendarOverrideApproved,
                .changeCalendarOverrideRejected,
                .closed,
                .completedWithFailure,
                .completedWithSuccess,
                .failed,
                .inProgress,
                .open,
                .pending,
                .pendingApproval,
                .pendingChangeCalendarOverride,
                .rejected,
                .resolved,
                .runbookInProgress,
                .scheduled,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .changeCalendarOverrideApproved: return "ChangeCalendarOverrideApproved"
            case .changeCalendarOverrideRejected: return "ChangeCalendarOverrideRejected"
            case .closed: return "Closed"
            case .completedWithFailure: return "CompletedWithFailure"
            case .completedWithSuccess: return "CompletedWithSuccess"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .open: return "Open"
            case .pending: return "Pending"
            case .pendingApproval: return "PendingApproval"
            case .pendingChangeCalendarOverride: return "PendingChangeCalendarOverride"
            case .rejected: return "Rejected"
            case .resolved: return "Resolved"
            case .runbookInProgress: return "RunbookInProgress"
            case .scheduled: return "Scheduled"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// A count of OpsItems.
    public struct OpsItemSummary: Swift.Sendable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: Foundation.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: Foundation.Date?
        /// A list of OpsItems by category.
        public var category: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: Foundation.Date?
        /// Operational data is custom data that provides useful reference details about the OpsItem.
        public var operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Systems Manager supports the following types of OpsItems:
        ///
        /// * /aws/issue This type of OpsItem is used for default OpsItems created by OpsCenter.
        ///
        /// * /aws/changerequest This type of OpsItem is used by Change Manager for reviewing and approving or rejecting change requests.
        ///
        /// * /aws/insight This type of OpsItem is used by OpsCenter for aggregating and reporting on duplicate OpsItems.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: Foundation.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: Foundation.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// A list of OpsItems by severity.
        public var severity: Swift.String?
        /// The impacted Amazon Web Services resource.
        public var source: Swift.String?
        /// The OpsItem status.
        public var status: SSMClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?

        public init(
            actualEndTime: Foundation.Date? = nil,
            actualStartTime: Foundation.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: Foundation.Date? = nil,
            plannedStartTime: Foundation.Date? = nil,
            priority: Swift.Int? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SSMClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.operationalData = operationalData
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
        }
    }
}

public struct DescribeOpsItemsOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of OpsItems.
    public var opsItemSummaries: [SSMClientTypes.OpsItemSummary]?

    public init(
        nextToken: Swift.String? = nil,
        opsItemSummaries: [SSMClientTypes.OpsItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsItemSummaries = opsItemSummaries
    }
}

/// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
public struct InvalidFilterOption: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The specified filter option isn't valid. Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidFilterOption" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum ParametersFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case keyId
        case name
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [ParametersFilterKey] {
            return [
                .keyId,
                .name,
                .type
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .keyId: return "KeyId"
            case .name: return "Name"
            case .type: return "Type"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// This data type is deprecated. Instead, use [ParameterStringFilter].
    public struct ParametersFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.ParametersFilterKey?
        /// The filter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.ParametersFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

extension SSMClientTypes {

    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ParameterStringFilter: Swift.Sendable {
        /// The name of the filter. The ParameterStringFilter object is used by the [DescribeParameters] and [GetParametersByPath] API operations. However, not all of the pattern values listed for Key can be used with both operations. For DescribeParameters, all of the listed patterns are valid except Label. For GetParametersByPath, the following patterns listed for Key aren't valid: tag, DataType, Name, Path, and Tier. For examples of Amazon Web Services CLI commands demonstrating valid parameter filter constructions, see [Searching for Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-search.html) in the Amazon Web Services Systems Manager User Guide.
        /// This member is required.
        public var key: Swift.String?
        /// For all filters used with [DescribeParameters], valid options include Equals and BeginsWith. The Name filter additionally supports the Contains option. (Exception: For filters using the key Path, valid options include Recursive and OneLevel.) For filters used with [GetParametersByPath], valid options include Equals and BeginsWith. (Exception: For filters using Label as the Key name, the only valid option is Equals.)
        public var option: Swift.String?
        /// The value you want to search for.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            option: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.option = option
            self.values = values
        }
    }
}

public struct DescribeParametersInput: Swift.Sendable {
    /// This data type is deprecated. Instead, use ParameterFilters.
    public var filters: [SSMClientTypes.ParametersFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Filters to limit the request results.
    public var parameterFilters: [SSMClientTypes.ParameterStringFilter]?
    /// Lists parameters that are shared with you. By default when using this option, the command returns parameters that have been shared using a standard Resource Access Manager Resource Share. In order for a parameter that was shared using the [PutResourcePolicy] command to be returned, the associated RAM Resource Share Created From Policy must have been promoted to a standard Resource Share using the RAM [PromoteResourceShareCreatedFromPolicy](https://docs.aws.amazon.com/ram/latest/APIReference/API_PromoteResourceShareCreatedFromPolicy.html) API operation. For more information about sharing parameters, see [Working with shared parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-shared-parameters.html) in the Amazon Web Services Systems Manager User Guide.
    public var shared: Swift.Bool?

    public init(
        filters: [SSMClientTypes.ParametersFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterFilters: [SSMClientTypes.ParameterStringFilter]? = nil,
        shared: Swift.Bool? = false
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
        self.shared = shared
    }
}

extension SSMClientTypes {

    /// One or more policies assigned to a parameter.
    public struct ParameterInlinePolicy: Swift.Sendable {
        /// The status of the policy. Policies report the following statuses: Pending (the policy hasn't been enforced or applied yet), Finished (the policy was applied), Failed (the policy wasn't applied), or InProgress (the policy is being applied now).
        public var policyStatus: Swift.String?
        /// The JSON text of the policy.
        public var policyText: Swift.String?
        /// The type of policy. Parameter Store, a capability of Amazon Web Services Systems Manager, supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
        public var policyType: Swift.String?

        public init(
            policyStatus: Swift.String? = nil,
            policyText: Swift.String? = nil,
            policyType: Swift.String? = nil
        )
        {
            self.policyStatus = policyStatus
            self.policyText = policyText
            self.policyType = policyType
        }
    }
}

extension SSMClientTypes {

    public enum ParameterTier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case advanced
        case intelligentTiering
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterTier] {
            return [
                .advanced,
                .intelligentTiering,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .intelligentTiering: return "Intelligent-Tiering"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum ParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case secureString
        case string
        case stringList
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .secureString,
                .string,
                .stringList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .secureString: return "SecureString"
            case .string: return "String"
            case .stringList: return "StringList"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Metadata includes information like the Amazon Resource Name (ARN) of the last user to update the parameter and the date and time the parameter was last used.
    public struct ParameterMetadata: Swift.Sendable {
        /// A parameter name can include only the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The (ARN) of the last user to update the parameter.
        public var arn: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Description of the parameter actions.
        public var description: Swift.String?
        /// The alias of the Key Management Service (KMS) key used to encrypt the parameter. Applies to SecureString parameters only.
        public var keyId: Swift.String?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: Foundation.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The parameter name.
        public var name: Swift.String?
        /// A list of policies associated with a parameter.
        public var policies: [SSMClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SSMClientTypes.ParameterTier?
        /// The type of parameter. Valid parameter types include the following: String, StringList, and SecureString.
        public var type: SSMClientTypes.ParameterType?
        /// The parameter version.
        public var version: Swift.Int

        public init(
            allowedPattern: Swift.String? = nil,
            arn: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SSMClientTypes.ParameterInlinePolicy]? = nil,
            tier: SSMClientTypes.ParameterTier? = nil,
            type: SSMClientTypes.ParameterType? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.arn = arn
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.version = version
        }
    }
}

public struct DescribeParametersOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items.
    public var nextToken: Swift.String?
    /// Parameters returned by the request.
    public var parameters: [SSMClientTypes.ParameterMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        parameters: [SSMClientTypes.ParameterMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

public struct DescribePatchBaselinesInput: Swift.Sendable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchBaselines include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-
    ///
    /// * OWNER Sample values: AWS | Self
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SSMClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch baselines to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Defines the basic information about a patch baseline.
    public struct PatchBaselineIdentity: Swift.Sendable {
        /// The description of the patch baseline.
        public var baselineDescription: Swift.String?
        /// The ID of the patch baseline.
        public var baselineId: Swift.String?
        /// The name of the patch baseline.
        public var baselineName: Swift.String?
        /// Indicates whether this is the default baseline. Amazon Web Services Systems Manager supports creating multiple default patch baselines. For example, you can create a default patch baseline for each operating system.
        public var defaultBaseline: Swift.Bool
        /// Defines the operating system the patch baseline applies to. The default value is WINDOWS.
        public var operatingSystem: SSMClientTypes.OperatingSystem?

        public init(
            baselineDescription: Swift.String? = nil,
            baselineId: Swift.String? = nil,
            baselineName: Swift.String? = nil,
            defaultBaseline: Swift.Bool = false,
            operatingSystem: SSMClientTypes.OperatingSystem? = nil
        )
        {
            self.baselineDescription = baselineDescription
            self.baselineId = baselineId
            self.baselineName = baselineName
            self.defaultBaseline = defaultBaseline
            self.operatingSystem = operatingSystem
        }
    }
}

public struct DescribePatchBaselinesOutput: Swift.Sendable {
    /// An array of PatchBaselineIdentity elements.
    public var baselineIdentities: [SSMClientTypes.PatchBaselineIdentity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        baselineIdentities: [SSMClientTypes.PatchBaselineIdentity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.baselineIdentities = baselineIdentities
        self.nextToken = nextToken
    }
}

public struct DescribePatchGroupsInput: Swift.Sendable {
    /// Each element in the array is a structure containing a key-value pair. Supported keys for DescribePatchGroups include the following:
    ///
    /// * NAME_PREFIX Sample values: AWS- | My-.
    ///
    /// * OPERATING_SYSTEM Sample values: AMAZON_LINUX | SUSE | WINDOWS
    public var filters: [SSMClientTypes.PatchOrchestratorFilter]?
    /// The maximum number of patch groups to return (per page).
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.PatchOrchestratorFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// The mapping between a patch group and the patch baseline the patch group is registered with.
    public struct PatchGroupPatchBaselineMapping: Swift.Sendable {
        /// The patch baseline the patch group is registered with.
        public var baselineIdentity: SSMClientTypes.PatchBaselineIdentity?
        /// The name of the patch group registered with the patch baseline.
        public var patchGroup: Swift.String?

        public init(
            baselineIdentity: SSMClientTypes.PatchBaselineIdentity? = nil,
            patchGroup: Swift.String? = nil
        )
        {
            self.baselineIdentity = baselineIdentity
            self.patchGroup = patchGroup
        }
    }
}

public struct DescribePatchGroupsOutput: Swift.Sendable {
    /// Each entry in the array contains:
    ///
    /// * PatchGroup: string (between 1 and 256 characters. Regex: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)
    ///
    /// * PatchBaselineIdentity: A PatchBaselineIdentity element.
    public var mappings: [SSMClientTypes.PatchGroupPatchBaselineMapping]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        mappings: [SSMClientTypes.PatchGroupPatchBaselineMapping]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappings = mappings
        self.nextToken = nextToken
    }
}

public struct DescribePatchGroupStateInput: Swift.Sendable {
    /// The name of the patch group whose patch snapshot should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init(
        patchGroup: Swift.String? = nil
    )
    {
        self.patchGroup = patchGroup
    }
}

public struct DescribePatchGroupStateOutput: Swift.Sendable {
    /// The number of managed nodes in the patch group.
    public var instances: Swift.Int
    /// The number of managed nodes where patches that are specified as Critical for compliance reporting in the patch baseline aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithCriticalNonCompliantPatches: Swift.Int?
    /// The number of managed nodes with patches from the patch baseline that failed to install.
    public var instancesWithFailedPatches: Swift.Int
    /// The number of managed nodes with patches installed that aren't defined in the patch baseline.
    public var instancesWithInstalledOtherPatches: Swift.Int
    /// The number of managed nodes with installed patches.
    public var instancesWithInstalledPatches: Swift.Int
    /// The number of managed nodes with patches installed by Patch Manager that haven't been rebooted after the patch installation. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithInstalledPendingRebootPatches: Swift.Int?
    /// The number of managed nodes with patches installed that are specified in a RejectedPatches list. Patches with a status of INSTALLED_REJECTED were typically installed before they were added to a RejectedPatches list. If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstancesWithInstalledRejectedPatches will always be 0 (zero).
    public var instancesWithInstalledRejectedPatches: Swift.Int?
    /// The number of managed nodes with missing patches from the patch baseline.
    public var instancesWithMissingPatches: Swift.Int
    /// The number of managed nodes with patches that aren't applicable.
    public var instancesWithNotApplicablePatches: Swift.Int
    /// The number of managed nodes with patches installed that are specified as other than Critical or Security but aren't compliant with the patch baseline. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithOtherNonCompliantPatches: Swift.Int?
    /// The number of managed nodes where patches that are specified as Security in a patch advisory aren't installed. These patches might be missing, have failed installation, were rejected, or were installed but awaiting a required managed node reboot. The status of these managed nodes is NON_COMPLIANT.
    public var instancesWithSecurityNonCompliantPatches: Swift.Int?
    /// The number of managed nodes with NotApplicable patches beyond the supported limit, which aren't reported by name to Inventory. Inventory is a capability of Amazon Web Services Systems Manager.
    public var instancesWithUnreportedNotApplicablePatches: Swift.Int?

    public init(
        instances: Swift.Int = 0,
        instancesWithCriticalNonCompliantPatches: Swift.Int? = 0,
        instancesWithFailedPatches: Swift.Int = 0,
        instancesWithInstalledOtherPatches: Swift.Int = 0,
        instancesWithInstalledPatches: Swift.Int = 0,
        instancesWithInstalledPendingRebootPatches: Swift.Int? = 0,
        instancesWithInstalledRejectedPatches: Swift.Int? = 0,
        instancesWithMissingPatches: Swift.Int = 0,
        instancesWithNotApplicablePatches: Swift.Int = 0,
        instancesWithOtherNonCompliantPatches: Swift.Int? = 0,
        instancesWithSecurityNonCompliantPatches: Swift.Int? = 0,
        instancesWithUnreportedNotApplicablePatches: Swift.Int? = 0
    )
    {
        self.instances = instances
        self.instancesWithCriticalNonCompliantPatches = instancesWithCriticalNonCompliantPatches
        self.instancesWithFailedPatches = instancesWithFailedPatches
        self.instancesWithInstalledOtherPatches = instancesWithInstalledOtherPatches
        self.instancesWithInstalledPatches = instancesWithInstalledPatches
        self.instancesWithInstalledPendingRebootPatches = instancesWithInstalledPendingRebootPatches
        self.instancesWithInstalledRejectedPatches = instancesWithInstalledRejectedPatches
        self.instancesWithMissingPatches = instancesWithMissingPatches
        self.instancesWithNotApplicablePatches = instancesWithNotApplicablePatches
        self.instancesWithOtherNonCompliantPatches = instancesWithOtherNonCompliantPatches
        self.instancesWithSecurityNonCompliantPatches = instancesWithSecurityNonCompliantPatches
        self.instancesWithUnreportedNotApplicablePatches = instancesWithUnreportedNotApplicablePatches
    }
}

extension SSMClientTypes {

    public enum PatchSet: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case os
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchSet] {
            return [
                .application,
                .os
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .os: return "OS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum PatchProperty: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case patchclassification
        case patchmsrcseverity
        case patchpriority
        case patchproductfamily
        case patchseverity
        case product
        case sdkUnknown(Swift.String)

        public static var allCases: [PatchProperty] {
            return [
                .patchclassification,
                .patchmsrcseverity,
                .patchpriority,
                .patchproductfamily,
                .patchseverity,
                .product
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .patchclassification: return "CLASSIFICATION"
            case .patchmsrcseverity: return "MSRC_SEVERITY"
            case .patchpriority: return "PRIORITY"
            case .patchproductfamily: return "PRODUCT_FAMILY"
            case .patchseverity: return "SEVERITY"
            case .product: return "PRODUCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePatchPropertiesInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The operating system type for which to list patches.
    /// This member is required.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// Indicates whether to list patches for the Windows operating system or for applications released by Microsoft. Not applicable for the Linux or macOS operating systems.
    public var patchSet: SSMClientTypes.PatchSet?
    /// The patch property for which you want to view patch details.
    /// This member is required.
    public var property: SSMClientTypes.PatchProperty?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        patchSet: SSMClientTypes.PatchSet? = nil,
        property: SSMClientTypes.PatchProperty? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operatingSystem = operatingSystem
        self.patchSet = patchSet
        self.property = property
    }
}

public struct DescribePatchPropertiesOutput: Swift.Sendable {
    /// The token for the next set of items to return. (You use this token in the next call.)
    public var nextToken: Swift.String?
    /// A list of the properties for patches matching the filter request parameters.
    public var properties: [[Swift.String: Swift.String]]?

    public init(
        nextToken: Swift.String? = nil,
        properties: [[Swift.String: Swift.String]]? = nil
    )
    {
        self.nextToken = nextToken
        self.properties = properties
    }
}

extension SSMClientTypes {

    public enum SessionFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invokedAfter
        case invokedBefore
        case owner
        case sessionId
        case status
        case targetId
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionFilterKey] {
            return [
                .invokedAfter,
                .invokedBefore,
                .owner,
                .sessionId,
                .status,
                .targetId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .owner: return "Owner"
            case .sessionId: return "SessionId"
            case .status: return "Status"
            case .targetId: return "Target"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for Session Manager information.
    public struct SessionFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.SessionFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2024-08-29T00:00:00Z to see sessions that started August 29, 2024, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2024-08-29T00:00:00Z to see sessions that started before August 29, 2024.
        ///
        /// * Target: Specify a managed node to which session connections have been made.
        ///
        /// * Owner: Specify an Amazon Web Services user to see a list of sessions started by that user.
        ///
        /// * Status: Specify a valid session status to see a list of all sessions with that status. Status values you can specify include:
        ///
        /// * Connected
        ///
        /// * Connecting
        ///
        /// * Disconnected
        ///
        /// * Terminated
        ///
        /// * Terminating
        ///
        /// * Failed
        ///
        ///
        ///
        ///
        /// * SessionId: Specify a session ID to return details about the session.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.SessionFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension SSMClientTypes {

    public enum SessionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case history
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .history
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .history: return "History"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSessionsInput: Swift.Sendable {
    /// One or more filters to limit the type of sessions returned by the request.
    public var filters: [SSMClientTypes.SessionFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The session status to retrieve a list of sessions for. For example, "Active".
    /// This member is required.
    public var state: SSMClientTypes.SessionState?

    public init(
        filters: [SSMClientTypes.SessionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: SSMClientTypes.SessionState? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

extension SSMClientTypes {

    /// Reserved for future use.
    public struct SessionManagerOutputUrl: Swift.Sendable {
        /// Reserved for future use.
        public var cloudWatchOutputUrl: Swift.String?
        /// Reserved for future use.
        public var s3OutputUrl: Swift.String?

        public init(
            cloudWatchOutputUrl: Swift.String? = nil,
            s3OutputUrl: Swift.String? = nil
        )
        {
            self.cloudWatchOutputUrl = cloudWatchOutputUrl
            self.s3OutputUrl = s3OutputUrl
        }
    }
}

extension SSMClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case connecting
        case disconnected
        case failed
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .connected,
                .connecting,
                .disconnected,
                .failed,
                .terminated,
                .terminating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connecting: return "Connecting"
            case .disconnected: return "Disconnected"
            case .failed: return "Failed"
            case .terminated: return "Terminated"
            case .terminating: return "Terminating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about a Session Manager connection to a managed node.
    public struct Session: Swift.Sendable {
        /// Reserved for future use.
        public var details: Swift.String?
        /// The name of the Session Manager SSM document used to define the parameters and plugin settings for the session. For example, SSM-SessionManagerRunShell.
        public var documentName: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session was terminated.
        public var endDate: Foundation.Date?
        /// The maximum duration of a session before it terminates.
        public var maxSessionDuration: Swift.String?
        /// Reserved for future use.
        public var outputUrl: SSMClientTypes.SessionManagerOutputUrl?
        /// The ID of the Amazon Web Services user that started the session.
        public var owner: Swift.String?
        /// The reason for connecting to the instance.
        public var reason: Swift.String?
        /// The ID of the session.
        public var sessionId: Swift.String?
        /// The date and time, in ISO-8601 Extended format, when the session began.
        public var startDate: Foundation.Date?
        /// The status of the session. For example, "Connected" or "Terminated".
        public var status: SSMClientTypes.SessionStatus?
        /// The managed node that the Session Manager session connected to.
        public var target: Swift.String?

        public init(
            details: Swift.String? = nil,
            documentName: Swift.String? = nil,
            endDate: Foundation.Date? = nil,
            maxSessionDuration: Swift.String? = nil,
            outputUrl: SSMClientTypes.SessionManagerOutputUrl? = nil,
            owner: Swift.String? = nil,
            reason: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startDate: Foundation.Date? = nil,
            status: SSMClientTypes.SessionStatus? = nil,
            target: Swift.String? = nil
        )
        {
            self.details = details
            self.documentName = documentName
            self.endDate = endDate
            self.maxSessionDuration = maxSessionDuration
            self.outputUrl = outputUrl
            self.owner = owner
            self.reason = reason
            self.sessionId = sessionId
            self.startDate = startDate
            self.status = status
            self.target = target
        }
    }
}

public struct DescribeSessionsOutput: Swift.Sendable {
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// A list of sessions meeting the request parameters.
    public var sessions: [SSMClientTypes.Session]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [SSMClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

/// The association wasn't found using the parameters you specified in the call. Verify the information and try again.
public struct OpsItemRelatedItemAssociationNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsItemRelatedItemAssociationNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DisassociateOpsItemRelatedItemInput: Swift.Sendable {
    /// The ID of the association for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var associationId: Swift.String?
    /// The ID of the OpsItem for which you want to delete an association between the OpsItem and a related item.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.opsItemId = opsItemId
    }
}

public struct DisassociateOpsItemRelatedItemOutput: Swift.Sendable {

    public init() { }
}

public struct GetAutomationExecutionInput: Swift.Sendable {
    /// The unique identifier for an existing automation execution to examine. The execution ID is returned by StartAutomationExecution when the execution of an Automation runbook is initiated.
    /// This member is required.
    public var automationExecutionId: Swift.String?

    public init(
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

extension SSMClientTypes {

    /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
    public struct ProgressCounters: Swift.Sendable {
        /// The total number of steps that the system cancelled in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var cancelledSteps: Swift.Int
        /// The total number of steps that failed to run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var failedSteps: Swift.Int
        /// The total number of steps that successfully completed in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var successSteps: Swift.Int
        /// The total number of steps that timed out in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var timedOutSteps: Swift.Int
        /// The total number of steps run in all specified Amazon Web Services Regions and Amazon Web Services accounts for the current Automation execution.
        public var totalSteps: Swift.Int

        public init(
            cancelledSteps: Swift.Int = 0,
            failedSteps: Swift.Int = 0,
            successSteps: Swift.Int = 0,
            timedOutSteps: Swift.Int = 0,
            totalSteps: Swift.Int = 0
        )
        {
            self.cancelledSteps = cancelledSteps
            self.failedSteps = failedSteps
            self.successSteps = successSteps
            self.timedOutSteps = timedOutSteps
            self.totalSteps = totalSteps
        }
    }
}

extension SSMClientTypes {

    /// Detailed information about the current state of an individual Automation execution.
    public struct AutomationExecution: Swift.Sendable {
        /// The details for the CloudWatch alarm applied to your automation.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// The ID of a State Manager association used in the Automation operation.
        public var associationId: Swift.String?
        /// The execution ID.
        public var automationExecutionId: Swift.String?
        /// The execution status of the Automation.
        public var automationExecutionStatus: SSMClientTypes.AutomationExecutionStatus?
        /// The subtype of the Automation operation. Currently, the only supported value is ChangeRequest.
        public var automationSubtype: SSMClientTypes.AutomationSubtype?
        /// The name of the Change Manager change request.
        public var changeRequestName: Swift.String?
        /// The action of the step that is currently running.
        public var currentAction: Swift.String?
        /// The name of the step that is currently running.
        public var currentStepName: Swift.String?
        /// The name of the Automation runbook used during the execution.
        public var documentName: Swift.String?
        /// The version of the document to use during execution.
        public var documentVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of the user who ran the automation.
        public var executedBy: Swift.String?
        /// The time the execution finished.
        public var executionEndTime: Foundation.Date?
        /// The time the execution started.
        public var executionStartTime: Foundation.Date?
        /// A message describing why an execution has failed, if the status is set to Failed.
        public var failureMessage: Swift.String?
        /// The MaxConcurrency value specified by the user when the execution started.
        public var maxConcurrency: Swift.String?
        /// The MaxErrors value specified by the user when the execution started.
        public var maxErrors: Swift.String?
        /// The automation execution mode.
        public var mode: SSMClientTypes.ExecutionMode?
        /// The ID of an OpsItem that is created to represent a Change Manager change request.
        public var opsItemId: Swift.String?
        /// The list of execution outputs as defined in the Automation runbook.
        public var outputs: [Swift.String: [Swift.String]]?
        /// The key-value map of execution parameters, which were supplied when calling [StartAutomationExecution].
        public var parameters: [Swift.String: [Swift.String]]?
        /// The AutomationExecutionId of the parent automation.
        public var parentAutomationExecutionId: Swift.String?
        /// An aggregate of step execution statuses displayed in the Amazon Web Services Systems Manager console for a multi-Region and multi-account Automation execution.
        public var progressCounters: SSMClientTypes.ProgressCounters?
        /// A list of resolved targets in the rate control execution.
        public var resolvedTargets: SSMClientTypes.ResolvedTargets?
        /// Information about the Automation runbooks that are run as part of a runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
        public var runbooks: [SSMClientTypes.Runbook]?
        /// The date and time the Automation operation is scheduled to start.
        public var scheduledTime: Foundation.Date?
        /// A list of details about the current state of all steps that comprise an execution. An Automation runbook contains a list of steps that are run in order.
        public var stepExecutions: [SSMClientTypes.StepExecution]?
        /// A boolean value that indicates if the response contains the full list of the Automation step executions. If true, use the DescribeAutomationStepExecutions API operation to get the full list of step executions.
        public var stepExecutionsTruncated: Swift.Bool
        /// The target of the execution.
        public var target: Swift.String?
        /// The combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the Automation.
        public var targetLocations: [SSMClientTypes.TargetLocation]?
        /// A publicly accessible URL for a file that contains the TargetLocations body. Currently, only files in presigned Amazon S3 buckets are supported
        public var targetLocationsURL: Swift.String?
        /// The specified key-value mapping of document parameters to target resources.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The parameter name.
        public var targetParameterName: Swift.String?
        /// The specified targets.
        public var targets: [SSMClientTypes.Target]?
        /// The CloudWatch alarm that was invoked by the automation.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?
        /// Variables defined for the automation.
        public var variables: [Swift.String: [Swift.String]]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            associationId: Swift.String? = nil,
            automationExecutionId: Swift.String? = nil,
            automationExecutionStatus: SSMClientTypes.AutomationExecutionStatus? = nil,
            automationSubtype: SSMClientTypes.AutomationSubtype? = nil,
            changeRequestName: Swift.String? = nil,
            currentAction: Swift.String? = nil,
            currentStepName: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            executedBy: Swift.String? = nil,
            executionEndTime: Foundation.Date? = nil,
            executionStartTime: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            mode: SSMClientTypes.ExecutionMode? = nil,
            opsItemId: Swift.String? = nil,
            outputs: [Swift.String: [Swift.String]]? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            parentAutomationExecutionId: Swift.String? = nil,
            progressCounters: SSMClientTypes.ProgressCounters? = nil,
            resolvedTargets: SSMClientTypes.ResolvedTargets? = nil,
            runbooks: [SSMClientTypes.Runbook]? = nil,
            scheduledTime: Foundation.Date? = nil,
            stepExecutions: [SSMClientTypes.StepExecution]? = nil,
            stepExecutionsTruncated: Swift.Bool = false,
            target: Swift.String? = nil,
            targetLocations: [SSMClientTypes.TargetLocation]? = nil,
            targetLocationsURL: Swift.String? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targetParameterName: Swift.String? = nil,
            targets: [SSMClientTypes.Target]? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil,
            variables: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.associationId = associationId
            self.automationExecutionId = automationExecutionId
            self.automationExecutionStatus = automationExecutionStatus
            self.automationSubtype = automationSubtype
            self.changeRequestName = changeRequestName
            self.currentAction = currentAction
            self.currentStepName = currentStepName
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.executedBy = executedBy
            self.executionEndTime = executionEndTime
            self.executionStartTime = executionStartTime
            self.failureMessage = failureMessage
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.mode = mode
            self.opsItemId = opsItemId
            self.outputs = outputs
            self.parameters = parameters
            self.parentAutomationExecutionId = parentAutomationExecutionId
            self.progressCounters = progressCounters
            self.resolvedTargets = resolvedTargets
            self.runbooks = runbooks
            self.scheduledTime = scheduledTime
            self.stepExecutions = stepExecutions
            self.stepExecutionsTruncated = stepExecutionsTruncated
            self.target = target
            self.targetLocations = targetLocations
            self.targetLocationsURL = targetLocationsURL
            self.targetMaps = targetMaps
            self.targetParameterName = targetParameterName
            self.targets = targets
            self.triggeredAlarms = triggeredAlarms
            self.variables = variables
        }
    }
}

public struct GetAutomationExecutionOutput: Swift.Sendable {
    /// Detailed information about the current state of an automation execution.
    public var automationExecution: SSMClientTypes.AutomationExecution?

    public init(
        automationExecution: SSMClientTypes.AutomationExecution? = nil
    )
    {
        self.automationExecution = automationExecution
    }
}

/// The SSM document type isn't valid. Valid document types are described in the DocumentType property.
public struct InvalidDocumentType: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDocumentType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The calendar entry contained in the specified SSM document isn't supported.
public struct UnsupportedCalendarException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedCalendarException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetCalendarStateInput: Swift.Sendable {
    /// (Optional) The specific time for which you want to get calendar state information, in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. If you don't specify a value or AtTime, the current time is used.
    public var atTime: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Systems Manager documents (SSM documents) that represent the calendar entries for which you want to get the state.
    /// This member is required.
    public var calendarNames: [Swift.String]?

    public init(
        atTime: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil
    )
    {
        self.atTime = atTime
        self.calendarNames = calendarNames
    }
}

extension SSMClientTypes {

    public enum CalendarState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [CalendarState] {
            return [
                .closed,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .open: return "OPEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCalendarStateOutput: Swift.Sendable {
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that you specified in your command. If you don't specify a time, GetCalendarState uses the current time.
    public var atTime: Swift.String?
    /// The time, as an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) string, that the calendar state will change. If the current calendar state is OPEN, NextTransitionTime indicates when the calendar state changes to CLOSED, and vice-versa.
    public var nextTransitionTime: Swift.String?
    /// The state of the calendar. An OPEN calendar indicates that actions are allowed to proceed, and a CLOSED calendar indicates that actions aren't allowed to proceed.
    public var state: SSMClientTypes.CalendarState?

    public init(
        atTime: Swift.String? = nil,
        nextTransitionTime: Swift.String? = nil,
        state: SSMClientTypes.CalendarState? = nil
    )
    {
        self.atTime = atTime
        self.nextTransitionTime = nextTransitionTime
        self.state = state
    }
}

/// The plugin name isn't valid.
public struct InvalidPluginName: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidPluginName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The command ID and managed node ID you specified didn't match any invocations. Verify the command ID and the managed node ID and try again.
public struct InvocationDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvocationDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

public struct GetCommandInvocationInput: Swift.Sendable {
    /// (Required) The parent command ID of the invocation plugin.
    /// This member is required.
    public var commandId: Swift.String?
    /// (Required) The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, and on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the step for which you want detailed results. If the document contains only one step, you can omit the name and details for that step. If the document contains more than one step, you must specify the name of the step for which you want to view details. Be sure to specify the name of the step, not the name of a plugin like aws:RunShellScript. To find the PluginName, check the document content and find the name of the step you want details for. Alternatively, use [ListCommandInvocations] with the CommandId and Details parameters. The PluginName is the Name attribute of the CommandPlugin object in the CommandPlugins list.
    public var pluginName: Swift.String?

    public init(
        commandId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.instanceId = instanceId
        self.pluginName = pluginName
    }
}

extension SSMClientTypes {

    /// Configuration options for sending command output to Amazon CloudWatch Logs.
    public struct CloudWatchOutputConfig: Swift.Sendable {
        /// The name of the CloudWatch Logs log group where you want to send command output. If you don't specify a group name, Amazon Web Services Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName
        public var cloudWatchLogGroupName: Swift.String?
        /// Enables Systems Manager to send command output to CloudWatch Logs.
        public var cloudWatchOutputEnabled: Swift.Bool

        public init(
            cloudWatchLogGroupName: Swift.String? = nil,
            cloudWatchOutputEnabled: Swift.Bool = false
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.cloudWatchOutputEnabled = cloudWatchOutputEnabled
        }
    }
}

extension SSMClientTypes {

    public enum CommandInvocationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case delayed
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandInvocationStatus] {
            return [
                .cancelled,
                .cancelling,
                .delayed,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .delayed: return "Delayed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCommandInvocationOutput: Swift.Sendable {
    /// Amazon CloudWatch Logs information where Systems Manager sent the command output.
    public var cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig?
    /// The parent command ID of the invocation plugin.
    public var commandId: Swift.String?
    /// The comment text for the command.
    public var comment: Swift.String?
    /// The name of the document that was run. For example, AWS-RunShellScript.
    public var documentName: Swift.String?
    /// The Systems Manager document (SSM document) version used in the request.
    public var documentVersion: Swift.String?
    /// Duration since ExecutionStartDateTime.
    public var executionElapsedTime: Swift.String?
    /// The date and time the plugin finished running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedAfter filter. aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionEndDateTime: Swift.String?
    /// The date and time the plugin started running. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample Amazon Web Services CLI command uses the InvokedBefore filter. aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z If the plugin hasn't started to run, the string is empty.
    public var executionStartDateTime: Swift.String?
    /// The ID of the managed node targeted by the command. A managed node can be an Amazon Elastic Compute Cloud (Amazon EC2) instance, edge device, or on-premises server or VM in your hybrid environment that is configured for Amazon Web Services Systems Manager.
    public var instanceId: Swift.String?
    /// The name of the plugin, or step name, for which details are reported. For example, aws:RunShellScript is a plugin.
    public var pluginName: Swift.String?
    /// The error level response code for the plugin script. If the response code is -1, then the command hasn't started running on the managed node, or it wasn't received by the node.
    public var responseCode: Swift.Int
    /// The first 8,000 characters written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorContent: Swift.String?
    /// The URL for the complete text written by the plugin to stderr. If the command hasn't finished running, then this string is empty.
    public var standardErrorUrl: Swift.String?
    /// The first 24,000 characters written by the plugin to stdout. If the command hasn't finished running, if ExecutionStatus is neither Succeeded nor Failed, then this string is empty.
    public var standardOutputContent: Swift.String?
    /// The URL for the complete text written by the plugin to stdout in Amazon Simple Storage Service (Amazon S3). If an S3 bucket wasn't specified, then this string is empty.
    public var standardOutputUrl: Swift.String?
    /// The status of this invocation plugin. This status can be different than StatusDetails.
    public var status: SSMClientTypes.CommandInvocationStatus?
    /// A detailed status of the command execution for an invocation. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
    ///
    /// * Pending: The command hasn't been sent to the managed node.
    ///
    /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
    ///
    /// * Delayed: The system attempted to send the command to the target, but the target wasn't available. The managed node might not be available because of network issues, because the node was stopped, or for similar reasons. The system will try to send the command again.
    ///
    /// * Success: The command or plugin ran successfully. This is a terminal state.
    ///
    /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Execution Timed Out: The command started to run on the managed node, but the execution wasn't complete before the timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Failed: The command wasn't run successfully on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
    ///
    /// * Cancelled: The command was terminated before it was completed. This is a terminal state.
    ///
    /// * Undeliverable: The command can't be delivered to the managed node. The node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
    ///
    /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
    public var statusDetails: Swift.String?

    public init(
        cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig? = nil,
        commandId: Swift.String? = nil,
        comment: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        executionElapsedTime: Swift.String? = nil,
        executionEndDateTime: Swift.String? = nil,
        executionStartDateTime: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        pluginName: Swift.String? = nil,
        responseCode: Swift.Int = 0,
        standardErrorContent: Swift.String? = nil,
        standardErrorUrl: Swift.String? = nil,
        standardOutputContent: Swift.String? = nil,
        standardOutputUrl: Swift.String? = nil,
        status: SSMClientTypes.CommandInvocationStatus? = nil,
        statusDetails: Swift.String? = nil
    )
    {
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.commandId = commandId
        self.comment = comment
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.executionElapsedTime = executionElapsedTime
        self.executionEndDateTime = executionEndDateTime
        self.executionStartDateTime = executionStartDateTime
        self.instanceId = instanceId
        self.pluginName = pluginName
        self.responseCode = responseCode
        self.standardErrorContent = standardErrorContent
        self.standardErrorUrl = standardErrorUrl
        self.standardOutputContent = standardOutputContent
        self.standardOutputUrl = standardOutputUrl
        self.status = status
        self.statusDetails = statusDetails
    }
}

public struct GetConnectionStatusInput: Swift.Sendable {
    /// The managed node ID.
    /// This member is required.
    public var target: Swift.String?

    public init(
        target: Swift.String? = nil
    )
    {
        self.target = target
    }
}

extension SSMClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .connected,
                .notConnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "connected"
            case .notConnected: return "notconnected"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetConnectionStatusOutput: Swift.Sendable {
    /// The status of the connection to the managed node.
    public var status: SSMClientTypes.ConnectionStatus?
    /// The ID of the managed node to check connection status.
    public var target: Swift.String?

    public init(
        status: SSMClientTypes.ConnectionStatus? = nil,
        target: Swift.String? = nil
    )
    {
        self.status = status
        self.target = target
    }
}

public struct GetDefaultPatchBaselineInput: Swift.Sendable {
    /// Returns the default patch baseline for the specified operating system.
    public var operatingSystem: SSMClientTypes.OperatingSystem?

    public init(
        operatingSystem: SSMClientTypes.OperatingSystem? = nil
    )
    {
        self.operatingSystem = operatingSystem
    }
}

public struct GetDefaultPatchBaselineOutput: Swift.Sendable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?
    /// The operating system for the returned patch baseline.
    public var operatingSystem: SSMClientTypes.OperatingSystem?

    public init(
        baselineId: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
    }
}

/// Patching for applications released by Microsoft is only available on EC2 instances and advanced instances. To patch applications released by Microsoft on on-premises servers and VMs, you must enable advanced instances. For more information, see [Turning on the advanced-instances tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-managedinstances-advanced.html) in the Amazon Web Services Systems Manager User Guide.
public struct UnsupportedFeatureRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedFeatureRequiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Defines the basic information about a patch baseline override.
    public struct BaselineOverride: Swift.Sendable {
        /// A set of rules defining the approval rules for a patch baseline.
        public var approvalRules: SSMClientTypes.PatchRuleGroup?
        /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var approvedPatches: [Swift.String]?
        /// Defines the compliance level for approved patches. When an approved patch is reported as missing, this value describes the severity of the compliance violation.
        public var approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel?
        /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
        public var approvedPatchesEnableNonSecurity: Swift.Bool
        /// A set of patch filters, typically used for approval rules.
        public var globalFilters: SSMClientTypes.PatchFilterGroup?
        /// The operating system rule used by the patch baseline override.
        public var operatingSystem: SSMClientTypes.OperatingSystem?
        /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
        public var rejectedPatches: [Swift.String]?
        /// The action for Patch Manager to take on patches included in the RejectedPackages list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
        public var rejectedPatchesAction: SSMClientTypes.PatchAction?
        /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
        public var sources: [SSMClientTypes.PatchSource]?

        public init(
            approvalRules: SSMClientTypes.PatchRuleGroup? = nil,
            approvedPatches: [Swift.String]? = nil,
            approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
            approvedPatchesEnableNonSecurity: Swift.Bool = false,
            globalFilters: SSMClientTypes.PatchFilterGroup? = nil,
            operatingSystem: SSMClientTypes.OperatingSystem? = nil,
            rejectedPatches: [Swift.String]? = nil,
            rejectedPatchesAction: SSMClientTypes.PatchAction? = nil,
            sources: [SSMClientTypes.PatchSource]? = nil
        )
        {
            self.approvalRules = approvalRules
            self.approvedPatches = approvedPatches
            self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
            self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
            self.globalFilters = globalFilters
            self.operatingSystem = operatingSystem
            self.rejectedPatches = rejectedPatches
            self.rejectedPatchesAction = rejectedPatchesAction
            self.sources = sources
        }
    }
}

public struct GetDeployablePatchSnapshotForInstanceInput: Swift.Sendable {
    /// Defines the basic information about a patch baseline override.
    public var baselineOverride: SSMClientTypes.BaselineOverride?
    /// The ID of the managed node for which the appropriate patch snapshot should be retrieved.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The snapshot ID provided by the user when running AWS-RunPatchBaseline.
    /// This member is required.
    public var snapshotId: Swift.String?

    public init(
        baselineOverride: SSMClientTypes.BaselineOverride? = nil,
        instanceId: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.baselineOverride = baselineOverride
        self.instanceId = instanceId
        self.snapshotId = snapshotId
    }
}

public struct GetDeployablePatchSnapshotForInstanceOutput: Swift.Sendable {
    /// The managed node ID.
    public var instanceId: Swift.String?
    /// Returns the specific operating system (for example Windows Server 2012 or Amazon Linux 2015.09) on the managed node for the specified patch snapshot.
    public var product: Swift.String?
    /// A pre-signed Amazon Simple Storage Service (Amazon S3) URL that can be used to download the patch snapshot.
    public var snapshotDownloadUrl: Swift.String?
    /// The user-defined snapshot ID.
    public var snapshotId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        product: Swift.String? = nil,
        snapshotDownloadUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.product = product
        self.snapshotDownloadUrl = snapshotDownloadUrl
        self.snapshotId = snapshotId
    }
}

public struct GetDocumentInput: Swift.Sendable {
    /// Returns the document in the specified format. The document format can be either JSON or YAML. JSON is the default format.
    public var documentFormat: SSMClientTypes.DocumentFormat?
    /// The document version for which you want information.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?
    /// An optional field specifying the version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document and can't be changed.
    public var versionName: Swift.String?

    public init(
        documentFormat: SSMClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.versionName = versionName
    }
}

extension SSMClientTypes {

    public enum AttachmentHashType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentHashType] {
            return [
                .sha256
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sha256: return "Sha256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// A structure that includes attributes that describe a document attachment.
    public struct AttachmentContent: Swift.Sendable {
        /// The cryptographic hash value of the document content.
        public var hash: Swift.String?
        /// The hash algorithm used to calculate the hash value.
        public var hashType: SSMClientTypes.AttachmentHashType?
        /// The name of an attachment.
        public var name: Swift.String?
        /// The size of an attachment in bytes.
        public var size: Swift.Int
        /// The URL location of the attachment content.
        public var url: Swift.String?

        public init(
            hash: Swift.String? = nil,
            hashType: SSMClientTypes.AttachmentHashType? = nil,
            name: Swift.String? = nil,
            size: Swift.Int = 0,
            url: Swift.String? = nil
        )
        {
            self.hash = hash
            self.hashType = hashType
            self.name = name
            self.size = size
            self.url = url
        }
    }
}

public struct GetDocumentOutput: Swift.Sendable {
    /// A description of the document attachments, including names, locations, sizes, and so on.
    public var attachmentsContent: [SSMClientTypes.AttachmentContent]?
    /// The contents of the SSM document.
    public var content: Swift.String?
    /// The date the SSM document was created.
    public var createdDate: Foundation.Date?
    /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
    public var displayName: Swift.String?
    /// The document format, either JSON or YAML.
    public var documentFormat: SSMClientTypes.DocumentFormat?
    /// The document type.
    public var documentType: SSMClientTypes.DocumentType?
    /// The document version.
    public var documentVersion: Swift.String?
    /// The name of the SSM document.
    public var name: Swift.String?
    /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
    public var requires: [SSMClientTypes.DocumentRequires]?
    /// The current review status of a new custom Systems Manager document (SSM document) created by a member of your organization, or of the latest version of an existing SSM document. Only one version of an SSM document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of an SSM document can be in review, or PENDING, at a time.
    public var reviewStatus: SSMClientTypes.ReviewStatus?
    /// The status of the SSM document, such as Creating, Active, Updating, Failed, and Deleting.
    public var status: SSMClientTypes.DocumentStatus?
    /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
    public var statusInformation: Swift.String?
    /// The version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init(
        attachmentsContent: [SSMClientTypes.AttachmentContent]? = nil,
        content: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SSMClientTypes.DocumentFormat? = nil,
        documentType: SSMClientTypes.DocumentType? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        requires: [SSMClientTypes.DocumentRequires]? = nil,
        reviewStatus: SSMClientTypes.ReviewStatus? = nil,
        status: SSMClientTypes.DocumentStatus? = nil,
        statusInformation: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachmentsContent = attachmentsContent
        self.content = content
        self.createdDate = createdDate
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentType = documentType
        self.documentVersion = documentVersion
        self.name = name
        self.requires = requires
        self.reviewStatus = reviewStatus
        self.status = status
        self.statusInformation = statusInformation
        self.versionName = versionName
    }
}

/// The specified aggregator isn't valid for inventory groups. Verify that the aggregator uses a valid inventory type such as AWS:Application or AWS:InstanceInformation.
public struct InvalidAggregatorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAggregator" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified inventory group isn't valid.
public struct InvalidInventoryGroupException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInventoryGroup" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified inventory item result attribute isn't valid.
public struct InvalidResultAttributeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResultAttribute" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum InventoryQueryOperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryQueryOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// One or more filters. Use a filter to return a more specific list of results.
    public struct InventoryFilter: Swift.Sendable {
        /// The name of the filter key.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter. The Exists filter must be used with aggregators. For more information, see [Aggregating inventory data](https://docs.aws.amazon.com/systems-manager/latest/userguide/inventory-aggregate.html) in the Amazon Web Services Systems Manager User Guide.
        public var type: SSMClientTypes.InventoryQueryOperatorType?
        /// Inventory filter values. Example: inventory filter where managed node IDs are specified as values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            type: SSMClientTypes.InventoryQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }
}

extension SSMClientTypes {

    /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
    public struct InventoryGroup: Swift.Sendable {
        /// Filters define the criteria for the group. The matchingCount field displays the number of resources that match the criteria. The notMatchingCount field displays the number of resources that don't match the criteria.
        /// This member is required.
        public var filters: [SSMClientTypes.InventoryFilter]?
        /// The name of the group.
        /// This member is required.
        public var name: Swift.String?

        public init(
            filters: [SSMClientTypes.InventoryFilter]? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.name = name
        }
    }
}

extension SSMClientTypes {

    /// The inventory item result attribute.
    public struct ResultAttribute: Swift.Sendable {
        /// Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value: AWS:InstanceInformation.
        /// This member is required.
        public var typeName: Swift.String?

        public init(
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }
}

extension SSMClientTypes {

    /// The inventory result item.
    public struct InventoryResultItem: Swift.Sendable {
        /// The time inventory item data was captured.
        public var captureTime: Swift.String?
        /// Contains all the inventory data of the item type. Results include attribute names and values.
        /// This member is required.
        public var content: [[Swift.String: Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// The schema version for the inventory result item/
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory result item type.
        /// This member is required.
        public var typeName: Swift.String?

        public init(
            captureTime: Swift.String? = nil,
            content: [[Swift.String: Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }
}

extension SSMClientTypes {

    /// Inventory query results.
    public struct InventoryResultEntity: Swift.Sendable {
        /// The data section in the inventory result entity JSON.
        public var data: [Swift.String: SSMClientTypes.InventoryResultItem]?
        /// ID of the inventory result entity. For example, for managed node inventory the result will be the managed node ID. For EC2 instance inventory, the result will be the instance ID.
        public var id: Swift.String?

        public init(
            data: [Swift.String: SSMClientTypes.InventoryResultItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }
}

public struct GetInventoryOutput: Swift.Sendable {
    /// Collection of inventory entities such as a collection of managed node inventory.
    public var entities: [SSMClientTypes.InventoryResultEntity]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        entities: [SSMClientTypes.InventoryResultEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

public struct GetInventorySchemaInput: Swift.Sendable {
    /// Returns inventory schemas that support aggregation. For example, this call returns the AWS:InstanceInformation type, because it supports aggregation based on the PlatformName, PlatformType, and PlatformVersion attributes.
    public var aggregator: Swift.Bool?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Returns the sub-type schema for a specified inventory type.
    public var subType: Swift.Bool?
    /// The type of inventory item to return.
    public var typeName: Swift.String?

    public init(
        aggregator: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subType: Swift.Bool? = false,
        typeName: Swift.String? = nil
    )
    {
        self.aggregator = aggregator
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subType = subType
        self.typeName = typeName
    }
}

extension SSMClientTypes {

    public enum InventoryAttributeDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InventoryAttributeDataType] {
            return [
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Attributes are the entries within the inventory item content. It contains name and value.
    public struct InventoryItemAttribute: Swift.Sendable {
        /// The data type of the inventory item attribute.
        /// This member is required.
        public var dataType: SSMClientTypes.InventoryAttributeDataType?
        /// Name of the inventory item attribute.
        /// This member is required.
        public var name: Swift.String?

        public init(
            dataType: SSMClientTypes.InventoryAttributeDataType? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.name = name
        }
    }
}

extension SSMClientTypes {

    /// The inventory item schema definition. Users can use this to compose inventory query filters.
    public struct InventoryItemSchema: Swift.Sendable {
        /// The schema attributes for inventory. This contains data type and attribute name.
        /// This member is required.
        public var attributes: [SSMClientTypes.InventoryItemAttribute]?
        /// The alias name of the inventory type. The alias name is used for display purposes.
        public var displayName: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with Amazon Web Services. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?
        /// The schema version for the inventory item.
        public var version: Swift.String?

        public init(
            attributes: [SSMClientTypes.InventoryItemAttribute]? = nil,
            displayName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.displayName = displayName
            self.typeName = typeName
            self.version = version
        }
    }
}

public struct GetInventorySchemaOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// Inventory schemas returned by the request.
    public var schemas: [SSMClientTypes.InventoryItemSchema]?

    public init(
        nextToken: Swift.String? = nil,
        schemas: [SSMClientTypes.InventoryItemSchema]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemas = schemas
    }
}

public struct GetMaintenanceWindowInput: Swift.Sendable {
    /// The ID of the maintenance window for which you want to retrieve information.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        windowId: Swift.String? = nil
    )
    {
        self.windowId = windowId
    }
}

public struct GetMaintenanceWindowOutput: Swift.Sendable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The date the maintenance window was created.
    public var createdDate: Foundation.Date?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// The description of the maintenance window.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int?
    /// Indicates whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The date the maintenance window was last modified.
    public var modifiedDate: Foundation.Date?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The next time the maintenance window will actually run, taking into account any specified times for the maintenance window to become active or inactive.
    public var nextExecutionTime: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init(
        allowUnassociatedTargets: Swift.Bool = false,
        createdDate: Foundation.Date? = nil,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int? = nil,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        modifiedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        nextExecutionTime: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.createdDate = createdDate
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.modifiedDate = modifiedDate
        self.name = name
        self.nextExecutionTime = nextExecutionTime
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

extension GetMaintenanceWindowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowOutput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), createdDate: \(Swift.String(describing: createdDate)), cutoff: \(Swift.String(describing: cutoff)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), modifiedDate: \(Swift.String(describing: modifiedDate)), name: \(Swift.String(describing: name)), nextExecutionTime: \(Swift.String(describing: nextExecutionTime)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\")"}
}

public struct GetMaintenanceWindowExecutionInput: Swift.Sendable {
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        windowExecutionId: Swift.String? = nil
    )
    {
        self.windowExecutionId = windowExecutionId
    }
}

public struct GetMaintenanceWindowExecutionOutput: Swift.Sendable {
    /// The time the maintenance window finished running.
    public var endTime: Foundation.Date?
    /// The time the maintenance window started running.
    public var startTime: Foundation.Date?
    /// The status of the maintenance window execution.
    public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The ID of the task executions from the maintenance window execution.
    public var taskIds: [Swift.String]?
    /// The ID of the maintenance window execution.
    public var windowExecutionId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        startTime: Foundation.Date? = nil,
        status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskIds: [Swift.String]? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskIds = taskIds
        self.windowExecutionId = windowExecutionId
    }
}

public struct GetMaintenanceWindowExecutionTaskInput: Swift.Sendable {
    /// The ID of the specific task execution in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution that includes the task.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

public struct GetMaintenanceWindowExecutionTaskOutput: Swift.Sendable {
    /// The details for the CloudWatch alarm you applied to your maintenance window task.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// The time the task execution completed.
    public var endTime: Foundation.Date?
    /// The defined maximum number of task executions that could be run in parallel.
    public var maxConcurrency: Swift.String?
    /// The defined maximum number of task execution errors allowed before scheduling of the task execution would have been stopped.
    public var maxErrors: Swift.String?
    /// The priority of the task.
    public var priority: Swift.Int
    /// The role that was assumed when running the task.
    public var serviceRole: Swift.String?
    /// The time the task execution started.
    public var startTime: Foundation.Date?
    /// The status of the task.
    public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Not available for all status values.
    public var statusDetails: Swift.String?
    /// The Amazon Resource Name (ARN) of the task that ran.
    public var taskArn: Swift.String?
    /// The ID of the specific task execution in the maintenance window task that was retrieved.
    public var taskExecutionId: Swift.String?
    /// The parameters passed to the task when it was run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format:
    ///
    /// * Key: string, between 1 and 255 characters
    ///
    /// * Value: an array of strings, each between 1 and 255 characters
    public var taskParameters: [[Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]]?
    /// The CloudWatch alarms that were invoked by the maintenance window task.
    public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?
    /// The type of task that was run.
    public var type: SSMClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window execution that includes the task.
    public var windowExecutionId: Swift.String?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        endTime: Foundation.Date? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRole: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskArn: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskParameters: [[Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]]? = nil,
        triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil,
        type: SSMClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.endTime = endTime
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.priority = priority
        self.serviceRole = serviceRole
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskArn = taskArn
        self.taskExecutionId = taskExecutionId
        self.taskParameters = taskParameters
        self.triggeredAlarms = triggeredAlarms
        self.type = type
        self.windowExecutionId = windowExecutionId
    }
}

extension GetMaintenanceWindowExecutionTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskOutput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), endTime: \(Swift.String(describing: endTime)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), priority: \(Swift.String(describing: priority)), serviceRole: \(Swift.String(describing: serviceRole)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskArn: \(Swift.String(describing: taskArn)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), triggeredAlarms: \(Swift.String(describing: triggeredAlarms)), type: \(Swift.String(describing: type)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), taskParameters: \"CONTENT_REDACTED\")"}
}

public struct GetMaintenanceWindowExecutionTaskInvocationInput: Swift.Sendable {
    /// The invocation ID to retrieve.
    /// This member is required.
    public var invocationId: Swift.String?
    /// The ID of the specific task in the maintenance window task that should be retrieved.
    /// This member is required.
    public var taskId: Swift.String?
    /// The ID of the maintenance window execution for which the task is a part.
    /// This member is required.
    public var windowExecutionId: Swift.String?

    public init(
        invocationId: Swift.String? = nil,
        taskId: Swift.String? = nil,
        windowExecutionId: Swift.String? = nil
    )
    {
        self.invocationId = invocationId
        self.taskId = taskId
        self.windowExecutionId = windowExecutionId
    }
}

public struct GetMaintenanceWindowExecutionTaskInvocationOutput: Swift.Sendable {
    /// The time that the task finished running on the target.
    public var endTime: Foundation.Date?
    /// The execution ID.
    public var executionId: Swift.String?
    /// The invocation ID.
    public var invocationId: Swift.String?
    /// User-provided value to be included in any Amazon CloudWatch Events or Amazon EventBridge events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The parameters used at the time that the task ran.
    public var parameters: Swift.String?
    /// The time that the task started running on the target.
    public var startTime: Foundation.Date?
    /// The task status for an invocation.
    public var status: SSMClientTypes.MaintenanceWindowExecutionStatus?
    /// The details explaining the status. Details are only available for certain status values.
    public var statusDetails: Swift.String?
    /// The task execution ID.
    public var taskExecutionId: Swift.String?
    /// Retrieves the task type for a maintenance window.
    public var taskType: SSMClientTypes.MaintenanceWindowTaskType?
    /// The maintenance window execution ID.
    public var windowExecutionId: Swift.String?
    /// The maintenance window target ID.
    public var windowTargetId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        executionId: Swift.String? = nil,
        invocationId: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        parameters: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: SSMClientTypes.MaintenanceWindowExecutionStatus? = nil,
        statusDetails: Swift.String? = nil,
        taskExecutionId: Swift.String? = nil,
        taskType: SSMClientTypes.MaintenanceWindowTaskType? = nil,
        windowExecutionId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.executionId = executionId
        self.invocationId = invocationId
        self.ownerInformation = ownerInformation
        self.parameters = parameters
        self.startTime = startTime
        self.status = status
        self.statusDetails = statusDetails
        self.taskExecutionId = taskExecutionId
        self.taskType = taskType
        self.windowExecutionId = windowExecutionId
        self.windowTargetId = windowTargetId
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowExecutionTaskInvocationOutput(endTime: \(Swift.String(describing: endTime)), executionId: \(Swift.String(describing: executionId)), invocationId: \(Swift.String(describing: invocationId)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), taskExecutionId: \(Swift.String(describing: taskExecutionId)), taskType: \(Swift.String(describing: taskType)), windowExecutionId: \(Swift.String(describing: windowExecutionId)), windowTargetId: \(Swift.String(describing: windowTargetId)), ownerInformation: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\")"}
}

public struct GetMaintenanceWindowTaskInput: Swift.Sendable {
    /// The maintenance window ID that includes the task to retrieve.
    /// This member is required.
    public var windowId: Swift.String?
    /// The maintenance window task ID to retrieve.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init(
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

extension SSMClientTypes {

    /// The parameters for an AUTOMATION task type.
    public struct MaintenanceWindowAutomationParameters: Swift.Sendable {
        /// The version of an Automation runbook to use during task execution.
        public var documentVersion: Swift.String?
        /// The parameters for the AUTOMATION task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For AUTOMATION task types, Amazon Web Services Systems Manager ignores any values specified for these parameters.
        public var parameters: [Swift.String: [Swift.String]]?

        public init(
            documentVersion: Swift.String? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil
        )
        {
            self.documentVersion = documentVersion
            self.parameters = parameters
        }
    }
}

extension SSMClientTypes {

    /// The parameters for a LAMBDA task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowLambdaParameters: Swift.Sendable {
        /// Pass client-specific information to the Lambda function that you are invoking. You can then process the client information in your Lambda function as you choose through the context variable.
        public var clientContext: Swift.String?
        /// JSON to provide to your Lambda function as input.
        public var payload: Foundation.Data?
        /// (Optional) Specify an Lambda function version or alias name. If you specify a function version, the operation uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the operation uses the alias ARN to invoke the Lambda function version to which the alias points.
        public var qualifier: Swift.String?

        public init(
            clientContext: Swift.String? = nil,
            payload: Foundation.Data? = nil,
            qualifier: Swift.String? = nil
        )
        {
            self.clientContext = clientContext
            self.payload = payload
            self.qualifier = qualifier
        }
    }
}

extension SSMClientTypes.MaintenanceWindowLambdaParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowLambdaParameters(clientContext: \(Swift.String(describing: clientContext)), qualifier: \(Swift.String(describing: qualifier)), payload: \"CONTENT_REDACTED\")"}
}

extension SSMClientTypes {

    public enum NotificationEvent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case cancelled
        case failed
        case inProgress
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationEvent] {
            return [
                .all,
                .cancelled,
                .failed,
                .inProgress,
                .success,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum NotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case command
        case invocation
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .command,
                .invocation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .command: return "Command"
            case .invocation: return "Invocation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Configurations for sending notifications.
    public struct NotificationConfig: Swift.Sendable {
        /// An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        public var notificationArn: Swift.String?
        /// The different events for which you can receive notifications. To learn more about these events, see [Monitoring Systems Manager status changes using Amazon SNS notifications](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
        public var notificationEvents: [SSMClientTypes.NotificationEvent]?
        /// The type of notification.
        ///
        /// * Command: Receive notification when the status of a command changes.
        ///
        /// * Invocation: For commands sent to multiple managed nodes, receive notification on a per-node basis when the status of a command changes.
        public var notificationType: SSMClientTypes.NotificationType?

        public init(
            notificationArn: Swift.String? = nil,
            notificationEvents: [SSMClientTypes.NotificationEvent]? = nil,
            notificationType: SSMClientTypes.NotificationType? = nil
        )
        {
            self.notificationArn = notificationArn
            self.notificationEvents = notificationEvents
            self.notificationType = notificationType
        }
    }
}

extension SSMClientTypes {

    /// The parameters for a RUN_COMMAND task type. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For RUN_COMMAND tasks, Systems Manager uses specified values for TaskParameters and LoggingInfo only if no values are specified for TaskInvocationParameters.
    public struct MaintenanceWindowRunCommandParameters: Swift.Sendable {
        /// Configuration options for sending command output to Amazon CloudWatch Logs.
        public var cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig?
        /// Information about the commands to run.
        public var comment: Swift.String?
        /// The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        public var documentHash: Swift.String?
        /// SHA-256 or SHA-1. SHA-1 hashes have been deprecated.
        public var documentHashType: SSMClientTypes.DocumentHashType?
        /// The Amazon Web Services Systems Manager document (SSM document) version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Amazon Web Services CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT"
        ///     --document-version "\$LATEST"
        ///
        ///
        ///     --document-version "3"
        public var documentVersion: Swift.String?
        /// Configurations for sending notifications about command status changes on a per-managed node basis.
        public var notificationConfig: SSMClientTypes.NotificationConfig?
        /// The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        public var outputS3BucketName: Swift.String?
        /// The S3 bucket subfolder.
        public var outputS3KeyPrefix: Swift.String?
        /// The parameters for the RUN_COMMAND task execution.
        public var parameters: [Swift.String: [Swift.String]]?
        /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
        public var serviceRoleArn: Swift.String?
        /// If this time is reached and the command hasn't already started running, it doesn't run.
        public var timeoutSeconds: Swift.Int?

        public init(
            cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig? = nil,
            comment: Swift.String? = nil,
            documentHash: Swift.String? = nil,
            documentHashType: SSMClientTypes.DocumentHashType? = nil,
            documentVersion: Swift.String? = nil,
            notificationConfig: SSMClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            serviceRoleArn: Swift.String? = nil,
            timeoutSeconds: Swift.Int? = nil
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.comment = comment
            self.documentHash = documentHash
            self.documentHashType = documentHashType
            self.documentVersion = documentVersion
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.parameters = parameters
            self.serviceRoleArn = serviceRoleArn
            self.timeoutSeconds = timeoutSeconds
        }
    }
}

extension SSMClientTypes.MaintenanceWindowRunCommandParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowRunCommandParameters(cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), comment: \(Swift.String(describing: comment)), documentHash: \(Swift.String(describing: documentHash)), documentHashType: \(Swift.String(describing: documentHashType)), documentVersion: \(Swift.String(describing: documentVersion)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)), parameters: \"CONTENT_REDACTED\")"}
}

extension SSMClientTypes {

    /// The parameters for a STEP_FUNCTIONS task. For information about specifying and updating task parameters, see [RegisterTaskWithMaintenanceWindow] and [UpdateMaintenanceWindowTask]. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. For Step Functions tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.
    public struct MaintenanceWindowStepFunctionsParameters: Swift.Sendable {
        /// The inputs for the STEP_FUNCTIONS task.
        public var input: Swift.String?
        /// The name of the STEP_FUNCTIONS task.
        public var name: Swift.String?

        public init(
            input: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.input = input
            self.name = name
        }
    }
}

extension SSMClientTypes.MaintenanceWindowStepFunctionsParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MaintenanceWindowStepFunctionsParameters(name: \(Swift.String(describing: name)), input: \"CONTENT_REDACTED\")"}
}

extension SSMClientTypes {

    /// The parameters for task execution.
    public struct MaintenanceWindowTaskInvocationParameters: Swift.Sendable {
        /// The parameters for an AUTOMATION task type.
        public var automation: SSMClientTypes.MaintenanceWindowAutomationParameters?
        /// The parameters for a LAMBDA task type.
        public var lambda: SSMClientTypes.MaintenanceWindowLambdaParameters?
        /// The parameters for a RUN_COMMAND task type.
        public var runCommand: SSMClientTypes.MaintenanceWindowRunCommandParameters?
        /// The parameters for a STEP_FUNCTIONS task type.
        public var stepFunctions: SSMClientTypes.MaintenanceWindowStepFunctionsParameters?

        public init(
            automation: SSMClientTypes.MaintenanceWindowAutomationParameters? = nil,
            lambda: SSMClientTypes.MaintenanceWindowLambdaParameters? = nil,
            runCommand: SSMClientTypes.MaintenanceWindowRunCommandParameters? = nil,
            stepFunctions: SSMClientTypes.MaintenanceWindowStepFunctionsParameters? = nil
        )
        {
            self.automation = automation
            self.lambda = lambda
            self.runCommand = runCommand
            self.stepFunctions = stepFunctions
        }
    }
}

public struct GetMaintenanceWindowTaskOutput: Swift.Sendable {
    /// The details for the CloudWatch alarm you applied to your maintenance window task.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// The action to take on tasks when the maintenance window cutoff time is reached. CONTINUE_TASK means that tasks continue to run. For Automation, Lambda, Step Functions tasks, CANCEL_TASK means that currently running task invocations continue, but no new task invocations are started. For Run Command tasks, CANCEL_TASK means the system attempts to stop the task by sending a CancelCommand operation.
    public var cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The retrieved task description.
    public var description: Swift.String?
    /// The location in Amazon Simple Storage Service (Amazon S3) where the task results are logged. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SSMClientTypes.LoggingInfo?
    /// The maximum number of targets allowed to run this task in parallel. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before the task stops being scheduled. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1, which may be reported in the response to this command. This value doesn't affect the running of your task and can be ignored.
    public var maxErrors: Swift.String?
    /// The retrieved task name.
    public var name: Swift.String?
    /// The priority of the task when it runs. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
    public var serviceRoleArn: Swift.String?
    /// The targets where the task should run.
    public var targets: [SSMClientTypes.Target]?
    /// The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types, the value of TaskArn is the SSM document name/ARN. For LAMBDA tasks, the value is the function name/ARN. For STEP_FUNCTIONS tasks, the value is the state machine ARN.
    public var taskArn: Swift.String?
    /// The parameters to pass to the task when it runs.
    public var taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to pass to the task when it runs. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task to run.
    public var taskType: SSMClientTypes.MaintenanceWindowTaskType?
    /// The retrieved maintenance window ID.
    public var windowId: Swift.String?
    /// The retrieved maintenance window task ID.
    public var windowTaskId: Swift.String?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SSMClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SSMClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

extension GetMaintenanceWindowTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMaintenanceWindowTaskOutput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskType: \(Swift.String(describing: taskType)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)), description: \"CONTENT_REDACTED\", taskParameters: \"CONTENT_REDACTED\")"}
}

public struct GetOpsItemInput: Swift.Sendable {
    /// The OpsItem Amazon Resource Name (ARN).
    public var opsItemArn: Swift.String?
    /// The ID of the OpsItem that you want to get.
    /// This member is required.
    public var opsItemId: Swift.String?

    public init(
        opsItemArn: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.opsItemArn = opsItemArn
        self.opsItemId = opsItemId
    }
}

extension SSMClientTypes {

    /// Operations engineers and IT professionals use Amazon Web Services Systems Manager OpsCenter to view, investigate, and remediate operational work items (OpsItems) impacting the performance and health of their Amazon Web Services resources. OpsCenter is integrated with Amazon EventBridge and Amazon CloudWatch. This means you can configure these services to automatically create an OpsItem in OpsCenter when a CloudWatch alarm enters the ALARM state or when EventBridge processes an event from any Amazon Web Services service that publishes events. Configuring Amazon CloudWatch alarms and EventBridge events to automatically create OpsItems allows you to quickly diagnose and remediate issues with Amazon Web Services resources from a single console. To help you diagnose issues, each OpsItem includes contextually relevant information such as the name and ID of the Amazon Web Services resource that generated the OpsItem, alarm or event details, alarm history, and an alarm timeline graph. For the Amazon Web Services resource, OpsCenter aggregates information from Config, CloudTrail logs, and EventBridge, so you don't have to navigate across multiple console pages during your investigation. For more information, see [Amazon Web Services Systems Manager OpsCenter](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter.html) in the Amazon Web Services Systems Manager User Guide.
    public struct OpsItem: Swift.Sendable {
        /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualEndTime: Foundation.Date?
        /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
        public var actualStartTime: Foundation.Date?
        /// An OpsItem category. Category options include: Availability, Cost, Performance, Recovery, Security.
        public var category: Swift.String?
        /// The ARN of the Amazon Web Services account that created the OpsItem.
        public var createdBy: Swift.String?
        /// The date and time the OpsItem was created.
        public var createdTime: Foundation.Date?
        /// The OpsItem description.
        public var description: Swift.String?
        /// The ARN of the Amazon Web Services account that last updated the OpsItem.
        public var lastModifiedBy: Swift.String?
        /// The date and time the OpsItem was last updated.
        public var lastModifiedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of an Amazon Simple Notification Service (Amazon SNS) topic where notifications are sent when this OpsItem is edited or changed.
        public var notifications: [SSMClientTypes.OpsItemNotification]?
        /// Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-manually-create-OpsItems.html) in the Amazon Web Services Systems Manager User Guide.
        public var operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]?
        /// The OpsItem Amazon Resource Name (ARN).
        public var opsItemArn: Swift.String?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The type of OpsItem. Systems Manager supports the following types of OpsItems:
        ///
        /// * /aws/issue This type of OpsItem is used for default OpsItems created by OpsCenter.
        ///
        /// * /aws/changerequest This type of OpsItem is used by Change Manager for reviewing and approving or rejecting change requests.
        ///
        /// * /aws/insight This type of OpsItem is used by OpsCenter for aggregating and reporting on duplicate OpsItems.
        public var opsItemType: Swift.String?
        /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedEndTime: Foundation.Date?
        /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
        public var plannedStartTime: Foundation.Date?
        /// The importance of this OpsItem in relation to other OpsItems in the system.
        public var priority: Swift.Int?
        /// One or more OpsItems that share something in common with the current OpsItem. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
        public var relatedOpsItems: [SSMClientTypes.RelatedOpsItem]?
        /// The severity of the OpsItem. Severity options range from 1 to 4.
        public var severity: Swift.String?
        /// The origin of the OpsItem, such as Amazon EC2 or Systems Manager. The impacted resource is a subset of source.
        public var source: Swift.String?
        /// The OpsItem status. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html) in the Amazon Web Services Systems Manager User Guide.
        public var status: SSMClientTypes.OpsItemStatus?
        /// A short heading that describes the nature of the OpsItem and the impacted resource.
        public var title: Swift.String?
        /// The version of this OpsItem. Each time the OpsItem is edited the version number increments by one.
        public var version: Swift.String?

        public init(
            actualEndTime: Foundation.Date? = nil,
            actualStartTime: Foundation.Date? = nil,
            category: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModifiedBy: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            notifications: [SSMClientTypes.OpsItemNotification]? = nil,
            operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]? = nil,
            opsItemArn: Swift.String? = nil,
            opsItemId: Swift.String? = nil,
            opsItemType: Swift.String? = nil,
            plannedEndTime: Foundation.Date? = nil,
            plannedStartTime: Foundation.Date? = nil,
            priority: Swift.Int? = nil,
            relatedOpsItems: [SSMClientTypes.RelatedOpsItem]? = nil,
            severity: Swift.String? = nil,
            source: Swift.String? = nil,
            status: SSMClientTypes.OpsItemStatus? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.actualEndTime = actualEndTime
            self.actualStartTime = actualStartTime
            self.category = category
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.notifications = notifications
            self.operationalData = operationalData
            self.opsItemArn = opsItemArn
            self.opsItemId = opsItemId
            self.opsItemType = opsItemType
            self.plannedEndTime = plannedEndTime
            self.plannedStartTime = plannedStartTime
            self.priority = priority
            self.relatedOpsItems = relatedOpsItems
            self.severity = severity
            self.source = source
            self.status = status
            self.title = title
            self.version = version
        }
    }
}

public struct GetOpsItemOutput: Swift.Sendable {
    /// The OpsItem.
    public var opsItem: SSMClientTypes.OpsItem?

    public init(
        opsItem: SSMClientTypes.OpsItem? = nil
    )
    {
        self.opsItem = opsItem
    }
}

public struct GetOpsMetadataInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of an OpsMetadata Object to view.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsMetadataArn = opsMetadataArn
    }
}

public struct GetOpsMetadataOutput: Swift.Sendable {
    /// OpsMetadata for an Application Manager application.
    public var metadata: [Swift.String: SSMClientTypes.MetadataValue]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The resource ID of the Application Manager application.
    public var resourceId: Swift.String?

    public init(
        metadata: [Swift.String: SSMClientTypes.MetadataValue]? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.metadata = metadata
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

extension SSMClientTypes {

    public enum OpsFilterOperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginWith
        case equal
        case exists
        case greaterThan
        case lessThan
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsFilterOperatorType] {
            return [
                .beginWith,
                .equal,
                .exists,
                .greaterThan,
                .lessThan,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginWith: return "BeginWith"
            case .equal: return "Equal"
            case .exists: return "Exists"
            case .greaterThan: return "GreaterThan"
            case .lessThan: return "LessThan"
            case .notEqual: return "NotEqual"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// A filter for viewing OpsData summaries.
    public struct OpsFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: Swift.String?
        /// The type of filter.
        public var type: SSMClientTypes.OpsFilterOperatorType?
        /// The filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            type: SSMClientTypes.OpsFilterOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }
}

extension SSMClientTypes {

    /// The OpsItem data type to return.
    public struct OpsResultAttribute: Swift.Sendable {
        /// Name of the data type. Valid value: AWS:OpsItem, AWS:EC2InstanceInformation, AWS:OpsItemTrendline, or AWS:ComplianceSummary.
        /// This member is required.
        public var typeName: Swift.String?

        public init(
            typeName: Swift.String? = nil
        )
        {
            self.typeName = typeName
        }
    }
}

extension SSMClientTypes {

    /// The OpsData summary.
    public struct OpsEntityItem: Swift.Sendable {
        /// The time the OpsData was captured.
        public var captureTime: Swift.String?
        /// The details of an OpsData summary.
        public var content: [[Swift.String: Swift.String]]?

        public init(
            captureTime: Swift.String? = nil,
            content: [[Swift.String: Swift.String]]? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
        }
    }
}

extension SSMClientTypes {

    /// The result of the query.
    public struct OpsEntity: Swift.Sendable {
        /// The data returned by the query.
        public var data: [Swift.String: SSMClientTypes.OpsEntityItem]?
        /// The query ID.
        public var id: Swift.String?

        public init(
            data: [Swift.String: SSMClientTypes.OpsEntityItem]? = nil,
            id: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
        }
    }
}

public struct GetOpsSummaryOutput: Swift.Sendable {
    /// The list of aggregated details and filtered OpsData.
    public var entities: [SSMClientTypes.OpsEntity]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        entities: [SSMClientTypes.OpsEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

/// The query key ID isn't valid.
public struct InvalidKeyId: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidKeyId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified parameter version wasn't found. Verify the parameter name and version, and try again.
public struct ParameterVersionNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterVersionNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetParameterInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the parameter that you want to query. For parameters shared with you from another account, you must use the full ARN. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version". For more information about shared parameters, see [Working with shared parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-shared-parameters.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var name: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool?

    public init(
        name: Swift.String? = nil,
        withDecryption: Swift.Bool? = false
    )
    {
        self.name = name
        self.withDecryption = withDecryption
    }
}

extension SSMClientTypes {

    /// An Amazon Web Services Systems Manager parameter in Parameter Store.
    public struct Parameter: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the parameter.
        public var arn: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Date the parameter was last changed or updated and the parameter version was created.
        public var lastModifiedDate: Foundation.Date?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats: parameter_name:version parameter_name:label
        public var selector: Swift.String?
        /// Applies to parameters that reference information in other Amazon Web Services services. SourceResult is the raw result or response from the source.
        public var sourceResult: Swift.String?
        /// The type of parameter. Valid values include the following: String, StringList, and SecureString. If type is StringList, the system returns a comma-separated string with no spaces between commas in the Value field.
        public var type: SSMClientTypes.ParameterType?
        /// The parameter value. If type is StringList, the system returns a comma-separated string with no spaces between commas in the Value field.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init(
            arn: Swift.String? = nil,
            dataType: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            selector: Swift.String? = nil,
            sourceResult: Swift.String? = nil,
            type: SSMClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.arn = arn
            self.dataType = dataType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.selector = selector
            self.sourceResult = sourceResult
            self.type = type
            self.value = value
            self.version = version
        }
    }
}

extension SSMClientTypes.Parameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Parameter(arn: \(Swift.String(describing: arn)), dataType: \(Swift.String(describing: dataType)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), name: \(Swift.String(describing: name)), selector: \(Swift.String(describing: selector)), sourceResult: \(Swift.String(describing: sourceResult)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), value: \"CONTENT_REDACTED\")"}
}

public struct GetParameterOutput: Swift.Sendable {
    /// Information about a parameter.
    public var parameter: SSMClientTypes.Parameter?

    public init(
        parameter: SSMClientTypes.Parameter? = nil
    )
    {
        self.parameter = parameter
    }
}

public struct GetParameterHistoryInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The name or Amazon Resource Name (ARN) of the parameter for which you want to review history. For parameters shared with you from another account, you must use the full ARN.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        withDecryption: Swift.Bool? = false
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.withDecryption = withDecryption
    }
}

extension SSMClientTypes {

    /// Information about parameter usage.
    public struct ParameterHistory: Swift.Sendable {
        /// Parameter names can include the following letters and symbols. a-zA-Z0-9_.-
        public var allowedPattern: Swift.String?
        /// The data type of the parameter, such as text or aws:ec2:image. The default is text.
        public var dataType: Swift.String?
        /// Information about the parameter.
        public var description: Swift.String?
        /// The alias of the Key Management Service (KMS) key used to encrypt the parameter. Applies to SecureString parameters only
        public var keyId: Swift.String?
        /// Labels assigned to the parameter version.
        public var labels: [Swift.String]?
        /// Date the parameter was last changed or updated.
        public var lastModifiedDate: Foundation.Date?
        /// Amazon Resource Name (ARN) of the Amazon Web Services user who last changed the parameter.
        public var lastModifiedUser: Swift.String?
        /// The name of the parameter.
        public var name: Swift.String?
        /// Information about the policies assigned to a parameter. [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html) in the Amazon Web Services Systems Manager User Guide.
        public var policies: [SSMClientTypes.ParameterInlinePolicy]?
        /// The parameter tier.
        public var tier: SSMClientTypes.ParameterTier?
        /// The type of parameter used.
        public var type: SSMClientTypes.ParameterType?
        /// The parameter value.
        public var value: Swift.String?
        /// The parameter version.
        public var version: Swift.Int

        public init(
            allowedPattern: Swift.String? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            name: Swift.String? = nil,
            policies: [SSMClientTypes.ParameterInlinePolicy]? = nil,
            tier: SSMClientTypes.ParameterTier? = nil,
            type: SSMClientTypes.ParameterType? = nil,
            value: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.allowedPattern = allowedPattern
            self.dataType = dataType
            self.description = description
            self.keyId = keyId
            self.labels = labels
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.name = name
            self.policies = policies
            self.tier = tier
            self.type = type
            self.value = value
            self.version = version
        }
    }
}

extension SSMClientTypes.ParameterHistory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterHistory(allowedPattern: \(Swift.String(describing: allowedPattern)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), keyId: \(Swift.String(describing: keyId)), labels: \(Swift.String(describing: labels)), lastModifiedDate: \(Swift.String(describing: lastModifiedDate)), lastModifiedUser: \(Swift.String(describing: lastModifiedUser)), name: \(Swift.String(describing: name)), policies: \(Swift.String(describing: policies)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), value: \"CONTENT_REDACTED\")"}
}

public struct GetParameterHistoryOutput: Swift.Sendable {
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// A list of parameters returned by the request.
    public var parameters: [SSMClientTypes.ParameterHistory]?

    public init(
        nextToken: Swift.String? = nil,
        parameters: [SSMClientTypes.ParameterHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

public struct GetParametersInput: Swift.Sendable {
    /// The names or Amazon Resource Names (ARNs) of the parameters that you want to query. For parameters shared with you from another account, you must use the full ARNs. To query by parameter label, use "Name": "name:label". To query by parameter version, use "Name": "name:version". The results for GetParameters requests are listed in alphabetical order in query responses. For information about shared parameters, see [Working with shared parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-shared-parameters.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var names: [Swift.String]?
    /// Return decrypted secure string value. Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.
    public var withDecryption: Swift.Bool?

    public init(
        names: [Swift.String]? = nil,
        withDecryption: Swift.Bool? = false
    )
    {
        self.names = names
        self.withDecryption = withDecryption
    }
}

public struct GetParametersOutput: Swift.Sendable {
    /// A list of parameters that aren't formatted correctly or don't run during an execution.
    public var invalidParameters: [Swift.String]?
    /// A list of details for a parameter.
    public var parameters: [SSMClientTypes.Parameter]?

    public init(
        invalidParameters: [Swift.String]? = nil,
        parameters: [SSMClientTypes.Parameter]? = nil
    )
    {
        self.invalidParameters = invalidParameters
        self.parameters = parameters
    }
}

public struct GetParametersByPathInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Filters to limit the request results. The following Key values are supported for GetParametersByPath: Type, KeyId, and Label. The following Key values aren't supported for GetParametersByPath: tag, DataType, Name, Path, and Tier.
    public var parameterFilters: [SSMClientTypes.ParameterStringFilter]?
    /// The hierarchy for the parameter. Hierarchies start with a forward slash (/). The hierarchy is the parameter name except the last part of the parameter. For the API call to succeed, the last part of the parameter name can't be in the path. A parameter name hierarchy can have a maximum of 15 levels. Here is an example of a hierarchy: /Finance/Prod/IAD/WinServ2016/license33
    /// This member is required.
    public var path: Swift.String?
    /// Retrieve all parameters within a hierarchy. If a user has access to a path, then the user can access all levels of that path. For example, if a user has permission to access path /a, then the user can also access /a/b. Even if a user has explicitly been denied access in IAM for parameter /a/b, they can still call the GetParametersByPath API operation recursively for /a and view /a/b.
    public var recursive: Swift.Bool?
    /// Retrieve all parameters in a hierarchy with their value decrypted.
    public var withDecryption: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        parameterFilters: [SSMClientTypes.ParameterStringFilter]? = nil,
        path: Swift.String? = nil,
        recursive: Swift.Bool? = false,
        withDecryption: Swift.Bool? = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterFilters = parameterFilters
        self.path = path
        self.recursive = recursive
        self.withDecryption = withDecryption
    }
}

public struct GetParametersByPathOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of parameters found in the specified hierarchy.
    public var parameters: [SSMClientTypes.Parameter]?

    public init(
        nextToken: Swift.String? = nil,
        parameters: [SSMClientTypes.Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

public struct GetPatchBaselineInput: Swift.Sendable {
    /// The ID of the patch baseline to retrieve. To retrieve information about an Amazon Web Services managed patch baseline, specify the full Amazon Resource Name (ARN) of the baseline. For example, for the baseline AWS-AmazonLinuxDefaultPatchBaseline, specify arn:aws:ssm:us-east-2:733109147000:patchbaseline/pb-0e392de35e7c563b7 instead of pb-0e392de35e7c563b7.
    /// This member is required.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

public struct GetPatchBaselineOutput: Swift.Sendable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SSMClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// Returns the specified compliance severity level for approved patches in the patch baseline.
    public var approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool?
    /// The ID of the retrieved patch baseline.
    public var baselineId: Swift.String?
    /// The date the patch baseline was created.
    public var createdDate: Foundation.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SSMClientTypes.PatchFilterGroup?
    /// The date the patch baseline was last modified.
    public var modifiedDate: Foundation.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// Returns the operating system specified for the patch baseline.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// Patch groups included in the patch baseline.
    public var patchGroups: [Swift.String]?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SSMClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SSMClientTypes.PatchSource]?

    public init(
        approvalRules: SSMClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool? = false,
        baselineId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SSMClientTypes.PatchFilterGroup? = nil,
        modifiedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        patchGroups: [Swift.String]? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SSMClientTypes.PatchAction? = nil,
        sources: [SSMClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.patchGroups = patchGroups
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

public struct GetPatchBaselineForPatchGroupInput: Swift.Sendable {
    /// Returns the operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// The name of the patch group whose patch baseline should be retrieved.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init(
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

public struct GetPatchBaselineForPatchGroupOutput: Swift.Sendable {
    /// The ID of the patch baseline that should be used for the patch group.
    public var baselineId: Swift.String?
    /// The operating system rule specified for patch groups using the patch baseline.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// The name of the patch group.
    public var patchGroup: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.operatingSystem = operatingSystem
        self.patchGroup = patchGroup
    }
}

public struct GetResourcePoliciesInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) of the resource to which the policies are attached.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension SSMClientTypes {

    /// A resource policy helps you to define the IAM entity (for example, an Amazon Web Services account) that can manage your Systems Manager resources. Currently, OpsItemGroup is the only resource that supports Systems Manager resource policies. The resource policy for OpsItemGroup enables Amazon Web Services accounts to view and interact with OpsCenter operational work items (OpsItems).
    public struct GetResourcePoliciesResponseEntry: Swift.Sendable {
        /// A resource policy helps you to define the IAM entity (for example, an Amazon Web Services account) that can manage your Systems Manager resources. Currently, OpsItemGroup is the only resource that supports Systems Manager resource policies. The resource policy for OpsItemGroup enables Amazon Web Services accounts to view and interact with OpsCenter operational work items (OpsItems).
        public var policy: Swift.String?
        /// ID of the current policy version. The hash helps to prevent a situation where multiple users attempt to overwrite a policy. You must provide this hash when updating or deleting a policy.
        public var policyHash: Swift.String?
        /// A policy ID.
        public var policyId: Swift.String?

        public init(
            policy: Swift.String? = nil,
            policyHash: Swift.String? = nil,
            policyId: Swift.String? = nil
        )
        {
            self.policy = policy
            self.policyHash = policyHash
            self.policyId = policyId
        }
    }
}

public struct GetResourcePoliciesOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// An array of the Policy object.
    public var policies: [SSMClientTypes.GetResourcePoliciesResponseEntry]?

    public init(
        nextToken: Swift.String? = nil,
        policies: [SSMClientTypes.GetResourcePoliciesResponseEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

/// The specified service setting wasn't found. Either the service name or the setting hasn't been provisioned by the Amazon Web Services service team.
public struct ServiceSettingNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceSettingNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request body of the GetServiceSetting API operation.
public struct GetServiceSettingInput: Swift.Sendable {
    /// The ID of the service setting to get. The setting ID can be one of the following.
    ///
    /// * /ssm/managed-instance/default-ec2-instance-management-role
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/managed-instance/activation-tier
    ///
    /// * /ssm/opsinsights/opscenter
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    /// This member is required.
    public var settingId: Swift.String?

    public init(
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

extension SSMClientTypes {

    /// The service setting data structure. ServiceSetting is an account-level setting for an Amazon Web Services service. This setting defines how a user interacts with or uses a service or a feature of a service. For example, if an Amazon Web Services service charges money to the account based on feature or service usage, then the Amazon Web Services service team might create a default setting of "false". This means the user can't use this feature unless they change the setting to "true" and intentionally opt in for a paid feature. Services map a SettingId object to a setting value. Amazon Web Services services teams define the default value for a SettingId. You can't create a new SettingId, but you can overwrite the default value if you have the ssm:UpdateServiceSetting permission for the setting. Use the [UpdateServiceSetting] API operation to change the default setting. Or, use the [ResetServiceSetting] to change the value back to the original value defined by the Amazon Web Services service team.
    public struct ServiceSetting: Swift.Sendable {
        /// The ARN of the service setting.
        public var arn: Swift.String?
        /// The last time the service setting was modified.
        public var lastModifiedDate: Foundation.Date?
        /// The ARN of the last modified user. This field is populated only if the setting value was overwritten.
        public var lastModifiedUser: Swift.String?
        /// The ID of the service setting.
        public var settingId: Swift.String?
        /// The value of the service setting.
        public var settingValue: Swift.String?
        /// The status of the service setting. The value can be Default, Customized or PendingUpdate.
        ///
        /// * Default: The current setting uses a default value provisioned by the Amazon Web Services service team.
        ///
        /// * Customized: The current setting use a custom value specified by the customer.
        ///
        /// * PendingUpdate: The current setting uses a default or custom value, but a setting change request is pending approval.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            settingId: Swift.String? = nil,
            settingValue: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.settingId = settingId
            self.settingValue = settingValue
            self.status = status
        }
    }
}

/// The query result body of the GetServiceSetting API operation.
public struct GetServiceSettingOutput: Swift.Sendable {
    /// The query result of the current service setting.
    public var serviceSetting: SSMClientTypes.ServiceSetting?

    public init(
        serviceSetting: SSMClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

/// A parameter version can have a maximum of ten labels.
public struct ParameterVersionLabelLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterVersionLabelLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct LabelParameterVersionInput: Swift.Sendable {
    /// One or more labels to attach to the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The parameter name on which you want to attach one or more labels. You can't enter the Amazon Resource Name (ARN) for a parameter, only the parameter name itself.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter on which you want to attach one or more labels. If no version is specified, the system attaches the label to the latest version.
    public var parameterVersion: Swift.Int?

    public init(
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int? = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

public struct LabelParameterVersionOutput: Swift.Sendable {
    /// The label doesn't meet the requirements. For information about parameter label requirements, see [Working with parameter labels](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html) in the Amazon Web Services Systems Manager User Guide.
    public var invalidLabels: [Swift.String]?
    /// The version of the parameter that has been labeled.
    public var parameterVersion: Swift.Int

    public init(
        invalidLabels: [Swift.String]? = nil,
        parameterVersion: Swift.Int = 0
    )
    {
        self.invalidLabels = invalidLabels
        self.parameterVersion = parameterVersion
    }
}

extension SSMClientTypes {

    public enum AssociationFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associationid
        case associationname
        case instanceid
        case lastexecutedafter
        case lastexecutedbefore
        case name
        case resourcegroupname
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationFilterKey] {
            return [
                .associationid,
                .associationname,
                .instanceid,
                .lastexecutedafter,
                .lastexecutedbefore,
                .name,
                .resourcegroupname,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associationid: return "AssociationId"
            case .associationname: return "AssociationName"
            case .instanceid: return "InstanceId"
            case .lastexecutedafter: return "LastExecutedAfter"
            case .lastexecutedbefore: return "LastExecutedBefore"
            case .name: return "Name"
            case .resourcegroupname: return "ResourceGroupName"
            case .status: return "AssociationStatusName"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter.
    public struct AssociationFilter: Swift.Sendable {
        /// The name of the filter. InstanceId has been deprecated.
        /// This member is required.
        public var key: SSMClientTypes.AssociationFilterKey?
        /// The filter value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.AssociationFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListAssociationsInput: Swift.Sendable {
    /// One or more filters. Use a filter to return a more specific list of results. Filtering associations using the InstanceID attribute only returns legacy associations created using the InstanceID attribute. Associations targeting the managed node that are part of the Target Attributes ResourceGroup or Tags aren't returned.
    public var associationFilterList: [SSMClientTypes.AssociationFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        associationFilterList: [SSMClientTypes.AssociationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationFilterList = associationFilterList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Describes an association of a Amazon Web Services Systems Manager document (SSM document) and a managed node.
    public struct Association: Swift.Sendable {
        /// The ID created by the system when you create an association. An association is a binding between a document and a set of targets with a schedule.
        public var associationId: Swift.String?
        /// The association name.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The version of the document used in the association. If you change a document version for a State Manager association, Systems Manager immediately runs the association unless you previously specifed the apply-only-at-cron-interval parameter. State Manager doesn't support running associations that use a new version of a document if that document is shared from another account. State Manager always runs the default version of a document if shared from another account, even though the Systems Manager console shows that a new version was processed. If you want to run an association using a new version of a document shared form another account, you must set the document version to default.
        public var documentVersion: Swift.String?
        /// The number of hours that an association can run on specified targets. After the resulting cutoff time passes, associations that are currently running are cancelled, and no pending executions are started on remaining targets.
        public var duration: Swift.Int?
        /// The managed node ID.
        public var instanceId: Swift.String?
        /// The date on which the association was last run.
        public var lastExecutionDate: Foundation.Date?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// Information about the association.
        public var overview: SSMClientTypes.AssociationOverview?
        /// A cron expression that specifies a schedule when the association runs. The schedule runs in Coordinated Universal Time (UTC).
        public var scheduleExpression: Swift.String?
        /// Number of days to wait after the scheduled day to run an association.
        public var scheduleOffset: Swift.Int?
        /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The managed nodes targeted by the request to create an association. You can target all managed nodes in an Amazon Web Services account by specifying the InstanceIds key with a value of *.
        public var targets: [SSMClientTypes.Target]?

        public init(
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            duration: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            lastExecutionDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            overview: SSMClientTypes.AssociationOverview? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targets: [SSMClientTypes.Target]? = nil
        )
        {
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.documentVersion = documentVersion
            self.duration = duration
            self.instanceId = instanceId
            self.lastExecutionDate = lastExecutionDate
            self.name = name
            self.overview = overview
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.targetMaps = targetMaps
            self.targets = targets
        }
    }
}

public struct ListAssociationsOutput: Swift.Sendable {
    /// The associations.
    public var associations: [SSMClientTypes.Association]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        associations: [SSMClientTypes.Association]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

public struct ListAssociationVersionsInput: Swift.Sendable {
    /// The association ID for which you want to view all versions.
    /// This member is required.
    public var associationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Information about the association version.
    public struct AssociationVersionInfo: Swift.Sendable {
        /// By default, when you create a new associations, the system runs it immediately after it is created and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you create it. This parameter isn't supported for rate expressions.
        public var applyOnlyAtCronInterval: Swift.Bool
        /// The ID created by the system when the association was created.
        public var associationId: Swift.String?
        /// The name specified for the association version when the association version was created.
        public var associationName: Swift.String?
        /// The association version.
        public var associationVersion: Swift.String?
        /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents your associations are gated under. The associations for this version only run when that Change Calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
        public var calendarNames: [Swift.String]?
        /// The severity level that is assigned to the association.
        public var complianceSeverity: SSMClientTypes.AssociationComplianceSeverity?
        /// The date the association version was created.
        public var createdDate: Foundation.Date?
        /// The version of an Amazon Web Services Systems Manager document (SSM document) used when the association version was created.
        public var documentVersion: Swift.String?
        /// The number of hours that an association can run on specified targets. After the resulting cutoff time passes, associations that are currently running are cancelled, and no pending executions are started on remaining targets.
        public var duration: Swift.Int?
        /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
        public var maxConcurrency: Swift.String?
        /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
        public var maxErrors: Swift.String?
        /// The name specified when the association was created.
        public var name: Swift.String?
        /// The location in Amazon S3 specified for the association when the association version was created.
        public var outputLocation: SSMClientTypes.InstanceAssociationOutputLocation?
        /// Parameters specified when the association version was created.
        public var parameters: [Swift.String: [Swift.String]]?
        /// The cron or rate schedule specified for the association when the association version was created.
        public var scheduleExpression: Swift.String?
        /// Number of days to wait after the scheduled day to run an association.
        public var scheduleOffset: Swift.Int?
        /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
        public var syncCompliance: SSMClientTypes.AssociationSyncCompliance?
        /// The combination of Amazon Web Services Regions and Amazon Web Services accounts where you wanted to run the association when this association version was created.
        public var targetLocations: [SSMClientTypes.TargetLocation]?
        /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
        public var targetMaps: [[Swift.String: [Swift.String]]]?
        /// The targets specified for the association when the association version was created.
        public var targets: [SSMClientTypes.Target]?

        public init(
            applyOnlyAtCronInterval: Swift.Bool = false,
            associationId: Swift.String? = nil,
            associationName: Swift.String? = nil,
            associationVersion: Swift.String? = nil,
            calendarNames: [Swift.String]? = nil,
            complianceSeverity: SSMClientTypes.AssociationComplianceSeverity? = nil,
            createdDate: Foundation.Date? = nil,
            documentVersion: Swift.String? = nil,
            duration: Swift.Int? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            name: Swift.String? = nil,
            outputLocation: SSMClientTypes.InstanceAssociationOutputLocation? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            syncCompliance: SSMClientTypes.AssociationSyncCompliance? = nil,
            targetLocations: [SSMClientTypes.TargetLocation]? = nil,
            targetMaps: [[Swift.String: [Swift.String]]]? = nil,
            targets: [SSMClientTypes.Target]? = nil
        )
        {
            self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
            self.associationId = associationId
            self.associationName = associationName
            self.associationVersion = associationVersion
            self.calendarNames = calendarNames
            self.complianceSeverity = complianceSeverity
            self.createdDate = createdDate
            self.documentVersion = documentVersion
            self.duration = duration
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.name = name
            self.outputLocation = outputLocation
            self.parameters = parameters
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.syncCompliance = syncCompliance
            self.targetLocations = targetLocations
            self.targetMaps = targetMaps
            self.targets = targets
        }
    }
}

extension SSMClientTypes.AssociationVersionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociationVersionInfo(applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), createdDate: \(Swift.String(describing: createdDate)), documentVersion: \(Swift.String(describing: documentVersion)), duration: \(Swift.String(describing: duration)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targets: \(Swift.String(describing: targets)), parameters: \"CONTENT_REDACTED\")"}
}

public struct ListAssociationVersionsOutput: Swift.Sendable {
    /// Information about all versions of the association for the specified association ID.
    public var associationVersions: [SSMClientTypes.AssociationVersionInfo]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        associationVersions: [SSMClientTypes.AssociationVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associationVersions = associationVersions
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum CommandFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case documentName
        case executionStage
        case invokedAfter
        case invokedBefore
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandFilterKey] {
            return [
                .documentName,
                .executionStage,
                .invokedAfter,
                .invokedBefore,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .documentName: return "DocumentName"
            case .executionStage: return "ExecutionStage"
            case .invokedAfter: return "InvokedAfter"
            case .invokedBefore: return "InvokedBefore"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a command filter. A managed node ID can't be specified when a command status is Pending because the command hasn't run on the node yet.
    public struct CommandFilter: Swift.Sendable {
        /// The name of the filter. The ExecutionStage filter can't be used with the ListCommandInvocations operation, only with ListCommands.
        /// This member is required.
        public var key: SSMClientTypes.CommandFilterKey?
        /// The filter value. Valid values for each filter key are as follows:
        ///
        /// * InvokedAfter: Specify a timestamp to limit your results. For example, specify 2024-07-07T00:00:00Z to see a list of command executions occurring July 7, 2021, and later.
        ///
        /// * InvokedBefore: Specify a timestamp to limit your results. For example, specify 2024-07-07T00:00:00Z to see a list of command executions from before July 7, 2021.
        ///
        /// * Status: Specify a valid command status to see a list of all command executions with that status. The status choices depend on the API you call. The status values you can specify for ListCommands are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Incomplete
        ///
        /// * NoInstancesInTag
        ///
        /// * LimitExceeded
        ///
        ///
        /// The status values you can specify for ListCommandInvocations are:
        ///
        /// * Pending
        ///
        /// * InProgress
        ///
        /// * Delayed
        ///
        /// * Success
        ///
        /// * Cancelled
        ///
        /// * Failed
        ///
        /// * TimedOut (this includes both Delivery and Execution time outs)
        ///
        /// * AccessDenied
        ///
        /// * DeliveryTimedOut
        ///
        /// * ExecutionTimedOut
        ///
        /// * Undeliverable
        ///
        /// * InvalidPlatform
        ///
        /// * Terminated
        ///
        ///
        ///
        ///
        /// * DocumentName: Specify name of the Amazon Web Services Systems Manager document (SSM document) for which you want to see command execution results. For example, specify AWS-RunPatchBaseline to see command executions that used this SSM document to perform security patching operations on managed nodes.
        ///
        /// * ExecutionStage: Specify one of the following values (ListCommands operations only):
        ///
        /// * Executing: Returns a list of command executions that are currently still running.
        ///
        /// * Complete: Returns a list of command executions that have already completed.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.CommandFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListCommandInvocationsInput: Swift.Sendable {
    /// (Optional) The invocations for a specific command ID.
    public var commandId: Swift.String?
    /// (Optional) If set this returns the response of the command executions and any command output. The default value is false.
    public var details: Swift.Bool?
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.CommandFilter]?
    /// (Optional) The command execution details for a specific managed node ID.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        commandId: Swift.String? = nil,
        details: Swift.Bool? = false,
        filters: [SSMClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.details = details
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum CommandPluginStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandPluginStatus] {
            return [
                .cancelled,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes plugin details.
    public struct CommandPlugin: Swift.Sendable {
        /// The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin, aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or aws:updateSSMAgent.
        public var name: Swift.String?
        /// Output of the plugin execution.
        public var output: Swift.String?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: amzn-s3-demo-bucket/my-prefix/i-02573cafcfEXAMPLE/awsrunShellScriptamzn-s3-demo-bucket is the name of the S3 bucket; my-prefix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response: amzn-s3-demo-bucket/my-prefix/i-02573cafcfEXAMPLE/awsrunShellScriptamzn-s3-demo-bucket is the name of the S3 bucket; my-prefix is the name of the S3 prefix; i-02573cafcfEXAMPLE is the managed node ID; awsrunShellScript is the name of the plugin.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Amazon Web Services Systems Manager automatically determines the S3 bucket region.
        public var outputS3Region: Swift.String?
        /// A numeric response code generated after running the plugin.
        public var responseCode: Swift.Int
        /// The time the plugin stopped running. Could stop prematurely if, for example, a cancel command was sent.
        public var responseFinishDateTime: Foundation.Date?
        /// The time the plugin started running.
        public var responseStartDateTime: Foundation.Date?
        /// The URL for the complete text written by the plugin to stderr. If execution isn't yet complete, then this string is empty.
        public var standardErrorUrl: Swift.String?
        /// The URL for the complete text written by the plugin to stdout in Amazon S3. If the S3 bucket for the command wasn't specified, then this string is empty.
        public var standardOutputUrl: Swift.String?
        /// The status of this plugin. You can run a document with multiple plugins.
        public var status: SSMClientTypes.CommandPluginStatus?
        /// A detailed status of the plugin execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Cancelled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist, or it might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit, and they don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        public var statusDetails: Swift.String?

        public init(
            name: Swift.String? = nil,
            output: Swift.String? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            responseCode: Swift.Int = 0,
            responseFinishDateTime: Foundation.Date? = nil,
            responseStartDateTime: Foundation.Date? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SSMClientTypes.CommandPluginStatus? = nil,
            statusDetails: Swift.String? = nil
        )
        {
            self.name = name
            self.output = output
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.responseCode = responseCode
            self.responseFinishDateTime = responseFinishDateTime
            self.responseStartDateTime = responseStartDateTime
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
        }
    }
}

extension SSMClientTypes {

    /// An invocation is a copy of a command sent to a specific managed node. A command can apply to one or more managed nodes. A command invocation applies to one managed node. For example, if a user runs SendCommand against three managed nodes, then a command invocation is created for each requested managed node ID. A command invocation returns status and detail information about a command you ran.
    public struct CommandInvocation: Swift.Sendable {
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig?
        /// The command against which this invocation was requested.
        public var commandId: Swift.String?
        /// Plugins processed by the command.
        public var commandPlugins: [SSMClientTypes.CommandPlugin]?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The document name that was requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The managed node ID in which this invocation was requested.
        public var instanceId: Swift.String?
        /// The fully qualified host name of the managed node.
        public var instanceName: Swift.String?
        /// Configurations for sending notifications about command status changes on a per managed node basis.
        public var notificationConfig: SSMClientTypes.NotificationConfig?
        /// The time and date the request was sent to this managed node.
        public var requestedDateTime: Foundation.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes on a per managed node basis.
        public var serviceRole: Swift.String?
        /// The URL to the plugin's StdErr file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardErrorUrl: Swift.String?
        /// The URL to the plugin's StdOut file in Amazon Simple Storage Service (Amazon S3), if the S3 bucket was defined for the parent command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined for the command, and the S3 bucket was defined for the command.
        public var standardOutputUrl: Swift.String?
        /// Whether or not the invocation succeeded, failed, or is pending.
        public var status: SSMClientTypes.CommandInvocationStatus?
        /// A detailed status of the command execution for each invocation (each managed node targeted by the command). StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to the managed node.
        ///
        /// * In Progress: The command has been sent to the managed node but hasn't reached a terminal state.
        ///
        /// * Success: The execution of the command or plugin was successfully completed. This is a terminal state.
        ///
        /// * Delivery Timed Out: The command wasn't delivered to the managed node before the delivery timeout expired. Delivery timeouts don't count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Execution Timed Out: Command execution started on the managed node, but the execution wasn't complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Failed: The command wasn't successful on the managed node. For a plugin, this indicates that the result code wasn't zero. For a command invocation, this indicates that the result code for one or more plugins wasn't zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.
        ///
        /// * Cancelled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Undeliverable: The command can't be delivered to the managed node. The managed node might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.
        ///
        /// * Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.
        ///
        /// * Delayed: The system attempted to send the command to the managed node but wasn't successful. The system retries again.
        public var statusDetails: Swift.String?
        /// Gets the trace output sent by the agent.
        public var traceOutput: Swift.String?

        public init(
            cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            commandPlugins: [SSMClientTypes.CommandPlugin]? = nil,
            comment: Swift.String? = nil,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            notificationConfig: SSMClientTypes.NotificationConfig? = nil,
            requestedDateTime: Foundation.Date? = nil,
            serviceRole: Swift.String? = nil,
            standardErrorUrl: Swift.String? = nil,
            standardOutputUrl: Swift.String? = nil,
            status: SSMClientTypes.CommandInvocationStatus? = nil,
            statusDetails: Swift.String? = nil,
            traceOutput: Swift.String? = nil
        )
        {
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.commandPlugins = commandPlugins
            self.comment = comment
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.instanceId = instanceId
            self.instanceName = instanceName
            self.notificationConfig = notificationConfig
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.standardErrorUrl = standardErrorUrl
            self.standardOutputUrl = standardOutputUrl
            self.status = status
            self.statusDetails = statusDetails
            self.traceOutput = traceOutput
        }
    }
}

public struct ListCommandInvocationsOutput: Swift.Sendable {
    /// (Optional) A list of all invocations.
    public var commandInvocations: [SSMClientTypes.CommandInvocation]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        commandInvocations: [SSMClientTypes.CommandInvocation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commandInvocations = commandInvocations
        self.nextToken = nextToken
    }
}

public struct ListCommandsInput: Swift.Sendable {
    /// (Optional) If provided, lists only the specified command.
    public var commandId: Swift.String?
    /// (Optional) One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.CommandFilter]?
    /// (Optional) Lists commands issued against this managed node ID. You can't specify a managed node ID in the same command that you specify Status = Pending. This is because the command hasn't reached the managed node yet.
    public var instanceId: Swift.String?
    /// (Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        commandId: Swift.String? = nil,
        filters: [SSMClientTypes.CommandFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commandId = commandId
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum CommandStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case inProgress
        case pending
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [CommandStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .inProgress,
                .pending,
                .success,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .pending: return "Pending"
            case .success: return "Success"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a command request.
    public struct Command: Swift.Sendable {
        /// The details for the CloudWatch alarm applied to your command.
        public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
        /// Amazon CloudWatch Logs information where you want Amazon Web Services Systems Manager to send the command output.
        public var cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig?
        /// A unique identifier for this command.
        public var commandId: Swift.String?
        /// User-specified information about the command, such as a brief description of what the command should do.
        public var comment: Swift.String?
        /// The number of targets for which the command invocation reached a terminal state. Terminal states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Cancelled, Terminated, or Undeliverable.
        public var completedCount: Swift.Int
        /// The number of targets for which the status is Delivery Timed Out.
        public var deliveryTimedOutCount: Swift.Int
        /// The name of the document requested for execution.
        public var documentName: Swift.String?
        /// The Systems Manager document (SSM document) version.
        public var documentVersion: Swift.String?
        /// The number of targets for which the status is Failed or Execution Timed Out.
        public var errorCount: Swift.Int
        /// If a command expires, it changes status to DeliveryTimedOut for all invocations that have the status InProgress, Pending, or Delayed. ExpiresAfter is calculated based on the total timeout for the overall command. For more information, see [Understanding command timeout values](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html?icmpid=docs_ec2_console#monitor-about-status-timeouts) in the Amazon Web Services Systems Manager User Guide.
        public var expiresAfter: Foundation.Date?
        /// The managed node IDs against which this command was requested.
        public var instanceIds: [Swift.String]?
        /// The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number of managed nodes, such as 10, or a percentage of nodes, such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Amazon Web Services Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxConcurrency: Swift.String?
        /// The maximum number of errors allowed before the system stops sending the command to additional targets. You can specify a number of errors, such as 10, or a percentage or errors, such as 10%. The default value is 0. For more information about how to use MaxErrors, see [Amazon Web Services Systems Manager Run Command](https://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html) in the Amazon Web Services Systems Manager User Guide.
        public var maxErrors: Swift.String?
        /// Configurations for sending notifications about command status changes.
        public var notificationConfig: SSMClientTypes.NotificationConfig?
        /// The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3BucketName: Swift.String?
        /// The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command.
        public var outputS3KeyPrefix: Swift.String?
        /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
        public var outputS3Region: Swift.String?
        /// The parameter values to be inserted in the document when running the command.
        public var parameters: [Swift.String: [Swift.String]]?
        /// The date and time the command was requested.
        public var requestedDateTime: Foundation.Date?
        /// The Identity and Access Management (IAM) service role that Run Command, a capability of Amazon Web Services Systems Manager, uses to act on your behalf when sending notifications about command status changes.
        public var serviceRole: Swift.String?
        /// The status of the command.
        public var status: SSMClientTypes.CommandStatus?
        /// A detailed status of the command execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see [Understanding command statuses](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html) in the Amazon Web Services Systems Manager User Guide. StatusDetails can be one of the following values:
        ///
        /// * Pending: The command hasn't been sent to any managed nodes.
        ///
        /// * In Progress: The command has been sent to at least one managed node but hasn't reached a final state on all managed nodes.
        ///
        /// * Success: The command successfully ran on all invocations. This is a terminal state.
        ///
        /// * Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of Delivery Timed Out. This is a terminal state.
        ///
        /// * Execution Timed Out: The value of MaxErrors or more command invocations shows a status of Execution Timed Out. This is a terminal state.
        ///
        /// * Failed: The value of MaxErrors or more command invocations shows a status of Failed. This is a terminal state.
        ///
        /// * Incomplete: The command was attempted on all managed nodes and one or more invocations doesn't have a value of Success but not enough invocations failed for the status to be Failed. This is a terminal state.
        ///
        /// * Cancelled: The command was terminated before it was completed. This is a terminal state.
        ///
        /// * Rate Exceeded: The number of managed nodes targeted by the command exceeded the account limit for pending invocations. The system has canceled the command before running it on any managed node. This is a terminal state.
        ///
        /// * Delayed: The system attempted to send the command to the managed node but wasn't successful. The system retries again.
        public var statusDetails: Swift.String?
        /// The number of targets for the command.
        public var targetCount: Swift.Int
        /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Targets is required if you don't provide one or more managed node IDs in the call.
        public var targets: [SSMClientTypes.Target]?
        /// The TimeoutSeconds value specified for a command.
        public var timeoutSeconds: Swift.Int?
        /// The CloudWatch alarm that was invoked by the command.
        public var triggeredAlarms: [SSMClientTypes.AlarmStateInformation]?

        public init(
            alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
            cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig? = nil,
            commandId: Swift.String? = nil,
            comment: Swift.String? = nil,
            completedCount: Swift.Int = 0,
            deliveryTimedOutCount: Swift.Int = 0,
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            errorCount: Swift.Int = 0,
            expiresAfter: Foundation.Date? = nil,
            instanceIds: [Swift.String]? = nil,
            maxConcurrency: Swift.String? = nil,
            maxErrors: Swift.String? = nil,
            notificationConfig: SSMClientTypes.NotificationConfig? = nil,
            outputS3BucketName: Swift.String? = nil,
            outputS3KeyPrefix: Swift.String? = nil,
            outputS3Region: Swift.String? = nil,
            parameters: [Swift.String: [Swift.String]]? = nil,
            requestedDateTime: Foundation.Date? = nil,
            serviceRole: Swift.String? = nil,
            status: SSMClientTypes.CommandStatus? = nil,
            statusDetails: Swift.String? = nil,
            targetCount: Swift.Int = 0,
            targets: [SSMClientTypes.Target]? = nil,
            timeoutSeconds: Swift.Int? = nil,
            triggeredAlarms: [SSMClientTypes.AlarmStateInformation]? = nil
        )
        {
            self.alarmConfiguration = alarmConfiguration
            self.cloudWatchOutputConfig = cloudWatchOutputConfig
            self.commandId = commandId
            self.comment = comment
            self.completedCount = completedCount
            self.deliveryTimedOutCount = deliveryTimedOutCount
            self.documentName = documentName
            self.documentVersion = documentVersion
            self.errorCount = errorCount
            self.expiresAfter = expiresAfter
            self.instanceIds = instanceIds
            self.maxConcurrency = maxConcurrency
            self.maxErrors = maxErrors
            self.notificationConfig = notificationConfig
            self.outputS3BucketName = outputS3BucketName
            self.outputS3KeyPrefix = outputS3KeyPrefix
            self.outputS3Region = outputS3Region
            self.parameters = parameters
            self.requestedDateTime = requestedDateTime
            self.serviceRole = serviceRole
            self.status = status
            self.statusDetails = statusDetails
            self.targetCount = targetCount
            self.targets = targets
            self.timeoutSeconds = timeoutSeconds
            self.triggeredAlarms = triggeredAlarms
        }
    }
}

extension SSMClientTypes.Command: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Command(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), commandId: \(Swift.String(describing: commandId)), comment: \(Swift.String(describing: comment)), completedCount: \(Swift.String(describing: completedCount)), deliveryTimedOutCount: \(Swift.String(describing: deliveryTimedOutCount)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), errorCount: \(Swift.String(describing: errorCount)), expiresAfter: \(Swift.String(describing: expiresAfter)), instanceIds: \(Swift.String(describing: instanceIds)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)), requestedDateTime: \(Swift.String(describing: requestedDateTime)), serviceRole: \(Swift.String(describing: serviceRole)), status: \(Swift.String(describing: status)), statusDetails: \(Swift.String(describing: statusDetails)), targetCount: \(Swift.String(describing: targetCount)), targets: \(Swift.String(describing: targets)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)), triggeredAlarms: \(Swift.String(describing: triggeredAlarms)), parameters: \"CONTENT_REDACTED\")"}
}

public struct ListCommandsOutput: Swift.Sendable {
    /// (Optional) The list of commands requested by the user.
    public var commands: [SSMClientTypes.Command]?
    /// (Optional) The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        commands: [SSMClientTypes.Command]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commands = commands
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum ComplianceQueryOperatorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginwith
        case equal
        case greaterthan
        case lessthan
        case notequal
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceQueryOperatorType] {
            return [
                .beginwith,
                .equal,
                .greaterthan,
                .lessthan,
                .notequal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginwith: return "BEGIN_WITH"
            case .equal: return "EQUAL"
            case .greaterthan: return "GREATER_THAN"
            case .lessthan: return "LESS_THAN"
            case .notequal: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// One or more filters. Use a filter to return a more specific list of results.
    public struct ComplianceStringFilter: Swift.Sendable {
        /// The name of the filter.
        public var key: Swift.String?
        /// The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith, LessThan, or GreaterThan.
        public var type: SSMClientTypes.ComplianceQueryOperatorType?
        /// The value for which to search.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            type: SSMClientTypes.ComplianceQueryOperatorType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.type = type
            self.values = values
        }
    }
}

public struct ListComplianceItemsInput: Swift.Sendable {
    /// One or more compliance filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The ID for the resources from which to get compliance information. Currently, you can only specify one resource ID.
    public var resourceIds: [Swift.String]?
    /// The type of resource from which to get compliance information. Currently, the only supported resource type is ManagedInstance.
    public var resourceTypes: [Swift.String]?

    public init(
        filters: [SSMClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceTypes = resourceTypes
    }
}

extension SSMClientTypes {

    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'
    public struct ComplianceExecutionSummary: Swift.Sendable {
        /// An ID created by the system when PutComplianceItems was called. For example, CommandID is a valid execution ID. You can use this ID in subsequent calls.
        public var executionId: Swift.String?
        /// The time the execution ran as a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'
        /// This member is required.
        public var executionTime: Foundation.Date?
        /// The type of execution. For example, Command is a valid execution type.
        public var executionType: Swift.String?

        public init(
            executionId: Swift.String? = nil,
            executionTime: Foundation.Date? = nil,
            executionType: Swift.String? = nil
        )
        {
            self.executionId = executionId
            self.executionTime = executionTime
            self.executionType = executionType
        }
    }
}

extension SSMClientTypes {

    public enum ComplianceSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceSeverity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .unspecified: return "UNSPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum ComplianceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .compliant,
                .noncompliant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about the compliance as defined by the resource type. For example, for a patch resource type, Items includes information about the PatchSeverity, Classification, and so on.
    public struct ComplianceItem: Swift.Sendable {
        /// The compliance type. For example, Association (for a State Manager association), Patch, or Custom:string are all valid compliance types.
        public var complianceType: Swift.String?
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String: Swift.String]?
        /// A summary for the compliance item. The summary includes an execution ID, the execution type (for example, command), and the execution time.
        public var executionSummary: SSMClientTypes.ComplianceExecutionSummary?
        /// An ID for the compliance item. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article; for example: KB4010320.
        public var id: Swift.String?
        /// An ID for the resource. For a managed node, this is the node ID.
        public var resourceId: Swift.String?
        /// The type of resource. ManagedInstance is currently the only supported resource type.
        public var resourceType: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        public var severity: SSMClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT, NON_COMPLIANT, or an empty string (for Windows patches that aren't applicable).
        public var status: SSMClientTypes.ComplianceStatus?
        /// A title for the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init(
            complianceType: Swift.String? = nil,
            details: [Swift.String: Swift.String]? = nil,
            executionSummary: SSMClientTypes.ComplianceExecutionSummary? = nil,
            id: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            severity: SSMClientTypes.ComplianceSeverity? = nil,
            status: SSMClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.details = details
            self.executionSummary = executionSummary
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.severity = severity
            self.status = status
            self.title = title
        }
    }
}

public struct ListComplianceItemsOutput: Swift.Sendable {
    /// A list of compliance information for the specified resource ID.
    public var complianceItems: [SSMClientTypes.ComplianceItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        complianceItems: [SSMClientTypes.ComplianceItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceItems = complianceItems
        self.nextToken = nextToken
    }
}

public struct ListComplianceSummariesInput: Swift.Sendable {
    /// One or more compliance or inventory filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. Currently, you can specify null or 50. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// The number of managed nodes found for each patch severity level defined in the request filter.
    public struct SeveritySummary: Swift.Sendable {
        /// The total number of resources or compliance items that have a severity level of Critical. Critical severity is determined by the organization that published the compliance items.
        public var criticalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.
        public var highCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.
        public var informationalCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.
        public var lowCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.
        public var mediumCount: Swift.Int
        /// The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.
        public var unspecifiedCount: Swift.Int

        public init(
            criticalCount: Swift.Int = 0,
            highCount: Swift.Int = 0,
            informationalCount: Swift.Int = 0,
            lowCount: Swift.Int = 0,
            mediumCount: Swift.Int = 0,
            unspecifiedCount: Swift.Int = 0
        )
        {
            self.criticalCount = criticalCount
            self.highCount = highCount
            self.informationalCount = informationalCount
            self.lowCount = lowCount
            self.mediumCount = mediumCount
            self.unspecifiedCount = unspecifiedCount
        }
    }
}

extension SSMClientTypes {

    /// A summary of resources that are compliant. The summary is organized according to the resource count for each compliance type.
    public struct CompliantSummary: Swift.Sendable {
        /// The total number of resources that are compliant.
        public var compliantCount: Swift.Int
        /// A summary of the compliance severity by compliance type.
        public var severitySummary: SSMClientTypes.SeveritySummary?

        public init(
            compliantCount: Swift.Int = 0,
            severitySummary: SSMClientTypes.SeveritySummary? = nil
        )
        {
            self.compliantCount = compliantCount
            self.severitySummary = severitySummary
        }
    }
}

extension SSMClientTypes {

    /// A summary of resources that aren't compliant. The summary is organized according to resource type.
    public struct NonCompliantSummary: Swift.Sendable {
        /// The total number of compliance items that aren't compliant.
        public var nonCompliantCount: Swift.Int
        /// A summary of the non-compliance severity by compliance type
        public var severitySummary: SSMClientTypes.SeveritySummary?

        public init(
            nonCompliantCount: Swift.Int = 0,
            severitySummary: SSMClientTypes.SeveritySummary? = nil
        )
        {
            self.nonCompliantCount = nonCompliantCount
            self.severitySummary = severitySummary
        }
    }
}

extension SSMClientTypes {

    /// A summary of compliance information by compliance type.
    public struct ComplianceSummaryItem: Swift.Sendable {
        /// The type of compliance item. For example, the compliance type can be Association, Patch, or Custom:string.
        public var complianceType: Swift.String?
        /// A list of COMPLIANT items for the specified compliance type.
        public var compliantSummary: SSMClientTypes.CompliantSummary?
        /// A list of NON_COMPLIANT items for the specified compliance type.
        public var nonCompliantSummary: SSMClientTypes.NonCompliantSummary?

        public init(
            complianceType: Swift.String? = nil,
            compliantSummary: SSMClientTypes.CompliantSummary? = nil,
            nonCompliantSummary: SSMClientTypes.NonCompliantSummary? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.nonCompliantSummary = nonCompliantSummary
        }
    }
}

public struct ListComplianceSummariesOutput: Swift.Sendable {
    /// A list of compliant and non-compliant summary counts based on compliance types. For example, this call returns State Manager associations, patches, or custom compliance types according to the filter criteria that you specified.
    public var complianceSummaryItems: [SSMClientTypes.ComplianceSummaryItem]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        complianceSummaryItems: [SSMClientTypes.ComplianceSummaryItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceSummaryItems = complianceSummaryItems
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum DocumentMetadataEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case documentreviews
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentMetadataEnum] {
            return [
                .documentreviews
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .documentreviews: return "DocumentReviews"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListDocumentMetadataHistoryInput: Swift.Sendable {
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The type of data for which details are being requested. Currently, the only supported value is DocumentReviews.
    /// This member is required.
    public var metadata: SSMClientTypes.DocumentMetadataEnum?
    /// The name of the change template.
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        documentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        metadata: SSMClientTypes.DocumentMetadataEnum? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.maxResults = maxResults
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum DocumentReviewCommentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comment
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewCommentType] {
            return [
                .comment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comment: return "Comment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about comments added to a document review request.
    public struct DocumentReviewCommentSource: Swift.Sendable {
        /// The content of a comment entered by a user who requests a review of a new document version, or who reviews the new version.
        public var content: Swift.String?
        /// The type of information added to a review request. Currently, only the value Comment is supported.
        public var type: SSMClientTypes.DocumentReviewCommentType?

        public init(
            content: Swift.String? = nil,
            type: SSMClientTypes.DocumentReviewCommentType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }
}

extension SSMClientTypes {

    /// Information about a reviewer's response to a document review request.
    public struct DocumentReviewerResponseSource: Swift.Sendable {
        /// The comment entered by a reviewer as part of their document review response.
        public var comment: [SSMClientTypes.DocumentReviewCommentSource]?
        /// The date and time that a reviewer entered a response to a document review request.
        public var createTime: Foundation.Date?
        /// The current review status of a new custom SSM document created by a member of your organization, or of the latest version of an existing SSM document. Only one version of a document can be in the APPROVED state at a time. When a new version is approved, the status of the previous version changes to REJECTED. Only one version of a document can be in review, or PENDING, at a time.
        public var reviewStatus: SSMClientTypes.ReviewStatus?
        /// The user in your organization assigned to review a document request.
        public var reviewer: Swift.String?
        /// The date and time that a reviewer last updated a response to a document review request.
        public var updatedTime: Foundation.Date?

        public init(
            comment: [SSMClientTypes.DocumentReviewCommentSource]? = nil,
            createTime: Foundation.Date? = nil,
            reviewStatus: SSMClientTypes.ReviewStatus? = nil,
            reviewer: Swift.String? = nil,
            updatedTime: Foundation.Date? = nil
        )
        {
            self.comment = comment
            self.createTime = createTime
            self.reviewStatus = reviewStatus
            self.reviewer = reviewer
            self.updatedTime = updatedTime
        }
    }
}

extension SSMClientTypes {

    /// Details about the response to a document review request.
    public struct DocumentMetadataResponseInfo: Swift.Sendable {
        /// Details about a reviewer's response to a document review request.
        public var reviewerResponse: [SSMClientTypes.DocumentReviewerResponseSource]?

        public init(
            reviewerResponse: [SSMClientTypes.DocumentReviewerResponseSource]? = nil
        )
        {
            self.reviewerResponse = reviewerResponse
        }
    }
}

public struct ListDocumentMetadataHistoryOutput: Swift.Sendable {
    /// The user ID of the person in the organization who requested the review of the change template.
    public var author: Swift.String?
    /// The version of the change template.
    public var documentVersion: Swift.String?
    /// Information about the response to the change template approval request.
    public var metadata: SSMClientTypes.DocumentMetadataResponseInfo?
    /// The name of the change template.
    public var name: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        author: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        metadata: SSMClientTypes.DocumentMetadataResponseInfo? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.author = author
        self.documentVersion = documentVersion
        self.metadata = metadata
        self.name = name
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    public enum DocumentFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case documenttype
        case name
        case owner
        case platformtypes
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFilterKey] {
            return [
                .documenttype,
                .name,
                .owner,
                .platformtypes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .documenttype: return "DocumentType"
            case .name: return "Name"
            case .owner: return "Owner"
            case .platformtypes: return "PlatformTypes"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// This data type is deprecated. Instead, use [DocumentKeyValuesFilter].
    public struct DocumentFilter: Swift.Sendable {
        /// The name of the filter.
        /// This member is required.
        public var key: SSMClientTypes.DocumentFilterKey?
        /// The value of the filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: SSMClientTypes.DocumentFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension SSMClientTypes {

    /// One or more filters. Use a filter to return a more specific list of documents. For keys, you can specify one or more tags that have been applied to a document. You can also use Amazon Web Services-provided keys, some of which have specific allowed values. These keys and their associated values are as follows: DocumentType
    ///
    /// * ApplicationConfiguration
    ///
    /// * ApplicationConfigurationSchema
    ///
    /// * Automation
    ///
    /// * ChangeCalendar
    ///
    /// * Command
    ///
    /// * Package
    ///
    /// * Policy
    ///
    /// * Session
    ///
    ///
    /// Owner Note that only one Owner can be specified in a request. For example: Key=Owner,Values=Self.
    ///
    /// * Amazon
    ///
    /// * Private
    ///
    /// * Public
    ///
    /// * Self
    ///
    /// * ThirdParty
    ///
    ///
    /// PlatformTypes
    ///
    /// * Linux
    ///
    /// * Windows
    ///
    ///
    /// Name is another Amazon Web Services-provided key. If you use Name as a key, you can use a name prefix to return a list of documents. For example, in the Amazon Web Services CLI, to return a list of all documents that begin with Te, run the following command: aws ssm list-documents --filters Key=Name,Values=Te You can also use the TargetType Amazon Web Services-provided key. For a list of valid resource type values that can be used with this key, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide. If you specify more than two keys, only documents that are identified by all the tags are returned in the results. If you specify more than two values for a key, documents that are identified by any of the values are returned in the results. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. For example, if you created a key called region and are using the Amazon Web Services CLI to call the list-documents command: aws ssm list-documents --filters Key=tag:region,Values=east,west Key=Owner,Values=Self
    public struct DocumentKeyValuesFilter: Swift.Sendable {
        /// The name of the filter key.
        public var key: Swift.String?
        /// The value for the filter key.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct ListDocumentsInput: Swift.Sendable {
    /// This data type is deprecated. Instead, use Filters.
    public var documentFilterList: [SSMClientTypes.DocumentFilter]?
    /// One or more DocumentKeyValuesFilter objects. Use a filter to return a more specific list of results. For keys, you can specify one or more key-value pair tags that have been applied to a document. Other valid keys include Owner, Name, PlatformTypes, DocumentType, and TargetType. For example, to return documents you own use Key=Owner,Values=Self. To specify a custom key-value pair, use the format Key=tag:tagName,Values=valueName. This API operation only supports filtering documents by using a single tag key and one or more tag values. For example: Key=tag:tagName,Values=valueName1,valueName2
    public var filters: [SSMClientTypes.DocumentKeyValuesFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        documentFilterList: [SSMClientTypes.DocumentFilter]? = nil,
        filters: [SSMClientTypes.DocumentKeyValuesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentFilterList = documentFilterList
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Describes the name of a SSM document.
    public struct DocumentIdentifier: Swift.Sendable {
        /// The user in your organization who created the document.
        public var author: Swift.String?
        /// The date the SSM document was created.
        public var createdDate: Foundation.Date?
        /// An optional field where you can specify a friendly name for the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SSMClientTypes.DocumentFormat?
        /// The document type.
        public var documentType: SSMClientTypes.DocumentType?
        /// The document version.
        public var documentVersion: Swift.String?
        /// The name of the SSM document.
        public var name: Swift.String?
        /// The Amazon Web Services user that created the document.
        public var owner: Swift.String?
        /// The operating system platform.
        public var platformTypes: [SSMClientTypes.PlatformType]?
        /// A list of SSM documents required by a document. For example, an ApplicationConfiguration document requires an ApplicationConfigurationSchema document.
        public var requires: [SSMClientTypes.DocumentRequires]?
        /// The current status of a document review.
        public var reviewStatus: SSMClientTypes.ReviewStatus?
        /// The schema version.
        public var schemaVersion: Swift.String?
        /// The tags, or metadata, that have been applied to the document.
        public var tags: [SSMClientTypes.Tag]?
        /// The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var targetType: Swift.String?
        /// An optional field specifying the version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init(
            author: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SSMClientTypes.DocumentFormat? = nil,
            documentType: SSMClientTypes.DocumentType? = nil,
            documentVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platformTypes: [SSMClientTypes.PlatformType]? = nil,
            requires: [SSMClientTypes.DocumentRequires]? = nil,
            reviewStatus: SSMClientTypes.ReviewStatus? = nil,
            schemaVersion: Swift.String? = nil,
            tags: [SSMClientTypes.Tag]? = nil,
            targetType: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.author = author
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentType = documentType
            self.documentVersion = documentVersion
            self.name = name
            self.owner = owner
            self.platformTypes = platformTypes
            self.requires = requires
            self.reviewStatus = reviewStatus
            self.schemaVersion = schemaVersion
            self.tags = tags
            self.targetType = targetType
            self.versionName = versionName
        }
    }
}

public struct ListDocumentsOutput: Swift.Sendable {
    /// The names of the SSM documents.
    public var documentIdentifiers: [SSMClientTypes.DocumentIdentifier]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        documentIdentifiers: [SSMClientTypes.DocumentIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentIdentifiers = documentIdentifiers
        self.nextToken = nextToken
    }
}

public struct ListDocumentVersionsInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The name of the document. You can specify an Amazon Resource Name (ARN).
    /// This member is required.
    public var name: Swift.String?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Version information about the document.
    public struct DocumentVersionInfo: Swift.Sendable {
        /// The date the document was created.
        public var createdDate: Foundation.Date?
        /// The friendly name of the SSM document. This value can differ for each version of the document. If you want to update this value, see [UpdateDocument].
        public var displayName: Swift.String?
        /// The document format, either JSON or YAML.
        public var documentFormat: SSMClientTypes.DocumentFormat?
        /// The document version.
        public var documentVersion: Swift.String?
        /// An identifier for the default version of the document.
        public var isDefaultVersion: Swift.Bool
        /// The document name.
        public var name: Swift.String?
        /// The current status of the approval review for the latest version of the document.
        public var reviewStatus: SSMClientTypes.ReviewStatus?
        /// The status of the SSM document, such as Creating, Active, Failed, and Deleting.
        public var status: SSMClientTypes.DocumentStatus?
        /// A message returned by Amazon Web Services Systems Manager that explains the Status value. For example, a Failed status might be explained by the StatusInformation message, "The specified S3 bucket doesn't exist. Verify that the URL of the S3 bucket is correct."
        public var statusInformation: Swift.String?
        /// The version of the artifact associated with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
        public var versionName: Swift.String?

        public init(
            createdDate: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            documentFormat: SSMClientTypes.DocumentFormat? = nil,
            documentVersion: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            name: Swift.String? = nil,
            reviewStatus: SSMClientTypes.ReviewStatus? = nil,
            status: SSMClientTypes.DocumentStatus? = nil,
            statusInformation: Swift.String? = nil,
            versionName: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.displayName = displayName
            self.documentFormat = documentFormat
            self.documentVersion = documentVersion
            self.isDefaultVersion = isDefaultVersion
            self.name = name
            self.reviewStatus = reviewStatus
            self.status = status
            self.statusInformation = statusInformation
            self.versionName = versionName
        }
    }
}

public struct ListDocumentVersionsOutput: Swift.Sendable {
    /// The document versions.
    public var documentVersions: [SSMClientTypes.DocumentVersionInfo]?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?

    public init(
        documentVersions: [SSMClientTypes.DocumentVersionInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.nextToken = nextToken
    }
}

public struct ListInventoryEntriesInput: Swift.Sendable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.InventoryFilter]?
    /// The managed node ID for which you want inventory information.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The type of inventory item for which you want information.
    /// This member is required.
    public var typeName: Swift.String?

    public init(
        filters: [SSMClientTypes.InventoryFilter]? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

public struct ListInventoryEntriesOutput: Swift.Sendable {
    /// The time that inventory information was collected for the managed nodes.
    public var captureTime: Swift.String?
    /// A list of inventory items on the managed nodes.
    public var entries: [[Swift.String: Swift.String]]?
    /// The managed node ID targeted by the request to query inventory information.
    public var instanceId: Swift.String?
    /// The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.
    public var nextToken: Swift.String?
    /// The inventory schema version used by the managed nodes.
    public var schemaVersion: Swift.String?
    /// The type of inventory item returned by the request.
    public var typeName: Swift.String?

    public init(
        captureTime: Swift.String? = nil,
        entries: [[Swift.String: Swift.String]]? = nil,
        instanceId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        schemaVersion: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.captureTime = captureTime
        self.entries = entries
        self.instanceId = instanceId
        self.nextToken = nextToken
        self.schemaVersion = schemaVersion
        self.typeName = typeName
    }
}

extension SSMClientTypes {

    public enum OpsItemEventFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case opsitemId
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterKey] {
            return [
                .opsitemId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .opsitemId: return "OpsItemId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum OpsItemEventFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemEventFilterOperator] {
            return [
                .equal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for a specific list of OpsItem events. You can filter event information by using tags. You specify tags by using a key-value pair mapping.
    public struct OpsItemEventFilter: Swift.Sendable {
        /// The name of the filter key. Currently, the only supported value is OpsItemId.
        /// This member is required.
        public var key: SSMClientTypes.OpsItemEventFilterKey?
        /// The operator used by the filter call. Currently, the only supported value is Equal.
        /// This member is required.
        public var `operator`: SSMClientTypes.OpsItemEventFilterOperator?
        /// The values for the filter, consisting of one or more OpsItem IDs.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.OpsItemEventFilterKey? = nil,
            `operator`: SSMClientTypes.OpsItemEventFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct ListOpsItemEventsInput: Swift.Sendable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.OpsItemEventFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.OpsItemEventFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Information about the user or resource that created an OpsItem event.
    public struct OpsItemIdentity: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM entity that created the OpsItem event.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension SSMClientTypes {

    /// Summary information about an OpsItem event or that associated an OpsItem with a related item.
    public struct OpsItemEventSummary: Swift.Sendable {
        /// Information about the user or resource that created the OpsItem event.
        public var createdBy: SSMClientTypes.OpsItemIdentity?
        /// The date and time the OpsItem event was created.
        public var createdTime: Foundation.Date?
        /// Specific information about the OpsItem event.
        public var detail: Swift.String?
        /// The type of information provided as a detail.
        public var detailType: Swift.String?
        /// The ID of the OpsItem event.
        public var eventId: Swift.String?
        /// The ID of the OpsItem.
        public var opsItemId: Swift.String?
        /// The source of the OpsItem event.
        public var source: Swift.String?

        public init(
            createdBy: SSMClientTypes.OpsItemIdentity? = nil,
            createdTime: Foundation.Date? = nil,
            detail: Swift.String? = nil,
            detailType: Swift.String? = nil,
            eventId: Swift.String? = nil,
            opsItemId: Swift.String? = nil,
            source: Swift.String? = nil
        )
        {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.detail = detail
            self.detailType = detailType
            self.eventId = eventId
            self.opsItemId = opsItemId
            self.source = source
        }
    }
}

public struct ListOpsItemEventsOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of event information for the specified OpsItems.
    public var summaries: [SSMClientTypes.OpsItemEventSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [SSMClientTypes.OpsItemEventSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

extension SSMClientTypes {

    public enum OpsItemRelatedItemsFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associationId
        case resourceType
        case resourceUri
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterKey] {
            return [
                .associationId,
                .resourceType,
                .resourceUri
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associationId: return "AssociationId"
            case .resourceType: return "ResourceType"
            case .resourceUri: return "ResourceUri"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    public enum OpsItemRelatedItemsFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case sdkUnknown(Swift.String)

        public static var allCases: [OpsItemRelatedItemsFilterOperator] {
            return [
                .equal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "Equal"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Describes a filter for a specific list of related-item resources.
    public struct OpsItemRelatedItemsFilter: Swift.Sendable {
        /// The name of the filter key. Supported values include ResourceUri, ResourceType, or AssociationId.
        /// This member is required.
        public var key: SSMClientTypes.OpsItemRelatedItemsFilterKey?
        /// The operator used by the filter call. The only supported operator is EQUAL.
        /// This member is required.
        public var `operator`: SSMClientTypes.OpsItemRelatedItemsFilterOperator?
        /// The values for the filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: SSMClientTypes.OpsItemRelatedItemsFilterKey? = nil,
            `operator`: SSMClientTypes.OpsItemRelatedItemsFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct ListOpsItemRelatedItemsInput: Swift.Sendable {
    /// One or more OpsItem filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.OpsItemRelatedItemsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The ID of the OpsItem for which you want to list all related-item resources.
    public var opsItemId: Swift.String?

    public init(
        filters: [SSMClientTypes.OpsItemRelatedItemsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opsItemId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opsItemId = opsItemId
    }
}

extension SSMClientTypes {

    /// Summary information about related-item resources for an OpsItem.
    public struct OpsItemRelatedItemSummary: Swift.Sendable {
        /// The association ID.
        public var associationId: Swift.String?
        /// The association type.
        public var associationType: Swift.String?
        /// Information about the user or resource that created an OpsItem event.
        public var createdBy: SSMClientTypes.OpsItemIdentity?
        /// The time the related-item association was created.
        public var createdTime: Foundation.Date?
        /// Information about the user or resource that created an OpsItem event.
        public var lastModifiedBy: SSMClientTypes.OpsItemIdentity?
        /// The time the related-item association was last updated.
        public var lastModifiedTime: Foundation.Date?
        /// The OpsItem ID.
        public var opsItemId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The Amazon Resource Name (ARN) of the related-item resource.
        public var resourceUri: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            associationType: Swift.String? = nil,
            createdBy: SSMClientTypes.OpsItemIdentity? = nil,
            createdTime: Foundation.Date? = nil,
            lastModifiedBy: SSMClientTypes.OpsItemIdentity? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            opsItemId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            resourceUri: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.associationType = associationType
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.opsItemId = opsItemId
            self.resourceType = resourceType
            self.resourceUri = resourceUri
        }
    }
}

public struct ListOpsItemRelatedItemsOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of related-item resources for the specified OpsItem.
    public var summaries: [SSMClientTypes.OpsItemRelatedItemSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [SSMClientTypes.OpsItemRelatedItemSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

extension SSMClientTypes {

    /// A filter to limit the number of OpsMetadata objects displayed.
    public struct OpsMetadataFilter: Swift.Sendable {
        /// A filter key.
        /// This member is required.
        public var key: Swift.String?
        /// A filter value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

public struct ListOpsMetadataInput: Swift.Sendable {
    /// One or more filters to limit the number of OpsMetadata objects returned by the call.
    public var filters: [SSMClientTypes.OpsMetadataFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.OpsMetadataFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Operational metadata for an application in Application Manager.
    public struct OpsMetadata: Swift.Sendable {
        /// The date the OpsMetadata objects was created.
        public var creationDate: Foundation.Date?
        /// The date the OpsMetadata object was last updated.
        public var lastModifiedDate: Foundation.Date?
        /// The user name who last updated the OpsMetadata object.
        public var lastModifiedUser: Swift.String?
        /// The Amazon Resource Name (ARN) of the OpsMetadata Object or blob.
        public var opsMetadataArn: Swift.String?
        /// The ID of the Application Manager application.
        public var resourceId: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lastModifiedUser: Swift.String? = nil,
            opsMetadataArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.lastModifiedUser = lastModifiedUser
            self.opsMetadataArn = opsMetadataArn
            self.resourceId = resourceId
        }
    }
}

public struct ListOpsMetadataOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Returns a list of OpsMetadata objects.
    public var opsMetadataList: [SSMClientTypes.OpsMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        opsMetadataList: [SSMClientTypes.OpsMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.opsMetadataList = opsMetadataList
    }
}

public struct ListResourceComplianceSummariesInput: Swift.Sendable {
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.ComplianceStringFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [SSMClientTypes.ComplianceStringFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMClientTypes {

    /// Compliance summary information for a specific resource.
    public struct ResourceComplianceSummaryItem: Swift.Sendable {
        /// The compliance type.
        public var complianceType: Swift.String?
        /// A list of items that are compliant for the resource.
        public var compliantSummary: SSMClientTypes.CompliantSummary?
        /// Information about the execution.
        public var executionSummary: SSMClientTypes.ComplianceExecutionSummary?
        /// A list of items that aren't compliant for the resource.
        public var nonCompliantSummary: SSMClientTypes.NonCompliantSummary?
        /// The highest severity item found for the resource. The resource is compliant for this item.
        public var overallSeverity: SSMClientTypes.ComplianceSeverity?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: Swift.String?
        /// The compliance status for the resource.
        public var status: SSMClientTypes.ComplianceStatus?

        public init(
            complianceType: Swift.String? = nil,
            compliantSummary: SSMClientTypes.CompliantSummary? = nil,
            executionSummary: SSMClientTypes.ComplianceExecutionSummary? = nil,
            nonCompliantSummary: SSMClientTypes.NonCompliantSummary? = nil,
            overallSeverity: SSMClientTypes.ComplianceSeverity? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: SSMClientTypes.ComplianceStatus? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantSummary = compliantSummary
            self.executionSummary = executionSummary
            self.nonCompliantSummary = nonCompliantSummary
            self.overallSeverity = overallSeverity
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
        }
    }
}

public struct ListResourceComplianceSummariesOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A summary count for specified or targeted managed nodes. Summary count includes information about compliant and non-compliant State Manager associations, patch status, or custom items according to the filter criteria that you specify.
    public var resourceComplianceSummaryItems: [SSMClientTypes.ResourceComplianceSummaryItem]?

    public init(
        nextToken: Swift.String? = nil,
        resourceComplianceSummaryItems: [SSMClientTypes.ResourceComplianceSummaryItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceComplianceSummaryItems = resourceComplianceSummaryItems
    }
}

public struct ListResourceDataSyncInput: Swift.Sendable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// View a list of resource data syncs according to the sync type. Specify SyncToDestination to view resource data syncs that synchronize data to an Amazon S3 bucket. Specify SyncFromSource to view resource data syncs from Organizations or from multiple Amazon Web Services Regions.
    public var syncType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncType = syncType
    }
}

extension SSMClientTypes {

    public enum LastResourceDataSyncStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [LastResourceDataSyncStatus] {
            return [
                .failed,
                .inprogress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists (Your organization doesn't exist) NoPermissions (The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Amazon Web Services Systems Manager Explorer.) InvalidOrganizationalUnit (You specified or selected an invalid unit in the resource data sync configuration.) TrustedAccessDisabled (You disabled Systems Manager access in the organization in Organizations.)
    public struct ResourceDataSyncSourceWithState: Swift.Sendable {
        /// The field name in SyncSource for the ResourceDataSyncAwsOrganizationsSource type.
        public var awsOrganizationsSource: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource?
        /// When you create a resource data sync, if you choose one of the Organizations options, then Systems Manager automatically enables all OpsData sources in the selected Amazon Web Services Regions for all Amazon Web Services accounts in your organization (or in the selected organization units). For more information, see [Setting up Systems Manager Explorer to display data from multiple accounts and Regions](https://docs.aws.amazon.com/systems-manager/latest/userguide/Explorer-resource-data-sync.html) in the Amazon Web Services Systems Manager User Guide.
        public var enableAllOpsDataSources: Swift.Bool
        /// Whether to automatically synchronize and aggregate data from new Amazon Web Services Regions when those Regions come online.
        public var includeFutureRegions: Swift.Bool
        /// The SyncSource Amazon Web Services Regions included in the resource data sync.
        public var sourceRegions: [Swift.String]?
        /// The type of data source for the resource data sync. SourceType is either AwsOrganizations (if an organization is present in Organizations) or singleAccountMultiRegions.
        public var sourceType: Swift.String?
        /// The data type name for including resource data sync state. There are four sync states: OrganizationNotExists: Your organization doesn't exist. NoPermissions: The system can't locate the service-linked role. This role is automatically created when a user creates a resource data sync in Explorer. InvalidOrganizationalUnit: You specified or selected an invalid unit in the resource data sync configuration. TrustedAccessDisabled: You disabled Systems Manager access in the organization in Organizations.
        public var state: Swift.String?

        public init(
            awsOrganizationsSource: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource? = nil,
            enableAllOpsDataSources: Swift.Bool = false,
            includeFutureRegions: Swift.Bool = false,
            sourceRegions: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.awsOrganizationsSource = awsOrganizationsSource
            self.enableAllOpsDataSources = enableAllOpsDataSources
            self.includeFutureRegions = includeFutureRegions
            self.sourceRegions = sourceRegions
            self.sourceType = sourceType
            self.state = state
        }
    }
}

extension SSMClientTypes {

    /// Information about a resource data sync configuration, including its current status and last successful sync.
    public struct ResourceDataSyncItem: Swift.Sendable {
        /// The status reported by the last sync.
        public var lastStatus: SSMClientTypes.LastResourceDataSyncStatus?
        /// The last time the sync operations returned a status of SUCCESSFUL (UTC).
        public var lastSuccessfulSyncTime: Foundation.Date?
        /// The status message details reported by the last sync.
        public var lastSyncStatusMessage: Swift.String?
        /// The last time the configuration attempted to sync (UTC).
        public var lastSyncTime: Foundation.Date?
        /// Configuration information for the target S3 bucket.
        public var s3Destination: SSMClientTypes.ResourceDataSyncS3Destination?
        /// The date and time the configuration was created (UTC).
        public var syncCreatedTime: Foundation.Date?
        /// The date and time the resource data sync was changed.
        public var syncLastModifiedTime: Foundation.Date?
        /// The name of the resource data sync.
        public var syncName: Swift.String?
        /// Information about the source where the data was synchronized.
        public var syncSource: SSMClientTypes.ResourceDataSyncSourceWithState?
        /// The type of resource data sync. If SyncType is SyncToDestination, then the resource data sync synchronizes data to an S3 bucket. If the SyncType is SyncFromSource then the resource data sync synchronizes data from Organizations or from multiple Amazon Web Services Regions.
        public var syncType: Swift.String?

        public init(
            lastStatus: SSMClientTypes.LastResourceDataSyncStatus? = nil,
            lastSuccessfulSyncTime: Foundation.Date? = nil,
            lastSyncStatusMessage: Swift.String? = nil,
            lastSyncTime: Foundation.Date? = nil,
            s3Destination: SSMClientTypes.ResourceDataSyncS3Destination? = nil,
            syncCreatedTime: Foundation.Date? = nil,
            syncLastModifiedTime: Foundation.Date? = nil,
            syncName: Swift.String? = nil,
            syncSource: SSMClientTypes.ResourceDataSyncSourceWithState? = nil,
            syncType: Swift.String? = nil
        )
        {
            self.lastStatus = lastStatus
            self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
            self.lastSyncStatusMessage = lastSyncStatusMessage
            self.lastSyncTime = lastSyncTime
            self.s3Destination = s3Destination
            self.syncCreatedTime = syncCreatedTime
            self.syncLastModifiedTime = syncLastModifiedTime
            self.syncName = syncName
            self.syncSource = syncSource
            self.syncType = syncType
        }
    }
}

public struct ListResourceDataSyncOutput: Swift.Sendable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of your current resource data sync configurations and their statuses.
    public var resourceDataSyncItems: [SSMClientTypes.ResourceDataSyncItem]?

    public init(
        nextToken: Swift.String? = nil,
        resourceDataSyncItems: [SSMClientTypes.ResourceDataSyncItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceDataSyncItems = resourceDataSyncItems
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource ID for which you want to see a list of tags.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Returns a list of tags for a specific resource type.
    /// This member is required.
    public var resourceType: SSMClientTypes.ResourceTypeForTagging?

    public init(
        resourceId: Swift.String? = nil,
        resourceType: SSMClientTypes.ResourceTypeForTagging? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags.
    public var tagList: [SSMClientTypes.Tag]?

    public init(
        tagList: [SSMClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

/// The document can't be shared with more Amazon Web Services accounts. You can specify a maximum of 20 accounts per API operation to share a private document. By default, you can share a private document with a maximum of 1,000 accounts and publicly share up to five documents. If you need to increase the quota for privately or publicly shared Systems Manager documents, contact Amazon Web Services Support.
public struct DocumentPermissionLimit: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentPermissionLimit" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ModifyDocumentPermissionInput: Swift.Sendable {
    /// The Amazon Web Services users that should have access to the document. The account IDs can either be a group of account IDs or All.
    public var accountIdsToAdd: [Swift.String]?
    /// The Amazon Web Services users that should no longer have access to the document. The Amazon Web Services user can either be a group of account IDs or All. This action has a higher priority than AccountIdsToAdd. If you specify an ID to add and the same ID to remove, the system removes access to the document.
    public var accountIdsToRemove: [Swift.String]?
    /// The name of the document that you want to share.
    /// This member is required.
    public var name: Swift.String?
    /// The permission type for the document. The permission type can be Share.
    /// This member is required.
    public var permissionType: SSMClientTypes.DocumentPermissionType?
    /// (Optional) The version of the document to share. If it isn't specified, the system choose the Default version to share.
    public var sharedDocumentVersion: Swift.String?

    public init(
        accountIdsToAdd: [Swift.String]? = nil,
        accountIdsToRemove: [Swift.String]? = nil,
        name: Swift.String? = nil,
        permissionType: SSMClientTypes.DocumentPermissionType? = nil,
        sharedDocumentVersion: Swift.String? = nil
    )
    {
        self.accountIdsToAdd = accountIdsToAdd
        self.accountIdsToRemove = accountIdsToRemove
        self.name = name
        self.permissionType = permissionType
        self.sharedDocumentVersion = sharedDocumentVersion
    }
}

public struct ModifyDocumentPermissionOutput: Swift.Sendable {

    public init() { }
}

/// You specified too many custom compliance types. You can specify a maximum of 10 different types.
public struct ComplianceTypeCountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ComplianceTypeCountLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more content items isn't valid.
public struct InvalidItemContentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var typeName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidItemContent" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.typeName = typeName
    }
}

/// The inventory item size has exceeded the size limit.
public struct ItemSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var typeName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ItemSizeLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.typeName = typeName
    }
}

/// The size of inventory data has exceeded the total size limit for the resource.
public struct TotalSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TotalSizeLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Information about a compliance item.
    public struct ComplianceItemEntry: Swift.Sendable {
        /// A "Key": "Value" tag combination for the compliance item.
        public var details: [Swift.String: Swift.String]?
        /// The compliance item ID. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article.
        public var id: Swift.String?
        /// The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.
        /// This member is required.
        public var severity: SSMClientTypes.ComplianceSeverity?
        /// The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.
        /// This member is required.
        public var status: SSMClientTypes.ComplianceStatus?
        /// The title of the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.
        public var title: Swift.String?

        public init(
            details: [Swift.String: Swift.String]? = nil,
            id: Swift.String? = nil,
            severity: SSMClientTypes.ComplianceSeverity? = nil,
            status: SSMClientTypes.ComplianceStatus? = nil,
            title: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.severity = severity
            self.status = status
            self.title = title
        }
    }
}

extension SSMClientTypes {

    public enum ComplianceUploadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceUploadType] {
            return [
                .complete,
                .partial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct PutComplianceItemsInput: Swift.Sendable {
    /// Specify the compliance type. For example, specify Association (for a State Manager association), Patch, or Custom:string.
    /// This member is required.
    public var complianceType: Swift.String?
    /// A summary of the call execution that includes an execution ID, the type of execution (for example, Command), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'
    /// This member is required.
    public var executionSummary: SSMClientTypes.ComplianceExecutionSummary?
    /// MD5 or SHA-256 content hash. The content hash is used to determine if existing information should be overwritten or ignored. If the content hashes match, the request to put compliance information is ignored.
    public var itemContentHash: Swift.String?
    /// Information about the compliance as defined by the resource type. For example, for a patch compliance type, Items includes information about the PatchSeverity, Classification, and so on.
    /// This member is required.
    public var items: [SSMClientTypes.ComplianceItemEntry]?
    /// Specify an ID for this resource. For a managed node, this is the node ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specify the type of resource. ManagedInstance is currently the only supported resource type.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The mode for uploading compliance items. You can specify COMPLETE or PARTIAL. In COMPLETE mode, the system overwrites all existing compliance information for the resource. You must provide a full list of compliance items each time you send the request. In PARTIAL mode, the system overwrites compliance information for a specific association. The association must be configured with SyncCompliance set to MANUAL. By default, all requests use COMPLETE mode. This attribute is only valid for association compliance.
    public var uploadType: SSMClientTypes.ComplianceUploadType?

    public init(
        complianceType: Swift.String? = nil,
        executionSummary: SSMClientTypes.ComplianceExecutionSummary? = nil,
        itemContentHash: Swift.String? = nil,
        items: [SSMClientTypes.ComplianceItemEntry]? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        uploadType: SSMClientTypes.ComplianceUploadType? = nil
    )
    {
        self.complianceType = complianceType
        self.executionSummary = executionSummary
        self.itemContentHash = itemContentHash
        self.items = items
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.uploadType = uploadType
    }
}

public struct PutComplianceItemsOutput: Swift.Sendable {

    public init() { }
}

/// You have exceeded the limit for custom schemas. Delete one or more custom schemas and try again.
public struct CustomSchemaCountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomSchemaCountLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You specified invalid keys or values in the Context attribute for InventoryItem. Verify the keys and values, and try again.
public struct InvalidInventoryItemContextException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInventoryItemContext" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The inventory item has invalid content.
public struct ItemContentMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var typeName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ItemContentMismatch" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.typeName = typeName
    }
}

/// The sub-type count exceeded the limit for the inventory type.
public struct SubTypeCountLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubTypeCountLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Context attribute that you specified for the InventoryItem isn't allowed for this inventory type. You can only use the Context attribute with inventory types like AWS:ComplianceItem.
public struct UnsupportedInventoryItemContextException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var typeName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedInventoryItemContext" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        typeName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.typeName = typeName
    }
}

/// Inventory item type schema version has to match supported versions in the service. Check output of GetInventorySchema to see the available schema version for each type.
public struct UnsupportedInventorySchemaVersionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedInventorySchemaVersion" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    /// Information collected from managed nodes based on your inventory policy document
    public struct InventoryItem: Swift.Sendable {
        /// The time the inventory information was collected.
        /// This member is required.
        public var captureTime: Swift.String?
        /// The inventory data of the inventory type.
        public var content: [[Swift.String: Swift.String]]?
        /// MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API doesn't update the inventory item type contents if the MD5 hash hasn't changed since last update.
        public var contentHash: Swift.String?
        /// A map of associated properties for a specified inventory type. For example, with this attribute, you can specify the ExecutionId, ExecutionType, ComplianceType properties of the AWS:ComplianceItem type.
        public var context: [Swift.String: Swift.String]?
        /// The schema version for the inventory item.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The name of the inventory type. Default inventory item type names start with AWS. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.
        /// This member is required.
        public var typeName: Swift.String?

        public init(
            captureTime: Swift.String? = nil,
            content: [[Swift.String: Swift.String]]? = nil,
            contentHash: Swift.String? = nil,
            context: [Swift.String: Swift.String]? = nil,
            schemaVersion: Swift.String? = nil,
            typeName: Swift.String? = nil
        )
        {
            self.captureTime = captureTime
            self.content = content
            self.contentHash = contentHash
            self.context = context
            self.schemaVersion = schemaVersion
            self.typeName = typeName
        }
    }
}

public struct PutInventoryInput: Swift.Sendable {
    /// An managed node ID where you want to add or update inventory items.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The inventory items that you want to add or update on managed nodes.
    /// This member is required.
    public var items: [SSMClientTypes.InventoryItem]?

    public init(
        instanceId: Swift.String? = nil,
        items: [SSMClientTypes.InventoryItem]? = nil
    )
    {
        self.instanceId = instanceId
        self.items = items
    }
}

public struct PutInventoryOutput: Swift.Sendable {
    /// Information about the request.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

/// A hierarchy can have a maximum of 15 levels. For more information, see [Requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html) in the Amazon Web Services Systems Manager User Guide.
public struct HierarchyLevelLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A hierarchy can have a maximum of 15 levels. For more information, see [About requirements and constraints for parameter names](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html#sysman-parameter-name-constraints) in the Amazon Web Services Systems Manager User Guide.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HierarchyLevelLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
public struct HierarchyTypeMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Parameter Store doesn't support changing a parameter type in a hierarchy. For example, you can't change a parameter from a String type to a SecureString type. You must create a new, unique parameter.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HierarchyTypeMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is a conflict in the policies specified for this parameter. You can't, for example, specify two Expiration policies for a parameter. Review your policies, and try again.
public struct IncompatiblePolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncompatiblePolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request doesn't meet the regular expression requirement.
public struct InvalidAllowedPatternException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request doesn't meet the regular expression requirement.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAllowedPatternException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A policy attribute or its value is invalid.
public struct InvalidPolicyAttributeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyAttributeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The policy type isn't supported. Parameter Store supports the following policy types: Expiration, ExpirationNotification, and NoChangeNotification.
public struct InvalidPolicyTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameter already exists. You can't create duplicate parameters.
public struct ParameterAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the number of parameters for this Amazon Web Services account. Delete one or more parameters and try again.
public struct ParameterLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Parameter Store retains the 100 most recently created versions of a parameter. After this number of versions has been created, Parameter Store deletes the oldest version when a new one is created. However, if the oldest version has a label attached to it, Parameter Store won't delete the version and instead presents this error message: An error occurred (ParameterMaxVersionLimitExceeded) when calling the PutParameter operation: You attempted to create a new version of parameter-name by calling the PutParameter API with the overwrite flag. Version version-number, the oldest version, can't be deleted because it has a label associated with it. Move the label to another version of the parameter, and try again. This safeguard is to prevent parameter versions with mission critical labels assigned to them from being deleted. To continue creating new parameters, first move the label from the oldest version of the parameter to a newer one for use in your operations. For information about moving parameter labels, see [Move a parameter label (console)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-console-move) or [Move a parameter label (CLI)](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html#sysman-paramstore-labels-cli-move) in the Amazon Web Services Systems Manager User Guide.
public struct ParameterMaxVersionLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterMaxVersionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameter name isn't valid.
public struct ParameterPatternMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter name isn't valid.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterPatternMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You specified more than the maximum number of allowed policies for the parameter. The maximum is 10.
public struct PoliciesLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PoliciesLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameter type isn't supported.
public struct UnsupportedParameterType: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedParameterType" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutParameterInput: Swift.Sendable {
    /// A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$
    public var allowedPattern: Swift.String?
    /// The data type for a String parameter. Supported data types include plain text and Amazon Machine Image (AMI) IDs. The following data type values are supported.
    ///
    /// * text
    ///
    /// * aws:ec2:image
    ///
    /// * aws:ssm:integration
    ///
    ///
    /// When you create a String parameter and specify aws:ec2:image, Amazon Web Services Systems Manager validates the parameter value is in the required format, such as ami-12345abcdeEXAMPLE, and that the specified AMI is available in your Amazon Web Services account. If the action is successful, the service sends back an HTTP 200 response which indicates a successful PutParameter call for all cases except for data type aws:ec2:image. If you call PutParameter with aws:ec2:image data type, a successful HTTP 200 response does not guarantee that your parameter was successfully created or updated. The aws:ec2:image value is validated asynchronously, and the PutParameter call returns before the validation is complete. If you submit an invalid AMI value, the PutParameter operation will return success, but the asynchronous validation will fail and the parameter will not be created or updated. To monitor whether your aws:ec2:image parameters are created successfully, see [Setting up notifications or trigger actions based on Parameter Store events](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-cwe.html). For more information about AMI format validation , see [Native parameter support for Amazon Machine Image IDs](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-ec2-aliases.html).
    public var dataType: Swift.String?
    /// Information about the parameter that you want to add to the system. Optional but recommended. Don't enter personally identifiable information in this field.
    public var description: Swift.String?
    /// The Key Management Service (KMS) ID that you want to use to encrypt a parameter. Use a custom key for better security. Required for parameters that use the SecureString data type. If you don't specify a key ID, the system uses the default key associated with your Amazon Web Services account which is not as secure as using a custom key.
    ///
    /// * To use a custom KMS key, choose the SecureString data type with the Key ID parameter.
    public var keyId: Swift.String?
    /// The fully qualified name of the parameter that you want to add to the system. You can't enter the Amazon Resource Name (ARN) for a parameter, only the parameter name itself. The fully qualified name includes the complete hierarchy of the parameter path and name. For parameters in a hierarchy, you must include a leading forward slash character (/) when you create or reference a parameter. For example: /Dev/DBServer/MySQL/db-string13 Naming Constraints:
    ///
    /// * Parameter names are case sensitive.
    ///
    /// * A parameter name must be unique within an Amazon Web Services Region
    ///
    /// * A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).
    ///
    /// * Parameter names can include only the following symbols and letters: a-zA-Z0-9_.- In addition, the slash character ( / ) is used to delineate hierarchies in parameter names. For example: /Dev/Production/East/Project-ABC/MyParameter
    ///
    /// * A parameter name can't include spaces.
    ///
    /// * Parameter hierarchies are limited to a maximum depth of fifteen levels.
    ///
    ///
    /// For additional information about valid values for parameter names, see [Creating Systems Manager parameters](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-su-create.html) in the Amazon Web Services Systems Manager User Guide. The maximum length constraint of 2048 characters listed below includes 1037 characters reserved for internal use by Systems Manager. The maximum length for a parameter name that you create is 1011 characters. This includes the characters in the ARN that precede the name you specify, such as arn:aws:ssm:us-east-2:111122223333:parameter/.
    /// This member is required.
    public var name: Swift.String?
    /// Overwrite an existing parameter. The default value is false.
    public var overwrite: Swift.Bool?
    /// One or more policies to apply to a parameter. This operation takes a JSON array. Parameter Store, a capability of Amazon Web Services Systems Manager supports the following policy types: Expiration: This policy deletes the parameter after it expires. When you create the policy, you specify the expiration date. You can update the expiration date and time by updating the policy. Updating the parameter doesn't affect the expiration date and time. When the expiration time is reached, Parameter Store deletes the parameter. ExpirationNotification: This policy initiates an event in Amazon CloudWatch Events that notifies you about the expiration. By using this policy, you can receive notification before or after the expiration time is reached, in units of days or hours. NoChangeNotification: This policy initiates a CloudWatch Events event if a parameter hasn't been modified for a specified period of time. This policy type is useful when, for example, a secret needs to be changed within a period of time, but it hasn't been changed. All existing policies are preserved until you send new policies or an empty policy. For more information about parameter policies, see [Assigning parameter policies](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-policies.html).
    public var policies: Swift.String?
    /// Optional metadata that you assign to a resource. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a Systems Manager parameter to identify the type of resource to which it applies, the environment, or the type of configuration data referenced by the parameter. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Resource,Value=S3bucket
    ///
    /// * Key=OS,Value=Windows
    ///
    /// * Key=ParameterType,Value=LicenseKey
    ///
    ///
    /// To add tags to an existing Systems Manager parameter, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?
    /// The parameter tier to assign to a parameter. Parameter Store offers a standard tier and an advanced tier for parameters. Standard parameters have a content size limit of 4 KB and can't be configured to use parameter policies. You can create a maximum of 10,000 standard parameters for each Region in an Amazon Web Services account. Standard parameters are offered at no additional cost. Advanced parameters have a content size limit of 8 KB and can be configured to use parameter policies. You can create a maximum of 100,000 advanced parameters for each Region in an Amazon Web Services account. Advanced parameters incur a charge. For more information, see [Managing parameter tiers](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html) in the Amazon Web Services Systems Manager User Guide. You can change a standard parameter to an advanced parameter any time. But you can't revert an advanced parameter to a standard parameter. Reverting an advanced parameter to a standard parameter would result in data loss because the system would truncate the size of the parameter from 8 KB to 4 KB. Reverting would also remove any policies attached to the parameter. Lastly, advanced parameters use a different form of encryption than standard parameters. If you no longer need an advanced parameter, or if you no longer want to incur charges for an advanced parameter, you must delete it and recreate it as a new standard parameter. Using the Default Tier Configuration In PutParameter requests, you can specify the tier to create the parameter in. Whenever you specify a tier in the request, Parameter Store creates or updates the parameter according to that request. However, if you don't specify a tier in a request, Parameter Store assigns the tier based on the current Parameter Store default tier configuration. The default tier when you begin using Parameter Store is the standard-parameter tier. If you use the advanced-parameter tier, you can specify one of the following as the default:
    ///
    /// * Advanced: With this option, Parameter Store evaluates all requests as advanced parameters.
    ///
    /// * Intelligent-Tiering: With this option, Parameter Store evaluates each request to determine if the parameter is standard or advanced. If the request doesn't include any options that require an advanced parameter, the parameter is created in the standard-parameter tier. If one or more options requiring an advanced parameter are included in the request, Parameter Store create a parameter in the advanced-parameter tier. This approach helps control your parameter-related costs by always creating standard parameters unless an advanced parameter is necessary.
    ///
    ///
    /// Options that require an advanced parameter include the following:
    ///
    /// * The content size of the parameter is more than 4 KB.
    ///
    /// * The parameter uses a parameter policy.
    ///
    /// * More than 10,000 parameters already exist in your Amazon Web Services account in the current Amazon Web Services Region.
    ///
    ///
    /// For more information about configuring the default tier option, see [Specifying a default parameter tier](https://docs.aws.amazon.com/systems-manager/latest/userguide/parameter-store-advanced-parameters.html#ps-default-tier) in the Amazon Web Services Systems Manager User Guide.
    public var tier: SSMClientTypes.ParameterTier?
    /// The type of parameter that you want to add to the system. SecureString isn't currently supported for CloudFormation templates. Items in a StringList must be separated by a comma (,). You can't use other punctuation or special character to escape items in the list. If you have a parameter value that requires a comma, then use the String data type. Specifying a parameter type isn't required when updating a parameter. You must specify a parameter type when creating a parameter.
    public var type: SSMClientTypes.ParameterType?
    /// The parameter value that you want to add to the system. Standard parameters have a value limit of 4 KB. Advanced parameters have a value limit of 8 KB. Parameters can't be referenced or nested in the values of other parameters. You can't include {{}} or {{ssm:parameter-name}} in a parameter value.
    /// This member is required.
    public var value: Swift.String?

    public init(
        allowedPattern: Swift.String? = nil,
        dataType: Swift.String? = nil,
        description: Swift.String? = nil,
        keyId: Swift.String? = nil,
        name: Swift.String? = nil,
        overwrite: Swift.Bool? = false,
        policies: Swift.String? = nil,
        tags: [SSMClientTypes.Tag]? = nil,
        tier: SSMClientTypes.ParameterTier? = nil,
        type: SSMClientTypes.ParameterType? = nil,
        value: Swift.String? = nil
    )
    {
        self.allowedPattern = allowedPattern
        self.dataType = dataType
        self.description = description
        self.keyId = keyId
        self.name = name
        self.overwrite = overwrite
        self.policies = policies
        self.tags = tags
        self.tier = tier
        self.type = type
        self.value = value
    }
}

extension PutParameterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutParameterInput(allowedPattern: \(Swift.String(describing: allowedPattern)), dataType: \(Swift.String(describing: dataType)), description: \(Swift.String(describing: description)), keyId: \(Swift.String(describing: keyId)), name: \(Swift.String(describing: name)), overwrite: \(Swift.String(describing: overwrite)), policies: \(Swift.String(describing: policies)), tags: \(Swift.String(describing: tags)), tier: \(Swift.String(describing: tier)), type: \(Swift.String(describing: type)), value: \"CONTENT_REDACTED\")"}
}

public struct PutParameterOutput: Swift.Sendable {
    /// The tier assigned to the parameter.
    public var tier: SSMClientTypes.ParameterTier?
    /// The new version number of a parameter. If you edit a parameter value, Parameter Store automatically creates a new version and assigns this new version a unique ID. You can reference a parameter version ID in API operations or in Systems Manager documents (SSM documents). By default, if you don't specify a specific version, the system returns the latest parameter value when a parameter is called.
    public var version: Swift.Int

    public init(
        tier: SSMClientTypes.ParameterTier? = nil,
        version: Swift.Int = 0
    )
    {
        self.tier = tier
        self.version = version
    }
}

/// The [PutResourcePolicy] API action enforces two limits. A policy can't be greater than 1024 bytes in size. And only one policy can be attached to OpsItemGroup. Verify these limits and try again.
public struct ResourcePolicyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var limit: Swift.Int = 0
        public internal(set) var limitType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePolicyLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        limitType: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.limit = limit
        self.properties.limitType = limitType
        self.properties.message = message
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// A policy you want to associate with a resource.
    /// This member is required.
    public var policy: Swift.String?
    /// ID of the current policy version. The hash helps to prevent a situation where multiple users attempt to overwrite a policy. You must provide this hash when updating or deleting a policy.
    public var policyHash: Swift.String?
    /// The policy ID.
    public var policyId: Swift.String?
    /// Amazon Resource Name (ARN) of the resource to which you want to attach a policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        policyHash: Swift.String? = nil,
        policyId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyHash = policyHash
        self.policyId = policyId
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// ID of the current policy version.
    public var policyHash: Swift.String?
    /// The policy ID. To update a policy, you must specify PolicyId and PolicyHash.
    public var policyId: Swift.String?

    public init(
        policyHash: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.policyHash = policyHash
        self.policyId = policyId
    }
}

public struct RegisterDefaultPatchBaselineInput: Swift.Sendable {
    /// The ID of the patch baseline that should be the default patch baseline.
    /// This member is required.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

public struct RegisterDefaultPatchBaselineOutput: Swift.Sendable {
    /// The ID of the default patch baseline.
    public var baselineId: Swift.String?

    public init(
        baselineId: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
    }
}

public struct RegisterPatchBaselineForPatchGroupInput: Swift.Sendable {
    /// The ID of the patch baseline to register with the patch group.
    /// This member is required.
    public var baselineId: Swift.String?
    /// The name of the patch group to be registered with the patch baseline.
    /// This member is required.
    public var patchGroup: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

public struct RegisterPatchBaselineForPatchGroupOutput: Swift.Sendable {
    /// The ID of the patch baseline the patch group was registered with.
    public var baselineId: Swift.String?
    /// The name of the patch group registered with the patch baseline.
    public var patchGroup: Swift.String?

    public init(
        baselineId: Swift.String? = nil,
        patchGroup: Swift.String? = nil
    )
    {
        self.baselineId = baselineId
        self.patchGroup = patchGroup
    }
}

public struct RegisterTargetWithMaintenanceWindowInput: Swift.Sendable {
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// An optional description for the target.
    public var description: Swift.String?
    /// An optional name for the target.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// The type of target being registered with the maintenance window.
    /// This member is required.
    public var resourceType: SSMClientTypes.MaintenanceWindowResourceType?
    /// The targets to register with the maintenance window. In other words, the managed nodes to run commands on when the maintenance window runs. If a single maintenance window task is registered with multiple targets, its task invocations occur sequentially and not in parallel. If your task must run on multiple targets at the same time, register a task for each target individually and assign each task the same priority level. You can specify targets using managed node IDs, resource group names, or tags that have been applied to managed nodes. Example 1: Specify managed node IDs Key=InstanceIds,Values=,, Example 2: Use tag key-pairs applied to managed nodes Key=tag:,Values=, Example 3: Use tag-keys applied to managed nodes Key=tag-key,Values=, Example 4: Use resource group names Key=resource-groups:Name,Values= Example 5: Use filters for resource group types Key=resource-groups:ResourceTypeFilters,Values=, For Key=resource-groups:ResourceTypeFilters, specify resource types in the following format Key=resource-groups:ResourceTypeFilters,Values=AWS::EC2::INSTANCE,AWS::EC2::VPC For more information about these examples formats, including the best use case for each one, see [Examples: Register targets with a maintenance window](https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var targets: [SSMClientTypes.Target]?
    /// The ID of the maintenance window the target should be registered with.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        resourceType: SSMClientTypes.MaintenanceWindowResourceType? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.resourceType = resourceType
        self.targets = targets
        self.windowId = windowId
    }
}

extension RegisterTargetWithMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTargetWithMaintenanceWindowInput(clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), resourceType: \(Swift.String(describing: resourceType)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\", ownerInformation: \"CONTENT_REDACTED\")"}
}

public struct RegisterTargetWithMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the target definition in this maintenance window.
    public var windowTargetId: Swift.String?

    public init(
        windowTargetId: Swift.String? = nil
    )
    {
        self.windowTargetId = windowTargetId
    }
}

/// You attempted to register a LAMBDA or STEP_FUNCTIONS task in a region where the corresponding service isn't available.
public struct FeatureNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FeatureNotAvailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RegisterTaskWithMaintenanceWindowInput: Swift.Sendable {
    /// The CloudWatch alarm you want to apply to your maintenance window task.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// User-provided idempotency token.
    public var clientToken: Swift.String?
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// An optional description for the task.
    public var description: Swift.String?
    /// A structure containing information about an Amazon Simple Storage Service (Amazon S3) bucket to write managed node-level logs to. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SSMClientTypes.LoggingInfo?
    /// The maximum number of targets this task can be run for, in parallel. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed before this task stops being scheduled. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxErrors: Swift.String?
    /// An optional name for the task.
    public var name: Swift.String?
    /// The priority of the task in the maintenance window, the lower the number the higher the priority. Tasks in a maintenance window are scheduled in priority order with tasks that have the same priority scheduled in parallel.
    public var priority: Swift.Int?
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or maintenance window targets). One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide. Specify managed nodes using the following format: Key=InstanceIds,Values=, Specify maintenance window targets using the following format: Key=WindowTargetIds,Values=,
    public var targets: [SSMClientTypes.Target]?
    /// The ARN of the task to run.
    /// This member is required.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty.
    public var taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters that should be passed to the task when it is run. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The type of task being registered.
    /// This member is required.
    public var taskType: SSMClientTypes.MaintenanceWindowTaskType?
    /// The ID of the maintenance window the task should be added to.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        clientToken: Swift.String? = nil,
        cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SSMClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        taskType: SSMClientTypes.MaintenanceWindowTaskType? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.clientToken = clientToken
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.taskType = taskType
        self.windowId = windowId
    }
}

extension RegisterTaskWithMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterTaskWithMaintenanceWindowInput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), clientToken: \(Swift.String(describing: clientToken)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), taskType: \(Swift.String(describing: taskType)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\", taskParameters: \"CONTENT_REDACTED\")"}
}

public struct RegisterTaskWithMaintenanceWindowOutput: Swift.Sendable {
    /// The ID of the task in the maintenance window.
    public var windowTaskId: Swift.String?

    public init(
        windowTaskId: Swift.String? = nil
    )
    {
        self.windowTaskId = windowTaskId
    }
}

public struct RemoveTagsFromResourceInput: Swift.Sendable {
    /// The ID of the resource from which you want to remove tags. For example: ManagedInstance: mi-012345abcde MaintenanceWindow: mw-012345abcde Automation: example-c160-4567-8519-012345abcde PatchBaseline: pb-012345abcde OpsMetadata object: ResourceID for tagging is created from the Amazon Resource Name (ARN) for the object. Specifically, ResourceID is created from the strings that come after the word opsmetadata in the ARN. For example, an OpsMetadata object with an ARN of arn:aws:ssm:us-east-2:1234567890:opsmetadata/aws/ssm/MyGroup/appmanager has a ResourceID of either aws/ssm/MyGroup/appmanager or /aws/ssm/MyGroup/appmanager. For the Document and Parameter values, use the name of the resource. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource from which you want to remove a tag. The ManagedInstance type for this API operation is only for on-premises managed nodes. Specify the name of the managed node in the following format: mi-ID_number . For example, mi-1a2b3c4d5e6f.
    /// This member is required.
    public var resourceType: SSMClientTypes.ResourceTypeForTagging?
    /// Tag keys that you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        resourceType: SSMClientTypes.ResourceTypeForTagging? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.tagKeys = tagKeys
    }
}

public struct RemoveTagsFromResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request body of the ResetServiceSetting API operation.
public struct ResetServiceSettingInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service setting to reset. The setting ID can be one of the following.
    ///
    /// * /ssm/managed-instance/default-ec2-instance-management-role
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/managed-instance/activation-tier
    ///
    /// * /ssm/opsinsights/opscenter
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    /// This member is required.
    public var settingId: Swift.String?

    public init(
        settingId: Swift.String? = nil
    )
    {
        self.settingId = settingId
    }
}

/// The result body of the ResetServiceSetting API operation.
public struct ResetServiceSettingOutput: Swift.Sendable {
    /// The current, effective service setting after calling the ResetServiceSetting API operation.
    public var serviceSetting: SSMClientTypes.ServiceSetting?

    public init(
        serviceSetting: SSMClientTypes.ServiceSetting? = nil
    )
    {
        self.serviceSetting = serviceSetting
    }
}

public struct ResumeSessionInput: Swift.Sendable {
    /// The ID of the disconnected session to resume.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

public struct ResumeSessionOutput: Swift.Sendable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the managed node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output). region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. Used to authenticate the connection to the managed node.
    public var tokenValue: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

/// The specified step name and execution ID don't exist. Verify the information and try again.
public struct AutomationStepNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationStepNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The signal isn't valid for the current Automation execution.
public struct InvalidAutomationSignalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAutomationSignalException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum SignalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approve
        case reject
        case resume
        case startStep
        case stopStep
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalType] {
            return [
                .approve,
                .reject,
                .resume,
                .startStep,
                .stopStep
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .resume: return "Resume"
            case .startStep: return "StartStep"
            case .stopStep: return "StopStep"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SendAutomationSignalInput: Swift.Sendable {
    /// The unique identifier for an existing Automation execution that you want to send the signal to.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The data sent with the signal. The data schema depends on the type of signal used in the request. For Approve and Reject signal types, the payload is an optional comment that you can send with the signal type. For example: Comment="Looks good" For StartStep and Resume signal types, you must send the name of the Automation step to start or resume as the payload. For example: StepName="step1" For the StopStep signal type, you must send the step execution ID as the payload. For example: StepExecutionId="97fff367-fc5a-4299-aed8-0123456789ab"
    public var payload: [Swift.String: [Swift.String]]?
    /// The type of signal to send to an Automation execution.
    /// This member is required.
    public var signalType: SSMClientTypes.SignalType?

    public init(
        automationExecutionId: Swift.String? = nil,
        payload: [Swift.String: [Swift.String]]? = nil,
        signalType: SSMClientTypes.SignalType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.payload = payload
        self.signalType = signalType
    }
}

public struct SendAutomationSignalOutput: Swift.Sendable {

    public init() { }
}

/// One or more configuration items isn't valid. Verify that a valid Amazon Resource Name (ARN) was provided for an Amazon Simple Notification Service topic.
public struct InvalidNotificationConfig: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNotificationConfig" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The S3 bucket doesn't exist.
public struct InvalidOutputFolder: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "InvalidOutputFolder" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

/// The role name can't contain invalid characters. Also verify that you specified an IAM role for notifications that includes the required trust policy. For information about configuring the IAM role for Run Command notifications, see [Monitoring Systems Manager status changes using Amazon SNS notifications](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
public struct InvalidRole: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRole" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct SendCommandInput: Swift.Sendable {
    /// The CloudWatch alarm you want to apply to your command.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// Enables Amazon Web Services Systems Manager to send Run Command output to Amazon CloudWatch Logs. Run Command is a capability of Amazon Web Services Systems Manager.
    public var cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig?
    /// User-specified information about the command, such as a brief description of what the command should do.
    public var comment: Swift.String?
    /// The Sha256 or Sha1 hash created by the system when the document was created. Sha1 hashes have been deprecated.
    public var documentHash: Swift.String?
    /// Sha256 or Sha1. Sha1 hashes have been deprecated.
    public var documentHashType: SSMClientTypes.DocumentHashType?
    /// The name of the Amazon Web Services Systems Manager document (SSM document) to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document Amazon Resource Name (ARN). For more information about how to use shared documents, see [Sharing SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-using-shared.html) in the Amazon Web Services Systems Manager User Guide. If you specify a document name or ARN that hasn't been shared with your account, you receive an InvalidDocument error.
    /// This member is required.
    public var documentName: Swift.String?
    /// The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you run commands by using the Command Line Interface (Amazon Web Services CLI), then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example: --document-version "\$DEFAULT" --document-version "\$LATEST" --document-version "3"
    public var documentVersion: Swift.String?
    /// The IDs of the managed nodes where the command should run. Specifying managed node IDs is most useful when you are targeting a limited number of managed nodes, though you can specify up to 50 IDs. To target a larger number of managed nodes, or if you prefer not to list individual node IDs, we recommend using the Targets option instead. Using Targets, which accepts tag key-value pairs to identify the managed nodes to send commands to, you can a send command to tens, hundreds, or thousands of nodes at once. For more information about how to use targets, see [Run commands at scale](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var instanceIds: [Swift.String]?
    /// (Optional) The maximum number of managed nodes that are allowed to run the command at the same time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see [Using concurrency controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity) in the Amazon Web Services Systems Manager User Guide.
    public var maxConcurrency: Swift.String?
    /// The maximum number of errors allowed without the command failing. When the command fails one more time beyond the value of MaxErrors, the systems stops sending the command to additional targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For more information about how to use MaxErrors, see [Using error controls](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors) in the Amazon Web Services Systems Manager User Guide.
    public var maxErrors: Swift.String?
    /// Configurations for sending notifications.
    public var notificationConfig: SSMClientTypes.NotificationConfig?
    /// The name of the S3 bucket where command execution responses should be stored.
    public var outputS3BucketName: Swift.String?
    /// The directory structure within the S3 bucket where the responses should be stored.
    public var outputS3KeyPrefix: Swift.String?
    /// (Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon Web Services Region of the S3 bucket.
    public var outputS3Region: Swift.String?
    /// The required and optional parameters specified in the document being run.
    public var parameters: [Swift.String: [Swift.String]]?
    /// The ARN of the Identity and Access Management (IAM) service role to use to publish Amazon Simple Notification Service (Amazon SNS) notifications for Run Command commands. This role must provide the sns:Publish permission for your notification topic. For information about creating and using this service role, see [Monitoring Systems Manager status changes using Amazon SNS notifications](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the Amazon Web Services Systems Manager User Guide.
    public var serviceRoleArn: Swift.String?
    /// An array of search criteria that targets managed nodes using a Key,Value combination that you specify. Specifying targets is most useful when you want to send a command to a large number of managed nodes at once. Using Targets, which accepts tag key-value pairs to identify managed nodes, you can send a command to tens, hundreds, or thousands of nodes at once. To send a command to a smaller number of managed nodes, you can use the InstanceIds option instead. For more information about how to use targets, see [Run commands at scale](https://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SSMClientTypes.Target]?
    /// If this time is reached and the command hasn't already started running, it won't run.
    public var timeoutSeconds: Swift.Int?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        cloudWatchOutputConfig: SSMClientTypes.CloudWatchOutputConfig? = nil,
        comment: Swift.String? = nil,
        documentHash: Swift.String? = nil,
        documentHashType: SSMClientTypes.DocumentHashType? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        instanceIds: [Swift.String]? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        notificationConfig: SSMClientTypes.NotificationConfig? = nil,
        outputS3BucketName: Swift.String? = nil,
        outputS3KeyPrefix: Swift.String? = nil,
        outputS3Region: Swift.String? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        serviceRoleArn: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        timeoutSeconds: Swift.Int? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.cloudWatchOutputConfig = cloudWatchOutputConfig
        self.comment = comment
        self.documentHash = documentHash
        self.documentHashType = documentHashType
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.instanceIds = instanceIds
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.notificationConfig = notificationConfig
        self.outputS3BucketName = outputS3BucketName
        self.outputS3KeyPrefix = outputS3KeyPrefix
        self.outputS3Region = outputS3Region
        self.parameters = parameters
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.timeoutSeconds = timeoutSeconds
    }
}

extension SendCommandInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendCommandInput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cloudWatchOutputConfig: \(Swift.String(describing: cloudWatchOutputConfig)), comment: \(Swift.String(describing: comment)), documentHash: \(Swift.String(describing: documentHash)), documentHashType: \(Swift.String(describing: documentHashType)), documentName: \(Swift.String(describing: documentName)), documentVersion: \(Swift.String(describing: documentVersion)), instanceIds: \(Swift.String(describing: instanceIds)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), notificationConfig: \(Swift.String(describing: notificationConfig)), outputS3BucketName: \(Swift.String(describing: outputS3BucketName)), outputS3KeyPrefix: \(Swift.String(describing: outputS3KeyPrefix)), outputS3Region: \(Swift.String(describing: outputS3Region)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), timeoutSeconds: \(Swift.String(describing: timeoutSeconds)), parameters: \"CONTENT_REDACTED\")"}
}

public struct SendCommandOutput: Swift.Sendable {
    /// The request as it was received by Systems Manager. Also provides the command ID which can be used future references to this request.
    public var command: SSMClientTypes.Command?

    public init(
        command: SSMClientTypes.Command? = nil
    )
    {
        self.command = command
    }
}

/// The association isn't valid or doesn't exist.
public struct InvalidAssociation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAssociation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartAssociationsOnceInput: Swift.Sendable {
    /// The association IDs that you want to run immediately and only one time.
    /// This member is required.
    public var associationIds: [Swift.String]?

    public init(
        associationIds: [Swift.String]? = nil
    )
    {
        self.associationIds = associationIds
    }
}

public struct StartAssociationsOnceOutput: Swift.Sendable {

    public init() { }
}

/// An Automation runbook with the specified name couldn't be found.
public struct AutomationDefinitionNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationDefinitionNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An Automation runbook with the specified name and version couldn't be found.
public struct AutomationDefinitionVersionNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationDefinitionVersionNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of simultaneously running Automation executions exceeded the allowable limit.
public struct AutomationExecutionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationExecutionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The supplied parameters for invoking the specified Automation runbook are incorrect. For example, they may not match the set of parameters permitted for the specified Automation document.
public struct InvalidAutomationExecutionParametersException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAutomationExecutionParameters" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartAutomationExecutionInput: Swift.Sendable {
    /// The CloudWatch alarm you want to apply to your automation.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// User-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the SSM document to run. This can be a public document or a custom document. To run a shared document belonging to another account, specify the document ARN. For more information about how to use shared documents, see [Sharing SSM documents](https://docs.aws.amazon.com/systems-manager/latest/userguide/documents-ssm-sharing.html) in the Amazon Web Services Systems Manager User Guide.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the Automation runbook to use for this execution.
    public var documentVersion: Swift.String?
    /// The maximum number of targets allowed to run this task in parallel. You can specify a number, such as 10, or a percentage, such as 10%. The default value is 10. If both this parameter and the TargetLocation:TargetsMaxConcurrency are supplied, TargetLocation:TargetsMaxConcurrency takes precedence.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops running the automation on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops running the automation when the fourth error is received. If you specify 0, then the system stops running the automation on additional targets after the first error result is returned. If you run an automation on 50 resources and set max-errors to 10%, then the system stops running the automation on additional targets when the sixth error is received. Executions that are already running an automation when max-errors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one at a time. If this parameter and the TargetLocation:TargetsMaxErrors parameter are both supplied, TargetLocation:TargetsMaxErrors takes precedence.
    public var maxErrors: Swift.String?
    /// The execution mode of the automation. Valid modes include the following: Auto and Interactive. The default mode is Auto.
    public var mode: SSMClientTypes.ExecutionMode?
    /// A key-value map of execution parameters, which match the declared parameters in the Automation runbook.
    public var parameters: [Swift.String: [Swift.String]]?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for an automation. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag an automation to identify an environment or operating system. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=environment,Value=test
    ///
    /// * Key=OS,Value=Windows
    ///
    ///
    /// To add tags to an existing automation, use the [AddTagsToResource] operation.
    public var tags: [SSMClientTypes.Tag]?
    /// A location is a combination of Amazon Web Services Regions and/or Amazon Web Services accounts where you want to run the automation. Use this operation to start an automation in multiple Amazon Web Services Regions and multiple Amazon Web Services accounts. For more information, see [Running automations in multiple Amazon Web Services Regions and accounts](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-automation-multiple-accounts-and-regions.html) in the Amazon Web Services Systems Manager User Guide.
    public var targetLocations: [SSMClientTypes.TargetLocation]?
    /// Specify a publicly accessible URL for a file that contains the TargetLocations body. Currently, only files in presigned Amazon S3 buckets are supported.
    public var targetLocationsURL: Swift.String?
    /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
    public var targetMaps: [[Swift.String: [Swift.String]]]?
    /// The name of the parameter used as the target resource for the rate-controlled execution. Required if you specify targets.
    public var targetParameterName: Swift.String?
    /// A key-value mapping to target resources. Required if you specify TargetParameterName. If both this parameter and the TargetLocation:Targets parameter are supplied, TargetLocation:Targets takes precedence.
    public var targets: [SSMClientTypes.Target]?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        mode: SSMClientTypes.ExecutionMode? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        tags: [SSMClientTypes.Tag]? = nil,
        targetLocations: [SSMClientTypes.TargetLocation]? = nil,
        targetLocationsURL: Swift.String? = nil,
        targetMaps: [[Swift.String: [Swift.String]]]? = nil,
        targetParameterName: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.mode = mode
        self.parameters = parameters
        self.tags = tags
        self.targetLocations = targetLocations
        self.targetLocationsURL = targetLocationsURL
        self.targetMaps = targetMaps
        self.targetParameterName = targetParameterName
        self.targets = targets
    }
}

public struct StartAutomationExecutionOutput: Swift.Sendable {
    /// The unique ID of a newly scheduled automation execution.
    public var automationExecutionId: Swift.String?

    public init(
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

/// Indicates that the Change Manager change template used in the change request was rejected or is still in a pending state.
public struct AutomationDefinitionNotApprovedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationDefinitionNotApproved" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartChangeRequestExecutionInput: Swift.Sendable {
    /// Indicates whether the change request can be approved automatically without the need for manual approvals. If AutoApprovable is enabled in a change template, then setting AutoApprove to true in StartChangeRequestExecution creates a change request that bypasses approver review. Change Calendar restrictions are not bypassed in this scenario. If the state of an associated calendar is CLOSED, change freeze approvers must still grant permission for this change request to run. If they don't, the change won't be processed until the calendar state is again OPEN.
    public var autoApprove: Swift.Bool?
    /// User-provided details about the change. If no details are provided, content specified in the Template information section of the associated change template is added.
    public var changeDetails: Swift.String?
    /// The name of the change request associated with the runbook workflow to be run.
    public var changeRequestName: Swift.String?
    /// The user-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.
    public var clientToken: Swift.String?
    /// The name of the change template document to run during the runbook workflow.
    /// This member is required.
    public var documentName: Swift.String?
    /// The version of the change template document to run during the runbook workflow.
    public var documentVersion: Swift.String?
    /// A key-value map of parameters that match the declared parameters in the change template document.
    public var parameters: [Swift.String: [Swift.String]]?
    /// Information about the Automation runbooks that are run during the runbook workflow. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    /// This member is required.
    public var runbooks: [SSMClientTypes.Runbook]?
    /// The time that the requester expects the runbook workflow related to the change request to complete. The time is an estimate only that the requester provides for reviewers.
    public var scheduledEndTime: Foundation.Date?
    /// The date and time specified in the change request to run the Automation runbooks. The Automation runbooks specified for the runbook workflow can't run until all required approvals for the change request have been received.
    public var scheduledTime: Foundation.Date?
    /// Optional metadata that you assign to a resource. You can specify a maximum of five tags for a change request. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For example, you might want to tag a change request to identify an environment or target Amazon Web Services Region. In this case, you could specify the following key-value pairs:
    ///
    /// * Key=Environment,Value=Production
    ///
    /// * Key=Region,Value=us-east-2
    public var tags: [SSMClientTypes.Tag]?

    public init(
        autoApprove: Swift.Bool? = false,
        changeDetails: Swift.String? = nil,
        changeRequestName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        documentName: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        runbooks: [SSMClientTypes.Runbook]? = nil,
        scheduledEndTime: Foundation.Date? = nil,
        scheduledTime: Foundation.Date? = nil,
        tags: [SSMClientTypes.Tag]? = nil
    )
    {
        self.autoApprove = autoApprove
        self.changeDetails = changeDetails
        self.changeRequestName = changeRequestName
        self.clientToken = clientToken
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.parameters = parameters
        self.runbooks = runbooks
        self.scheduledEndTime = scheduledEndTime
        self.scheduledTime = scheduledTime
        self.tags = tags
    }
}

public struct StartChangeRequestExecutionOutput: Swift.Sendable {
    /// The unique ID of a runbook workflow operation. (A runbook workflow is a type of Automation operation.)
    public var automationExecutionId: Swift.String?

    public init(
        automationExecutionId: Swift.String? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
    }
}

/// The specified target managed node for the session isn't fully configured for use with Session Manager. For more information, see [Setting up Session Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-getting-started.html) in the Amazon Web Services Systems Manager User Guide. This error is also returned if you attempt to start a session on a managed node that is located in a different account or Region
public struct TargetNotConnected: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TargetNotConnected" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartSessionInput: Swift.Sendable {
    /// The name of the SSM document you want to use to define the type of session, input parameters, or preferences for the session. For example, SSM-SessionManagerRunShell. You can call the [GetDocument] API to verify the document exists before attempting to start a session. If no document name is provided, a shell to the managed node is launched by default. For more information, see [Start a session](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-sessions-start.html) in the Amazon Web Services Systems Manager User Guide.
    public var documentName: Swift.String?
    /// The values you want to specify for the parameters defined in the Session document.
    public var parameters: [Swift.String: [Swift.String]]?
    /// The reason for connecting to the instance. This value is included in the details for the Amazon CloudWatch Events event created when you start the session.
    public var reason: Swift.String?
    /// The managed node to connect to for the session.
    /// This member is required.
    public var target: Swift.String?

    public init(
        documentName: Swift.String? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        reason: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.documentName = documentName
        self.parameters = parameters
        self.reason = reason
        self.target = target
    }
}

public struct StartSessionOutput: Swift.Sendable {
    /// The ID of the session.
    public var sessionId: Swift.String?
    /// A URL back to SSM Agent on the managed node that the Session Manager client uses to send commands and receive output from the node. Format: wss://ssmmessages.region.amazonaws.com/v1/data-channel/session-id?stream=(input|output) region represents the Region identifier for an Amazon Web Services Region supported by Amazon Web Services Systems Manager, such as us-east-2 for the US East (Ohio) Region. For a list of supported region values, see the Region column in [Systems Manager service endpoints](https://docs.aws.amazon.com/general/latest/gr/ssm.html#ssm_region) in the Amazon Web Services General Reference. session-id represents the ID of a Session Manager session, such as 1a2b3c4dEXAMPLE.
    public var streamUrl: Swift.String?
    /// An encrypted token value containing session and caller information. This token is used to authenticate the connection to the managed node, and is valid only long enough to ensure the connection is successful. Never share your session's token.
    public var tokenValue: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        streamUrl: Swift.String? = nil,
        tokenValue: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamUrl = streamUrl
        self.tokenValue = tokenValue
    }
}

/// The specified update status operation isn't valid.
public struct InvalidAutomationStatusUpdateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAutomationStatusUpdateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSMClientTypes {

    public enum StopType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancel
        case complete
        case sdkUnknown(Swift.String)

        public static var allCases: [StopType] {
            return [
                .cancel,
                .complete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancel: return "Cancel"
            case .complete: return "Complete"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StopAutomationExecutionInput: Swift.Sendable {
    /// The execution ID of the Automation to stop.
    /// This member is required.
    public var automationExecutionId: Swift.String?
    /// The stop request type. Valid types include the following: Cancel and Complete. The default type is Cancel.
    public var type: SSMClientTypes.StopType?

    public init(
        automationExecutionId: Swift.String? = nil,
        type: SSMClientTypes.StopType? = nil
    )
    {
        self.automationExecutionId = automationExecutionId
        self.type = type
    }
}

public struct StopAutomationExecutionOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateSessionInput: Swift.Sendable {
    /// The ID of the session to terminate.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

public struct TerminateSessionOutput: Swift.Sendable {
    /// The ID of the session that has been terminated.
    public var sessionId: Swift.String?

    public init(
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

public struct UnlabelParameterVersionInput: Swift.Sendable {
    /// One or more labels to delete from the specified parameter version.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The name of the parameter from which you want to delete one or more labels. You can't enter the Amazon Resource Name (ARN) for a parameter, only the parameter name itself.
    /// This member is required.
    public var name: Swift.String?
    /// The specific version of the parameter which you want to delete one or more labels from. If it isn't present, the call will fail.
    /// This member is required.
    public var parameterVersion: Swift.Int?

    public init(
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameterVersion: Swift.Int? = 0
    )
    {
        self.labels = labels
        self.name = name
        self.parameterVersion = parameterVersion
    }
}

public struct UnlabelParameterVersionOutput: Swift.Sendable {
    /// The labels that aren't attached to the given parameter version.
    public var invalidLabels: [Swift.String]?
    /// A list of all labels deleted from the parameter.
    public var removedLabels: [Swift.String]?

    public init(
        invalidLabels: [Swift.String]? = nil,
        removedLabels: [Swift.String]? = nil
    )
    {
        self.invalidLabels = invalidLabels
        self.removedLabels = removedLabels
    }
}

/// You have reached the maximum number versions allowed for an association. Each association has a limit of 1,000 versions.
public struct AssociationVersionLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AssociationVersionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The update isn't valid.
public struct InvalidUpdate: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidUpdate" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateAssociationInput: Swift.Sendable {
    /// The details for the CloudWatch alarm you want to apply to an automation or command.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// By default, when you update an association, the system runs it immediately after it is updated and then according to the schedule you specified. Specify this option if you don't want an association to run immediately after you update it. This parameter isn't supported for rate expressions. If you chose this option when you created an association and later you edit that association or you make changes to the SSM document on which that association is based (by using the Documents page in the console), State Manager applies the association at the next specified cron interval. For example, if you chose the Latest version of an SSM document when you created an association and you edit the association by choosing a different document version on the Documents page, State Manager applies the association at the next specified cron interval if you previously selected this option. If this option wasn't selected, State Manager immediately runs the association. You can reset this option. To do so, specify the no-apply-only-at-cron-interval parameter when you update the association from the command line. This parameter forces the association to run immediately after updating it and according to the interval specified.
    public var applyOnlyAtCronInterval: Swift.Bool?
    /// The ID of the association you want to update.
    /// This member is required.
    public var associationId: Swift.String?
    /// The name of the association that you want to update.
    public var associationName: Swift.String?
    /// This parameter is provided for concurrency control purposes. You must specify the latest association version in the service. If you want to ensure that this request succeeds, either specify $LATEST, or omit this parameter.
    public var associationVersion: Swift.String?
    /// Choose the parameter that will define how your automation will branch out. This target is required for associations that use an Automation runbook and target resources by using rate controls. Automation is a capability of Amazon Web Services Systems Manager.
    public var automationTargetParameterName: Swift.String?
    /// The names or Amazon Resource Names (ARNs) of the Change Calendar type documents you want to gate your associations under. The associations only run when that change calendar is open. For more information, see [Amazon Web Services Systems Manager Change Calendar](https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-change-calendar).
    public var calendarNames: [Swift.String]?
    /// The severity level to assign to the association.
    public var complianceSeverity: SSMClientTypes.AssociationComplianceSeverity?
    /// The document version you want update for the association. State Manager doesn't support running associations that use a new version of a document if that document is shared from another account. State Manager always runs the default version of a document if shared from another account, even though the Systems Manager console shows that a new version was processed. If you want to run an association using a new version of a document shared form another account, you must set the document version to default.
    public var documentVersion: Swift.String?
    /// The number of hours the association can run before it is canceled. Duration applies to associations that are currently running, and any pending and in progress commands on all targets. If a target was taken offline for the association to run, it is made available again immediately, without a reboot. The Duration parameter applies only when both these conditions are true:
    ///
    /// * The association for which you specify a duration is cancelable according to the parameters of the SSM command document or Automation runbook associated with this execution.
    ///
    /// * The command specifies the [ApplyOnlyAtCronInterval](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_UpdateAssociation.html#systemsmanager-UpdateAssociation-request-ApplyOnlyAtCronInterval) parameter, which means that the association doesn't run immediately after it is updated, but only according to the specified schedule.
    public var duration: Swift.Int?
    /// The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time. If a new managed node starts and attempts to run an association while Systems Manager is running MaxConcurrency associations, the association is allowed to run. During the next association interval, the new managed node will process its association within the limit specified for MaxConcurrency.
    public var maxConcurrency: Swift.String?
    /// The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 managed nodes and set MaxError to 10%, then the system stops sending the request when the sixth error is received. Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.
    public var maxErrors: Swift.String?
    /// The name of the SSM Command document or Automation runbook that contains the configuration information for the managed node. You can specify Amazon Web Services-predefined documents, documents you created, or a document that is shared with you from another account. For Systems Manager document (SSM document) that are shared with you from other Amazon Web Services accounts, you must specify the complete SSM document ARN, in the following format: arn:aws:ssm:region:account-id:document/document-name  For example: arn:aws:ssm:us-east-2:12345678912:document/My-Shared-Document For Amazon Web Services-predefined documents and SSM documents you created in your account, you only need to specify the document name. For example, AWS-ApplyPatchBaseline or My-Document.
    public var name: Swift.String?
    /// An S3 bucket where you want to store the results of this request.
    public var outputLocation: SSMClientTypes.InstanceAssociationOutputLocation?
    /// The parameters you want to update for the association. If you create a parameter using Parameter Store, a capability of Amazon Web Services Systems Manager, you can reference the parameter using {{ssm:parameter-name}}.
    public var parameters: [Swift.String: [Swift.String]]?
    /// The cron expression used to schedule the association that you want to update.
    public var scheduleExpression: Swift.String?
    /// Number of days to wait after the scheduled day to run an association. For example, if you specified a cron schedule of cron(0 0 ? * THU#2 *), you could specify an offset of 3 to run the association each Sunday after the second Thursday of the month. For more information about cron schedules for associations, see [Reference: Cron and rate expressions for Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/reference-cron-and-rate-expressions.html) in the Amazon Web Services Systems Manager User Guide. To use offsets, you must specify the ApplyOnlyAtCronInterval parameter. This option tells the system not to run an association immediately after you create it.
    public var scheduleOffset: Swift.Int?
    /// The mode for generating association compliance. You can specify AUTO or MANUAL. In AUTO mode, the system uses the status of the association execution to determine the compliance status. If the association execution runs successfully, then the association is COMPLIANT. If the association execution doesn't run successfully, the association is NON-COMPLIANT. In MANUAL mode, you must specify the AssociationId as a parameter for the [PutComplianceItems] API operation. In this case, compliance data isn't managed by State Manager, a capability of Amazon Web Services Systems Manager. It is managed by your direct call to the [PutComplianceItems] API operation. By default, all associations use AUTO mode.
    public var syncCompliance: SSMClientTypes.AssociationSyncCompliance?
    /// A location is a combination of Amazon Web Services Regions and Amazon Web Services accounts where you want to run the association. Use this action to update an association in multiple Regions and multiple accounts.
    public var targetLocations: [SSMClientTypes.TargetLocation]?
    /// A key-value mapping of document parameters to target resources. Both Targets and TargetMaps can't be specified together.
    public var targetMaps: [[Swift.String: [Swift.String]]]?
    /// The targets of the association.
    public var targets: [SSMClientTypes.Target]?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        applyOnlyAtCronInterval: Swift.Bool? = false,
        associationId: Swift.String? = nil,
        associationName: Swift.String? = nil,
        associationVersion: Swift.String? = nil,
        automationTargetParameterName: Swift.String? = nil,
        calendarNames: [Swift.String]? = nil,
        complianceSeverity: SSMClientTypes.AssociationComplianceSeverity? = nil,
        documentVersion: Swift.String? = nil,
        duration: Swift.Int? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        outputLocation: SSMClientTypes.InstanceAssociationOutputLocation? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        scheduleExpression: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        syncCompliance: SSMClientTypes.AssociationSyncCompliance? = nil,
        targetLocations: [SSMClientTypes.TargetLocation]? = nil,
        targetMaps: [[Swift.String: [Swift.String]]]? = nil,
        targets: [SSMClientTypes.Target]? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.applyOnlyAtCronInterval = applyOnlyAtCronInterval
        self.associationId = associationId
        self.associationName = associationName
        self.associationVersion = associationVersion
        self.automationTargetParameterName = automationTargetParameterName
        self.calendarNames = calendarNames
        self.complianceSeverity = complianceSeverity
        self.documentVersion = documentVersion
        self.duration = duration
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.outputLocation = outputLocation
        self.parameters = parameters
        self.scheduleExpression = scheduleExpression
        self.scheduleOffset = scheduleOffset
        self.syncCompliance = syncCompliance
        self.targetLocations = targetLocations
        self.targetMaps = targetMaps
        self.targets = targets
    }
}

extension UpdateAssociationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssociationInput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), applyOnlyAtCronInterval: \(Swift.String(describing: applyOnlyAtCronInterval)), associationId: \(Swift.String(describing: associationId)), associationName: \(Swift.String(describing: associationName)), associationVersion: \(Swift.String(describing: associationVersion)), automationTargetParameterName: \(Swift.String(describing: automationTargetParameterName)), calendarNames: \(Swift.String(describing: calendarNames)), complianceSeverity: \(Swift.String(describing: complianceSeverity)), documentVersion: \(Swift.String(describing: documentVersion)), duration: \(Swift.String(describing: duration)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), outputLocation: \(Swift.String(describing: outputLocation)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), syncCompliance: \(Swift.String(describing: syncCompliance)), targetLocations: \(Swift.String(describing: targetLocations)), targetMaps: \(Swift.String(describing: targetMaps)), targets: \(Swift.String(describing: targets)), parameters: \"CONTENT_REDACTED\")"}
}

public struct UpdateAssociationOutput: Swift.Sendable {
    /// The description of the association that was updated.
    public var associationDescription: SSMClientTypes.AssociationDescription?

    public init(
        associationDescription: SSMClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

/// The updated status is the same as the current status.
public struct StatusUnchanged: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "StatusUnchanged" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

public struct UpdateAssociationStatusInput: Swift.Sendable {
    /// The association status.
    /// This member is required.
    public var associationStatus: SSMClientTypes.AssociationStatus?
    /// The managed node ID.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the SSM document.
    /// This member is required.
    public var name: Swift.String?

    public init(
        associationStatus: SSMClientTypes.AssociationStatus? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.associationStatus = associationStatus
        self.instanceId = instanceId
        self.name = name
    }
}

public struct UpdateAssociationStatusOutput: Swift.Sendable {
    /// Information about the association.
    public var associationDescription: SSMClientTypes.AssociationDescription?

    public init(
        associationDescription: SSMClientTypes.AssociationDescription? = nil
    )
    {
        self.associationDescription = associationDescription
    }
}

/// The document has too many versions. Delete one or more document versions and try again.
public struct DocumentVersionLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentVersionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The content of the association document matches another document. Change the content of the document and try again.
public struct DuplicateDocumentContent: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateDocumentContent" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The version name has already been used in this document. Specify a different version name, and then try again.
public struct DuplicateDocumentVersionName: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateDocumentVersionName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateDocumentInput: Swift.Sendable {
    /// A list of key-value pairs that describe attachments to a version of a document.
    public var attachments: [SSMClientTypes.AttachmentsSource]?
    /// A valid JSON or YAML string.
    /// This member is required.
    public var content: Swift.String?
    /// The friendly name of the SSM document that you want to update. This value can differ for each version of the document. If you don't specify a value for this parameter in your request, the existing value is applied to the new document version.
    public var displayName: Swift.String?
    /// Specify the document format for the new document version. Systems Manager supports JSON and YAML documents. JSON is the default format.
    public var documentFormat: SSMClientTypes.DocumentFormat?
    /// The version of the document that you want to update. Currently, Systems Manager supports updating only the latest version of the document. You can specify the version number of the latest version or use the $LATEST variable. If you change a document version for a State Manager association, Systems Manager immediately runs the association unless you previously specifed the apply-only-at-cron-interval parameter.
    public var documentVersion: Swift.String?
    /// The name of the SSM document that you want to update.
    /// This member is required.
    public var name: Swift.String?
    /// Specify a new target type for the document.
    public var targetType: Swift.String?
    /// An optional field specifying the version of the artifact you are updating with the document. For example, 12.6. This value is unique across all versions of a document, and can't be changed.
    public var versionName: Swift.String?

    public init(
        attachments: [SSMClientTypes.AttachmentsSource]? = nil,
        content: Swift.String? = nil,
        displayName: Swift.String? = nil,
        documentFormat: SSMClientTypes.DocumentFormat? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil,
        targetType: Swift.String? = nil,
        versionName: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.content = content
        self.displayName = displayName
        self.documentFormat = documentFormat
        self.documentVersion = documentVersion
        self.name = name
        self.targetType = targetType
        self.versionName = versionName
    }
}

public struct UpdateDocumentOutput: Swift.Sendable {
    /// A description of the document that was updated.
    public var documentDescription: SSMClientTypes.DocumentDescription?

    public init(
        documentDescription: SSMClientTypes.DocumentDescription? = nil
    )
    {
        self.documentDescription = documentDescription
    }
}

public struct UpdateDocumentDefaultVersionInput: Swift.Sendable {
    /// The version of a custom document that you want to set as the default version.
    /// This member is required.
    public var documentVersion: Swift.String?
    /// The name of a custom document that you want to set as the default version.
    /// This member is required.
    public var name: Swift.String?

    public init(
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentVersion = documentVersion
        self.name = name
    }
}

extension SSMClientTypes {

    /// A default version of a document.
    public struct DocumentDefaultVersionDescription: Swift.Sendable {
        /// The default version of the document.
        public var defaultVersion: Swift.String?
        /// The default version of the artifact associated with the document.
        public var defaultVersionName: Swift.String?
        /// The name of the document.
        public var name: Swift.String?

        public init(
            defaultVersion: Swift.String? = nil,
            defaultVersionName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.defaultVersion = defaultVersion
            self.defaultVersionName = defaultVersionName
            self.name = name
        }
    }
}

public struct UpdateDocumentDefaultVersionOutput: Swift.Sendable {
    /// The description of a custom document that you want to set as the default version.
    public var description: SSMClientTypes.DocumentDefaultVersionDescription?

    public init(
        description: SSMClientTypes.DocumentDefaultVersionDescription? = nil
    )
    {
        self.description = description
    }
}

extension SSMClientTypes {

    public enum DocumentReviewAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approve
        case reject
        case sendforreview
        case updatereview
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentReviewAction] {
            return [
                .approve,
                .reject,
                .sendforreview,
                .updatereview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approve: return "Approve"
            case .reject: return "Reject"
            case .sendforreview: return "SendForReview"
            case .updatereview: return "UpdateReview"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMClientTypes {

    /// Information about a document approval review.
    public struct DocumentReviews: Swift.Sendable {
        /// The action to take on a document approval review request.
        /// This member is required.
        public var action: SSMClientTypes.DocumentReviewAction?
        /// A comment entered by a user in your organization about the document review request.
        public var comment: [SSMClientTypes.DocumentReviewCommentSource]?

        public init(
            action: SSMClientTypes.DocumentReviewAction? = nil,
            comment: [SSMClientTypes.DocumentReviewCommentSource]? = nil
        )
        {
            self.action = action
            self.comment = comment
        }
    }
}

public struct UpdateDocumentMetadataInput: Swift.Sendable {
    /// The change template review details to update.
    /// This member is required.
    public var documentReviews: SSMClientTypes.DocumentReviews?
    /// The version of a change template in which to update approval metadata.
    public var documentVersion: Swift.String?
    /// The name of the change template for which a version's metadata is to be updated.
    /// This member is required.
    public var name: Swift.String?

    public init(
        documentReviews: SSMClientTypes.DocumentReviews? = nil,
        documentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.documentReviews = documentReviews
        self.documentVersion = documentVersion
        self.name = name
    }
}

public struct UpdateDocumentMetadataOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMaintenanceWindowInput: Swift.Sendable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool?
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int?
    /// An optional description for the update request.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int?
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become inactive. EndDate allows you to set a date and time in the future when the maintenance window will no longer run.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// If True, then all fields that are required by the [CreateMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait after the date and time specified by a cron expression before running the maintenance window. For example, the following cron expression schedules a maintenance window to run the third Tuesday of every month at 11:30 PM. cron(30 23 ? * TUE#3 *) If the schedule offset is 2, the maintenance window won't run until two days later.
    public var scheduleOffset: Swift.Int?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when you want the maintenance window to become active. StartDate allows you to delay activation of the maintenance window until the specified future date. When using a rate schedule, if you provide a start date that occurs in the past, the current date and time are used as the start date.
    public var startDate: Swift.String?
    /// The ID of the maintenance window to update.
    /// This member is required.
    public var windowId: Swift.String?

    public init(
        allowUnassociatedTargets: Swift.Bool? = false,
        cutoff: Swift.Int? = 0,
        description: Swift.String? = nil,
        duration: Swift.Int? = nil,
        enabled: Swift.Bool? = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        replace: Swift.Bool? = false,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.replace = replace
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

extension UpdateMaintenanceWindowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowInput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), cutoff: \(Swift.String(describing: cutoff)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), replace: \(Swift.String(describing: replace)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateMaintenanceWindowOutput: Swift.Sendable {
    /// Whether targets must be registered with the maintenance window before tasks can be defined for those targets.
    public var allowUnassociatedTargets: Swift.Bool
    /// The number of hours before the end of the maintenance window that Amazon Web Services Systems Manager stops scheduling new tasks for execution.
    public var cutoff: Swift.Int
    /// An optional description of the update.
    public var description: Swift.String?
    /// The duration of the maintenance window in hours.
    public var duration: Swift.Int?
    /// Whether the maintenance window is enabled.
    public var enabled: Swift.Bool
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become inactive. The maintenance window won't run after this specified time.
    public var endDate: Swift.String?
    /// The name of the maintenance window.
    public var name: Swift.String?
    /// The schedule of the maintenance window in the form of a cron or rate expression.
    public var schedule: Swift.String?
    /// The number of days to wait to run a maintenance window after the scheduled cron expression date and time.
    public var scheduleOffset: Swift.Int?
    /// The time zone that the scheduled maintenance window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website.
    public var scheduleTimezone: Swift.String?
    /// The date and time, in ISO-8601 Extended format, for when the maintenance window is scheduled to become active. The maintenance window won't run before this specified time.
    public var startDate: Swift.String?
    /// The ID of the created maintenance window.
    public var windowId: Swift.String?

    public init(
        allowUnassociatedTargets: Swift.Bool = false,
        cutoff: Swift.Int = 0,
        description: Swift.String? = nil,
        duration: Swift.Int? = nil,
        enabled: Swift.Bool = false,
        endDate: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: Swift.String? = nil,
        scheduleOffset: Swift.Int? = nil,
        scheduleTimezone: Swift.String? = nil,
        startDate: Swift.String? = nil,
        windowId: Swift.String? = nil
    )
    {
        self.allowUnassociatedTargets = allowUnassociatedTargets
        self.cutoff = cutoff
        self.description = description
        self.duration = duration
        self.enabled = enabled
        self.endDate = endDate
        self.name = name
        self.schedule = schedule
        self.scheduleOffset = scheduleOffset
        self.scheduleTimezone = scheduleTimezone
        self.startDate = startDate
        self.windowId = windowId
    }
}

extension UpdateMaintenanceWindowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowOutput(allowUnassociatedTargets: \(Swift.String(describing: allowUnassociatedTargets)), cutoff: \(Swift.String(describing: cutoff)), duration: \(Swift.String(describing: duration)), enabled: \(Swift.String(describing: enabled)), endDate: \(Swift.String(describing: endDate)), name: \(Swift.String(describing: name)), schedule: \(Swift.String(describing: schedule)), scheduleOffset: \(Swift.String(describing: scheduleOffset)), scheduleTimezone: \(Swift.String(describing: scheduleTimezone)), startDate: \(Swift.String(describing: startDate)), windowId: \(Swift.String(describing: windowId)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateMaintenanceWindowTargetInput: Swift.Sendable {
    /// An optional description for the update.
    public var description: Swift.String?
    /// A name for the update.
    public var name: Swift.String?
    /// User-provided value that will be included in any Amazon CloudWatch Events events raised while running tasks for these targets in this maintenance window.
    public var ownerInformation: Swift.String?
    /// If True, then all fields that are required by the [RegisterTargetWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool?
    /// The targets to add or replace.
    public var targets: [SSMClientTypes.Target]?
    /// The maintenance window ID with which to modify the target.
    /// This member is required.
    public var windowId: Swift.String?
    /// The target ID to modify.
    /// This member is required.
    public var windowTargetId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        replace: Swift.Bool? = false,
        targets: [SSMClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.replace = replace
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

extension UpdateMaintenanceWindowTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTargetInput(name: \(Swift.String(describing: name)), replace: \(Swift.String(describing: replace)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)), description: \"CONTENT_REDACTED\", ownerInformation: \"CONTENT_REDACTED\")"}
}

public struct UpdateMaintenanceWindowTargetOutput: Swift.Sendable {
    /// The updated description.
    public var description: Swift.String?
    /// The updated name.
    public var name: Swift.String?
    /// The updated owner.
    public var ownerInformation: Swift.String?
    /// The updated targets.
    public var targets: [SSMClientTypes.Target]?
    /// The maintenance window ID specified in the update request.
    public var windowId: Swift.String?
    /// The target ID specified in the update request.
    public var windowTargetId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerInformation: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        windowId: Swift.String? = nil,
        windowTargetId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.ownerInformation = ownerInformation
        self.targets = targets
        self.windowId = windowId
        self.windowTargetId = windowTargetId
    }
}

extension UpdateMaintenanceWindowTargetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTargetOutput(name: \(Swift.String(describing: name)), targets: \(Swift.String(describing: targets)), windowId: \(Swift.String(describing: windowId)), windowTargetId: \(Swift.String(describing: windowTargetId)), description: \"CONTENT_REDACTED\", ownerInformation: \"CONTENT_REDACTED\")"}
}

public struct UpdateMaintenanceWindowTaskInput: Swift.Sendable {
    /// The CloudWatch alarm you want to apply to your maintenance window task.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    ///
    /// * CONTINUE_TASK: When the cutoff time is reached, any tasks that are running continue. The default value.
    ///
    /// * CANCEL_TASK:
    ///
    /// * For Automation, Lambda, Step Functions tasks: When the cutoff time is reached, any task invocations that are already running continue, but no new task invocations are started.
    ///
    /// * For Run Command tasks: When the cutoff time is reached, the system sends a [CancelCommand] operation that attempts to cancel the command associated with the task. However, there is no guarantee that the command will be terminated and the underlying process stopped.
    ///
    ///
    /// The status for tasks that are not completed is TIMED_OUT.
    public var cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The new task description to specify.
    public var description: Swift.String?
    /// The new logging location in Amazon S3 to specify. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SSMClientTypes.LoggingInfo?
    /// The new MaxConcurrency value you want to specify. MaxConcurrency is the number of targets that are allowed to run this task, in parallel. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxConcurrency: Swift.String?
    /// The new MaxErrors value to specify. MaxErrors is the maximum number of errors that are allowed before the task stops being scheduled. Although this element is listed as "Required: No", a value can be omitted only when you are registering or updating a [targetless task](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) You must provide a value in all other cases. For maintenance window tasks without a target specified, you can't supply a value for this option. Instead, the system inserts a placeholder value of 1. This value doesn't affect the running of your task.
    public var maxErrors: Swift.String?
    /// The new task name to specify.
    public var name: Swift.String?
    /// The new task priority to specify. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
    public var priority: Swift.Int?
    /// If True, then all fields that are required by the [RegisterTaskWithMaintenanceWindow] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
    public var serviceRoleArn: Swift.String?
    /// The targets (either managed nodes or tags) to modify. Managed nodes are specified using the format Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using the format  Key=tag_name,Values=tag_value. One or more targets must be specified for maintenance window Run Command-type tasks. Depending on the task, targets are optional for other maintenance window task types (Automation, Lambda, and Step Functions). For more information about running tasks that don't specify targets, see [Registering maintenance window tasks without targets](https://docs.aws.amazon.com/systems-manager/latest/userguide/maintenance-windows-targetless-tasks.html) in the Amazon Web Services Systems Manager User Guide.
    public var targets: [SSMClientTypes.Target]?
    /// The task ARN to modify.
    public var taskArn: Swift.String?
    /// The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty. When you update a maintenance window task that has options specified in TaskInvocationParameters, you must provide again all the TaskInvocationParameters values that you want to retain. The values you don't specify again are removed. For example, suppose that when you registered a Run Command task, you specified TaskInvocationParameters values for Comment, NotificationConfig, and OutputS3BucketName. If you update the maintenance window task and specify only a different OutputS3BucketName value, the values for Comment and NotificationConfig are removed.
    public var taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The parameters to modify. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters]. The map has the following format: Key: string, between 1 and 255 characters Value: an array of strings, each string is between 1 and 255 characters
    public var taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The maintenance window ID that contains the task to modify.
    /// This member is required.
    public var windowId: Swift.String?
    /// The task ID to modify.
    /// This member is required.
    public var windowTaskId: Swift.String?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SSMClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = 0,
        replace: Swift.Bool? = false,
        serviceRoleArn: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.replace = replace
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

extension UpdateMaintenanceWindowTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTaskInput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), replace: \(Swift.String(describing: replace)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)), description: \"CONTENT_REDACTED\", taskParameters: \"CONTENT_REDACTED\")"}
}

public struct UpdateMaintenanceWindowTaskOutput: Swift.Sendable {
    /// The details for the CloudWatch alarm you applied to your maintenance window task.
    public var alarmConfiguration: SSMClientTypes.AlarmConfiguration?
    /// The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
    public var cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior?
    /// The updated task description.
    public var description: Swift.String?
    /// The updated logging information in Amazon S3. LoggingInfo has been deprecated. To specify an Amazon Simple Storage Service (Amazon S3) bucket to contain logs, instead use the OutputS3BucketName and OutputS3KeyPrefix options in the TaskInvocationParameters structure. For information about how Amazon Web Services Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var loggingInfo: SSMClientTypes.LoggingInfo?
    /// The updated MaxConcurrency value.
    public var maxConcurrency: Swift.String?
    /// The updated MaxErrors value.
    public var maxErrors: Swift.String?
    /// The updated task name.
    public var name: Swift.String?
    /// The updated priority value.
    public var priority: Swift.Int
    /// The Amazon Resource Name (ARN) of the IAM service role for Amazon Web Services Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run RegisterTaskWithMaintenanceWindow. However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the Amazon Web Services Systems Manager User Guide.
    public var serviceRoleArn: Swift.String?
    /// The updated target values.
    public var targets: [SSMClientTypes.Target]?
    /// The updated task ARN value.
    public var taskArn: Swift.String?
    /// The updated parameter values.
    public var taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters?
    /// The updated parameter values. TaskParameters has been deprecated. To specify parameters to pass to a task when it runs, instead use the Parameters option in the TaskInvocationParameters structure. For information about how Systems Manager handles these options for the supported maintenance window task types, see [MaintenanceWindowTaskInvocationParameters].
    public var taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]?
    /// The ID of the maintenance window that was updated.
    public var windowId: Swift.String?
    /// The task ID of the maintenance window that was updated.
    public var windowTaskId: Swift.String?

    public init(
        alarmConfiguration: SSMClientTypes.AlarmConfiguration? = nil,
        cutoffBehavior: SSMClientTypes.MaintenanceWindowTaskCutoffBehavior? = nil,
        description: Swift.String? = nil,
        loggingInfo: SSMClientTypes.LoggingInfo? = nil,
        maxConcurrency: Swift.String? = nil,
        maxErrors: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int = 0,
        serviceRoleArn: Swift.String? = nil,
        targets: [SSMClientTypes.Target]? = nil,
        taskArn: Swift.String? = nil,
        taskInvocationParameters: SSMClientTypes.MaintenanceWindowTaskInvocationParameters? = nil,
        taskParameters: [Swift.String: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression]? = nil,
        windowId: Swift.String? = nil,
        windowTaskId: Swift.String? = nil
    )
    {
        self.alarmConfiguration = alarmConfiguration
        self.cutoffBehavior = cutoffBehavior
        self.description = description
        self.loggingInfo = loggingInfo
        self.maxConcurrency = maxConcurrency
        self.maxErrors = maxErrors
        self.name = name
        self.priority = priority
        self.serviceRoleArn = serviceRoleArn
        self.targets = targets
        self.taskArn = taskArn
        self.taskInvocationParameters = taskInvocationParameters
        self.taskParameters = taskParameters
        self.windowId = windowId
        self.windowTaskId = windowTaskId
    }
}

extension UpdateMaintenanceWindowTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMaintenanceWindowTaskOutput(alarmConfiguration: \(Swift.String(describing: alarmConfiguration)), cutoffBehavior: \(Swift.String(describing: cutoffBehavior)), loggingInfo: \(Swift.String(describing: loggingInfo)), maxConcurrency: \(Swift.String(describing: maxConcurrency)), maxErrors: \(Swift.String(describing: maxErrors)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), targets: \(Swift.String(describing: targets)), taskArn: \(Swift.String(describing: taskArn)), taskInvocationParameters: \(Swift.String(describing: taskInvocationParameters)), windowId: \(Swift.String(describing: windowId)), windowTaskId: \(Swift.String(describing: windowTaskId)), description: \"CONTENT_REDACTED\", taskParameters: \"CONTENT_REDACTED\")"}
}

public struct UpdateManagedInstanceRoleInput: Swift.Sendable {
    /// The name of the Identity and Access Management (IAM) role that you want to assign to the managed node. This IAM role must provide AssumeRole permissions for the Amazon Web Services Systems Manager service principal ssm.amazonaws.com. For more information, see [Create the IAM service role required for Systems Manager in hybrid and multicloud environments](https://docs.aws.amazon.com/systems-manager/latest/userguide/hybrid-multicloud-service-role.html) in the Amazon Web Services Systems Manager User Guide. You can't specify an IAM service-linked role for this parameter. You must create a unique role.
    /// This member is required.
    public var iamRole: Swift.String?
    /// The ID of the managed node where you want to update the role.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        iamRole: Swift.String? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.iamRole = iamRole
        self.instanceId = instanceId
    }
}

public struct UpdateManagedInstanceRoleOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateOpsItemInput: Swift.Sendable {
    /// The time a runbook workflow ended. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualEndTime: Foundation.Date?
    /// The time a runbook workflow started. Currently reported only for the OpsItem type /aws/changerequest.
    public var actualStartTime: Foundation.Date?
    /// Specify a new category for an OpsItem.
    public var category: Swift.String?
    /// User-defined text that contains information about the OpsItem, in Markdown format.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of an SNS topic where notifications are sent when this OpsItem is edited or changed.
    public var notifications: [SSMClientTypes.OpsItemNotification]?
    /// Add new keys or edit existing key-value pairs of the OperationalData map in the OpsItem object. Operational data is custom data that provides useful reference details about the OpsItem. For example, you can specify log files, error strings, license keys, troubleshooting tips, or other relevant data. You enter operational data as key-value pairs. The key has a maximum length of 128 characters. The value has a maximum size of 20 KB. Operational data keys can't begin with the following: amazon, aws, amzn, ssm, /amazon, /aws, /amzn, /ssm. You can choose to make the data searchable by other users in the account or you can restrict search access. Searchable data means that all users with access to the OpsItem Overview page (as provided by the [DescribeOpsItems] API operation) can view and search on the specified data. Operational data that isn't searchable is only viewable by users who have access to the OpsItem (as provided by the [GetOpsItem] API operation). Use the /aws/resources key in OperationalData to specify a related resource in the request. Use the /aws/automations key in OperationalData to associate an Automation runbook with the OpsItem. To view Amazon Web Services CLI example commands that use these keys, see [Creating OpsItems manually](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-manually-create-OpsItems.html) in the Amazon Web Services Systems Manager User Guide.
    public var operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]?
    /// Keys that you want to remove from the OperationalData map.
    public var operationalDataToDelete: [Swift.String]?
    /// The OpsItem Amazon Resource Name (ARN).
    public var opsItemArn: Swift.String?
    /// The ID of the OpsItem.
    /// This member is required.
    public var opsItemId: Swift.String?
    /// The time specified in a change request for a runbook workflow to end. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedEndTime: Foundation.Date?
    /// The time specified in a change request for a runbook workflow to start. Currently supported only for the OpsItem type /aws/changerequest.
    public var plannedStartTime: Foundation.Date?
    /// The importance of this OpsItem in relation to other OpsItems in the system.
    public var priority: Swift.Int?
    /// One or more OpsItems that share something in common with the current OpsItems. For example, related OpsItems can include OpsItems with similar error messages, impacted resources, or statuses for the impacted resource.
    public var relatedOpsItems: [SSMClientTypes.RelatedOpsItem]?
    /// Specify a new severity for an OpsItem.
    public var severity: Swift.String?
    /// The OpsItem status. For more information, see [Editing OpsItem details](https://docs.aws.amazon.com/systems-manager/latest/userguide/OpsCenter-working-with-OpsItems-editing-details.html) in the Amazon Web Services Systems Manager User Guide.
    public var status: SSMClientTypes.OpsItemStatus?
    /// A short heading that describes the nature of the OpsItem and the impacted resource.
    public var title: Swift.String?

    public init(
        actualEndTime: Foundation.Date? = nil,
        actualStartTime: Foundation.Date? = nil,
        category: Swift.String? = nil,
        description: Swift.String? = nil,
        notifications: [SSMClientTypes.OpsItemNotification]? = nil,
        operationalData: [Swift.String: SSMClientTypes.OpsItemDataValue]? = nil,
        operationalDataToDelete: [Swift.String]? = nil,
        opsItemArn: Swift.String? = nil,
        opsItemId: Swift.String? = nil,
        plannedEndTime: Foundation.Date? = nil,
        plannedStartTime: Foundation.Date? = nil,
        priority: Swift.Int? = nil,
        relatedOpsItems: [SSMClientTypes.RelatedOpsItem]? = nil,
        severity: Swift.String? = nil,
        status: SSMClientTypes.OpsItemStatus? = nil,
        title: Swift.String? = nil
    )
    {
        self.actualEndTime = actualEndTime
        self.actualStartTime = actualStartTime
        self.category = category
        self.description = description
        self.notifications = notifications
        self.operationalData = operationalData
        self.operationalDataToDelete = operationalDataToDelete
        self.opsItemArn = opsItemArn
        self.opsItemId = opsItemId
        self.plannedEndTime = plannedEndTime
        self.plannedStartTime = plannedStartTime
        self.priority = priority
        self.relatedOpsItems = relatedOpsItems
        self.severity = severity
        self.status = status
        self.title = title
    }
}

public struct UpdateOpsItemOutput: Swift.Sendable {

    public init() { }
}

/// The OpsMetadata object exceeds the maximum number of OpsMetadata keys that you can assign to an application in Application Manager.
public struct OpsMetadataKeyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OpsMetadataKeyLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateOpsMetadataInput: Swift.Sendable {
    /// The metadata keys to delete from the OpsMetadata object.
    public var keysToDelete: [Swift.String]?
    /// Metadata to add to an OpsMetadata object.
    public var metadataToUpdate: [Swift.String: SSMClientTypes.MetadataValue]?
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object to update.
    /// This member is required.
    public var opsMetadataArn: Swift.String?

    public init(
        keysToDelete: [Swift.String]? = nil,
        metadataToUpdate: [Swift.String: SSMClientTypes.MetadataValue]? = nil,
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.keysToDelete = keysToDelete
        self.metadataToUpdate = metadataToUpdate
        self.opsMetadataArn = opsMetadataArn
    }
}

public struct UpdateOpsMetadataOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the OpsMetadata Object that was updated.
    public var opsMetadataArn: Swift.String?

    public init(
        opsMetadataArn: Swift.String? = nil
    )
    {
        self.opsMetadataArn = opsMetadataArn
    }
}

public struct UpdatePatchBaselineInput: Swift.Sendable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SSMClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var approvedPatches: [Swift.String]?
    /// Assigns a new compliance severity level to an existing patch baseline.
    public var approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool?
    /// The ID of the patch baseline to update.
    /// This member is required.
    public var baselineId: Swift.String?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to include patches in the baseline.
    public var globalFilters: SSMClientTypes.PatchFilterGroup?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// A list of explicitly rejected patches for the baseline. For information about accepted formats for lists of approved patches and rejected patches, see [Package name formats for approved and rejected patch lists](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html) in the Amazon Web Services Systems Manager User Guide.
    public var rejectedPatches: [Swift.String]?
    /// The action for Patch Manager to take on patches included in the RejectedPackages list. ALLOW_AS_DEPENDENCY Linux and macOS: A package in the rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as INSTALLED_OTHER. This is the default action if no option is specified. Windows Server: Windows Server doesn't support the concept of package dependencies. If a package in the rejected patches list and already installed on the node, its status is reported as INSTALLED_OTHER. Any package not already installed on the node is skipped. This is the default action if no option is specified. BLOCK All OSs: Packages in the rejected patches list, and packages that include them as dependencies, aren't installed by Patch Manager under any circumstances. If a package was installed before it was added to the rejected patches list, or is installed outside of Patch Manager afterward, it's considered noncompliant with the patch baseline and its status is reported as INSTALLED_REJECTED.
    public var rejectedPatchesAction: SSMClientTypes.PatchAction?
    /// If True, then all fields that are required by the [CreatePatchBaseline] operation are also required for this API request. Optional fields that aren't specified are set to null.
    public var replace: Swift.Bool?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SSMClientTypes.PatchSource]?

    public init(
        approvalRules: SSMClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool? = false,
        baselineId: Swift.String? = nil,
        description: Swift.String? = nil,
        globalFilters: SSMClientTypes.PatchFilterGroup? = nil,
        name: Swift.String? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SSMClientTypes.PatchAction? = nil,
        replace: Swift.Bool? = false,
        sources: [SSMClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.description = description
        self.globalFilters = globalFilters
        self.name = name
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.replace = replace
        self.sources = sources
    }
}

public struct UpdatePatchBaselineOutput: Swift.Sendable {
    /// A set of rules used to include patches in the baseline.
    public var approvalRules: SSMClientTypes.PatchRuleGroup?
    /// A list of explicitly approved patches for the baseline.
    public var approvedPatches: [Swift.String]?
    /// The compliance severity level assigned to the patch baseline after the update completed.
    public var approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel?
    /// Indicates whether the list of approved patches includes non-security updates that should be applied to the managed nodes. The default value is false. Applies to Linux managed nodes only.
    public var approvedPatchesEnableNonSecurity: Swift.Bool?
    /// The ID of the deleted patch baseline.
    public var baselineId: Swift.String?
    /// The date when the patch baseline was created.
    public var createdDate: Foundation.Date?
    /// A description of the patch baseline.
    public var description: Swift.String?
    /// A set of global filters used to exclude patches from the baseline.
    public var globalFilters: SSMClientTypes.PatchFilterGroup?
    /// The date when the patch baseline was last modified.
    public var modifiedDate: Foundation.Date?
    /// The name of the patch baseline.
    public var name: Swift.String?
    /// The operating system rule used by the updated patch baseline.
    public var operatingSystem: SSMClientTypes.OperatingSystem?
    /// A list of explicitly rejected patches for the baseline.
    public var rejectedPatches: [Swift.String]?
    /// The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.
    public var rejectedPatchesAction: SSMClientTypes.PatchAction?
    /// Information about the patches to use to update the managed nodes, including target operating systems and source repositories. Applies to Linux managed nodes only.
    public var sources: [SSMClientTypes.PatchSource]?

    public init(
        approvalRules: SSMClientTypes.PatchRuleGroup? = nil,
        approvedPatches: [Swift.String]? = nil,
        approvedPatchesComplianceLevel: SSMClientTypes.PatchComplianceLevel? = nil,
        approvedPatchesEnableNonSecurity: Swift.Bool? = false,
        baselineId: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        globalFilters: SSMClientTypes.PatchFilterGroup? = nil,
        modifiedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        operatingSystem: SSMClientTypes.OperatingSystem? = nil,
        rejectedPatches: [Swift.String]? = nil,
        rejectedPatchesAction: SSMClientTypes.PatchAction? = nil,
        sources: [SSMClientTypes.PatchSource]? = nil
    )
    {
        self.approvalRules = approvalRules
        self.approvedPatches = approvedPatches
        self.approvedPatchesComplianceLevel = approvedPatchesComplianceLevel
        self.approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurity
        self.baselineId = baselineId
        self.createdDate = createdDate
        self.description = description
        self.globalFilters = globalFilters
        self.modifiedDate = modifiedDate
        self.name = name
        self.operatingSystem = operatingSystem
        self.rejectedPatches = rejectedPatches
        self.rejectedPatchesAction = rejectedPatchesAction
        self.sources = sources
    }
}

/// Another UpdateResourceDataSync request is being processed. Wait a few minutes and try again.
public struct ResourceDataSyncConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceDataSyncConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateResourceDataSyncInput: Swift.Sendable {
    /// The name of the resource data sync you want to update.
    /// This member is required.
    public var syncName: Swift.String?
    /// Specify information about the data sources to synchronize.
    /// This member is required.
    public var syncSource: SSMClientTypes.ResourceDataSyncSource?
    /// The type of resource data sync. The supported SyncType is SyncFromSource.
    /// This member is required.
    public var syncType: Swift.String?

    public init(
        syncName: Swift.String? = nil,
        syncSource: SSMClientTypes.ResourceDataSyncSource? = nil,
        syncType: Swift.String? = nil
    )
    {
        self.syncName = syncName
        self.syncSource = syncSource
        self.syncType = syncType
    }
}

public struct UpdateResourceDataSyncOutput: Swift.Sendable {

    public init() { }
}

/// The request body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service setting to update. For example, arn:aws:ssm:us-east-1:111122223333:servicesetting/ssm/parameter-store/high-throughput-enabled. The setting ID can be one of the following.
    ///
    /// * /ssm/managed-instance/default-ec2-instance-management-role
    ///
    /// * /ssm/automation/customer-script-log-destination
    ///
    /// * /ssm/automation/customer-script-log-group-name
    ///
    /// * /ssm/documents/console/public-sharing-permission
    ///
    /// * /ssm/managed-instance/activation-tier
    ///
    /// * /ssm/opsinsights/opscenter
    ///
    /// * /ssm/parameter-store/default-parameter-tier
    ///
    /// * /ssm/parameter-store/high-throughput-enabled
    ///
    ///
    /// Permissions to update the /ssm/managed-instance/default-ec2-instance-management-role setting should only be provided to administrators. Implement least privilege access when allowing individuals to configure or modify the Default Host Management Configuration.
    /// This member is required.
    public var settingId: Swift.String?
    /// The new value to specify for the service setting. The following list specifies the available values for each setting.
    ///
    /// * For /ssm/managed-instance/default-ec2-instance-management-role, enter the name of an IAM role.
    ///
    /// * For /ssm/automation/customer-script-log-destination, enter CloudWatch.
    ///
    /// * For /ssm/automation/customer-script-log-group-name, enter the name of an Amazon CloudWatch Logs log group.
    ///
    /// * For /ssm/documents/console/public-sharing-permission, enter Enable or Disable.
    ///
    /// * For /ssm/managed-instance/activation-tier, enter standard or advanced.
    ///
    /// * For /ssm/opsinsights/opscenter, enter Enabled or Disabled.
    ///
    /// * For /ssm/parameter-store/default-parameter-tier, enter Standard, Advanced, or Intelligent-Tiering
    ///
    /// * For /ssm/parameter-store/high-throughput-enabled, enter true or false.
    /// This member is required.
    public var settingValue: Swift.String?

    public init(
        settingId: Swift.String? = nil,
        settingValue: Swift.String? = nil
    )
    {
        self.settingId = settingId
        self.settingValue = settingValue
    }
}

/// The result body of the UpdateServiceSetting API operation.
public struct UpdateServiceSettingOutput: Swift.Sendable {

    public init() { }
}

extension SSMClientTypes {

    /// Specifies the inventory type and attribute for the aggregation execution.
    public struct InventoryAggregator: Swift.Sendable {
        /// Nested aggregators to further refine aggregation for an inventory type.
        public var aggregators: [SSMClientTypes.InventoryAggregator]?
        /// The inventory type and attribute name for aggregation.
        public var expression: Swift.String?
        /// A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.
        public var groups: [SSMClientTypes.InventoryGroup]?

        public init(
            aggregators: [SSMClientTypes.InventoryAggregator]? = nil,
            expression: Swift.String? = nil,
            groups: [SSMClientTypes.InventoryGroup]? = nil
        )
        {
            self.aggregators = aggregators
            self.expression = expression
            self.groups = groups
        }
    }
}

extension SSMClientTypes {

    /// One or more aggregators for viewing counts of OpsData using different dimensions such as Source, CreatedTime, or Source and CreatedTime, to name a few.
    public struct OpsAggregator: Swift.Sendable {
        /// Either a Range or Count aggregator for limiting an OpsData summary.
        public var aggregatorType: Swift.String?
        /// A nested aggregator for viewing counts of OpsData.
        public var aggregators: [SSMClientTypes.OpsAggregator]?
        /// The name of an OpsData attribute on which to limit the count of OpsData.
        public var attributeName: Swift.String?
        /// The aggregator filters.
        public var filters: [SSMClientTypes.OpsFilter]?
        /// The data type name to use for viewing counts of OpsData.
        public var typeName: Swift.String?
        /// The aggregator value.
        public var values: [Swift.String: Swift.String]?

        public init(
            aggregatorType: Swift.String? = nil,
            aggregators: [SSMClientTypes.OpsAggregator]? = nil,
            attributeName: Swift.String? = nil,
            filters: [SSMClientTypes.OpsFilter]? = nil,
            typeName: Swift.String? = nil,
            values: [Swift.String: Swift.String]? = nil
        )
        {
            self.aggregatorType = aggregatorType
            self.aggregators = aggregators
            self.attributeName = attributeName
            self.filters = filters
            self.typeName = typeName
            self.values = values
        }
    }
}

public struct GetInventoryInput: Swift.Sendable {
    /// Returns counts of inventory types based on one or more expressions. For example, if you aggregate by using an expression that uses the AWS:InstanceInformation.PlatformType type, you can see a count of how many Windows and Linux managed nodes exist in your inventoried fleet.
    public var aggregators: [SSMClientTypes.InventoryAggregator]?
    /// One or more filters. Use a filter to return a more specific list of results.
    public var filters: [SSMClientTypes.InventoryFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. (You received this token from a previous call.)
    public var nextToken: Swift.String?
    /// The list of inventory item types to return.
    public var resultAttributes: [SSMClientTypes.ResultAttribute]?

    public init(
        aggregators: [SSMClientTypes.InventoryAggregator]? = nil,
        filters: [SSMClientTypes.InventoryFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resultAttributes: [SSMClientTypes.ResultAttribute]? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
    }
}

public struct GetOpsSummaryInput: Swift.Sendable {
    /// Optional aggregators that return counts of OpsData based on one or more expressions.
    public var aggregators: [SSMClientTypes.OpsAggregator]?
    /// Optional filters used to scope down the returned OpsData.
    public var filters: [SSMClientTypes.OpsFilter]?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The OpsData data type to return.
    public var resultAttributes: [SSMClientTypes.OpsResultAttribute]?
    /// Specify the name of a resource data sync to get.
    public var syncName: Swift.String?

    public init(
        aggregators: [SSMClientTypes.OpsAggregator]? = nil,
        filters: [SSMClientTypes.OpsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resultAttributes: [SSMClientTypes.OpsResultAttribute]? = nil,
        syncName: Swift.String? = nil
    )
    {
        self.aggregators = aggregators
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resultAttributes = resultAttributes
        self.syncName = syncName
    }
}

extension AddTagsToResourceInput {

    static func urlPathProvider(_ value: AddTagsToResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateOpsItemRelatedItemInput {

    static func urlPathProvider(_ value: AssociateOpsItemRelatedItemInput) -> Swift.String? {
        return "/"
    }
}

extension CancelCommandInput {

    static func urlPathProvider(_ value: CancelCommandInput) -> Swift.String? {
        return "/"
    }
}

extension CancelMaintenanceWindowExecutionInput {

    static func urlPathProvider(_ value: CancelMaintenanceWindowExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateActivationInput {

    static func urlPathProvider(_ value: CreateActivationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAssociationInput {

    static func urlPathProvider(_ value: CreateAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAssociationBatchInput {

    static func urlPathProvider(_ value: CreateAssociationBatchInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDocumentInput {

    static func urlPathProvider(_ value: CreateDocumentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMaintenanceWindowInput {

    static func urlPathProvider(_ value: CreateMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOpsItemInput {

    static func urlPathProvider(_ value: CreateOpsItemInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOpsMetadataInput {

    static func urlPathProvider(_ value: CreateOpsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePatchBaselineInput {

    static func urlPathProvider(_ value: CreatePatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResourceDataSyncInput {

    static func urlPathProvider(_ value: CreateResourceDataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteActivationInput {

    static func urlPathProvider(_ value: DeleteActivationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAssociationInput {

    static func urlPathProvider(_ value: DeleteAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDocumentInput {

    static func urlPathProvider(_ value: DeleteDocumentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInventoryInput {

    static func urlPathProvider(_ value: DeleteInventoryInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMaintenanceWindowInput {

    static func urlPathProvider(_ value: DeleteMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOpsItemInput {

    static func urlPathProvider(_ value: DeleteOpsItemInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOpsMetadataInput {

    static func urlPathProvider(_ value: DeleteOpsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteParameterInput {

    static func urlPathProvider(_ value: DeleteParameterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteParametersInput {

    static func urlPathProvider(_ value: DeleteParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePatchBaselineInput {

    static func urlPathProvider(_ value: DeletePatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceDataSyncInput {

    static func urlPathProvider(_ value: DeleteResourceDataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterManagedInstanceInput {

    static func urlPathProvider(_ value: DeregisterManagedInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterPatchBaselineForPatchGroupInput {

    static func urlPathProvider(_ value: DeregisterPatchBaselineForPatchGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterTargetFromMaintenanceWindowInput {

    static func urlPathProvider(_ value: DeregisterTargetFromMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterTaskFromMaintenanceWindowInput {

    static func urlPathProvider(_ value: DeregisterTaskFromMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeActivationsInput {

    static func urlPathProvider(_ value: DescribeActivationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssociationInput {

    static func urlPathProvider(_ value: DescribeAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssociationExecutionsInput {

    static func urlPathProvider(_ value: DescribeAssociationExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAssociationExecutionTargetsInput {

    static func urlPathProvider(_ value: DescribeAssociationExecutionTargetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAutomationExecutionsInput {

    static func urlPathProvider(_ value: DescribeAutomationExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAutomationStepExecutionsInput {

    static func urlPathProvider(_ value: DescribeAutomationStepExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAvailablePatchesInput {

    static func urlPathProvider(_ value: DescribeAvailablePatchesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDocumentInput {

    static func urlPathProvider(_ value: DescribeDocumentInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDocumentPermissionInput {

    static func urlPathProvider(_ value: DescribeDocumentPermissionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEffectiveInstanceAssociationsInput {

    static func urlPathProvider(_ value: DescribeEffectiveInstanceAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput {

    static func urlPathProvider(_ value: DescribeEffectivePatchesForPatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceAssociationsStatusInput {

    static func urlPathProvider(_ value: DescribeInstanceAssociationsStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceInformationInput {

    static func urlPathProvider(_ value: DescribeInstanceInformationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstancePatchesInput {

    static func urlPathProvider(_ value: DescribeInstancePatchesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstancePatchStatesInput {

    static func urlPathProvider(_ value: DescribeInstancePatchStatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput {

    static func urlPathProvider(_ value: DescribeInstancePatchStatesForPatchGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstancePropertiesInput {

    static func urlPathProvider(_ value: DescribeInstancePropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInventoryDeletionsInput {

    static func urlPathProvider(_ value: DescribeInventoryDeletionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowExecutionsInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowExecutionTaskInvocationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowExecutionTasksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowsInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowScheduleInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowScheduleInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowsForTargetInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowsForTargetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowTargetsInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowTargetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMaintenanceWindowTasksInput {

    static func urlPathProvider(_ value: DescribeMaintenanceWindowTasksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOpsItemsInput {

    static func urlPathProvider(_ value: DescribeOpsItemsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeParametersInput {

    static func urlPathProvider(_ value: DescribeParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePatchBaselinesInput {

    static func urlPathProvider(_ value: DescribePatchBaselinesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePatchGroupsInput {

    static func urlPathProvider(_ value: DescribePatchGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePatchGroupStateInput {

    static func urlPathProvider(_ value: DescribePatchGroupStateInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePatchPropertiesInput {

    static func urlPathProvider(_ value: DescribePatchPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSessionsInput {

    static func urlPathProvider(_ value: DescribeSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateOpsItemRelatedItemInput {

    static func urlPathProvider(_ value: DisassociateOpsItemRelatedItemInput) -> Swift.String? {
        return "/"
    }
}

extension GetAutomationExecutionInput {

    static func urlPathProvider(_ value: GetAutomationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetCalendarStateInput {

    static func urlPathProvider(_ value: GetCalendarStateInput) -> Swift.String? {
        return "/"
    }
}

extension GetCommandInvocationInput {

    static func urlPathProvider(_ value: GetCommandInvocationInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionStatusInput {

    static func urlPathProvider(_ value: GetConnectionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetDefaultPatchBaselineInput {

    static func urlPathProvider(_ value: GetDefaultPatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension GetDeployablePatchSnapshotForInstanceInput {

    static func urlPathProvider(_ value: GetDeployablePatchSnapshotForInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetDocumentInput {

    static func urlPathProvider(_ value: GetDocumentInput) -> Swift.String? {
        return "/"
    }
}

extension GetInventoryInput {

    static func urlPathProvider(_ value: GetInventoryInput) -> Swift.String? {
        return "/"
    }
}

extension GetInventorySchemaInput {

    static func urlPathProvider(_ value: GetInventorySchemaInput) -> Swift.String? {
        return "/"
    }
}

extension GetMaintenanceWindowInput {

    static func urlPathProvider(_ value: GetMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension GetMaintenanceWindowExecutionInput {

    static func urlPathProvider(_ value: GetMaintenanceWindowExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetMaintenanceWindowExecutionTaskInput {

    static func urlPathProvider(_ value: GetMaintenanceWindowExecutionTaskInput) -> Swift.String? {
        return "/"
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationInput {

    static func urlPathProvider(_ value: GetMaintenanceWindowExecutionTaskInvocationInput) -> Swift.String? {
        return "/"
    }
}

extension GetMaintenanceWindowTaskInput {

    static func urlPathProvider(_ value: GetMaintenanceWindowTaskInput) -> Swift.String? {
        return "/"
    }
}

extension GetOpsItemInput {

    static func urlPathProvider(_ value: GetOpsItemInput) -> Swift.String? {
        return "/"
    }
}

extension GetOpsMetadataInput {

    static func urlPathProvider(_ value: GetOpsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetOpsSummaryInput {

    static func urlPathProvider(_ value: GetOpsSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetParameterInput {

    static func urlPathProvider(_ value: GetParameterInput) -> Swift.String? {
        return "/"
    }
}

extension GetParameterHistoryInput {

    static func urlPathProvider(_ value: GetParameterHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension GetParametersInput {

    static func urlPathProvider(_ value: GetParametersInput) -> Swift.String? {
        return "/"
    }
}

extension GetParametersByPathInput {

    static func urlPathProvider(_ value: GetParametersByPathInput) -> Swift.String? {
        return "/"
    }
}

extension GetPatchBaselineInput {

    static func urlPathProvider(_ value: GetPatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension GetPatchBaselineForPatchGroupInput {

    static func urlPathProvider(_ value: GetPatchBaselineForPatchGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePoliciesInput {

    static func urlPathProvider(_ value: GetResourcePoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceSettingInput {

    static func urlPathProvider(_ value: GetServiceSettingInput) -> Swift.String? {
        return "/"
    }
}

extension LabelParameterVersionInput {

    static func urlPathProvider(_ value: LabelParameterVersionInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociationsInput {

    static func urlPathProvider(_ value: ListAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAssociationVersionsInput {

    static func urlPathProvider(_ value: ListAssociationVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCommandInvocationsInput {

    static func urlPathProvider(_ value: ListCommandInvocationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCommandsInput {

    static func urlPathProvider(_ value: ListCommandsInput) -> Swift.String? {
        return "/"
    }
}

extension ListComplianceItemsInput {

    static func urlPathProvider(_ value: ListComplianceItemsInput) -> Swift.String? {
        return "/"
    }
}

extension ListComplianceSummariesInput {

    static func urlPathProvider(_ value: ListComplianceSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDocumentMetadataHistoryInput {

    static func urlPathProvider(_ value: ListDocumentMetadataHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListDocumentsInput {

    static func urlPathProvider(_ value: ListDocumentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDocumentVersionsInput {

    static func urlPathProvider(_ value: ListDocumentVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListInventoryEntriesInput {

    static func urlPathProvider(_ value: ListInventoryEntriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpsItemEventsInput {

    static func urlPathProvider(_ value: ListOpsItemEventsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpsItemRelatedItemsInput {

    static func urlPathProvider(_ value: ListOpsItemRelatedItemsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpsMetadataInput {

    static func urlPathProvider(_ value: ListOpsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceComplianceSummariesInput {

    static func urlPathProvider(_ value: ListResourceComplianceSummariesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceDataSyncInput {

    static func urlPathProvider(_ value: ListResourceDataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ModifyDocumentPermissionInput {

    static func urlPathProvider(_ value: ModifyDocumentPermissionInput) -> Swift.String? {
        return "/"
    }
}

extension PutComplianceItemsInput {

    static func urlPathProvider(_ value: PutComplianceItemsInput) -> Swift.String? {
        return "/"
    }
}

extension PutInventoryInput {

    static func urlPathProvider(_ value: PutInventoryInput) -> Swift.String? {
        return "/"
    }
}

extension PutParameterInput {

    static func urlPathProvider(_ value: PutParameterInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterDefaultPatchBaselineInput {

    static func urlPathProvider(_ value: RegisterDefaultPatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterPatchBaselineForPatchGroupInput {

    static func urlPathProvider(_ value: RegisterPatchBaselineForPatchGroupInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterTargetWithMaintenanceWindowInput {

    static func urlPathProvider(_ value: RegisterTargetWithMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterTaskWithMaintenanceWindowInput {

    static func urlPathProvider(_ value: RegisterTaskWithMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension RemoveTagsFromResourceInput {

    static func urlPathProvider(_ value: RemoveTagsFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ResetServiceSettingInput {

    static func urlPathProvider(_ value: ResetServiceSettingInput) -> Swift.String? {
        return "/"
    }
}

extension ResumeSessionInput {

    static func urlPathProvider(_ value: ResumeSessionInput) -> Swift.String? {
        return "/"
    }
}

extension SendAutomationSignalInput {

    static func urlPathProvider(_ value: SendAutomationSignalInput) -> Swift.String? {
        return "/"
    }
}

extension SendCommandInput {

    static func urlPathProvider(_ value: SendCommandInput) -> Swift.String? {
        return "/"
    }
}

extension StartAssociationsOnceInput {

    static func urlPathProvider(_ value: StartAssociationsOnceInput) -> Swift.String? {
        return "/"
    }
}

extension StartAutomationExecutionInput {

    static func urlPathProvider(_ value: StartAutomationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartChangeRequestExecutionInput {

    static func urlPathProvider(_ value: StartChangeRequestExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartSessionInput {

    static func urlPathProvider(_ value: StartSessionInput) -> Swift.String? {
        return "/"
    }
}

extension StopAutomationExecutionInput {

    static func urlPathProvider(_ value: StopAutomationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateSessionInput {

    static func urlPathProvider(_ value: TerminateSessionInput) -> Swift.String? {
        return "/"
    }
}

extension UnlabelParameterVersionInput {

    static func urlPathProvider(_ value: UnlabelParameterVersionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAssociationInput {

    static func urlPathProvider(_ value: UpdateAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAssociationStatusInput {

    static func urlPathProvider(_ value: UpdateAssociationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDocumentInput {

    static func urlPathProvider(_ value: UpdateDocumentInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDocumentDefaultVersionInput {

    static func urlPathProvider(_ value: UpdateDocumentDefaultVersionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDocumentMetadataInput {

    static func urlPathProvider(_ value: UpdateDocumentMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMaintenanceWindowInput {

    static func urlPathProvider(_ value: UpdateMaintenanceWindowInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMaintenanceWindowTargetInput {

    static func urlPathProvider(_ value: UpdateMaintenanceWindowTargetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMaintenanceWindowTaskInput {

    static func urlPathProvider(_ value: UpdateMaintenanceWindowTaskInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateManagedInstanceRoleInput {

    static func urlPathProvider(_ value: UpdateManagedInstanceRoleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOpsItemInput {

    static func urlPathProvider(_ value: UpdateOpsItemInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOpsMetadataInput {

    static func urlPathProvider(_ value: UpdateOpsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePatchBaselineInput {

    static func urlPathProvider(_ value: UpdatePatchBaselineInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResourceDataSyncInput {

    static func urlPathProvider(_ value: UpdateResourceDataSyncInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceSettingInput {

    static func urlPathProvider(_ value: UpdateServiceSettingInput) -> Swift.String? {
        return "/"
    }
}

extension AddTagsToResourceInput {

    static func write(value: AddTagsToResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateOpsItemRelatedItemInput {

    static func write(value: AssociateOpsItemRelatedItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationType"].write(value.associationType)
        try writer["OpsItemId"].write(value.opsItemId)
        try writer["ResourceType"].write(value.resourceType)
        try writer["ResourceUri"].write(value.resourceUri)
    }
}

extension CancelCommandInput {

    static func write(value: CancelCommandInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommandId"].write(value.commandId)
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelMaintenanceWindowExecutionInput {

    static func write(value: CancelMaintenanceWindowExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension CreateActivationInput {

    static func write(value: CreateActivationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultInstanceName"].write(value.defaultInstanceName)
        try writer["Description"].write(value.description)
        try writer["ExpirationDate"].writeTimestamp(value.expirationDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["IamRole"].write(value.iamRole)
        try writer["RegistrationLimit"].write(value.registrationLimit)
        try writer["RegistrationMetadata"].writeList(value.registrationMetadata, memberWritingClosure: SSMClientTypes.RegistrationMetadataItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAssociationInput {

    static func write(value: CreateAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["ApplyOnlyAtCronInterval"].write(value.applyOnlyAtCronInterval)
        try writer["AssociationName"].write(value.associationName)
        try writer["AutomationTargetParameterName"].write(value.automationTargetParameterName)
        try writer["CalendarNames"].writeList(value.calendarNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSeverity"].write(value.complianceSeverity)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Duration"].write(value.duration)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Name"].write(value.name)
        try writer["OutputLocation"].write(value.outputLocation, with: SSMClientTypes.InstanceAssociationOutputLocation.write(value:to:))
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["SyncCompliance"].write(value.syncCompliance)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetLocations"].writeList(value.targetLocations, memberWritingClosure: SSMClientTypes.TargetLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetMaps"].writeList(value.targetMaps, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAssociationBatchInput {

    static func write(value: CreateAssociationBatchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Entries"].writeList(value.entries, memberWritingClosure: SSMClientTypes.CreateAssociationBatchRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDocumentInput {

    static func write(value: CreateDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attachments"].writeList(value.attachments, memberWritingClosure: SSMClientTypes.AttachmentsSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Content"].write(value.content)
        try writer["DisplayName"].write(value.displayName)
        try writer["DocumentFormat"].write(value.documentFormat)
        try writer["DocumentType"].write(value.documentType)
        try writer["Name"].write(value.name)
        try writer["Requires"].writeList(value.requires, memberWritingClosure: SSMClientTypes.DocumentRequires.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetType"].write(value.targetType)
        try writer["VersionName"].write(value.versionName)
    }
}

extension CreateMaintenanceWindowInput {

    static func write(value: CreateMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowUnassociatedTargets"].write(value.allowUnassociatedTargets)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Cutoff"].write(value.cutoff)
        try writer["Description"].write(value.description)
        try writer["Duration"].write(value.duration)
        try writer["EndDate"].write(value.endDate)
        try writer["Name"].write(value.name)
        try writer["Schedule"].write(value.schedule)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["ScheduleTimezone"].write(value.scheduleTimezone)
        try writer["StartDate"].write(value.startDate)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateOpsItemInput {

    static func write(value: CreateOpsItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActualEndTime"].writeTimestamp(value.actualEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ActualStartTime"].writeTimestamp(value.actualStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Category"].write(value.category)
        try writer["Description"].write(value.description)
        try writer["Notifications"].writeList(value.notifications, memberWritingClosure: SSMClientTypes.OpsItemNotification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OperationalData"].writeMap(value.operationalData, valueWritingClosure: SSMClientTypes.OpsItemDataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OpsItemType"].write(value.opsItemType)
        try writer["PlannedEndTime"].writeTimestamp(value.plannedEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["PlannedStartTime"].writeTimestamp(value.plannedStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Priority"].write(value.priority)
        try writer["RelatedOpsItems"].writeList(value.relatedOpsItems, memberWritingClosure: SSMClientTypes.RelatedOpsItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severity"].write(value.severity)
        try writer["Source"].write(value.source)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].write(value.title)
    }
}

extension CreateOpsMetadataInput {

    static func write(value: CreateOpsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].writeMap(value.metadata, valueWritingClosure: SSMClientTypes.MetadataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceId"].write(value.resourceId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePatchBaselineInput {

    static func write(value: CreatePatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApprovalRules"].write(value.approvalRules, with: SSMClientTypes.PatchRuleGroup.write(value:to:))
        try writer["ApprovedPatches"].writeList(value.approvedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApprovedPatchesComplianceLevel"].write(value.approvedPatchesComplianceLevel)
        try writer["ApprovedPatchesEnableNonSecurity"].write(value.approvedPatchesEnableNonSecurity)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["GlobalFilters"].write(value.globalFilters, with: SSMClientTypes.PatchFilterGroup.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OperatingSystem"].write(value.operatingSystem)
        try writer["RejectedPatches"].writeList(value.rejectedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RejectedPatchesAction"].write(value.rejectedPatchesAction)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: SSMClientTypes.PatchSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResourceDataSyncInput {

    static func write(value: CreateResourceDataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Destination"].write(value.s3Destination, with: SSMClientTypes.ResourceDataSyncS3Destination.write(value:to:))
        try writer["SyncName"].write(value.syncName)
        try writer["SyncSource"].write(value.syncSource, with: SSMClientTypes.ResourceDataSyncSource.write(value:to:))
        try writer["SyncType"].write(value.syncType)
    }
}

extension DeleteActivationInput {

    static func write(value: DeleteActivationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationId"].write(value.activationId)
    }
}

extension DeleteAssociationInput {

    static func write(value: DeleteAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
    }
}

extension DeleteDocumentInput {

    static func write(value: DeleteDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Force"].write(value.force)
        try writer["Name"].write(value.name)
        try writer["VersionName"].write(value.versionName)
    }
}

extension DeleteInventoryInput {

    static func write(value: DeleteInventoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DryRun"].write(value.dryRun)
        try writer["SchemaDeleteOption"].write(value.schemaDeleteOption)
        try writer["TypeName"].write(value.typeName)
    }
}

extension DeleteMaintenanceWindowInput {

    static func write(value: DeleteMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowId"].write(value.windowId)
    }
}

extension DeleteOpsItemInput {

    static func write(value: DeleteOpsItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OpsItemId"].write(value.opsItemId)
    }
}

extension DeleteOpsMetadataInput {

    static func write(value: DeleteOpsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OpsMetadataArn"].write(value.opsMetadataArn)
    }
}

extension DeleteParameterInput {

    static func write(value: DeleteParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension DeleteParametersInput {

    static func write(value: DeleteParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeletePatchBaselineInput {

    static func write(value: DeletePatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
    }
}

extension DeleteResourceDataSyncInput {

    static func write(value: DeleteResourceDataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SyncName"].write(value.syncName)
        try writer["SyncType"].write(value.syncType)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyHash"].write(value.policyHash)
        try writer["PolicyId"].write(value.policyId)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DeregisterManagedInstanceInput {

    static func write(value: DeregisterManagedInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension DeregisterPatchBaselineForPatchGroupInput {

    static func write(value: DeregisterPatchBaselineForPatchGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
        try writer["PatchGroup"].write(value.patchGroup)
    }
}

extension DeregisterTargetFromMaintenanceWindowInput {

    static func write(value: DeregisterTargetFromMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Safe"].write(value.safe)
        try writer["WindowId"].write(value.windowId)
        try writer["WindowTargetId"].write(value.windowTargetId)
    }
}

extension DeregisterTaskFromMaintenanceWindowInput {

    static func write(value: DeregisterTaskFromMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowId"].write(value.windowId)
        try writer["WindowTaskId"].write(value.windowTaskId)
    }
}

extension DescribeActivationsInput {

    static func write(value: DescribeActivationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.DescribeActivationsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAssociationInput {

    static func write(value: DescribeAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["AssociationVersion"].write(value.associationVersion)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
    }
}

extension DescribeAssociationExecutionsInput {

    static func write(value: DescribeAssociationExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.AssociationExecutionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAssociationExecutionTargetsInput {

    static func write(value: DescribeAssociationExecutionTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["ExecutionId"].write(value.executionId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.AssociationExecutionTargetsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAutomationExecutionsInput {

    static func write(value: DescribeAutomationExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.AutomationExecutionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAutomationStepExecutionsInput {

    static func write(value: DescribeAutomationStepExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationExecutionId"].write(value.automationExecutionId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.StepExecutionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ReverseOrder"].write(value.reverseOrder)
    }
}

extension DescribeAvailablePatchesInput {

    static func write(value: DescribeAvailablePatchesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.PatchOrchestratorFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeDocumentInput {

    static func write(value: DescribeDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Name"].write(value.name)
        try writer["VersionName"].write(value.versionName)
    }
}

extension DescribeDocumentPermissionInput {

    static func write(value: DescribeDocumentPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
        try writer["PermissionType"].write(value.permissionType)
    }
}

extension DescribeEffectiveInstanceAssociationsInput {

    static func write(value: DescribeEffectiveInstanceAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeEffectivePatchesForPatchBaselineInput {

    static func write(value: DescribeEffectivePatchesForPatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstanceAssociationsStatusInput {

    static func write(value: DescribeInstanceAssociationsStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstanceInformationInput {

    static func write(value: DescribeInstanceInformationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.InstanceInformationStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceInformationFilterList"].writeList(value.instanceInformationFilterList, memberWritingClosure: SSMClientTypes.InstanceInformationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstancePatchesInput {

    static func write(value: DescribeInstancePatchesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.PatchOrchestratorFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstancePatchStatesInput {

    static func write(value: DescribeInstancePatchStatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInstancePatchStatesForPatchGroupInput {

    static func write(value: DescribeInstancePatchStatesForPatchGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.InstancePatchStateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PatchGroup"].write(value.patchGroup)
    }
}

extension DescribeInstancePropertiesInput {

    static func write(value: DescribeInstancePropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FiltersWithOperator"].writeList(value.filtersWithOperator, memberWritingClosure: SSMClientTypes.InstancePropertyStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstancePropertyFilterList"].writeList(value.instancePropertyFilterList, memberWritingClosure: SSMClientTypes.InstancePropertyFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeInventoryDeletionsInput {

    static func write(value: DescribeInventoryDeletionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionId"].write(value.deletionId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeMaintenanceWindowExecutionsInput {

    static func write(value: DescribeMaintenanceWindowExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WindowId"].write(value.windowId)
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsInput {

    static func write(value: DescribeMaintenanceWindowExecutionTaskInvocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TaskId"].write(value.taskId)
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension DescribeMaintenanceWindowExecutionTasksInput {

    static func write(value: DescribeMaintenanceWindowExecutionTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension DescribeMaintenanceWindowsInput {

    static func write(value: DescribeMaintenanceWindowsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeMaintenanceWindowScheduleInput {

    static func write(value: DescribeMaintenanceWindowScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.PatchOrchestratorFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WindowId"].write(value.windowId)
    }
}

extension DescribeMaintenanceWindowsForTargetInput {

    static func write(value: DescribeMaintenanceWindowsForTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeMaintenanceWindowTargetsInput {

    static func write(value: DescribeMaintenanceWindowTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WindowId"].write(value.windowId)
    }
}

extension DescribeMaintenanceWindowTasksInput {

    static func write(value: DescribeMaintenanceWindowTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.MaintenanceWindowFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WindowId"].write(value.windowId)
    }
}

extension DescribeOpsItemsInput {

    static func write(value: DescribeOpsItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpsItemFilters"].writeList(value.opsItemFilters, memberWritingClosure: SSMClientTypes.OpsItemFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeParametersInput {

    static func write(value: DescribeParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.ParametersFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParameterFilters"].writeList(value.parameterFilters, memberWritingClosure: SSMClientTypes.ParameterStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Shared"].write(value.shared)
    }
}

extension DescribePatchBaselinesInput {

    static func write(value: DescribePatchBaselinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.PatchOrchestratorFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribePatchGroupsInput {

    static func write(value: DescribePatchGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.PatchOrchestratorFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribePatchGroupStateInput {

    static func write(value: DescribePatchGroupStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PatchGroup"].write(value.patchGroup)
    }
}

extension DescribePatchPropertiesInput {

    static func write(value: DescribePatchPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OperatingSystem"].write(value.operatingSystem)
        try writer["PatchSet"].write(value.patchSet)
        try writer["Property"].write(value.property)
    }
}

extension DescribeSessionsInput {

    static func write(value: DescribeSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.SessionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["State"].write(value.state)
    }
}

extension DisassociateOpsItemRelatedItemInput {

    static func write(value: DisassociateOpsItemRelatedItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["OpsItemId"].write(value.opsItemId)
    }
}

extension GetAutomationExecutionInput {

    static func write(value: GetAutomationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationExecutionId"].write(value.automationExecutionId)
    }
}

extension GetCalendarStateInput {

    static func write(value: GetCalendarStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AtTime"].write(value.atTime)
        try writer["CalendarNames"].writeList(value.calendarNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetCommandInvocationInput {

    static func write(value: GetCommandInvocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommandId"].write(value.commandId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["PluginName"].write(value.pluginName)
    }
}

extension GetConnectionStatusInput {

    static func write(value: GetConnectionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Target"].write(value.target)
    }
}

extension GetDefaultPatchBaselineInput {

    static func write(value: GetDefaultPatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperatingSystem"].write(value.operatingSystem)
    }
}

extension GetDeployablePatchSnapshotForInstanceInput {

    static func write(value: GetDeployablePatchSnapshotForInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineOverride"].write(value.baselineOverride, with: SSMClientTypes.BaselineOverride.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["SnapshotId"].write(value.snapshotId)
    }
}

extension GetDocumentInput {

    static func write(value: GetDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentFormat"].write(value.documentFormat)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Name"].write(value.name)
        try writer["VersionName"].write(value.versionName)
    }
}

extension GetInventoryInput {

    static func write(value: GetInventoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregators"].writeList(value.aggregators, memberWritingClosure: SSMClientTypes.InventoryAggregator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.InventoryFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResultAttributes"].writeList(value.resultAttributes, memberWritingClosure: SSMClientTypes.ResultAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetInventorySchemaInput {

    static func write(value: GetInventorySchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregator"].write(value.aggregator)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SubType"].write(value.subType)
        try writer["TypeName"].write(value.typeName)
    }
}

extension GetMaintenanceWindowInput {

    static func write(value: GetMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowId"].write(value.windowId)
    }
}

extension GetMaintenanceWindowExecutionInput {

    static func write(value: GetMaintenanceWindowExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension GetMaintenanceWindowExecutionTaskInput {

    static func write(value: GetMaintenanceWindowExecutionTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TaskId"].write(value.taskId)
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationInput {

    static func write(value: GetMaintenanceWindowExecutionTaskInvocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvocationId"].write(value.invocationId)
        try writer["TaskId"].write(value.taskId)
        try writer["WindowExecutionId"].write(value.windowExecutionId)
    }
}

extension GetMaintenanceWindowTaskInput {

    static func write(value: GetMaintenanceWindowTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowId"].write(value.windowId)
        try writer["WindowTaskId"].write(value.windowTaskId)
    }
}

extension GetOpsItemInput {

    static func write(value: GetOpsItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OpsItemArn"].write(value.opsItemArn)
        try writer["OpsItemId"].write(value.opsItemId)
    }
}

extension GetOpsMetadataInput {

    static func write(value: GetOpsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpsMetadataArn"].write(value.opsMetadataArn)
    }
}

extension GetOpsSummaryInput {

    static func write(value: GetOpsSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregators"].writeList(value.aggregators, memberWritingClosure: SSMClientTypes.OpsAggregator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.OpsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResultAttributes"].writeList(value.resultAttributes, memberWritingClosure: SSMClientTypes.OpsResultAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SyncName"].write(value.syncName)
    }
}

extension GetParameterInput {

    static func write(value: GetParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["WithDecryption"].write(value.withDecryption)
    }
}

extension GetParameterHistoryInput {

    static func write(value: GetParameterHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
        try writer["WithDecryption"].write(value.withDecryption)
    }
}

extension GetParametersInput {

    static func write(value: GetParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WithDecryption"].write(value.withDecryption)
    }
}

extension GetParametersByPathInput {

    static func write(value: GetParametersByPathInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParameterFilters"].writeList(value.parameterFilters, memberWritingClosure: SSMClientTypes.ParameterStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["Recursive"].write(value.recursive)
        try writer["WithDecryption"].write(value.withDecryption)
    }
}

extension GetPatchBaselineInput {

    static func write(value: GetPatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
    }
}

extension GetPatchBaselineForPatchGroupInput {

    static func write(value: GetPatchBaselineForPatchGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperatingSystem"].write(value.operatingSystem)
        try writer["PatchGroup"].write(value.patchGroup)
    }
}

extension GetResourcePoliciesInput {

    static func write(value: GetResourcePoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetServiceSettingInput {

    static func write(value: GetServiceSettingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SettingId"].write(value.settingId)
    }
}

extension LabelParameterVersionInput {

    static func write(value: LabelParameterVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterVersion"].write(value.parameterVersion)
    }
}

extension ListAssociationsInput {

    static func write(value: ListAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationFilterList"].writeList(value.associationFilterList, memberWritingClosure: SSMClientTypes.AssociationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAssociationVersionsInput {

    static func write(value: ListAssociationVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCommandInvocationsInput {

    static func write(value: ListCommandInvocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommandId"].write(value.commandId)
        try writer["Details"].write(value.details)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.CommandFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCommandsInput {

    static func write(value: ListCommandsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommandId"].write(value.commandId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.CommandFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListComplianceItemsInput {

    static func write(value: ListComplianceItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.ComplianceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIds"].writeList(value.resourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListComplianceSummariesInput {

    static func write(value: ListComplianceSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.ComplianceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDocumentMetadataHistoryInput {

    static func write(value: ListDocumentMetadataHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metadata"].write(value.metadata)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDocumentsInput {

    static func write(value: ListDocumentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentFilterList"].writeList(value.documentFilterList, memberWritingClosure: SSMClientTypes.DocumentFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.DocumentKeyValuesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListDocumentVersionsInput {

    static func write(value: ListDocumentVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["Name"].write(value.name)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListInventoryEntriesInput {

    static func write(value: ListInventoryEntriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.InventoryFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TypeName"].write(value.typeName)
    }
}

extension ListOpsItemEventsInput {

    static func write(value: ListOpsItemEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.OpsItemEventFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListOpsItemRelatedItemsInput {

    static func write(value: ListOpsItemRelatedItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.OpsItemRelatedItemsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpsItemId"].write(value.opsItemId)
    }
}

extension ListOpsMetadataInput {

    static func write(value: ListOpsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.OpsMetadataFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceComplianceSummariesInput {

    static func write(value: ListResourceComplianceSummariesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.ComplianceStringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceDataSyncInput {

    static func write(value: ListResourceDataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SyncType"].write(value.syncType)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ModifyDocumentPermissionInput {

    static func write(value: ModifyDocumentPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIdsToAdd"].writeList(value.accountIdsToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AccountIdsToRemove"].writeList(value.accountIdsToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PermissionType"].write(value.permissionType)
        try writer["SharedDocumentVersion"].write(value.sharedDocumentVersion)
    }
}

extension PutComplianceItemsInput {

    static func write(value: PutComplianceItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ExecutionSummary"].write(value.executionSummary, with: SSMClientTypes.ComplianceExecutionSummary.write(value:to:))
        try writer["ItemContentHash"].write(value.itemContentHash)
        try writer["Items"].writeList(value.items, memberWritingClosure: SSMClientTypes.ComplianceItemEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
        try writer["UploadType"].write(value.uploadType)
    }
}

extension PutInventoryInput {

    static func write(value: PutInventoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["Items"].writeList(value.items, memberWritingClosure: SSMClientTypes.InventoryItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutParameterInput {

    static func write(value: PutParameterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedPattern"].write(value.allowedPattern)
        try writer["DataType"].write(value.dataType)
        try writer["Description"].write(value.description)
        try writer["KeyId"].write(value.keyId)
        try writer["Name"].write(value.name)
        try writer["Overwrite"].write(value.overwrite)
        try writer["Policies"].write(value.policies)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tier"].write(value.tier)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["PolicyHash"].write(value.policyHash)
        try writer["PolicyId"].write(value.policyId)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension RegisterDefaultPatchBaselineInput {

    static func write(value: RegisterDefaultPatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
    }
}

extension RegisterPatchBaselineForPatchGroupInput {

    static func write(value: RegisterPatchBaselineForPatchGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaselineId"].write(value.baselineId)
        try writer["PatchGroup"].write(value.patchGroup)
    }
}

extension RegisterTargetWithMaintenanceWindowInput {

    static func write(value: RegisterTargetWithMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["OwnerInformation"].write(value.ownerInformation)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WindowId"].write(value.windowId)
    }
}

extension RegisterTaskWithMaintenanceWindowInput {

    static func write(value: RegisterTaskWithMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["CutoffBehavior"].write(value.cutoffBehavior)
        try writer["Description"].write(value.description)
        try writer["LoggingInfo"].write(value.loggingInfo, with: SSMClientTypes.LoggingInfo.write(value:to:))
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskArn"].write(value.taskArn)
        try writer["TaskInvocationParameters"].write(value.taskInvocationParameters, with: SSMClientTypes.MaintenanceWindowTaskInvocationParameters.write(value:to:))
        try writer["TaskParameters"].writeMap(value.taskParameters, valueWritingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TaskType"].write(value.taskType)
        try writer["WindowId"].write(value.windowId)
    }
}

extension RemoveTagsFromResourceInput {

    static func write(value: RemoveTagsFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ResetServiceSettingInput {

    static func write(value: ResetServiceSettingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SettingId"].write(value.settingId)
    }
}

extension ResumeSessionInput {

    static func write(value: ResumeSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

extension SendAutomationSignalInput {

    static func write(value: SendAutomationSignalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationExecutionId"].write(value.automationExecutionId)
        try writer["Payload"].writeMap(value.payload, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SignalType"].write(value.signalType)
    }
}

extension SendCommandInput {

    static func write(value: SendCommandInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["CloudWatchOutputConfig"].write(value.cloudWatchOutputConfig, with: SSMClientTypes.CloudWatchOutputConfig.write(value:to:))
        try writer["Comment"].write(value.comment)
        try writer["DocumentHash"].write(value.documentHash)
        try writer["DocumentHashType"].write(value.documentHashType)
        try writer["DocumentName"].write(value.documentName)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["NotificationConfig"].write(value.notificationConfig, with: SSMClientTypes.NotificationConfig.write(value:to:))
        try writer["OutputS3BucketName"].write(value.outputS3BucketName)
        try writer["OutputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["OutputS3Region"].write(value.outputS3Region)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeoutSeconds"].write(value.timeoutSeconds)
    }
}

extension StartAssociationsOnceInput {

    static func write(value: StartAssociationsOnceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationIds"].writeList(value.associationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartAutomationExecutionInput {

    static func write(value: StartAutomationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["DocumentName"].write(value.documentName)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Mode"].write(value.mode)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetLocations"].writeList(value.targetLocations, memberWritingClosure: SSMClientTypes.TargetLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetLocationsURL"].write(value.targetLocationsURL)
        try writer["TargetMaps"].writeList(value.targetMaps, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetParameterName"].write(value.targetParameterName)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartChangeRequestExecutionInput {

    static func write(value: StartChangeRequestExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoApprove"].write(value.autoApprove)
        try writer["ChangeDetails"].write(value.changeDetails)
        try writer["ChangeRequestName"].write(value.changeRequestName)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DocumentName"].write(value.documentName)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Runbooks"].writeList(value.runbooks, memberWritingClosure: SSMClientTypes.Runbook.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScheduledEndTime"].writeTimestamp(value.scheduledEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ScheduledTime"].writeTimestamp(value.scheduledTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartSessionInput {

    static func write(value: StartSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentName"].write(value.documentName)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Reason"].write(value.reason)
        try writer["Target"].write(value.target)
    }
}

extension StopAutomationExecutionInput {

    static func write(value: StopAutomationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationExecutionId"].write(value.automationExecutionId)
        try writer["Type"].write(value.type)
    }
}

extension TerminateSessionInput {

    static func write(value: TerminateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SessionId"].write(value.sessionId)
    }
}

extension UnlabelParameterVersionInput {

    static func write(value: UnlabelParameterVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterVersion"].write(value.parameterVersion)
    }
}

extension UpdateAssociationInput {

    static func write(value: UpdateAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["ApplyOnlyAtCronInterval"].write(value.applyOnlyAtCronInterval)
        try writer["AssociationId"].write(value.associationId)
        try writer["AssociationName"].write(value.associationName)
        try writer["AssociationVersion"].write(value.associationVersion)
        try writer["AutomationTargetParameterName"].write(value.automationTargetParameterName)
        try writer["CalendarNames"].writeList(value.calendarNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSeverity"].write(value.complianceSeverity)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Duration"].write(value.duration)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Name"].write(value.name)
        try writer["OutputLocation"].write(value.outputLocation, with: SSMClientTypes.InstanceAssociationOutputLocation.write(value:to:))
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["SyncCompliance"].write(value.syncCompliance)
        try writer["TargetLocations"].writeList(value.targetLocations, memberWritingClosure: SSMClientTypes.TargetLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetMaps"].writeList(value.targetMaps, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAssociationStatusInput {

    static func write(value: UpdateAssociationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationStatus"].write(value.associationStatus, with: SSMClientTypes.AssociationStatus.write(value:to:))
        try writer["InstanceId"].write(value.instanceId)
        try writer["Name"].write(value.name)
    }
}

extension UpdateDocumentInput {

    static func write(value: UpdateDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attachments"].writeList(value.attachments, memberWritingClosure: SSMClientTypes.AttachmentsSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Content"].write(value.content)
        try writer["DisplayName"].write(value.displayName)
        try writer["DocumentFormat"].write(value.documentFormat)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Name"].write(value.name)
        try writer["TargetType"].write(value.targetType)
        try writer["VersionName"].write(value.versionName)
    }
}

extension UpdateDocumentDefaultVersionInput {

    static func write(value: UpdateDocumentDefaultVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Name"].write(value.name)
    }
}

extension UpdateDocumentMetadataInput {

    static func write(value: UpdateDocumentMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentReviews"].write(value.documentReviews, with: SSMClientTypes.DocumentReviews.write(value:to:))
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Name"].write(value.name)
    }
}

extension UpdateMaintenanceWindowInput {

    static func write(value: UpdateMaintenanceWindowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowUnassociatedTargets"].write(value.allowUnassociatedTargets)
        try writer["Cutoff"].write(value.cutoff)
        try writer["Description"].write(value.description)
        try writer["Duration"].write(value.duration)
        try writer["Enabled"].write(value.enabled)
        try writer["EndDate"].write(value.endDate)
        try writer["Name"].write(value.name)
        try writer["Replace"].write(value.replace)
        try writer["Schedule"].write(value.schedule)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["ScheduleTimezone"].write(value.scheduleTimezone)
        try writer["StartDate"].write(value.startDate)
        try writer["WindowId"].write(value.windowId)
    }
}

extension UpdateMaintenanceWindowTargetInput {

    static func write(value: UpdateMaintenanceWindowTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["OwnerInformation"].write(value.ownerInformation)
        try writer["Replace"].write(value.replace)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WindowId"].write(value.windowId)
        try writer["WindowTargetId"].write(value.windowTargetId)
    }
}

extension UpdateMaintenanceWindowTaskInput {

    static func write(value: UpdateMaintenanceWindowTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["CutoffBehavior"].write(value.cutoffBehavior)
        try writer["Description"].write(value.description)
        try writer["LoggingInfo"].write(value.loggingInfo, with: SSMClientTypes.LoggingInfo.write(value:to:))
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Name"].write(value.name)
        try writer["Priority"].write(value.priority)
        try writer["Replace"].write(value.replace)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskArn"].write(value.taskArn)
        try writer["TaskInvocationParameters"].write(value.taskInvocationParameters, with: SSMClientTypes.MaintenanceWindowTaskInvocationParameters.write(value:to:))
        try writer["TaskParameters"].writeMap(value.taskParameters, valueWritingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WindowId"].write(value.windowId)
        try writer["WindowTaskId"].write(value.windowTaskId)
    }
}

extension UpdateManagedInstanceRoleInput {

    static func write(value: UpdateManagedInstanceRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamRole"].write(value.iamRole)
        try writer["InstanceId"].write(value.instanceId)
    }
}

extension UpdateOpsItemInput {

    static func write(value: UpdateOpsItemInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActualEndTime"].writeTimestamp(value.actualEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ActualStartTime"].writeTimestamp(value.actualStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Category"].write(value.category)
        try writer["Description"].write(value.description)
        try writer["Notifications"].writeList(value.notifications, memberWritingClosure: SSMClientTypes.OpsItemNotification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OperationalData"].writeMap(value.operationalData, valueWritingClosure: SSMClientTypes.OpsItemDataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OperationalDataToDelete"].writeList(value.operationalDataToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OpsItemArn"].write(value.opsItemArn)
        try writer["OpsItemId"].write(value.opsItemId)
        try writer["PlannedEndTime"].writeTimestamp(value.plannedEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["PlannedStartTime"].writeTimestamp(value.plannedStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Priority"].write(value.priority)
        try writer["RelatedOpsItems"].writeList(value.relatedOpsItems, memberWritingClosure: SSMClientTypes.RelatedOpsItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severity"].write(value.severity)
        try writer["Status"].write(value.status)
        try writer["Title"].write(value.title)
    }
}

extension UpdateOpsMetadataInput {

    static func write(value: UpdateOpsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeysToDelete"].writeList(value.keysToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetadataToUpdate"].writeMap(value.metadataToUpdate, valueWritingClosure: SSMClientTypes.MetadataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["OpsMetadataArn"].write(value.opsMetadataArn)
    }
}

extension UpdatePatchBaselineInput {

    static func write(value: UpdatePatchBaselineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApprovalRules"].write(value.approvalRules, with: SSMClientTypes.PatchRuleGroup.write(value:to:))
        try writer["ApprovedPatches"].writeList(value.approvedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApprovedPatchesComplianceLevel"].write(value.approvedPatchesComplianceLevel)
        try writer["ApprovedPatchesEnableNonSecurity"].write(value.approvedPatchesEnableNonSecurity)
        try writer["BaselineId"].write(value.baselineId)
        try writer["Description"].write(value.description)
        try writer["GlobalFilters"].write(value.globalFilters, with: SSMClientTypes.PatchFilterGroup.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RejectedPatches"].writeList(value.rejectedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RejectedPatchesAction"].write(value.rejectedPatchesAction)
        try writer["Replace"].write(value.replace)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: SSMClientTypes.PatchSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResourceDataSyncInput {

    static func write(value: UpdateResourceDataSyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SyncName"].write(value.syncName)
        try writer["SyncSource"].write(value.syncSource, with: SSMClientTypes.ResourceDataSyncSource.write(value:to:))
        try writer["SyncType"].write(value.syncType)
    }
}

extension UpdateServiceSettingInput {

    static func write(value: UpdateServiceSettingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SettingId"].write(value.settingId)
        try writer["SettingValue"].write(value.settingValue)
    }
}

extension AddTagsToResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsToResourceOutput {
        return AddTagsToResourceOutput()
    }
}

extension AssociateOpsItemRelatedItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateOpsItemRelatedItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateOpsItemRelatedItemOutput()
        value.associationId = try reader["AssociationId"].readIfPresent()
        return value
    }
}

extension CancelCommandOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelCommandOutput {
        return CancelCommandOutput()
    }
}

extension CancelMaintenanceWindowExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMaintenanceWindowExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMaintenanceWindowExecutionOutput()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        return value
    }
}

extension CreateActivationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateActivationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateActivationOutput()
        value.activationCode = try reader["ActivationCode"].readIfPresent()
        value.activationId = try reader["ActivationId"].readIfPresent()
        return value
    }
}

extension CreateAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssociationOutput()
        value.associationDescription = try reader["AssociationDescription"].readIfPresent(with: SSMClientTypes.AssociationDescription.read(from:))
        return value
    }
}

extension CreateAssociationBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssociationBatchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssociationBatchOutput()
        value.failed = try reader["Failed"].readListIfPresent(memberReadingClosure: SSMClientTypes.FailedCreateAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successful = try reader["Successful"].readListIfPresent(memberReadingClosure: SSMClientTypes.AssociationDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDocumentOutput()
        value.documentDescription = try reader["DocumentDescription"].readIfPresent(with: SSMClientTypes.DocumentDescription.read(from:))
        return value
    }
}

extension CreateMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMaintenanceWindowOutput()
        value.windowId = try reader["WindowId"].readIfPresent()
        return value
    }
}

extension CreateOpsItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOpsItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOpsItemOutput()
        value.opsItemArn = try reader["OpsItemArn"].readIfPresent()
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        return value
    }
}

extension CreateOpsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOpsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOpsMetadataOutput()
        value.opsMetadataArn = try reader["OpsMetadataArn"].readIfPresent()
        return value
    }
}

extension CreatePatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePatchBaselineOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        return value
    }
}

extension CreateResourceDataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceDataSyncOutput {
        return CreateResourceDataSyncOutput()
    }
}

extension DeleteActivationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteActivationOutput {
        return DeleteActivationOutput()
    }
}

extension DeleteAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssociationOutput {
        return DeleteAssociationOutput()
    }
}

extension DeleteDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDocumentOutput {
        return DeleteDocumentOutput()
    }
}

extension DeleteInventoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInventoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInventoryOutput()
        value.deletionId = try reader["DeletionId"].readIfPresent()
        value.deletionSummary = try reader["DeletionSummary"].readIfPresent(with: SSMClientTypes.InventoryDeletionSummary.read(from:))
        value.typeName = try reader["TypeName"].readIfPresent()
        return value
    }
}

extension DeleteMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMaintenanceWindowOutput()
        value.windowId = try reader["WindowId"].readIfPresent()
        return value
    }
}

extension DeleteOpsItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOpsItemOutput {
        return DeleteOpsItemOutput()
    }
}

extension DeleteOpsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOpsMetadataOutput {
        return DeleteOpsMetadataOutput()
    }
}

extension DeleteParameterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteParameterOutput {
        return DeleteParameterOutput()
    }
}

extension DeleteParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteParametersOutput()
        value.deletedParameters = try reader["DeletedParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.invalidParameters = try reader["InvalidParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeletePatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePatchBaselineOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        return value
    }
}

extension DeleteResourceDataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceDataSyncOutput {
        return DeleteResourceDataSyncOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeregisterManagedInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterManagedInstanceOutput {
        return DeregisterManagedInstanceOutput()
    }
}

extension DeregisterPatchBaselineForPatchGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterPatchBaselineForPatchGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterPatchBaselineForPatchGroupOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.patchGroup = try reader["PatchGroup"].readIfPresent()
        return value
    }
}

extension DeregisterTargetFromMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterTargetFromMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTargetFromMaintenanceWindowOutput()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        return value
    }
}

extension DeregisterTaskFromMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterTaskFromMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTaskFromMaintenanceWindowOutput()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTaskId = try reader["WindowTaskId"].readIfPresent()
        return value
    }
}

extension DescribeActivationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeActivationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeActivationsOutput()
        value.activationList = try reader["ActivationList"].readListIfPresent(memberReadingClosure: SSMClientTypes.Activation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssociationOutput()
        value.associationDescription = try reader["AssociationDescription"].readIfPresent(with: SSMClientTypes.AssociationDescription.read(from:))
        return value
    }
}

extension DescribeAssociationExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssociationExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssociationExecutionsOutput()
        value.associationExecutions = try reader["AssociationExecutions"].readListIfPresent(memberReadingClosure: SSMClientTypes.AssociationExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAssociationExecutionTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssociationExecutionTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssociationExecutionTargetsOutput()
        value.associationExecutionTargets = try reader["AssociationExecutionTargets"].readListIfPresent(memberReadingClosure: SSMClientTypes.AssociationExecutionTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAutomationExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAutomationExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAutomationExecutionsOutput()
        value.automationExecutionMetadataList = try reader["AutomationExecutionMetadataList"].readListIfPresent(memberReadingClosure: SSMClientTypes.AutomationExecutionMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAutomationStepExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAutomationStepExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAutomationStepExecutionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.stepExecutions = try reader["StepExecutions"].readListIfPresent(memberReadingClosure: SSMClientTypes.StepExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeAvailablePatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAvailablePatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAvailablePatchesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.patches = try reader["Patches"].readListIfPresent(memberReadingClosure: SSMClientTypes.Patch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDocumentOutput()
        value.document = try reader["Document"].readIfPresent(with: SSMClientTypes.DocumentDescription.read(from:))
        return value
    }
}

extension DescribeDocumentPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDocumentPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDocumentPermissionOutput()
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountSharingInfoList = try reader["AccountSharingInfoList"].readListIfPresent(memberReadingClosure: SSMClientTypes.AccountSharingInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEffectiveInstanceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEffectiveInstanceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEffectiveInstanceAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstanceAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeEffectivePatchesForPatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEffectivePatchesForPatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEffectivePatchesForPatchBaselineOutput()
        value.effectivePatches = try reader["EffectivePatches"].readListIfPresent(memberReadingClosure: SSMClientTypes.EffectivePatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstanceAssociationsStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceAssociationsStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceAssociationsStatusOutput()
        value.instanceAssociationStatusInfos = try reader["InstanceAssociationStatusInfos"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstanceAssociationStatusInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstanceInformationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceInformationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceInformationOutput()
        value.instanceInformationList = try reader["InstanceInformationList"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstanceInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstancePatchesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstancePatchesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstancePatchesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.patches = try reader["Patches"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchComplianceData.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeInstancePatchStatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstancePatchStatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstancePatchStatesOutput()
        value.instancePatchStates = try reader["InstancePatchStates"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstancePatchState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstancePatchStatesForPatchGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstancePatchStatesForPatchGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstancePatchStatesForPatchGroupOutput()
        value.instancePatchStates = try reader["InstancePatchStates"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstancePatchState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstancePropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstancePropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstancePropertiesOutput()
        value.instanceProperties = try reader["InstanceProperties"].readListIfPresent(memberReadingClosure: SSMClientTypes.InstanceProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInventoryDeletionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInventoryDeletionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInventoryDeletionsOutput()
        value.inventoryDeletions = try reader["InventoryDeletions"].readListIfPresent(memberReadingClosure: SSMClientTypes.InventoryDeletionStatusItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeMaintenanceWindowExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowExecutionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.windowExecutions = try reader["WindowExecutions"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowExecutionTaskInvocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowExecutionTaskInvocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowExecutionTaskInvocationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.windowExecutionTaskInvocationIdentities = try reader["WindowExecutionTaskInvocationIdentities"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowExecutionTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowExecutionTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowExecutionTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.windowExecutionTaskIdentities = try reader["WindowExecutionTaskIdentities"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowExecutionTaskIdentity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.windowIdentities = try reader["WindowIdentities"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowIdentity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowScheduleOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.scheduledWindowExecutions = try reader["ScheduledWindowExecutions"].readListIfPresent(memberReadingClosure: SSMClientTypes.ScheduledWindowExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowsForTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowsForTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowsForTargetOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.windowIdentities = try reader["WindowIdentities"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowIdentityForTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowTargetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeMaintenanceWindowTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMaintenanceWindowTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMaintenanceWindowTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tasks = try reader["Tasks"].readListIfPresent(memberReadingClosure: SSMClientTypes.MaintenanceWindowTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOpsItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOpsItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOpsItemsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.opsItemSummaries = try reader["OpsItemSummaries"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsItemSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeParametersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: SSMClientTypes.ParameterMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePatchBaselinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePatchBaselinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePatchBaselinesOutput()
        value.baselineIdentities = try reader["BaselineIdentities"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchBaselineIdentity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribePatchGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePatchGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePatchGroupsOutput()
        value.mappings = try reader["Mappings"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchGroupPatchBaselineMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribePatchGroupStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePatchGroupStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePatchGroupStateOutput()
        value.instances = try reader["Instances"].readIfPresent() ?? 0
        value.instancesWithCriticalNonCompliantPatches = try reader["InstancesWithCriticalNonCompliantPatches"].readIfPresent()
        value.instancesWithFailedPatches = try reader["InstancesWithFailedPatches"].readIfPresent() ?? 0
        value.instancesWithInstalledOtherPatches = try reader["InstancesWithInstalledOtherPatches"].readIfPresent() ?? 0
        value.instancesWithInstalledPatches = try reader["InstancesWithInstalledPatches"].readIfPresent() ?? 0
        value.instancesWithInstalledPendingRebootPatches = try reader["InstancesWithInstalledPendingRebootPatches"].readIfPresent()
        value.instancesWithInstalledRejectedPatches = try reader["InstancesWithInstalledRejectedPatches"].readIfPresent()
        value.instancesWithMissingPatches = try reader["InstancesWithMissingPatches"].readIfPresent() ?? 0
        value.instancesWithNotApplicablePatches = try reader["InstancesWithNotApplicablePatches"].readIfPresent() ?? 0
        value.instancesWithOtherNonCompliantPatches = try reader["InstancesWithOtherNonCompliantPatches"].readIfPresent()
        value.instancesWithSecurityNonCompliantPatches = try reader["InstancesWithSecurityNonCompliantPatches"].readIfPresent()
        value.instancesWithUnreportedNotApplicablePatches = try reader["InstancesWithUnreportedNotApplicablePatches"].readIfPresent()
        return value
    }
}

extension DescribePatchPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePatchPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePatchPropertiesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: SSMClientTypes.Session.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateOpsItemRelatedItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateOpsItemRelatedItemOutput {
        return DisassociateOpsItemRelatedItemOutput()
    }
}

extension GetAutomationExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutomationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutomationExecutionOutput()
        value.automationExecution = try reader["AutomationExecution"].readIfPresent(with: SSMClientTypes.AutomationExecution.read(from:))
        return value
    }
}

extension GetCalendarStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCalendarStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCalendarStateOutput()
        value.atTime = try reader["AtTime"].readIfPresent()
        value.nextTransitionTime = try reader["NextTransitionTime"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension GetCommandInvocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCommandInvocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCommandInvocationOutput()
        value.cloudWatchOutputConfig = try reader["CloudWatchOutputConfig"].readIfPresent(with: SSMClientTypes.CloudWatchOutputConfig.read(from:))
        value.commandId = try reader["CommandId"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.executionElapsedTime = try reader["ExecutionElapsedTime"].readIfPresent()
        value.executionEndDateTime = try reader["ExecutionEndDateTime"].readIfPresent()
        value.executionStartDateTime = try reader["ExecutionStartDateTime"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.pluginName = try reader["PluginName"].readIfPresent()
        value.responseCode = try reader["ResponseCode"].readIfPresent() ?? 0
        value.standardErrorContent = try reader["StandardErrorContent"].readIfPresent()
        value.standardErrorUrl = try reader["StandardErrorUrl"].readIfPresent()
        value.standardOutputContent = try reader["StandardOutputContent"].readIfPresent()
        value.standardOutputUrl = try reader["StandardOutputUrl"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        return value
    }
}

extension GetConnectionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionStatusOutput()
        value.status = try reader["Status"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        return value
    }
}

extension GetDefaultPatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultPatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultPatchBaselineOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        return value
    }
}

extension GetDeployablePatchSnapshotForInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeployablePatchSnapshotForInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeployablePatchSnapshotForInstanceOutput()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.product = try reader["Product"].readIfPresent()
        value.snapshotDownloadUrl = try reader["SnapshotDownloadUrl"].readIfPresent()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        return value
    }
}

extension GetDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentOutput()
        value.attachmentsContent = try reader["AttachmentsContent"].readListIfPresent(memberReadingClosure: SSMClientTypes.AttachmentContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.content = try reader["Content"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.documentFormat = try reader["DocumentFormat"].readIfPresent()
        value.documentType = try reader["DocumentType"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.requires = try reader["Requires"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentRequires.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusInformation = try reader["StatusInformation"].readIfPresent()
        value.versionName = try reader["VersionName"].readIfPresent()
        return value
    }
}

extension GetInventoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInventoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInventoryOutput()
        value.entities = try reader["Entities"].readListIfPresent(memberReadingClosure: SSMClientTypes.InventoryResultEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetInventorySchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInventorySchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInventorySchemaOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemas = try reader["Schemas"].readListIfPresent(memberReadingClosure: SSMClientTypes.InventoryItemSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMaintenanceWindowOutput()
        value.allowUnassociatedTargets = try reader["AllowUnassociatedTargets"].readIfPresent() ?? false
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cutoff = try reader["Cutoff"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.endDate = try reader["EndDate"].readIfPresent()
        value.modifiedDate = try reader["ModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.nextExecutionTime = try reader["NextExecutionTime"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent()
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.scheduleTimezone = try reader["ScheduleTimezone"].readIfPresent()
        value.startDate = try reader["StartDate"].readIfPresent()
        value.windowId = try reader["WindowId"].readIfPresent()
        return value
    }
}

extension GetMaintenanceWindowExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMaintenanceWindowExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMaintenanceWindowExecutionOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.taskIds = try reader["TaskIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        return value
    }
}

extension GetMaintenanceWindowExecutionTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMaintenanceWindowExecutionTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMaintenanceWindowExecutionTaskOutput()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskExecutionId = try reader["TaskExecutionId"].readIfPresent()
        value.taskParameters = try reader["TaskParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        return value
    }
}

extension GetMaintenanceWindowExecutionTaskInvocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMaintenanceWindowExecutionTaskInvocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMaintenanceWindowExecutionTaskInvocationOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.invocationId = try reader["InvocationId"].readIfPresent()
        value.ownerInformation = try reader["OwnerInformation"].readIfPresent()
        value.parameters = try reader["Parameters"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.taskExecutionId = try reader["TaskExecutionId"].readIfPresent()
        value.taskType = try reader["TaskType"].readIfPresent()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        return value
    }
}

extension GetMaintenanceWindowTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMaintenanceWindowTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMaintenanceWindowTaskOutput()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.cutoffBehavior = try reader["CutoffBehavior"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.loggingInfo = try reader["LoggingInfo"].readIfPresent(with: SSMClientTypes.LoggingInfo.read(from:))
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskInvocationParameters = try reader["TaskInvocationParameters"].readIfPresent(with: SSMClientTypes.MaintenanceWindowTaskInvocationParameters.read(from:))
        value.taskParameters = try reader["TaskParameters"].readMapIfPresent(valueReadingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.taskType = try reader["TaskType"].readIfPresent()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTaskId = try reader["WindowTaskId"].readIfPresent()
        return value
    }
}

extension GetOpsItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpsItemOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOpsItemOutput()
        value.opsItem = try reader["OpsItem"].readIfPresent(with: SSMClientTypes.OpsItem.read(from:))
        return value
    }
}

extension GetOpsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOpsMetadataOutput()
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SSMClientTypes.MetadataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        return value
    }
}

extension GetOpsSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpsSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOpsSummaryOutput()
        value.entities = try reader["Entities"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetParameterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetParameterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParameterOutput()
        value.parameter = try reader["Parameter"].readIfPresent(with: SSMClientTypes.Parameter.read(from:))
        return value
    }
}

extension GetParameterHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetParameterHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParameterHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: SSMClientTypes.ParameterHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParametersOutput()
        value.invalidParameters = try reader["InvalidParameters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: SSMClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetParametersByPathOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetParametersByPathOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParametersByPathOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: SSMClientTypes.Parameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPatchBaselineOutput()
        value.approvalRules = try reader["ApprovalRules"].readIfPresent(with: SSMClientTypes.PatchRuleGroup.read(from:))
        value.approvedPatches = try reader["ApprovedPatches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.approvedPatchesComplianceLevel = try reader["ApprovedPatchesComplianceLevel"].readIfPresent()
        value.approvedPatchesEnableNonSecurity = try reader["ApprovedPatchesEnableNonSecurity"].readIfPresent()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.globalFilters = try reader["GlobalFilters"].readIfPresent(with: SSMClientTypes.PatchFilterGroup.read(from:))
        value.modifiedDate = try reader["ModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        value.patchGroups = try reader["PatchGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rejectedPatches = try reader["RejectedPatches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rejectedPatchesAction = try reader["RejectedPatchesAction"].readIfPresent()
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPatchBaselineForPatchGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPatchBaselineForPatchGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPatchBaselineForPatchGroupOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        value.patchGroup = try reader["PatchGroup"].readIfPresent()
        return value
    }
}

extension GetResourcePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: SSMClientTypes.GetResourcePoliciesResponseEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetServiceSettingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceSettingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceSettingOutput()
        value.serviceSetting = try reader["ServiceSetting"].readIfPresent(with: SSMClientTypes.ServiceSetting.read(from:))
        return value
    }
}

extension LabelParameterVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LabelParameterVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = LabelParameterVersionOutput()
        value.invalidLabels = try reader["InvalidLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterVersion = try reader["ParameterVersion"].readIfPresent() ?? 0
        return value
    }
}

extension ListAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociationsOutput()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: SSMClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAssociationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociationVersionsOutput()
        value.associationVersions = try reader["AssociationVersions"].readListIfPresent(memberReadingClosure: SSMClientTypes.AssociationVersionInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCommandInvocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCommandInvocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCommandInvocationsOutput()
        value.commandInvocations = try reader["CommandInvocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.CommandInvocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCommandsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCommandsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCommandsOutput()
        value.commands = try reader["Commands"].readListIfPresent(memberReadingClosure: SSMClientTypes.Command.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListComplianceItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComplianceItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComplianceItemsOutput()
        value.complianceItems = try reader["ComplianceItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.ComplianceItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListComplianceSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComplianceSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComplianceSummariesOutput()
        value.complianceSummaryItems = try reader["ComplianceSummaryItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.ComplianceSummaryItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDocumentMetadataHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDocumentMetadataHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDocumentMetadataHistoryOutput()
        value.author = try reader["Author"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent(with: SSMClientTypes.DocumentMetadataResponseInfo.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDocumentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDocumentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDocumentsOutput()
        value.documentIdentifiers = try reader["DocumentIdentifiers"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDocumentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDocumentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDocumentVersionsOutput()
        value.documentVersions = try reader["DocumentVersions"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentVersionInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInventoryEntriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInventoryEntriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInventoryEntriesOutput()
        value.captureTime = try reader["CaptureTime"].readIfPresent()
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.typeName = try reader["TypeName"].readIfPresent()
        return value
    }
}

extension ListOpsItemEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpsItemEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpsItemEventsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.summaries = try reader["Summaries"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsItemEventSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOpsItemRelatedItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpsItemRelatedItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpsItemRelatedItemsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.summaries = try reader["Summaries"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsItemRelatedItemSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOpsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpsMetadataOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.opsMetadataList = try reader["OpsMetadataList"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceComplianceSummariesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceComplianceSummariesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceComplianceSummariesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceComplianceSummaryItems = try reader["ResourceComplianceSummaryItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.ResourceComplianceSummaryItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceDataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceDataSyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDataSyncOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceDataSyncItems = try reader["ResourceDataSyncItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.ResourceDataSyncItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: SSMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ModifyDocumentPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ModifyDocumentPermissionOutput {
        return ModifyDocumentPermissionOutput()
    }
}

extension PutComplianceItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutComplianceItemsOutput {
        return PutComplianceItemsOutput()
    }
}

extension PutInventoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInventoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutInventoryOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension PutParameterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutParameterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutParameterOutput()
        value.tier = try reader["Tier"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.policyHash = try reader["PolicyHash"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        return value
    }
}

extension RegisterDefaultPatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterDefaultPatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterDefaultPatchBaselineOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        return value
    }
}

extension RegisterPatchBaselineForPatchGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterPatchBaselineForPatchGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterPatchBaselineForPatchGroupOutput()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.patchGroup = try reader["PatchGroup"].readIfPresent()
        return value
    }
}

extension RegisterTargetWithMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterTargetWithMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTargetWithMaintenanceWindowOutput()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        return value
    }
}

extension RegisterTaskWithMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterTaskWithMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTaskWithMaintenanceWindowOutput()
        value.windowTaskId = try reader["WindowTaskId"].readIfPresent()
        return value
    }
}

extension RemoveTagsFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsFromResourceOutput {
        return RemoveTagsFromResourceOutput()
    }
}

extension ResetServiceSettingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetServiceSettingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetServiceSettingOutput()
        value.serviceSetting = try reader["ServiceSetting"].readIfPresent(with: SSMClientTypes.ServiceSetting.read(from:))
        return value
    }
}

extension ResumeSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResumeSessionOutput()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.streamUrl = try reader["StreamUrl"].readIfPresent()
        value.tokenValue = try reader["TokenValue"].readIfPresent()
        return value
    }
}

extension SendAutomationSignalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendAutomationSignalOutput {
        return SendAutomationSignalOutput()
    }
}

extension SendCommandOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendCommandOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendCommandOutput()
        value.command = try reader["Command"].readIfPresent(with: SSMClientTypes.Command.read(from:))
        return value
    }
}

extension StartAssociationsOnceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssociationsOnceOutput {
        return StartAssociationsOnceOutput()
    }
}

extension StartAutomationExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAutomationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAutomationExecutionOutput()
        value.automationExecutionId = try reader["AutomationExecutionId"].readIfPresent()
        return value
    }
}

extension StartChangeRequestExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartChangeRequestExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartChangeRequestExecutionOutput()
        value.automationExecutionId = try reader["AutomationExecutionId"].readIfPresent()
        return value
    }
}

extension StartSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSessionOutput()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.streamUrl = try reader["StreamUrl"].readIfPresent()
        value.tokenValue = try reader["TokenValue"].readIfPresent()
        return value
    }
}

extension StopAutomationExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAutomationExecutionOutput {
        return StopAutomationExecutionOutput()
    }
}

extension TerminateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateSessionOutput()
        value.sessionId = try reader["SessionId"].readIfPresent()
        return value
    }
}

extension UnlabelParameterVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnlabelParameterVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnlabelParameterVersionOutput()
        value.invalidLabels = try reader["InvalidLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.removedLabels = try reader["RemovedLabels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssociationOutput()
        value.associationDescription = try reader["AssociationDescription"].readIfPresent(with: SSMClientTypes.AssociationDescription.read(from:))
        return value
    }
}

extension UpdateAssociationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssociationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssociationStatusOutput()
        value.associationDescription = try reader["AssociationDescription"].readIfPresent(with: SSMClientTypes.AssociationDescription.read(from:))
        return value
    }
}

extension UpdateDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDocumentOutput()
        value.documentDescription = try reader["DocumentDescription"].readIfPresent(with: SSMClientTypes.DocumentDescription.read(from:))
        return value
    }
}

extension UpdateDocumentDefaultVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentDefaultVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDocumentDefaultVersionOutput()
        value.description = try reader["Description"].readIfPresent(with: SSMClientTypes.DocumentDefaultVersionDescription.read(from:))
        return value
    }
}

extension UpdateDocumentMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentMetadataOutput {
        return UpdateDocumentMetadataOutput()
    }
}

extension UpdateMaintenanceWindowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMaintenanceWindowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMaintenanceWindowOutput()
        value.allowUnassociatedTargets = try reader["AllowUnassociatedTargets"].readIfPresent() ?? false
        value.cutoff = try reader["Cutoff"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.endDate = try reader["EndDate"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.schedule = try reader["Schedule"].readIfPresent()
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.scheduleTimezone = try reader["ScheduleTimezone"].readIfPresent()
        value.startDate = try reader["StartDate"].readIfPresent()
        value.windowId = try reader["WindowId"].readIfPresent()
        return value
    }
}

extension UpdateMaintenanceWindowTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMaintenanceWindowTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMaintenanceWindowTargetOutput()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ownerInformation = try reader["OwnerInformation"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        return value
    }
}

extension UpdateMaintenanceWindowTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMaintenanceWindowTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMaintenanceWindowTaskOutput()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.cutoffBehavior = try reader["CutoffBehavior"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.loggingInfo = try reader["LoggingInfo"].readIfPresent(with: SSMClientTypes.LoggingInfo.read(from:))
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskInvocationParameters = try reader["TaskInvocationParameters"].readIfPresent(with: SSMClientTypes.MaintenanceWindowTaskInvocationParameters.read(from:))
        value.taskParameters = try reader["TaskParameters"].readMapIfPresent(valueReadingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTaskId = try reader["WindowTaskId"].readIfPresent()
        return value
    }
}

extension UpdateManagedInstanceRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateManagedInstanceRoleOutput {
        return UpdateManagedInstanceRoleOutput()
    }
}

extension UpdateOpsItemOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOpsItemOutput {
        return UpdateOpsItemOutput()
    }
}

extension UpdateOpsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOpsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOpsMetadataOutput()
        value.opsMetadataArn = try reader["OpsMetadataArn"].readIfPresent()
        return value
    }
}

extension UpdatePatchBaselineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePatchBaselineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePatchBaselineOutput()
        value.approvalRules = try reader["ApprovalRules"].readIfPresent(with: SSMClientTypes.PatchRuleGroup.read(from:))
        value.approvedPatches = try reader["ApprovedPatches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.approvedPatchesComplianceLevel = try reader["ApprovedPatchesComplianceLevel"].readIfPresent()
        value.approvedPatchesEnableNonSecurity = try reader["ApprovedPatchesEnableNonSecurity"].readIfPresent()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.globalFilters = try reader["GlobalFilters"].readIfPresent(with: SSMClientTypes.PatchFilterGroup.read(from:))
        value.modifiedDate = try reader["ModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        value.rejectedPatches = try reader["RejectedPatches"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rejectedPatchesAction = try reader["RejectedPatchesAction"].readIfPresent()
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateResourceDataSyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceDataSyncOutput {
        return UpdateResourceDataSyncOutput()
    }
}

extension UpdateServiceSettingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceSettingOutput {
        return UpdateServiceSettingOutput()
    }
}

enum AddTagsToResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "InvalidResourceType": return try InvalidResourceType.makeError(baseError: baseError)
            case "TooManyTagsError": return try TooManyTagsError.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateOpsItemRelatedItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemConflictException": return try OpsItemConflictException.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            case "OpsItemLimitExceededException": return try OpsItemLimitExceededException.makeError(baseError: baseError)
            case "OpsItemNotFoundException": return try OpsItemNotFoundException.makeError(baseError: baseError)
            case "OpsItemRelatedItemAlreadyExistsException": return try OpsItemRelatedItemAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelCommandOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateInstanceId": return try DuplicateInstanceId.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidCommandId": return try InvalidCommandId.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMaintenanceWindowExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateActivationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidParameters": return try InvalidParameters.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationAlreadyExists": return try AssociationAlreadyExists.makeError(baseError: baseError)
            case "AssociationLimitExceeded": return try AssociationLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidOutputLocation": return try InvalidOutputLocation.makeError(baseError: baseError)
            case "InvalidParameters": return try InvalidParameters.makeError(baseError: baseError)
            case "InvalidSchedule": return try InvalidSchedule.makeError(baseError: baseError)
            case "InvalidTag": return try InvalidTag.makeError(baseError: baseError)
            case "InvalidTarget": return try InvalidTarget.makeError(baseError: baseError)
            case "InvalidTargetMaps": return try InvalidTargetMaps.makeError(baseError: baseError)
            case "UnsupportedPlatformType": return try UnsupportedPlatformType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssociationBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationLimitExceeded": return try AssociationLimitExceeded.makeError(baseError: baseError)
            case "DuplicateInstanceId": return try DuplicateInstanceId.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidOutputLocation": return try InvalidOutputLocation.makeError(baseError: baseError)
            case "InvalidParameters": return try InvalidParameters.makeError(baseError: baseError)
            case "InvalidSchedule": return try InvalidSchedule.makeError(baseError: baseError)
            case "InvalidTarget": return try InvalidTarget.makeError(baseError: baseError)
            case "InvalidTargetMaps": return try InvalidTargetMaps.makeError(baseError: baseError)
            case "UnsupportedPlatformType": return try UnsupportedPlatformType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DocumentAlreadyExists": return try DocumentAlreadyExists.makeError(baseError: baseError)
            case "DocumentLimitExceeded": return try DocumentLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocumentContent": return try InvalidDocumentContent.makeError(baseError: baseError)
            case "InvalidDocumentSchemaVersion": return try InvalidDocumentSchemaVersion.makeError(baseError: baseError)
            case "MaxDocumentSizeExceeded": return try MaxDocumentSizeExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOpsItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemAccessDeniedException": return try OpsItemAccessDeniedException.makeError(baseError: baseError)
            case "OpsItemAlreadyExistsException": return try OpsItemAlreadyExistsException.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            case "OpsItemLimitExceededException": return try OpsItemLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOpsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsMetadataAlreadyExistsException": return try OpsMetadataAlreadyExistsException.makeError(baseError: baseError)
            case "OpsMetadataInvalidArgumentException": return try OpsMetadataInvalidArgumentException.makeError(baseError: baseError)
            case "OpsMetadataLimitExceededException": return try OpsMetadataLimitExceededException.makeError(baseError: baseError)
            case "OpsMetadataTooManyUpdatesException": return try OpsMetadataTooManyUpdatesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceDataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceDataSyncAlreadyExists": return try ResourceDataSyncAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceDataSyncCountExceeded": return try ResourceDataSyncCountExceededException.makeError(baseError: baseError)
            case "ResourceDataSyncInvalidConfiguration": return try ResourceDataSyncInvalidConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteActivationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidActivation": return try InvalidActivation.makeError(baseError: baseError)
            case "InvalidActivationId": return try InvalidActivationId.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociatedInstances": return try AssociatedInstances.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentOperation": return try InvalidDocumentOperation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInventoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDeleteInventoryParameters": return try InvalidDeleteInventoryParametersException.makeError(baseError: baseError)
            case "InvalidInventoryRequest": return try InvalidInventoryRequestException.makeError(baseError: baseError)
            case "InvalidOption": return try InvalidOptionException.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOpsItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOpsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsMetadataInvalidArgumentException": return try OpsMetadataInvalidArgumentException.makeError(baseError: baseError)
            case "OpsMetadataNotFoundException": return try OpsMetadataNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteParameterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ParameterNotFound": return try ParameterNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceDataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceDataSyncInvalidConfiguration": return try ResourceDataSyncInvalidConfigurationException.makeError(baseError: baseError)
            case "ResourceDataSyncNotFound": return try ResourceDataSyncNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "MalformedResourcePolicyDocumentException": return try MalformedResourcePolicyDocumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyConflictException": return try ResourcePolicyConflictException.makeError(baseError: baseError)
            case "ResourcePolicyInvalidParameterException": return try ResourcePolicyInvalidParameterException.makeError(baseError: baseError)
            case "ResourcePolicyNotFoundException": return try ResourcePolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterManagedInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterPatchBaselineForPatchGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterTargetFromMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "TargetInUseException": return try TargetInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterTaskFromMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeActivationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAssociationVersion": return try InvalidAssociationVersion.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssociationExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssociationExecutionTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "AssociationExecutionDoesNotExist": return try AssociationExecutionDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAutomationExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidFilterValue": return try InvalidFilterValue.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAutomationStepExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationExecutionNotFound": return try AutomationExecutionNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidFilterValue": return try InvalidFilterValue.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAvailablePatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDocumentPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentOperation": return try InvalidDocumentOperation.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidPermissionType": return try InvalidPermissionType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEffectiveInstanceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEffectivePatchesForPatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "UnsupportedOperatingSystem": return try UnsupportedOperatingSystem.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceAssociationsStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceInformationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidInstanceInformationFilterValue": return try InvalidInstanceInformationFilterValue.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstancePatchesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstancePatchStatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstancePatchStatesForPatchGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstancePropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidActivationId": return try InvalidActivationId.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidInstancePropertyFilterValue": return try InvalidInstancePropertyFilterValue.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInventoryDeletionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDeletionId": return try InvalidDeletionIdException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowExecutionTaskInvocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowExecutionTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowsForTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMaintenanceWindowTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOpsItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidFilterOption": return try InvalidFilterOption.makeError(baseError: baseError)
            case "InvalidFilterValue": return try InvalidFilterValue.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePatchBaselinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePatchGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePatchGroupStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePatchPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateOpsItemRelatedItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemConflictException": return try OpsItemConflictException.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            case "OpsItemNotFoundException": return try OpsItemNotFoundException.makeError(baseError: baseError)
            case "OpsItemRelatedItemAssociationNotFoundException": return try OpsItemRelatedItemAssociationNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutomationExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationExecutionNotFound": return try AutomationExecutionNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCalendarStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentType": return try InvalidDocumentType.makeError(baseError: baseError)
            case "UnsupportedCalendarException": return try UnsupportedCalendarException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCommandInvocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidCommandId": return try InvalidCommandId.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidPluginName": return try InvalidPluginName.makeError(baseError: baseError)
            case "InvocationDoesNotExist": return try InvocationDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultPatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeployablePatchSnapshotForInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "UnsupportedFeatureRequiredException": return try UnsupportedFeatureRequiredException.makeError(baseError: baseError)
            case "UnsupportedOperatingSystem": return try UnsupportedOperatingSystem.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInventoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAggregator": return try InvalidAggregatorException.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidInventoryGroup": return try InvalidInventoryGroupException.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidResultAttribute": return try InvalidResultAttributeException.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInventorySchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMaintenanceWindowExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMaintenanceWindowExecutionTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMaintenanceWindowExecutionTaskInvocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMaintenanceWindowTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpsItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemAccessDeniedException": return try OpsItemAccessDeniedException.makeError(baseError: baseError)
            case "OpsItemNotFoundException": return try OpsItemNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsMetadataInvalidArgumentException": return try OpsMetadataInvalidArgumentException.makeError(baseError: baseError)
            case "OpsMetadataNotFoundException": return try OpsMetadataNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpsSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAggregator": return try InvalidAggregatorException.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            case "ResourceDataSyncNotFound": return try ResourceDataSyncNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetParameterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidKeyId": return try InvalidKeyId.makeError(baseError: baseError)
            case "ParameterNotFound": return try ParameterNotFound.makeError(baseError: baseError)
            case "ParameterVersionNotFound": return try ParameterVersionNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetParameterHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidKeyId": return try InvalidKeyId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "ParameterNotFound": return try ParameterNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidKeyId": return try InvalidKeyId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetParametersByPathOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidFilterOption": return try InvalidFilterOption.makeError(baseError: baseError)
            case "InvalidFilterValue": return try InvalidFilterValue.makeError(baseError: baseError)
            case "InvalidKeyId": return try InvalidKeyId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPatchBaselineForPatchGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyInvalidParameterException": return try ResourcePolicyInvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceSettingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ServiceSettingNotFound": return try ServiceSettingNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LabelParameterVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ParameterNotFound": return try ParameterNotFound.makeError(baseError: baseError)
            case "ParameterVersionLabelLimitExceeded": return try ParameterVersionLabelLimitExceeded.makeError(baseError: baseError)
            case "ParameterVersionNotFound": return try ParameterVersionNotFound.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCommandInvocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidCommandId": return try InvalidCommandId.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCommandsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidCommandId": return try InvalidCommandId.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComplianceItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "InvalidResourceType": return try InvalidResourceType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComplianceSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDocumentMetadataHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDocumentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilterKey": return try InvalidFilterKey.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDocumentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInventoryEntriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpsItemEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            case "OpsItemLimitExceededException": return try OpsItemLimitExceededException.makeError(baseError: baseError)
            case "OpsItemNotFoundException": return try OpsItemNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpsItemRelatedItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsMetadataInvalidArgumentException": return try OpsMetadataInvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceComplianceSummariesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidFilter": return try InvalidFilter.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceDataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidNextToken": return try InvalidNextToken.makeError(baseError: baseError)
            case "ResourceDataSyncInvalidConfiguration": return try ResourceDataSyncInvalidConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "InvalidResourceType": return try InvalidResourceType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ModifyDocumentPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DocumentLimitExceeded": return try DocumentLimitExceeded.makeError(baseError: baseError)
            case "DocumentPermissionLimit": return try DocumentPermissionLimit.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidPermissionType": return try InvalidPermissionType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutComplianceItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ComplianceTypeCountLimitExceeded": return try ComplianceTypeCountLimitExceededException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidItemContent": return try InvalidItemContentException.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "InvalidResourceType": return try InvalidResourceType.makeError(baseError: baseError)
            case "ItemSizeLimitExceeded": return try ItemSizeLimitExceededException.makeError(baseError: baseError)
            case "TotalSizeLimitExceeded": return try TotalSizeLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInventoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CustomSchemaCountLimitExceeded": return try CustomSchemaCountLimitExceededException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidInventoryItemContext": return try InvalidInventoryItemContextException.makeError(baseError: baseError)
            case "InvalidItemContent": return try InvalidItemContentException.makeError(baseError: baseError)
            case "InvalidTypeName": return try InvalidTypeNameException.makeError(baseError: baseError)
            case "ItemContentMismatch": return try ItemContentMismatchException.makeError(baseError: baseError)
            case "ItemSizeLimitExceeded": return try ItemSizeLimitExceededException.makeError(baseError: baseError)
            case "SubTypeCountLimitExceeded": return try SubTypeCountLimitExceededException.makeError(baseError: baseError)
            case "TotalSizeLimitExceeded": return try TotalSizeLimitExceededException.makeError(baseError: baseError)
            case "UnsupportedInventoryItemContext": return try UnsupportedInventoryItemContextException.makeError(baseError: baseError)
            case "UnsupportedInventorySchemaVersion": return try UnsupportedInventorySchemaVersionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutParameterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "HierarchyLevelLimitExceededException": return try HierarchyLevelLimitExceededException.makeError(baseError: baseError)
            case "HierarchyTypeMismatchException": return try HierarchyTypeMismatchException.makeError(baseError: baseError)
            case "IncompatiblePolicyException": return try IncompatiblePolicyException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAllowedPatternException": return try InvalidAllowedPatternException.makeError(baseError: baseError)
            case "InvalidKeyId": return try InvalidKeyId.makeError(baseError: baseError)
            case "InvalidPolicyAttributeException": return try InvalidPolicyAttributeException.makeError(baseError: baseError)
            case "InvalidPolicyTypeException": return try InvalidPolicyTypeException.makeError(baseError: baseError)
            case "ParameterAlreadyExists": return try ParameterAlreadyExists.makeError(baseError: baseError)
            case "ParameterLimitExceeded": return try ParameterLimitExceeded.makeError(baseError: baseError)
            case "ParameterMaxVersionLimitExceeded": return try ParameterMaxVersionLimitExceeded.makeError(baseError: baseError)
            case "ParameterPatternMismatchException": return try ParameterPatternMismatchException.makeError(baseError: baseError)
            case "PoliciesLimitExceededException": return try PoliciesLimitExceededException.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            case "UnsupportedParameterType": return try UnsupportedParameterType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "MalformedResourcePolicyDocumentException": return try MalformedResourcePolicyDocumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePolicyConflictException": return try ResourcePolicyConflictException.makeError(baseError: baseError)
            case "ResourcePolicyInvalidParameterException": return try ResourcePolicyInvalidParameterException.makeError(baseError: baseError)
            case "ResourcePolicyLimitExceededException": return try ResourcePolicyLimitExceededException.makeError(baseError: baseError)
            case "ResourcePolicyNotFoundException": return try ResourcePolicyNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterDefaultPatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterPatchBaselineForPatchGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterTargetWithMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterTaskWithMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "FeatureNotAvailableException": return try FeatureNotAvailableException.makeError(baseError: baseError)
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidResourceId": return try InvalidResourceId.makeError(baseError: baseError)
            case "InvalidResourceType": return try InvalidResourceType.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetServiceSettingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ServiceSettingNotFound": return try ServiceSettingNotFound.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendAutomationSignalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationExecutionNotFound": return try AutomationExecutionNotFoundException.makeError(baseError: baseError)
            case "AutomationStepNotFoundException": return try AutomationStepNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAutomationSignalException": return try InvalidAutomationSignalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendCommandOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateInstanceId": return try DuplicateInstanceId.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "InvalidNotificationConfig": return try InvalidNotificationConfig.makeError(baseError: baseError)
            case "InvalidOutputFolder": return try InvalidOutputFolder.makeError(baseError: baseError)
            case "InvalidParameters": return try InvalidParameters.makeError(baseError: baseError)
            case "InvalidRole": return try InvalidRole.makeError(baseError: baseError)
            case "MaxDocumentSizeExceeded": return try MaxDocumentSizeExceeded.makeError(baseError: baseError)
            case "UnsupportedPlatformType": return try UnsupportedPlatformType.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssociationsOnceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InvalidAssociation": return try InvalidAssociation.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAutomationExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationDefinitionNotFound": return try AutomationDefinitionNotFoundException.makeError(baseError: baseError)
            case "AutomationDefinitionVersionNotFound": return try AutomationDefinitionVersionNotFoundException.makeError(baseError: baseError)
            case "AutomationExecutionLimitExceeded": return try AutomationExecutionLimitExceededException.makeError(baseError: baseError)
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAutomationExecutionParameters": return try InvalidAutomationExecutionParametersException.makeError(baseError: baseError)
            case "InvalidTarget": return try InvalidTarget.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartChangeRequestExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationDefinitionNotApproved": return try AutomationDefinitionNotApprovedException.makeError(baseError: baseError)
            case "AutomationDefinitionNotFound": return try AutomationDefinitionNotFoundException.makeError(baseError: baseError)
            case "AutomationDefinitionVersionNotFound": return try AutomationDefinitionVersionNotFoundException.makeError(baseError: baseError)
            case "AutomationExecutionLimitExceeded": return try AutomationExecutionLimitExceededException.makeError(baseError: baseError)
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAutomationExecutionParameters": return try InvalidAutomationExecutionParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "TargetNotConnected": return try TargetNotConnected.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAutomationExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AutomationExecutionNotFound": return try AutomationExecutionNotFoundException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAutomationStatusUpdateException": return try InvalidAutomationStatusUpdateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnlabelParameterVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ParameterNotFound": return try ParameterNotFound.makeError(baseError: baseError)
            case "ParameterVersionNotFound": return try ParameterVersionNotFound.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "AssociationVersionLimitExceeded": return try AssociationVersionLimitExceeded.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidAssociationVersion": return try InvalidAssociationVersion.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "InvalidOutputLocation": return try InvalidOutputLocation.makeError(baseError: baseError)
            case "InvalidParameters": return try InvalidParameters.makeError(baseError: baseError)
            case "InvalidSchedule": return try InvalidSchedule.makeError(baseError: baseError)
            case "InvalidTarget": return try InvalidTarget.makeError(baseError: baseError)
            case "InvalidTargetMaps": return try InvalidTargetMaps.makeError(baseError: baseError)
            case "InvalidUpdate": return try InvalidUpdate.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssociationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AssociationDoesNotExist": return try AssociationDoesNotExist.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            case "StatusUnchanged": return try StatusUnchanged.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DocumentVersionLimitExceeded": return try DocumentVersionLimitExceeded.makeError(baseError: baseError)
            case "DuplicateDocumentContent": return try DuplicateDocumentContent.makeError(baseError: baseError)
            case "DuplicateDocumentVersionName": return try DuplicateDocumentVersionName.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentContent": return try InvalidDocumentContent.makeError(baseError: baseError)
            case "InvalidDocumentOperation": return try InvalidDocumentOperation.makeError(baseError: baseError)
            case "InvalidDocumentSchemaVersion": return try InvalidDocumentSchemaVersion.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            case "MaxDocumentSizeExceeded": return try MaxDocumentSizeExceeded.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentDefaultVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentSchemaVersion": return try InvalidDocumentSchemaVersion.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidDocument": return try InvalidDocument.makeError(baseError: baseError)
            case "InvalidDocumentOperation": return try InvalidDocumentOperation.makeError(baseError: baseError)
            case "InvalidDocumentVersion": return try InvalidDocumentVersion.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMaintenanceWindowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMaintenanceWindowTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMaintenanceWindowTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateManagedInstanceRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "InvalidInstanceId": return try InvalidInstanceId.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOpsItemOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsItemAccessDeniedException": return try OpsItemAccessDeniedException.makeError(baseError: baseError)
            case "OpsItemAlreadyExistsException": return try OpsItemAlreadyExistsException.makeError(baseError: baseError)
            case "OpsItemConflictException": return try OpsItemConflictException.makeError(baseError: baseError)
            case "OpsItemInvalidParameterException": return try OpsItemInvalidParameterException.makeError(baseError: baseError)
            case "OpsItemLimitExceededException": return try OpsItemLimitExceededException.makeError(baseError: baseError)
            case "OpsItemNotFoundException": return try OpsItemNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOpsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "OpsMetadataInvalidArgumentException": return try OpsMetadataInvalidArgumentException.makeError(baseError: baseError)
            case "OpsMetadataKeyLimitExceededException": return try OpsMetadataKeyLimitExceededException.makeError(baseError: baseError)
            case "OpsMetadataNotFoundException": return try OpsMetadataNotFoundException.makeError(baseError: baseError)
            case "OpsMetadataTooManyUpdatesException": return try OpsMetadataTooManyUpdatesException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePatchBaselineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DoesNotExistException": return try DoesNotExistException.makeError(baseError: baseError)
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceDataSyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ResourceDataSyncConflictException": return try ResourceDataSyncConflictException.makeError(baseError: baseError)
            case "ResourceDataSyncInvalidConfiguration": return try ResourceDataSyncInvalidConfigurationException.makeError(baseError: baseError)
            case "ResourceDataSyncNotFound": return try ResourceDataSyncNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceSettingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerError": return try InternalServerError.makeError(baseError: baseError)
            case "ServiceSettingNotFound": return try ServiceSettingNotFound.makeError(baseError: baseError)
            case "TooManyUpdates": return try TooManyUpdates.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyUpdates {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyUpdates {
        let reader = baseError.errorBodyReader
        var value = TooManyUpdates()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceId {
        var value = InvalidResourceId()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerError {
        let reader = baseError.errorBodyReader
        var value = InternalServerError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsError {
        var value = TooManyTagsError()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceType {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceType {
        var value = InvalidResourceType()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemNotFoundException {
        let reader = baseError.errorBodyReader
        var value = OpsItemNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemRelatedItemAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemRelatedItemAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = OpsItemRelatedItemAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.properties.resourceUri = try reader["ResourceUri"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = OpsItemLimitExceededException()
        value.properties.limit = try reader["Limit"].readIfPresent() ?? 0
        value.properties.limitType = try reader["LimitType"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemInvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemInvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = OpsItemInvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.parameterNames = try reader["ParameterNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemConflictException {
        let reader = baseError.errorBodyReader
        var value = OpsItemConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInstanceId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInstanceId {
        let reader = baseError.errorBodyReader
        var value = InvalidInstanceId()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCommandId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCommandId {
        var value = InvalidCommandId()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateInstanceId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateInstanceId {
        var value = DuplicateInstanceId()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DoesNotExistException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DoesNotExistException {
        let reader = baseError.errorBodyReader
        var value = DoesNotExistException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameters {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameters {
        let reader = baseError.errorBodyReader
        var value = InvalidParameters()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTarget {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTarget {
        let reader = baseError.errorBodyReader
        var value = InvalidTarget()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedPlatformType {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedPlatformType {
        let reader = baseError.errorBodyReader
        var value = UnsupportedPlatformType()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociationLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociationLimitExceeded {
        var value = AssociationLimitExceeded()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSchedule {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSchedule {
        let reader = baseError.errorBodyReader
        var value = InvalidSchedule()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocumentVersion {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocumentVersion {
        let reader = baseError.errorBodyReader
        var value = InvalidDocumentVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTargetMaps {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTargetMaps {
        let reader = baseError.errorBodyReader
        var value = InvalidTargetMaps()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocument {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocument {
        let reader = baseError.errorBodyReader
        var value = InvalidDocument()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTag {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTag {
        let reader = baseError.errorBodyReader
        var value = InvalidTag()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociationAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociationAlreadyExists {
        var value = AssociationAlreadyExists()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOutputLocation {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOutputLocation {
        var value = InvalidOutputLocation()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DocumentLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DocumentLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = DocumentLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocumentContent {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocumentContent {
        let reader = baseError.errorBodyReader
        var value = InvalidDocumentContent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxDocumentSizeExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxDocumentSizeExceeded {
        let reader = baseError.errorBodyReader
        var value = MaxDocumentSizeExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocumentSchemaVersion {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocumentSchemaVersion {
        let reader = baseError.errorBodyReader
        var value = InvalidDocumentSchemaVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DocumentAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DocumentAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = DocumentAlreadyExists()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatch {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotentParameterMismatch {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatch()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = OpsItemAccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = OpsItemAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataInvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataInvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataInvalidArgumentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataTooManyUpdatesException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataTooManyUpdatesException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataTooManyUpdatesException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDataSyncInvalidConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceDataSyncInvalidConfigurationException {
        let reader = baseError.errorBodyReader
        var value = ResourceDataSyncInvalidConfigurationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDataSyncAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceDataSyncAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceDataSyncAlreadyExistsException()
        value.properties.syncName = try reader["SyncName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDataSyncCountExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceDataSyncCountExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceDataSyncCountExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidActivationId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidActivationId {
        let reader = baseError.errorBodyReader
        var value = InvalidActivationId()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidActivation {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidActivation {
        let reader = baseError.errorBodyReader
        var value = InvalidActivation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociationDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociationDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = AssociationDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociatedInstances {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociatedInstances {
        var value = AssociatedInstances()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocumentOperation {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocumentOperation {
        let reader = baseError.errorBodyReader
        var value = InvalidDocumentOperation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInventoryRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInventoryRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidInventoryRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOptionException {
        let reader = baseError.errorBodyReader
        var value = InvalidOptionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDeleteInventoryParametersException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDeleteInventoryParametersException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeleteInventoryParametersException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTypeNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTypeNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidTypeNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataNotFoundException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterNotFound {
        let reader = baseError.errorBodyReader
        var value = ParameterNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDataSyncNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceDataSyncNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceDataSyncNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.syncName = try reader["SyncName"].readIfPresent()
        value.properties.syncType = try reader["SyncType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyInvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyInvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyInvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.parameterNames = try reader["ParameterNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MalformedResourcePolicyDocumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MalformedResourcePolicyDocumentException {
        let reader = baseError.errorBodyReader
        var value = MalformedResourcePolicyDocumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TargetInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TargetInUseException {
        let reader = baseError.errorBodyReader
        var value = TargetInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFilter {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFilter {
        let reader = baseError.errorBodyReader
        var value = InvalidFilter()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextToken {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextToken {
        let reader = baseError.errorBodyReader
        var value = InvalidNextToken()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAssociationVersion {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAssociationVersion {
        let reader = baseError.errorBodyReader
        var value = InvalidAssociationVersion()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociationExecutionDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociationExecutionDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = AssociationExecutionDoesNotExist()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFilterKey {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFilterKey {
        var value = InvalidFilterKey()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFilterValue {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFilterValue {
        let reader = baseError.errorBodyReader
        var value = InvalidFilterValue()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationExecutionNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationExecutionNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AutomationExecutionNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPermissionType {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPermissionType {
        let reader = baseError.errorBodyReader
        var value = InvalidPermissionType()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperatingSystem {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedOperatingSystem {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperatingSystem()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInstanceInformationFilterValue {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInstanceInformationFilterValue {
        let reader = baseError.errorBodyReader
        var value = InvalidInstanceInformationFilterValue()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInstancePropertyFilterValue {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInstancePropertyFilterValue {
        let reader = baseError.errorBodyReader
        var value = InvalidInstancePropertyFilterValue()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDeletionIdException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDeletionIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeletionIdException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidFilterOption {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidFilterOption {
        let reader = baseError.errorBodyReader
        var value = InvalidFilterOption()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsItemRelatedItemAssociationNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsItemRelatedItemAssociationNotFoundException {
        let reader = baseError.errorBodyReader
        var value = OpsItemRelatedItemAssociationNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDocumentType {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDocumentType {
        let reader = baseError.errorBodyReader
        var value = InvalidDocumentType()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedCalendarException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedCalendarException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedCalendarException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPluginName {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPluginName {
        var value = InvalidPluginName()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvocationDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvocationDoesNotExist {
        var value = InvocationDoesNotExist()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedFeatureRequiredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedFeatureRequiredException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedFeatureRequiredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResultAttributeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResultAttributeException {
        let reader = baseError.errorBodyReader
        var value = InvalidResultAttributeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInventoryGroupException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInventoryGroupException {
        let reader = baseError.errorBodyReader
        var value = InvalidInventoryGroupException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAggregatorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAggregatorException {
        let reader = baseError.errorBodyReader
        var value = InvalidAggregatorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidKeyId {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidKeyId {
        let reader = baseError.errorBodyReader
        var value = InvalidKeyId()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterVersionNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterVersionNotFound {
        let reader = baseError.errorBodyReader
        var value = ParameterVersionNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceSettingNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceSettingNotFound {
        let reader = baseError.errorBodyReader
        var value = ServiceSettingNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterVersionLabelLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterVersionLabelLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ParameterVersionLabelLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DocumentPermissionLimit {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DocumentPermissionLimit {
        let reader = baseError.errorBodyReader
        var value = DocumentPermissionLimit()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ItemSizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ItemSizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ItemSizeLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.typeName = try reader["TypeName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ComplianceTypeCountLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ComplianceTypeCountLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ComplianceTypeCountLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidItemContentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidItemContentException {
        let reader = baseError.errorBodyReader
        var value = InvalidItemContentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.typeName = try reader["TypeName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TotalSizeLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TotalSizeLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = TotalSizeLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ItemContentMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ItemContentMismatchException {
        let reader = baseError.errorBodyReader
        var value = ItemContentMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.typeName = try reader["TypeName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomSchemaCountLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CustomSchemaCountLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CustomSchemaCountLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedInventorySchemaVersionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedInventorySchemaVersionException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedInventorySchemaVersionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedInventoryItemContextException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedInventoryItemContextException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedInventoryItemContextException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.typeName = try reader["TypeName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInventoryItemContextException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInventoryItemContextException {
        let reader = baseError.errorBodyReader
        var value = InvalidInventoryItemContextException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubTypeCountLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> SubTypeCountLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = SubTypeCountLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PoliciesLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> PoliciesLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = PoliciesLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HierarchyTypeMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> HierarchyTypeMismatchException {
        let reader = baseError.errorBodyReader
        var value = HierarchyTypeMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ParameterAlreadyExists()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HierarchyLevelLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> HierarchyLevelLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = HierarchyLevelLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPolicyTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPolicyTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidPolicyTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAllowedPatternException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAllowedPatternException {
        let reader = baseError.errorBodyReader
        var value = InvalidAllowedPatternException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IncompatiblePolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IncompatiblePolicyException {
        let reader = baseError.errorBodyReader
        var value = IncompatiblePolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ParameterLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterPatternMismatchException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterPatternMismatchException {
        let reader = baseError.errorBodyReader
        var value = ParameterPatternMismatchException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedParameterType {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedParameterType {
        let reader = baseError.errorBodyReader
        var value = UnsupportedParameterType()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ParameterMaxVersionLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ParameterMaxVersionLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ParameterMaxVersionLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPolicyAttributeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPolicyAttributeException {
        let reader = baseError.errorBodyReader
        var value = InvalidPolicyAttributeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePolicyLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourcePolicyLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourcePolicyLimitExceededException()
        value.properties.limit = try reader["Limit"].readIfPresent() ?? 0
        value.properties.limitType = try reader["LimitType"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = AlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FeatureNotAvailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> FeatureNotAvailableException {
        let reader = baseError.errorBodyReader
        var value = FeatureNotAvailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAutomationSignalException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAutomationSignalException {
        let reader = baseError.errorBodyReader
        var value = InvalidAutomationSignalException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationStepNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationStepNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AutomationStepNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRole {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRole {
        let reader = baseError.errorBodyReader
        var value = InvalidRole()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNotificationConfig {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNotificationConfig {
        let reader = baseError.errorBodyReader
        var value = InvalidNotificationConfig()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOutputFolder {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOutputFolder {
        var value = InvalidOutputFolder()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAssociation {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAssociation {
        let reader = baseError.errorBodyReader
        var value = InvalidAssociation()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationDefinitionNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationDefinitionNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AutomationDefinitionNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationDefinitionVersionNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationDefinitionVersionNotFoundException {
        let reader = baseError.errorBodyReader
        var value = AutomationDefinitionVersionNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationExecutionLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationExecutionLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = AutomationExecutionLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAutomationExecutionParametersException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAutomationExecutionParametersException {
        let reader = baseError.errorBodyReader
        var value = InvalidAutomationExecutionParametersException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AutomationDefinitionNotApprovedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AutomationDefinitionNotApprovedException {
        let reader = baseError.errorBodyReader
        var value = AutomationDefinitionNotApprovedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TargetNotConnected {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TargetNotConnected {
        let reader = baseError.errorBodyReader
        var value = TargetNotConnected()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAutomationStatusUpdateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAutomationStatusUpdateException {
        let reader = baseError.errorBodyReader
        var value = InvalidAutomationStatusUpdateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AssociationVersionLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AssociationVersionLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = AssociationVersionLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidUpdate {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidUpdate {
        let reader = baseError.errorBodyReader
        var value = InvalidUpdate()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StatusUnchanged {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StatusUnchanged {
        var value = StatusUnchanged()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateDocumentContent {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateDocumentContent {
        let reader = baseError.errorBodyReader
        var value = DuplicateDocumentContent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DocumentVersionLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DocumentVersionLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = DocumentVersionLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateDocumentVersionName {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateDocumentVersionName {
        let reader = baseError.errorBodyReader
        var value = DuplicateDocumentVersionName()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpsMetadataKeyLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OpsMetadataKeyLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = OpsMetadataKeyLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceDataSyncConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceDataSyncConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceDataSyncConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SSMClientTypes.AssociationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationDescription()
        value.name = try reader["Name"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateAssociationDate = try reader["LastUpdateAssociationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent(with: SSMClientTypes.AssociationStatus.read(from:))
        value.overview = try reader["Overview"].readIfPresent(with: SSMClientTypes.AssociationOverview.read(from:))
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.automationTargetParameterName = try reader["AutomationTargetParameterName"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.outputLocation = try reader["OutputLocation"].readIfPresent(with: SSMClientTypes.InstanceAssociationOutputLocation.read(from:))
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulExecutionDate = try reader["LastSuccessfulExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.associationName = try reader["AssociationName"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.complianceSeverity = try reader["ComplianceSeverity"].readIfPresent()
        value.syncCompliance = try reader["SyncCompliance"].readIfPresent()
        value.applyOnlyAtCronInterval = try reader["ApplyOnlyAtCronInterval"].readIfPresent() ?? false
        value.calendarNames = try reader["CalendarNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocations = try reader["TargetLocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.TargetLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.AlarmStateInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AlarmStateInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AlarmStateInformation()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSMClientTypes.AlarmConfiguration {

    static func write(value: SSMClientTypes.AlarmConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alarms"].writeList(value.alarms, memberWritingClosure: SSMClientTypes.Alarm.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IgnorePollAlarmFailure"].write(value.ignorePollAlarmFailure)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AlarmConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AlarmConfiguration()
        value.ignorePollAlarmFailure = try reader["IgnorePollAlarmFailure"].readIfPresent() ?? false
        value.alarms = try reader["Alarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.Alarm.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMClientTypes.Alarm {

    static func write(value: SSMClientTypes.Alarm?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Alarm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Alarm()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension SSMClientTypes.TargetLocation {

    static func write(value: SSMClientTypes.TargetLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeAccounts"].writeList(value.excludeAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExecutionRoleName"].write(value.executionRoleName)
        try writer["IncludeChildOrganizationUnits"].write(value.includeChildOrganizationUnits)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetLocationAlarmConfiguration"].write(value.targetLocationAlarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["TargetLocationMaxConcurrency"].write(value.targetLocationMaxConcurrency)
        try writer["TargetLocationMaxErrors"].write(value.targetLocationMaxErrors)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetsMaxConcurrency"].write(value.targetsMaxConcurrency)
        try writer["TargetsMaxErrors"].write(value.targetsMaxErrors)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.TargetLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.TargetLocation()
        value.accounts = try reader["Accounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocationMaxConcurrency = try reader["TargetLocationMaxConcurrency"].readIfPresent()
        value.targetLocationMaxErrors = try reader["TargetLocationMaxErrors"].readIfPresent()
        value.executionRoleName = try reader["ExecutionRoleName"].readIfPresent()
        value.targetLocationAlarmConfiguration = try reader["TargetLocationAlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.includeChildOrganizationUnits = try reader["IncludeChildOrganizationUnits"].readIfPresent() ?? false
        value.excludeAccounts = try reader["ExcludeAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetsMaxConcurrency = try reader["TargetsMaxConcurrency"].readIfPresent()
        value.targetsMaxErrors = try reader["TargetsMaxErrors"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.Target {

    static func write(value: SSMClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Target()
        value.key = try reader["Key"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.InstanceAssociationOutputLocation {

    static func write(value: SSMClientTypes.InstanceAssociationOutputLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Location"].write(value.s3Location, with: SSMClientTypes.S3OutputLocation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceAssociationOutputLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceAssociationOutputLocation()
        value.s3Location = try reader["S3Location"].readIfPresent(with: SSMClientTypes.S3OutputLocation.read(from:))
        return value
    }
}

extension SSMClientTypes.S3OutputLocation {

    static func write(value: SSMClientTypes.S3OutputLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutputS3BucketName"].write(value.outputS3BucketName)
        try writer["OutputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["OutputS3Region"].write(value.outputS3Region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.S3OutputLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.S3OutputLocation()
        value.outputS3Region = try reader["OutputS3Region"].readIfPresent()
        value.outputS3BucketName = try reader["OutputS3BucketName"].readIfPresent()
        value.outputS3KeyPrefix = try reader["OutputS3KeyPrefix"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.AssociationOverview {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationOverview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationOverview()
        value.status = try reader["Status"].readIfPresent()
        value.detailedStatus = try reader["DetailedStatus"].readIfPresent()
        value.associationStatusAggregatedCount = try reader["AssociationStatusAggregatedCount"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.AssociationStatus {

    static func write(value: SSMClientTypes.AssociationStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalInfo"].write(value.additionalInfo)
        try writer["Date"].writeTimestamp(value.date, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Message"].write(value.message)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationStatus()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.additionalInfo = try reader["AdditionalInfo"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.FailedCreateAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.FailedCreateAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.FailedCreateAssociation()
        value.entry = try reader["Entry"].readIfPresent(with: SSMClientTypes.CreateAssociationBatchRequestEntry.read(from:))
        value.message = try reader["Message"].readIfPresent()
        value.fault = try reader["Fault"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.CreateAssociationBatchRequestEntry {

    static func write(value: SSMClientTypes.CreateAssociationBatchRequestEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlarmConfiguration"].write(value.alarmConfiguration, with: SSMClientTypes.AlarmConfiguration.write(value:to:))
        try writer["ApplyOnlyAtCronInterval"].write(value.applyOnlyAtCronInterval)
        try writer["AssociationName"].write(value.associationName)
        try writer["AutomationTargetParameterName"].write(value.automationTargetParameterName)
        try writer["CalendarNames"].writeList(value.calendarNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSeverity"].write(value.complianceSeverity)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Duration"].write(value.duration)
        try writer["InstanceId"].write(value.instanceId)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Name"].write(value.name)
        try writer["OutputLocation"].write(value.outputLocation, with: SSMClientTypes.InstanceAssociationOutputLocation.write(value:to:))
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["ScheduleOffset"].write(value.scheduleOffset)
        try writer["SyncCompliance"].write(value.syncCompliance)
        try writer["TargetLocations"].writeList(value.targetLocations, memberWritingClosure: SSMClientTypes.TargetLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetMaps"].writeList(value.targetMaps, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.CreateAssociationBatchRequestEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.CreateAssociationBatchRequestEntry()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.automationTargetParameterName = try reader["AutomationTargetParameterName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.outputLocation = try reader["OutputLocation"].readIfPresent(with: SSMClientTypes.InstanceAssociationOutputLocation.read(from:))
        value.associationName = try reader["AssociationName"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.complianceSeverity = try reader["ComplianceSeverity"].readIfPresent()
        value.syncCompliance = try reader["SyncCompliance"].readIfPresent()
        value.applyOnlyAtCronInterval = try reader["ApplyOnlyAtCronInterval"].readIfPresent() ?? false
        value.calendarNames = try reader["CalendarNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocations = try reader["TargetLocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.TargetLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        return value
    }
}

extension SSMClientTypes.DocumentDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentDescription()
        value.sha1 = try reader["Sha1"].readIfPresent()
        value.hash = try reader["Hash"].readIfPresent()
        value.hashType = try reader["HashType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.versionName = try reader["VersionName"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusInformation = try reader["StatusInformation"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.platformTypes = try reader["PlatformTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SSMClientTypes.PlatformType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.documentType = try reader["DocumentType"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.defaultVersion = try reader["DefaultVersion"].readIfPresent()
        value.documentFormat = try reader["DocumentFormat"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SSMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attachmentsInformation = try reader["AttachmentsInformation"].readListIfPresent(memberReadingClosure: SSMClientTypes.AttachmentInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requires = try reader["Requires"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentRequires.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.author = try reader["Author"].readIfPresent()
        value.reviewInformation = try reader["ReviewInformation"].readListIfPresent(memberReadingClosure: SSMClientTypes.ReviewInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.approvedVersion = try reader["ApprovedVersion"].readIfPresent()
        value.pendingReviewVersion = try reader["PendingReviewVersion"].readIfPresent()
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryEnum = try reader["CategoryEnum"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ReviewInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ReviewInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ReviewInformation()
        value.reviewedTime = try reader["ReviewedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.reviewer = try reader["Reviewer"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.DocumentRequires {

    static func write(value: SSMClientTypes.DocumentRequires?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["RequireType"].write(value.requireType)
        try writer["Version"].write(value.version)
        try writer["VersionName"].write(value.versionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentRequires {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentRequires()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        value.requireType = try reader["RequireType"].readIfPresent()
        value.versionName = try reader["VersionName"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.AttachmentInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AttachmentInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AttachmentInformation()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.Tag {

    static func write(value: SSMClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension SSMClientTypes.DocumentParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentParameter()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InventoryDeletionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryDeletionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryDeletionSummary()
        value.totalCount = try reader["TotalCount"].readIfPresent() ?? 0
        value.remainingCount = try reader["RemainingCount"].readIfPresent() ?? 0
        value.summaryItems = try reader["SummaryItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.InventoryDeletionSummaryItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.InventoryDeletionSummaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryDeletionSummaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryDeletionSummaryItem()
        value.version = try reader["Version"].readIfPresent()
        value.count = try reader["Count"].readIfPresent() ?? 0
        value.remainingCount = try reader["RemainingCount"].readIfPresent() ?? 0
        return value
    }
}

extension SSMClientTypes.Activation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Activation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Activation()
        value.activationId = try reader["ActivationId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultInstanceName = try reader["DefaultInstanceName"].readIfPresent()
        value.iamRole = try reader["IamRole"].readIfPresent()
        value.registrationLimit = try reader["RegistrationLimit"].readIfPresent()
        value.registrationsCount = try reader["RegistrationsCount"].readIfPresent()
        value.expirationDate = try reader["ExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expired = try reader["Expired"].readIfPresent() ?? false
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SSMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.AssociationExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationExecution()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.detailedStatus = try reader["DetailedStatus"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceCountByStatus = try reader["ResourceCountByStatus"].readIfPresent()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.AssociationExecutionTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationExecutionTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationExecutionTarget()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.detailedStatus = try reader["DetailedStatus"].readIfPresent()
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.outputSource = try reader["OutputSource"].readIfPresent(with: SSMClientTypes.OutputSource.read(from:))
        return value
    }
}

extension SSMClientTypes.OutputSource {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OutputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OutputSource()
        value.outputSourceId = try reader["OutputSourceId"].readIfPresent()
        value.outputSourceType = try reader["OutputSourceType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.AutomationExecutionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AutomationExecutionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AutomationExecutionMetadata()
        value.automationExecutionId = try reader["AutomationExecutionId"].readIfPresent()
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.automationExecutionStatus = try reader["AutomationExecutionStatus"].readIfPresent()
        value.executionStartTime = try reader["ExecutionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionEndTime = try reader["ExecutionEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executedBy = try reader["ExecutedBy"].readIfPresent()
        value.logFile = try reader["LogFile"].readIfPresent()
        value.outputs = try reader["Outputs"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.mode = try reader["Mode"].readIfPresent()
        value.parentAutomationExecutionId = try reader["ParentAutomationExecutionId"].readIfPresent()
        value.currentStepName = try reader["CurrentStepName"].readIfPresent()
        value.currentAction = try reader["CurrentAction"].readIfPresent()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.targetParameterName = try reader["TargetParameterName"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.resolvedTargets = try reader["ResolvedTargets"].readIfPresent(with: SSMClientTypes.ResolvedTargets.read(from:))
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.automationType = try reader["AutomationType"].readIfPresent()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocationsURL = try reader["TargetLocationsURL"].readIfPresent()
        value.automationSubtype = try reader["AutomationSubtype"].readIfPresent()
        value.scheduledTime = try reader["ScheduledTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.runbooks = try reader["Runbooks"].readListIfPresent(memberReadingClosure: SSMClientTypes.Runbook.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.changeRequestName = try reader["ChangeRequestName"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.Runbook {

    static func write(value: SSMClientTypes.Runbook?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentName"].write(value.documentName)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxErrors"].write(value.maxErrors)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TargetLocations"].writeList(value.targetLocations, memberWritingClosure: SSMClientTypes.TargetLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetMaps"].writeList(value.targetMaps, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetParameterName"].write(value.targetParameterName)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Runbook {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Runbook()
        value.documentName = try reader["DocumentName"].readIfPresent() ?? ""
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetParameterName = try reader["TargetParameterName"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.targetLocations = try reader["TargetLocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.TargetLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ResolvedTargets {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResolvedTargets {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResolvedTargets()
        value.parameterValues = try reader["ParameterValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.truncated = try reader["Truncated"].readIfPresent() ?? false
        return value
    }
}

extension SSMClientTypes.StepExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.StepExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.StepExecution()
        value.stepName = try reader["StepName"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.timeoutSeconds = try reader["TimeoutSeconds"].readIfPresent()
        value.onFailure = try reader["OnFailure"].readIfPresent()
        value.maxAttempts = try reader["MaxAttempts"].readIfPresent()
        value.executionStartTime = try reader["ExecutionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionEndTime = try reader["ExecutionEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stepStatus = try reader["StepStatus"].readIfPresent()
        value.responseCode = try reader["ResponseCode"].readIfPresent()
        value.inputs = try reader["Inputs"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputs = try reader["Outputs"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.response = try reader["Response"].readIfPresent()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.failureDetails = try reader["FailureDetails"].readIfPresent(with: SSMClientTypes.FailureDetails.read(from:))
        value.stepExecutionId = try reader["StepExecutionId"].readIfPresent()
        value.overriddenParameters = try reader["OverriddenParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.isEnd = try reader["IsEnd"].readIfPresent()
        value.nextStep = try reader["NextStep"].readIfPresent()
        value.isCritical = try reader["IsCritical"].readIfPresent()
        value.validNextSteps = try reader["ValidNextSteps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocation = try reader["TargetLocation"].readIfPresent(with: SSMClientTypes.TargetLocation.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parentStepDetails = try reader["ParentStepDetails"].readIfPresent(with: SSMClientTypes.ParentStepDetails.read(from:))
        return value
    }
}

extension SSMClientTypes.ParentStepDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ParentStepDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ParentStepDetails()
        value.stepExecutionId = try reader["StepExecutionId"].readIfPresent()
        value.stepName = try reader["StepName"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.iteration = try reader["Iteration"].readIfPresent()
        value.iteratorValue = try reader["IteratorValue"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.FailureDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.FailureDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.FailureDetails()
        value.failureStage = try reader["FailureStage"].readIfPresent()
        value.failureType = try reader["FailureType"].readIfPresent()
        value.details = try reader["Details"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.Patch {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Patch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Patch()
        value.id = try reader["Id"].readIfPresent()
        value.releaseDate = try reader["ReleaseDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.title = try reader["Title"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.contentUrl = try reader["ContentUrl"].readIfPresent()
        value.vendor = try reader["Vendor"].readIfPresent()
        value.productFamily = try reader["ProductFamily"].readIfPresent()
        value.product = try reader["Product"].readIfPresent()
        value.classification = try reader["Classification"].readIfPresent()
        value.msrcSeverity = try reader["MsrcSeverity"].readIfPresent()
        value.kbNumber = try reader["KbNumber"].readIfPresent()
        value.msrcNumber = try reader["MsrcNumber"].readIfPresent()
        value.language = try reader["Language"].readIfPresent()
        value.advisoryIds = try reader["AdvisoryIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.bugzillaIds = try reader["BugzillaIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cveIds = try reader["CVEIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.epoch = try reader["Epoch"].readIfPresent() ?? 0
        value.version = try reader["Version"].readIfPresent()
        value.release = try reader["Release"].readIfPresent()
        value.arch = try reader["Arch"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.repository = try reader["Repository"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.AccountSharingInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AccountSharingInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AccountSharingInfo()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.sharedDocumentVersion = try reader["SharedDocumentVersion"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstanceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceAssociation()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.EffectivePatch {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.EffectivePatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.EffectivePatch()
        value.patch = try reader["Patch"].readIfPresent(with: SSMClientTypes.Patch.read(from:))
        value.patchStatus = try reader["PatchStatus"].readIfPresent(with: SSMClientTypes.PatchStatus.read(from:))
        return value
    }
}

extension SSMClientTypes.PatchStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchStatus()
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.complianceLevel = try reader["ComplianceLevel"].readIfPresent()
        value.approvalDate = try reader["ApprovalDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.InstanceAssociationStatusInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceAssociationStatusInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceAssociationStatusInfo()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.executionDate = try reader["ExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.detailedStatus = try reader["DetailedStatus"].readIfPresent()
        value.executionSummary = try reader["ExecutionSummary"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.outputUrl = try reader["OutputUrl"].readIfPresent(with: SSMClientTypes.InstanceAssociationOutputUrl.read(from:))
        value.associationName = try reader["AssociationName"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstanceAssociationOutputUrl {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceAssociationOutputUrl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceAssociationOutputUrl()
        value.s3OutputUrl = try reader["S3OutputUrl"].readIfPresent(with: SSMClientTypes.S3OutputUrl.read(from:))
        return value
    }
}

extension SSMClientTypes.S3OutputUrl {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.S3OutputUrl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.S3OutputUrl()
        value.outputUrl = try reader["OutputUrl"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstanceInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceInformation()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.pingStatus = try reader["PingStatus"].readIfPresent()
        value.lastPingDateTime = try reader["LastPingDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.agentVersion = try reader["AgentVersion"].readIfPresent()
        value.isLatestVersion = try reader["IsLatestVersion"].readIfPresent()
        value.platformType = try reader["PlatformType"].readIfPresent()
        value.platformName = try reader["PlatformName"].readIfPresent()
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.activationId = try reader["ActivationId"].readIfPresent()
        value.iamRole = try reader["IamRole"].readIfPresent()
        value.registrationDate = try reader["RegistrationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ipAddress = try reader["IPAddress"].readIfPresent()
        value.computerName = try reader["ComputerName"].readIfPresent()
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.lastAssociationExecutionDate = try reader["LastAssociationExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulAssociationExecutionDate = try reader["LastSuccessfulAssociationExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.associationOverview = try reader["AssociationOverview"].readIfPresent(with: SSMClientTypes.InstanceAggregatedAssociationOverview.read(from:))
        value.sourceId = try reader["SourceId"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstanceAggregatedAssociationOverview {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceAggregatedAssociationOverview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceAggregatedAssociationOverview()
        value.detailedStatus = try reader["DetailedStatus"].readIfPresent()
        value.instanceAssociationStatusAggregatedCount = try reader["InstanceAssociationStatusAggregatedCount"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.PatchComplianceData {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchComplianceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchComplianceData()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.kbId = try reader["KBId"].readIfPresent() ?? ""
        value.classification = try reader["Classification"].readIfPresent() ?? ""
        value.severity = try reader["Severity"].readIfPresent() ?? ""
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.installedTime = try reader["InstalledTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.cveIds = try reader["CVEIds"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstancePatchState {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstancePatchState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstancePatchState()
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.patchGroup = try reader["PatchGroup"].readIfPresent() ?? ""
        value.baselineId = try reader["BaselineId"].readIfPresent() ?? ""
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.installOverrideList = try reader["InstallOverrideList"].readIfPresent()
        value.ownerInformation = try reader["OwnerInformation"].readIfPresent()
        value.installedCount = try reader["InstalledCount"].readIfPresent() ?? 0
        value.installedOtherCount = try reader["InstalledOtherCount"].readIfPresent() ?? 0
        value.installedPendingRebootCount = try reader["InstalledPendingRebootCount"].readIfPresent()
        value.installedRejectedCount = try reader["InstalledRejectedCount"].readIfPresent()
        value.missingCount = try reader["MissingCount"].readIfPresent() ?? 0
        value.failedCount = try reader["FailedCount"].readIfPresent() ?? 0
        value.unreportedNotApplicableCount = try reader["UnreportedNotApplicableCount"].readIfPresent()
        value.notApplicableCount = try reader["NotApplicableCount"].readIfPresent() ?? 0
        value.operationStartTime = try reader["OperationStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.operationEndTime = try reader["OperationEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.operation = try reader["Operation"].readIfPresent() ?? .sdkUnknown("")
        value.lastNoRebootInstallOperationTime = try reader["LastNoRebootInstallOperationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rebootOption = try reader["RebootOption"].readIfPresent()
        value.criticalNonCompliantCount = try reader["CriticalNonCompliantCount"].readIfPresent()
        value.securityNonCompliantCount = try reader["SecurityNonCompliantCount"].readIfPresent()
        value.otherNonCompliantCount = try reader["OtherNonCompliantCount"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InstanceProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InstanceProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InstanceProperty()
        value.name = try reader["Name"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.instanceRole = try reader["InstanceRole"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.instanceState = try reader["InstanceState"].readIfPresent()
        value.architecture = try reader["Architecture"].readIfPresent()
        value.ipAddress = try reader["IPAddress"].readIfPresent()
        value.launchTime = try reader["LaunchTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pingStatus = try reader["PingStatus"].readIfPresent()
        value.lastPingDateTime = try reader["LastPingDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.agentVersion = try reader["AgentVersion"].readIfPresent()
        value.platformType = try reader["PlatformType"].readIfPresent()
        value.platformName = try reader["PlatformName"].readIfPresent()
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.activationId = try reader["ActivationId"].readIfPresent()
        value.iamRole = try reader["IamRole"].readIfPresent()
        value.registrationDate = try reader["RegistrationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.computerName = try reader["ComputerName"].readIfPresent()
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.lastAssociationExecutionDate = try reader["LastAssociationExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulAssociationExecutionDate = try reader["LastSuccessfulAssociationExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.associationOverview = try reader["AssociationOverview"].readIfPresent(with: SSMClientTypes.InstanceAggregatedAssociationOverview.read(from:))
        value.sourceId = try reader["SourceId"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InventoryDeletionStatusItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryDeletionStatusItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryDeletionStatusItem()
        value.deletionId = try reader["DeletionId"].readIfPresent()
        value.typeName = try reader["TypeName"].readIfPresent()
        value.deletionStartTime = try reader["DeletionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastStatus = try reader["LastStatus"].readIfPresent()
        value.lastStatusMessage = try reader["LastStatusMessage"].readIfPresent()
        value.deletionSummary = try reader["DeletionSummary"].readIfPresent(with: SSMClientTypes.InventoryDeletionSummary.read(from:))
        value.lastStatusUpdateTime = try reader["LastStatusUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowExecution()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowExecutionTaskInvocationIdentity()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        value.taskExecutionId = try reader["TaskExecutionId"].readIfPresent()
        value.invocationId = try reader["InvocationId"].readIfPresent()
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.taskType = try reader["TaskType"].readIfPresent()
        value.parameters = try reader["Parameters"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ownerInformation = try reader["OwnerInformation"].readIfPresent()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowExecutionTaskIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowExecutionTaskIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowExecutionTaskIdentity()
        value.windowExecutionId = try reader["WindowExecutionId"].readIfPresent()
        value.taskExecutionId = try reader["TaskExecutionId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskType = try reader["TaskType"].readIfPresent()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowIdentity()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.duration = try reader["Duration"].readIfPresent()
        value.cutoff = try reader["Cutoff"].readIfPresent() ?? 0
        value.schedule = try reader["Schedule"].readIfPresent()
        value.scheduleTimezone = try reader["ScheduleTimezone"].readIfPresent()
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.endDate = try reader["EndDate"].readIfPresent()
        value.startDate = try reader["StartDate"].readIfPresent()
        value.nextExecutionTime = try reader["NextExecutionTime"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ScheduledWindowExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ScheduledWindowExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ScheduledWindowExecution()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.executionTime = try reader["ExecutionTime"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowIdentityForTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowIdentityForTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowIdentityForTarget()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowTarget()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTargetId = try reader["WindowTargetId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerInformation = try reader["OwnerInformation"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowTask {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowTask()
        value.windowId = try reader["WindowId"].readIfPresent()
        value.windowTaskId = try reader["WindowTaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskParameters = try reader["TaskParameters"].readMapIfPresent(valueReadingClosure: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.priority = try reader["Priority"].readIfPresent() ?? 0
        value.loggingInfo = try reader["LoggingInfo"].readIfPresent(with: SSMClientTypes.LoggingInfo.read(from:))
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.cutoffBehavior = try reader["CutoffBehavior"].readIfPresent()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        return value
    }
}

extension SSMClientTypes.LoggingInfo {

    static func write(value: SSMClientTypes.LoggingInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["S3Region"].write(value.s3Region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.LoggingInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.LoggingInfo()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent() ?? ""
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.s3Region = try reader["S3Region"].readIfPresent() ?? ""
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowTaskParameterValueExpression {

    static func write(value: SSMClientTypes.MaintenanceWindowTaskParameterValueExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowTaskParameterValueExpression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowTaskParameterValueExpression()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.OpsItemSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemSummary()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.priority = try reader["Priority"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.operationalData = try reader["OperationalData"].readMapIfPresent(valueReadingClosure: SSMClientTypes.OpsItemDataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.category = try reader["Category"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.opsItemType = try reader["OpsItemType"].readIfPresent()
        value.actualStartTime = try reader["ActualStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.actualEndTime = try reader["ActualEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.plannedStartTime = try reader["PlannedStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.plannedEndTime = try reader["PlannedEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.OpsItemDataValue {

    static func write(value: SSMClientTypes.OpsItemDataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemDataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemDataValue()
        value.value = try reader["Value"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ParameterMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ParameterMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ParameterMetadata()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.keyId = try reader["KeyId"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["LastModifiedUser"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.allowedPattern = try reader["AllowedPattern"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.tier = try reader["Tier"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: SSMClientTypes.ParameterInlinePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataType = try reader["DataType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ParameterInlinePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ParameterInlinePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ParameterInlinePolicy()
        value.policyText = try reader["PolicyText"].readIfPresent()
        value.policyType = try reader["PolicyType"].readIfPresent()
        value.policyStatus = try reader["PolicyStatus"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.PatchBaselineIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchBaselineIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchBaselineIdentity()
        value.baselineId = try reader["BaselineId"].readIfPresent()
        value.baselineName = try reader["BaselineName"].readIfPresent()
        value.operatingSystem = try reader["OperatingSystem"].readIfPresent()
        value.baselineDescription = try reader["BaselineDescription"].readIfPresent()
        value.defaultBaseline = try reader["DefaultBaseline"].readIfPresent() ?? false
        return value
    }
}

extension SSMClientTypes.PatchGroupPatchBaselineMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchGroupPatchBaselineMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchGroupPatchBaselineMapping()
        value.patchGroup = try reader["PatchGroup"].readIfPresent()
        value.baselineIdentity = try reader["BaselineIdentity"].readIfPresent(with: SSMClientTypes.PatchBaselineIdentity.read(from:))
        return value
    }
}

extension SSMClientTypes.Session {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Session {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Session()
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endDate = try reader["EndDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        value.details = try reader["Details"].readIfPresent()
        value.outputUrl = try reader["OutputUrl"].readIfPresent(with: SSMClientTypes.SessionManagerOutputUrl.read(from:))
        value.maxSessionDuration = try reader["MaxSessionDuration"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.SessionManagerOutputUrl {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.SessionManagerOutputUrl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.SessionManagerOutputUrl()
        value.s3OutputUrl = try reader["S3OutputUrl"].readIfPresent()
        value.cloudWatchOutputUrl = try reader["CloudWatchOutputUrl"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.AutomationExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AutomationExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AutomationExecution()
        value.automationExecutionId = try reader["AutomationExecutionId"].readIfPresent()
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.executionStartTime = try reader["ExecutionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionEndTime = try reader["ExecutionEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.automationExecutionStatus = try reader["AutomationExecutionStatus"].readIfPresent()
        value.stepExecutions = try reader["StepExecutions"].readListIfPresent(memberReadingClosure: SSMClientTypes.StepExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stepExecutionsTruncated = try reader["StepExecutionsTruncated"].readIfPresent() ?? false
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputs = try reader["Outputs"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.parentAutomationExecutionId = try reader["ParentAutomationExecutionId"].readIfPresent()
        value.executedBy = try reader["ExecutedBy"].readIfPresent()
        value.currentStepName = try reader["CurrentStepName"].readIfPresent()
        value.currentAction = try reader["CurrentAction"].readIfPresent()
        value.targetParameterName = try reader["TargetParameterName"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.resolvedTargets = try reader["ResolvedTargets"].readIfPresent(with: SSMClientTypes.ResolvedTargets.read(from:))
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.targetLocations = try reader["TargetLocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.TargetLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.progressCounters = try reader["ProgressCounters"].readIfPresent(with: SSMClientTypes.ProgressCounters.read(from:))
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocationsURL = try reader["TargetLocationsURL"].readIfPresent()
        value.automationSubtype = try reader["AutomationSubtype"].readIfPresent()
        value.scheduledTime = try reader["ScheduledTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.runbooks = try reader["Runbooks"].readListIfPresent(memberReadingClosure: SSMClientTypes.Runbook.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.changeRequestName = try reader["ChangeRequestName"].readIfPresent()
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ProgressCounters {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ProgressCounters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ProgressCounters()
        value.totalSteps = try reader["TotalSteps"].readIfPresent() ?? 0
        value.successSteps = try reader["SuccessSteps"].readIfPresent() ?? 0
        value.failedSteps = try reader["FailedSteps"].readIfPresent() ?? 0
        value.cancelledSteps = try reader["CancelledSteps"].readIfPresent() ?? 0
        value.timedOutSteps = try reader["TimedOutSteps"].readIfPresent() ?? 0
        return value
    }
}

extension SSMClientTypes.CloudWatchOutputConfig {

    static func write(value: SSMClientTypes.CloudWatchOutputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogGroupName"].write(value.cloudWatchLogGroupName)
        try writer["CloudWatchOutputEnabled"].write(value.cloudWatchOutputEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.CloudWatchOutputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.CloudWatchOutputConfig()
        value.cloudWatchLogGroupName = try reader["CloudWatchLogGroupName"].readIfPresent()
        value.cloudWatchOutputEnabled = try reader["CloudWatchOutputEnabled"].readIfPresent() ?? false
        return value
    }
}

extension SSMClientTypes.AttachmentContent {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AttachmentContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AttachmentContent()
        value.name = try reader["Name"].readIfPresent()
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.hash = try reader["Hash"].readIfPresent()
        value.hashType = try reader["HashType"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InventoryResultEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryResultEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryResultEntity()
        value.id = try reader["Id"].readIfPresent()
        value.data = try reader["Data"].readMapIfPresent(valueReadingClosure: SSMClientTypes.InventoryResultItem.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.InventoryResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryResultItem()
        value.typeName = try reader["TypeName"].readIfPresent() ?? ""
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent() ?? ""
        value.captureTime = try reader["CaptureTime"].readIfPresent()
        value.contentHash = try reader["ContentHash"].readIfPresent()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMClientTypes.InventoryItemSchema {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryItemSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryItemSchema()
        value.typeName = try reader["TypeName"].readIfPresent() ?? ""
        value.version = try reader["Version"].readIfPresent()
        value.attributes = try reader["Attributes"].readListIfPresent(memberReadingClosure: SSMClientTypes.InventoryItemAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.displayName = try reader["DisplayName"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.InventoryItemAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.InventoryItemAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.InventoryItemAttribute()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.dataType = try reader["DataType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowTaskInvocationParameters {

    static func write(value: SSMClientTypes.MaintenanceWindowTaskInvocationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Automation"].write(value.automation, with: SSMClientTypes.MaintenanceWindowAutomationParameters.write(value:to:))
        try writer["Lambda"].write(value.lambda, with: SSMClientTypes.MaintenanceWindowLambdaParameters.write(value:to:))
        try writer["RunCommand"].write(value.runCommand, with: SSMClientTypes.MaintenanceWindowRunCommandParameters.write(value:to:))
        try writer["StepFunctions"].write(value.stepFunctions, with: SSMClientTypes.MaintenanceWindowStepFunctionsParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowTaskInvocationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowTaskInvocationParameters()
        value.runCommand = try reader["RunCommand"].readIfPresent(with: SSMClientTypes.MaintenanceWindowRunCommandParameters.read(from:))
        value.automation = try reader["Automation"].readIfPresent(with: SSMClientTypes.MaintenanceWindowAutomationParameters.read(from:))
        value.stepFunctions = try reader["StepFunctions"].readIfPresent(with: SSMClientTypes.MaintenanceWindowStepFunctionsParameters.read(from:))
        value.lambda = try reader["Lambda"].readIfPresent(with: SSMClientTypes.MaintenanceWindowLambdaParameters.read(from:))
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowLambdaParameters {

    static func write(value: SSMClientTypes.MaintenanceWindowLambdaParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientContext"].write(value.clientContext)
        try writer["Payload"].write(value.payload)
        try writer["Qualifier"].write(value.qualifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowLambdaParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowLambdaParameters()
        value.clientContext = try reader["ClientContext"].readIfPresent()
        value.qualifier = try reader["Qualifier"].readIfPresent()
        value.payload = try reader["Payload"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowStepFunctionsParameters {

    static func write(value: SSMClientTypes.MaintenanceWindowStepFunctionsParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Input"].write(value.input)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowStepFunctionsParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowStepFunctionsParameters()
        value.input = try reader["Input"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowAutomationParameters {

    static func write(value: SSMClientTypes.MaintenanceWindowAutomationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowAutomationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowAutomationParameters()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.MaintenanceWindowRunCommandParameters {

    static func write(value: SSMClientTypes.MaintenanceWindowRunCommandParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchOutputConfig"].write(value.cloudWatchOutputConfig, with: SSMClientTypes.CloudWatchOutputConfig.write(value:to:))
        try writer["Comment"].write(value.comment)
        try writer["DocumentHash"].write(value.documentHash)
        try writer["DocumentHashType"].write(value.documentHashType)
        try writer["DocumentVersion"].write(value.documentVersion)
        try writer["NotificationConfig"].write(value.notificationConfig, with: SSMClientTypes.NotificationConfig.write(value:to:))
        try writer["OutputS3BucketName"].write(value.outputS3BucketName)
        try writer["OutputS3KeyPrefix"].write(value.outputS3KeyPrefix)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ServiceRoleArn"].write(value.serviceRoleArn)
        try writer["TimeoutSeconds"].write(value.timeoutSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MaintenanceWindowRunCommandParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MaintenanceWindowRunCommandParameters()
        value.comment = try reader["Comment"].readIfPresent()
        value.cloudWatchOutputConfig = try reader["CloudWatchOutputConfig"].readIfPresent(with: SSMClientTypes.CloudWatchOutputConfig.read(from:))
        value.documentHash = try reader["DocumentHash"].readIfPresent()
        value.documentHashType = try reader["DocumentHashType"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.notificationConfig = try reader["NotificationConfig"].readIfPresent(with: SSMClientTypes.NotificationConfig.read(from:))
        value.outputS3BucketName = try reader["OutputS3BucketName"].readIfPresent()
        value.outputS3KeyPrefix = try reader["OutputS3KeyPrefix"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serviceRoleArn = try reader["ServiceRoleArn"].readIfPresent()
        value.timeoutSeconds = try reader["TimeoutSeconds"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.NotificationConfig {

    static func write(value: SSMClientTypes.NotificationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotificationArn"].write(value.notificationArn)
        try writer["NotificationEvents"].writeList(value.notificationEvents, memberWritingClosure: SmithyReadWrite.WritingClosureBox<SSMClientTypes.NotificationEvent>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotificationType"].write(value.notificationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.NotificationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.NotificationConfig()
        value.notificationArn = try reader["NotificationArn"].readIfPresent()
        value.notificationEvents = try reader["NotificationEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SSMClientTypes.NotificationEvent>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notificationType = try reader["NotificationType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.OpsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItem()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.opsItemType = try reader["OpsItemType"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notifications = try reader["Notifications"].readListIfPresent(memberReadingClosure: SSMClientTypes.OpsItemNotification.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.priority = try reader["Priority"].readIfPresent()
        value.relatedOpsItems = try reader["RelatedOpsItems"].readListIfPresent(memberReadingClosure: SSMClientTypes.RelatedOpsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.operationalData = try reader["OperationalData"].readMapIfPresent(valueReadingClosure: SSMClientTypes.OpsItemDataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.category = try reader["Category"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.actualStartTime = try reader["ActualStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.actualEndTime = try reader["ActualEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.plannedStartTime = try reader["PlannedStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.plannedEndTime = try reader["PlannedEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.opsItemArn = try reader["OpsItemArn"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.RelatedOpsItem {

    static func write(value: SSMClientTypes.RelatedOpsItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OpsItemId"].write(value.opsItemId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.RelatedOpsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.RelatedOpsItem()
        value.opsItemId = try reader["OpsItemId"].readIfPresent() ?? ""
        return value
    }
}

extension SSMClientTypes.OpsItemNotification {

    static func write(value: SSMClientTypes.OpsItemNotification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemNotification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemNotification()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.MetadataValue {

    static func write(value: SSMClientTypes.MetadataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.MetadataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.MetadataValue()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.OpsEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsEntity()
        value.id = try reader["Id"].readIfPresent()
        value.data = try reader["Data"].readMapIfPresent(valueReadingClosure: SSMClientTypes.OpsEntityItem.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.OpsEntityItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsEntityItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsEntityItem()
        value.captureTime = try reader["CaptureTime"].readIfPresent()
        value.content = try reader["Content"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.Parameter {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Parameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Parameter()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.selector = try reader["Selector"].readIfPresent()
        value.sourceResult = try reader["SourceResult"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["ARN"].readIfPresent()
        value.dataType = try reader["DataType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ParameterHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ParameterHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ParameterHistory()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.keyId = try reader["KeyId"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["LastModifiedUser"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.allowedPattern = try reader["AllowedPattern"].readIfPresent()
        value.version = try reader["Version"].readIfPresent() ?? 0
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tier = try reader["Tier"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: SSMClientTypes.ParameterInlinePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataType = try reader["DataType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.PatchFilterGroup {

    static func write(value: SSMClientTypes.PatchFilterGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PatchFilters"].writeList(value.patchFilters, memberWritingClosure: SSMClientTypes.PatchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchFilterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchFilterGroup()
        value.patchFilters = try reader["PatchFilters"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMClientTypes.PatchFilter {

    static func write(value: SSMClientTypes.PatchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchFilter()
        value.key = try reader["Key"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMClientTypes.PatchRuleGroup {

    static func write(value: SSMClientTypes.PatchRuleGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PatchRules"].writeList(value.patchRules, memberWritingClosure: SSMClientTypes.PatchRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchRuleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchRuleGroup()
        value.patchRules = try reader["PatchRules"].readListIfPresent(memberReadingClosure: SSMClientTypes.PatchRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMClientTypes.PatchRule {

    static func write(value: SSMClientTypes.PatchRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApproveAfterDays"].write(value.approveAfterDays)
        try writer["ApproveUntilDate"].write(value.approveUntilDate)
        try writer["ComplianceLevel"].write(value.complianceLevel)
        try writer["EnableNonSecurity"].write(value.enableNonSecurity)
        try writer["PatchFilterGroup"].write(value.patchFilterGroup, with: SSMClientTypes.PatchFilterGroup.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchRule()
        value.patchFilterGroup = try reader["PatchFilterGroup"].readIfPresent(with: SSMClientTypes.PatchFilterGroup.read(from:))
        value.complianceLevel = try reader["ComplianceLevel"].readIfPresent()
        value.approveAfterDays = try reader["ApproveAfterDays"].readIfPresent()
        value.approveUntilDate = try reader["ApproveUntilDate"].readIfPresent()
        value.enableNonSecurity = try reader["EnableNonSecurity"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.PatchSource {

    static func write(value: SSMClientTypes.PatchSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration)
        try writer["Name"].write(value.name)
        try writer["Products"].writeList(value.products, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.PatchSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.PatchSource()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.products = try reader["Products"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.configuration = try reader["Configuration"].readIfPresent() ?? ""
        return value
    }
}

extension SSMClientTypes.GetResourcePoliciesResponseEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.GetResourcePoliciesResponseEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.GetResourcePoliciesResponseEntry()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.policyHash = try reader["PolicyHash"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ServiceSetting {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ServiceSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ServiceSetting()
        value.settingId = try reader["SettingId"].readIfPresent()
        value.settingValue = try reader["SettingValue"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["LastModifiedUser"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.Association {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Association {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Association()
        value.name = try reader["Name"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastExecutionDate = try reader["LastExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.overview = try reader["Overview"].readIfPresent(with: SSMClientTypes.AssociationOverview.read(from:))
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.associationName = try reader["AssociationName"].readIfPresent()
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.AssociationVersionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.AssociationVersionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.AssociationVersionInfo()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.associationVersion = try reader["AssociationVersion"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.outputLocation = try reader["OutputLocation"].readIfPresent(with: SSMClientTypes.InstanceAssociationOutputLocation.read(from:))
        value.associationName = try reader["AssociationName"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.complianceSeverity = try reader["ComplianceSeverity"].readIfPresent()
        value.syncCompliance = try reader["SyncCompliance"].readIfPresent()
        value.applyOnlyAtCronInterval = try reader["ApplyOnlyAtCronInterval"].readIfPresent() ?? false
        value.calendarNames = try reader["CalendarNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetLocations = try reader["TargetLocations"].readListIfPresent(memberReadingClosure: SSMClientTypes.TargetLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scheduleOffset = try reader["ScheduleOffset"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent()
        value.targetMaps = try reader["TargetMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.CommandInvocation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.CommandInvocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.CommandInvocation()
        value.commandId = try reader["CommandId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceName = try reader["InstanceName"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.requestedDateTime = try reader["RequestedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.traceOutput = try reader["TraceOutput"].readIfPresent()
        value.standardOutputUrl = try reader["StandardOutputUrl"].readIfPresent()
        value.standardErrorUrl = try reader["StandardErrorUrl"].readIfPresent()
        value.commandPlugins = try reader["CommandPlugins"].readListIfPresent(memberReadingClosure: SSMClientTypes.CommandPlugin.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.notificationConfig = try reader["NotificationConfig"].readIfPresent(with: SSMClientTypes.NotificationConfig.read(from:))
        value.cloudWatchOutputConfig = try reader["CloudWatchOutputConfig"].readIfPresent(with: SSMClientTypes.CloudWatchOutputConfig.read(from:))
        return value
    }
}

extension SSMClientTypes.CommandPlugin {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.CommandPlugin {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.CommandPlugin()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.responseCode = try reader["ResponseCode"].readIfPresent() ?? 0
        value.responseStartDateTime = try reader["ResponseStartDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.responseFinishDateTime = try reader["ResponseFinishDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.output = try reader["Output"].readIfPresent()
        value.standardOutputUrl = try reader["StandardOutputUrl"].readIfPresent()
        value.standardErrorUrl = try reader["StandardErrorUrl"].readIfPresent()
        value.outputS3Region = try reader["OutputS3Region"].readIfPresent()
        value.outputS3BucketName = try reader["OutputS3BucketName"].readIfPresent()
        value.outputS3KeyPrefix = try reader["OutputS3KeyPrefix"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.Command {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.Command {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.Command()
        value.commandId = try reader["CommandId"].readIfPresent()
        value.documentName = try reader["DocumentName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.comment = try reader["Comment"].readIfPresent()
        value.expiresAfter = try reader["ExpiresAfter"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.instanceIds = try reader["InstanceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestedDateTime = try reader["RequestedDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.statusDetails = try reader["StatusDetails"].readIfPresent()
        value.outputS3Region = try reader["OutputS3Region"].readIfPresent()
        value.outputS3BucketName = try reader["OutputS3BucketName"].readIfPresent()
        value.outputS3KeyPrefix = try reader["OutputS3KeyPrefix"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.maxErrors = try reader["MaxErrors"].readIfPresent()
        value.targetCount = try reader["TargetCount"].readIfPresent() ?? 0
        value.completedCount = try reader["CompletedCount"].readIfPresent() ?? 0
        value.errorCount = try reader["ErrorCount"].readIfPresent() ?? 0
        value.deliveryTimedOutCount = try reader["DeliveryTimedOutCount"].readIfPresent() ?? 0
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.notificationConfig = try reader["NotificationConfig"].readIfPresent(with: SSMClientTypes.NotificationConfig.read(from:))
        value.cloudWatchOutputConfig = try reader["CloudWatchOutputConfig"].readIfPresent(with: SSMClientTypes.CloudWatchOutputConfig.read(from:))
        value.timeoutSeconds = try reader["TimeoutSeconds"].readIfPresent()
        value.alarmConfiguration = try reader["AlarmConfiguration"].readIfPresent(with: SSMClientTypes.AlarmConfiguration.read(from:))
        value.triggeredAlarms = try reader["TriggeredAlarms"].readListIfPresent(memberReadingClosure: SSMClientTypes.AlarmStateInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ComplianceItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ComplianceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ComplianceItem()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.executionSummary = try reader["ExecutionSummary"].readIfPresent(with: SSMClientTypes.ComplianceExecutionSummary.read(from:))
        value.details = try reader["Details"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ComplianceExecutionSummary {

    static func write(value: SSMClientTypes.ComplianceExecutionSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionId"].write(value.executionId)
        try writer["ExecutionTime"].writeTimestamp(value.executionTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ExecutionType"].write(value.executionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ComplianceExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ComplianceExecutionSummary()
        value.executionTime = try reader["ExecutionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.executionId = try reader["ExecutionId"].readIfPresent()
        value.executionType = try reader["ExecutionType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ComplianceSummaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ComplianceSummaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ComplianceSummaryItem()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.compliantSummary = try reader["CompliantSummary"].readIfPresent(with: SSMClientTypes.CompliantSummary.read(from:))
        value.nonCompliantSummary = try reader["NonCompliantSummary"].readIfPresent(with: SSMClientTypes.NonCompliantSummary.read(from:))
        return value
    }
}

extension SSMClientTypes.NonCompliantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.NonCompliantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.NonCompliantSummary()
        value.nonCompliantCount = try reader["NonCompliantCount"].readIfPresent() ?? 0
        value.severitySummary = try reader["SeveritySummary"].readIfPresent(with: SSMClientTypes.SeveritySummary.read(from:))
        return value
    }
}

extension SSMClientTypes.SeveritySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.SeveritySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.SeveritySummary()
        value.criticalCount = try reader["CriticalCount"].readIfPresent() ?? 0
        value.highCount = try reader["HighCount"].readIfPresent() ?? 0
        value.mediumCount = try reader["MediumCount"].readIfPresent() ?? 0
        value.lowCount = try reader["LowCount"].readIfPresent() ?? 0
        value.informationalCount = try reader["InformationalCount"].readIfPresent() ?? 0
        value.unspecifiedCount = try reader["UnspecifiedCount"].readIfPresent() ?? 0
        return value
    }
}

extension SSMClientTypes.CompliantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.CompliantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.CompliantSummary()
        value.compliantCount = try reader["CompliantCount"].readIfPresent() ?? 0
        value.severitySummary = try reader["SeveritySummary"].readIfPresent(with: SSMClientTypes.SeveritySummary.read(from:))
        return value
    }
}

extension SSMClientTypes.DocumentMetadataResponseInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentMetadataResponseInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentMetadataResponseInfo()
        value.reviewerResponse = try reader["ReviewerResponse"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentReviewerResponseSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.DocumentReviewerResponseSource {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentReviewerResponseSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentReviewerResponseSource()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTime = try reader["UpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.comment = try reader["Comment"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentReviewCommentSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reviewer = try reader["Reviewer"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.DocumentReviewCommentSource {

    static func write(value: SSMClientTypes.DocumentReviewCommentSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentReviewCommentSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentReviewCommentSource()
        value.type = try reader["Type"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.DocumentIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentIdentifier()
        value.name = try reader["Name"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.versionName = try reader["VersionName"].readIfPresent()
        value.platformTypes = try reader["PlatformTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SSMClientTypes.PlatformType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.documentType = try reader["DocumentType"].readIfPresent()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent()
        value.documentFormat = try reader["DocumentFormat"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SSMClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requires = try reader["Requires"].readListIfPresent(memberReadingClosure: SSMClientTypes.DocumentRequires.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.author = try reader["Author"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.DocumentVersionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentVersionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentVersionInfo()
        value.name = try reader["Name"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        value.versionName = try reader["VersionName"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isDefaultVersion = try reader["IsDefaultVersion"].readIfPresent() ?? false
        value.documentFormat = try reader["DocumentFormat"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusInformation = try reader["StatusInformation"].readIfPresent()
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.OpsItemEventSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemEventSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemEventSummary()
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.eventId = try reader["EventId"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.detailType = try reader["DetailType"].readIfPresent()
        value.detail = try reader["Detail"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: SSMClientTypes.OpsItemIdentity.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.OpsItemIdentity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemIdentity()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.OpsItemRelatedItemSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsItemRelatedItemSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsItemRelatedItemSummary()
        value.opsItemId = try reader["OpsItemId"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.associationType = try reader["AssociationType"].readIfPresent()
        value.resourceUri = try reader["ResourceUri"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: SSMClientTypes.OpsItemIdentity.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedBy = try reader["LastModifiedBy"].readIfPresent(with: SSMClientTypes.OpsItemIdentity.read(from:))
        value.lastModifiedTime = try reader["LastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.OpsMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.OpsMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.OpsMetadata()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.opsMetadataArn = try reader["OpsMetadataArn"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedUser = try reader["LastModifiedUser"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMClientTypes.ResourceComplianceSummaryItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceComplianceSummaryItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceComplianceSummaryItem()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.overallSeverity = try reader["OverallSeverity"].readIfPresent()
        value.executionSummary = try reader["ExecutionSummary"].readIfPresent(with: SSMClientTypes.ComplianceExecutionSummary.read(from:))
        value.compliantSummary = try reader["CompliantSummary"].readIfPresent(with: SSMClientTypes.CompliantSummary.read(from:))
        value.nonCompliantSummary = try reader["NonCompliantSummary"].readIfPresent(with: SSMClientTypes.NonCompliantSummary.read(from:))
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncItem()
        value.syncName = try reader["SyncName"].readIfPresent()
        value.syncType = try reader["SyncType"].readIfPresent()
        value.syncSource = try reader["SyncSource"].readIfPresent(with: SSMClientTypes.ResourceDataSyncSourceWithState.read(from:))
        value.s3Destination = try reader["S3Destination"].readIfPresent(with: SSMClientTypes.ResourceDataSyncS3Destination.read(from:))
        value.lastSyncTime = try reader["LastSyncTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulSyncTime = try reader["LastSuccessfulSyncTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.syncLastModifiedTime = try reader["SyncLastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastStatus = try reader["LastStatus"].readIfPresent()
        value.syncCreatedTime = try reader["SyncCreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSyncStatusMessage = try reader["LastSyncStatusMessage"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncS3Destination {

    static func write(value: SSMClientTypes.ResourceDataSyncS3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSKMSKeyARN"].write(value.awskmsKeyARN)
        try writer["BucketName"].write(value.bucketName)
        try writer["DestinationDataSharing"].write(value.destinationDataSharing, with: SSMClientTypes.ResourceDataSyncDestinationDataSharing.write(value:to:))
        try writer["Prefix"].write(value.`prefix`)
        try writer["Region"].write(value.region)
        try writer["SyncFormat"].write(value.syncFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncS3Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncS3Destination()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.syncFormat = try reader["SyncFormat"].readIfPresent() ?? .sdkUnknown("")
        value.region = try reader["Region"].readIfPresent() ?? ""
        value.awskmsKeyARN = try reader["AWSKMSKeyARN"].readIfPresent()
        value.destinationDataSharing = try reader["DestinationDataSharing"].readIfPresent(with: SSMClientTypes.ResourceDataSyncDestinationDataSharing.read(from:))
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncDestinationDataSharing {

    static func write(value: SSMClientTypes.ResourceDataSyncDestinationDataSharing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationDataSharingType"].write(value.destinationDataSharingType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncDestinationDataSharing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncDestinationDataSharing()
        value.destinationDataSharingType = try reader["DestinationDataSharingType"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncSourceWithState {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncSourceWithState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncSourceWithState()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.awsOrganizationsSource = try reader["AwsOrganizationsSource"].readIfPresent(with: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource.read(from:))
        value.sourceRegions = try reader["SourceRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.includeFutureRegions = try reader["IncludeFutureRegions"].readIfPresent() ?? false
        value.state = try reader["State"].readIfPresent()
        value.enableAllOpsDataSources = try reader["EnableAllOpsDataSources"].readIfPresent() ?? false
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncAwsOrganizationsSource {

    static func write(value: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationSourceType"].write(value.organizationSourceType)
        try writer["OrganizationalUnits"].writeList(value.organizationalUnits, memberWritingClosure: SSMClientTypes.ResourceDataSyncOrganizationalUnit.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncAwsOrganizationsSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncAwsOrganizationsSource()
        value.organizationSourceType = try reader["OrganizationSourceType"].readIfPresent() ?? ""
        value.organizationalUnits = try reader["OrganizationalUnits"].readListIfPresent(memberReadingClosure: SSMClientTypes.ResourceDataSyncOrganizationalUnit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMClientTypes.ResourceDataSyncOrganizationalUnit {

    static func write(value: SSMClientTypes.ResourceDataSyncOrganizationalUnit?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationalUnitId"].write(value.organizationalUnitId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.ResourceDataSyncOrganizationalUnit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.ResourceDataSyncOrganizationalUnit()
        value.organizationalUnitId = try reader["OrganizationalUnitId"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.DocumentDefaultVersionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMClientTypes.DocumentDefaultVersionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMClientTypes.DocumentDefaultVersionDescription()
        value.name = try reader["Name"].readIfPresent()
        value.defaultVersion = try reader["DefaultVersion"].readIfPresent()
        value.defaultVersionName = try reader["DefaultVersionName"].readIfPresent()
        return value
    }
}

extension SSMClientTypes.RegistrationMetadataItem {

    static func write(value: SSMClientTypes.RegistrationMetadataItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension SSMClientTypes.AttachmentsSource {

    static func write(value: SSMClientTypes.AttachmentsSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.ResourceDataSyncSource {

    static func write(value: SSMClientTypes.ResourceDataSyncSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsOrganizationsSource"].write(value.awsOrganizationsSource, with: SSMClientTypes.ResourceDataSyncAwsOrganizationsSource.write(value:to:))
        try writer["EnableAllOpsDataSources"].write(value.enableAllOpsDataSources)
        try writer["IncludeFutureRegions"].write(value.includeFutureRegions)
        try writer["SourceRegions"].writeList(value.sourceRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
    }
}

extension SSMClientTypes.DescribeActivationsFilter {

    static func write(value: SSMClientTypes.DescribeActivationsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterKey"].write(value.filterKey)
        try writer["FilterValues"].writeList(value.filterValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.AssociationExecutionFilter {

    static func write(value: SSMClientTypes.AssociationExecutionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }
}

extension SSMClientTypes.AssociationExecutionTargetsFilter {

    static func write(value: SSMClientTypes.AssociationExecutionTargetsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension SSMClientTypes.AutomationExecutionFilter {

    static func write(value: SSMClientTypes.AutomationExecutionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.StepExecutionFilter {

    static func write(value: SSMClientTypes.StepExecutionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.PatchOrchestratorFilter {

    static func write(value: SSMClientTypes.PatchOrchestratorFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InstanceInformationFilter {

    static func write(value: SSMClientTypes.InstanceInformationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["valueSet"].writeList(value.valueSet, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InstanceInformationStringFilter {

    static func write(value: SSMClientTypes.InstanceInformationStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InstancePatchStateFilter {

    static func write(value: SSMClientTypes.InstancePatchStateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InstancePropertyFilter {

    static func write(value: SSMClientTypes.InstancePropertyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["valueSet"].writeList(value.valueSet, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InstancePropertyStringFilter {

    static func write(value: SSMClientTypes.InstancePropertyStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.MaintenanceWindowFilter {

    static func write(value: SSMClientTypes.MaintenanceWindowFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.OpsItemFilter {

    static func write(value: SSMClientTypes.OpsItemFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.ParametersFilter {

    static func write(value: SSMClientTypes.ParametersFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.ParameterStringFilter {

    static func write(value: SSMClientTypes.ParameterStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Option"].write(value.option)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.SessionFilter {

    static func write(value: SSMClientTypes.SessionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension SSMClientTypes.BaselineOverride {

    static func write(value: SSMClientTypes.BaselineOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApprovalRules"].write(value.approvalRules, with: SSMClientTypes.PatchRuleGroup.write(value:to:))
        try writer["ApprovedPatches"].writeList(value.approvedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApprovedPatchesComplianceLevel"].write(value.approvedPatchesComplianceLevel)
        try writer["ApprovedPatchesEnableNonSecurity"].write(value.approvedPatchesEnableNonSecurity)
        try writer["GlobalFilters"].write(value.globalFilters, with: SSMClientTypes.PatchFilterGroup.write(value:to:))
        try writer["OperatingSystem"].write(value.operatingSystem)
        try writer["RejectedPatches"].writeList(value.rejectedPatches, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RejectedPatchesAction"].write(value.rejectedPatchesAction)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: SSMClientTypes.PatchSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InventoryFilter {

    static func write(value: SSMClientTypes.InventoryFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InventoryAggregator {

    static func write(value: SSMClientTypes.InventoryAggregator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregators"].writeList(value.aggregators, memberWritingClosure: SSMClientTypes.InventoryAggregator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Expression"].write(value.expression)
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SSMClientTypes.InventoryGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.InventoryGroup {

    static func write(value: SSMClientTypes.InventoryGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.InventoryFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }
}

extension SSMClientTypes.ResultAttribute {

    static func write(value: SSMClientTypes.ResultAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TypeName"].write(value.typeName)
    }
}

extension SSMClientTypes.OpsFilter {

    static func write(value: SSMClientTypes.OpsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.OpsAggregator {

    static func write(value: SSMClientTypes.OpsAggregator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregatorType"].write(value.aggregatorType)
        try writer["Aggregators"].writeList(value.aggregators, memberWritingClosure: SSMClientTypes.OpsAggregator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AttributeName"].write(value.attributeName)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SSMClientTypes.OpsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TypeName"].write(value.typeName)
        try writer["Values"].writeMap(value.values, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SSMClientTypes.OpsResultAttribute {

    static func write(value: SSMClientTypes.OpsResultAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TypeName"].write(value.typeName)
    }
}

extension SSMClientTypes.AssociationFilter {

    static func write(value: SSMClientTypes.AssociationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension SSMClientTypes.CommandFilter {

    static func write(value: SSMClientTypes.CommandFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension SSMClientTypes.ComplianceStringFilter {

    static func write(value: SSMClientTypes.ComplianceStringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.DocumentFilter {

    static func write(value: SSMClientTypes.DocumentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension SSMClientTypes.DocumentKeyValuesFilter {

    static func write(value: SSMClientTypes.DocumentKeyValuesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.OpsItemEventFilter {

    static func write(value: SSMClientTypes.OpsItemEventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.OpsItemRelatedItemsFilter {

    static func write(value: SSMClientTypes.OpsItemRelatedItemsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.OpsMetadataFilter {

    static func write(value: SSMClientTypes.OpsMetadataFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SSMClientTypes.ComplianceItemEntry {

    static func write(value: SSMClientTypes.ComplianceItemEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Details"].writeMap(value.details, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Id"].write(value.id)
        try writer["Severity"].write(value.severity)
        try writer["Status"].write(value.status)
        try writer["Title"].write(value.title)
    }
}

extension SSMClientTypes.InventoryItem {

    static func write(value: SSMClientTypes.InventoryItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CaptureTime"].write(value.captureTime)
        try writer["Content"].writeList(value.content, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["ContentHash"].write(value.contentHash)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SchemaVersion"].write(value.schemaVersion)
        try writer["TypeName"].write(value.typeName)
    }
}

extension SSMClientTypes.DocumentReviews {

    static func write(value: SSMClientTypes.DocumentReviews?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Comment"].writeList(value.comment, memberWritingClosure: SSMClientTypes.DocumentReviewCommentSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum SSMClientTypes {}
