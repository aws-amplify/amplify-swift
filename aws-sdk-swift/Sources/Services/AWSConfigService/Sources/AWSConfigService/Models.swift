//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteAggregationAuthorizationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConfigRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConfigurationAggregatorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConfigurationRecorderOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConformancePackOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDeliveryChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOrganizationConfigRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteOrganizationConformancePackOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePendingAggregationRequestOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourceConfigOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRetentionConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct GetComplianceSummaryByConfigRuleInput: Swift.Sendable {

    public init() { }
}

public struct PutConfigRuleOutput: Swift.Sendable {

    public init() { }
}

public struct PutConfigurationRecorderOutput: Swift.Sendable {

    public init() { }
}

public struct PutDeliveryChannelOutput: Swift.Sendable {

    public init() { }
}

public struct PutResourceConfigOutput: Swift.Sendable {

    public init() { }
}

public struct StartConfigurationRecorderOutput: Swift.Sendable {

    public init() { }
}

public struct StopConfigurationRecorderOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension ConfigClientTypes {

    /// A collection of accounts and regions.
    public struct AccountAggregationSource: Swift.Sendable {
        /// The 12-digit account ID of the account being aggregated.
        /// This member is required.
        public var accountIds: [Swift.String]?
        /// If true, aggregate existing Config regions and future regions.
        public var allAwsRegions: Swift.Bool
        /// The source regions being aggregated.
        public var awsRegions: [Swift.String]?

        public init(
            accountIds: [Swift.String]? = nil,
            allAwsRegions: Swift.Bool = false,
            awsRegions: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
        }
    }
}

extension ConfigClientTypes {

    /// The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item, up to a maximum number.
    public struct ComplianceContributorCount: Swift.Sendable {
        /// Indicates whether the maximum count is reached.
        public var capExceeded: Swift.Bool
        /// The number of Amazon Web Services resources or Config rules responsible for the current compliance of the item.
        public var cappedCount: Swift.Int

        public init(
            capExceeded: Swift.Bool = false,
            cappedCount: Swift.Int = 0
        )
        {
            self.capExceeded = capExceeded
            self.cappedCount = cappedCount
        }
    }
}

extension ConfigClientTypes {

    public enum ComplianceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case insufficientData
        case nonCompliant
        case notApplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceType] {
            return [
                .compliant,
                .insufficientData,
                .nonCompliant,
                .notApplicable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .nonCompliant: return "NON_COMPLIANT"
            case .notApplicable: return "NOT_APPLICABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.
    public struct Compliance: Swift.Sendable {
        /// The number of Amazon Web Services resources or Config rules that cause a result of NON_COMPLIANT, up to a maximum number.
        public var complianceContributorCount: ConfigClientTypes.ComplianceContributorCount?
        /// Indicates whether an Amazon Web Services resource or Config rule is compliant. A resource is compliant if it complies with all of the Config rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules. A rule is compliant if all of the resources that the rule evaluates comply with it. A rule is noncompliant if any of these resources do not comply. Config returns the INSUFFICIENT_DATA value when no evaluation results are available for the Amazon Web Services resource or Config rule. For the Compliance data type, Config supports only COMPLIANT, NON_COMPLIANT, and INSUFFICIENT_DATA values. Config does not support the NOT_APPLICABLE value for the Compliance data type.
        public var complianceType: ConfigClientTypes.ComplianceType?

        public init(
            complianceContributorCount: ConfigClientTypes.ComplianceContributorCount? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil
        )
        {
            self.complianceContributorCount = complianceContributorCount
            self.complianceType = complianceType
        }
    }
}

extension ConfigClientTypes {

    /// Indicates whether an Config rule is compliant based on account ID, region, compliance, and rule name. A rule is compliant if all of the resources that the rule evaluated comply with it. It is noncompliant if any of these resources do not comply.
    public struct AggregateComplianceByConfigRule: Swift.Sendable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// Indicates whether an Amazon Web Services resource or Config rule is compliant and provides the number of contributors that affect the compliance.
        public var compliance: ConfigClientTypes.Compliance?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            compliance: ConfigClientTypes.Compliance? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.configRuleName = configRuleName
        }
    }
}

extension ConfigClientTypes {

    public enum ConformancePackComplianceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case insufficientData
        case nonCompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [ConformancePackComplianceType] {
            return [
                .compliant,
                .insufficientData,
                .nonCompliant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .nonCompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Provides the number of compliant and noncompliant rules within a conformance pack. Also provides the compliance status of the conformance pack and the total rule count which includes compliant rules, noncompliant rules, and rules that cannot be evaluated due to insufficient data. A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.
    public struct AggregateConformancePackCompliance: Swift.Sendable {
        /// The compliance status of the conformance pack.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The number of compliant Config Rules.
        public var compliantRuleCount: Swift.Int
        /// The number of noncompliant Config Rules.
        public var nonCompliantRuleCount: Swift.Int
        /// Total number of compliant rules, noncompliant rules, and the rules that do not have any applicable resources to evaluate upon resulting in insufficient data.
        public var totalRuleCount: Swift.Int

        public init(
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            compliantRuleCount: Swift.Int = 0,
            nonCompliantRuleCount: Swift.Int = 0,
            totalRuleCount: Swift.Int = 0
        )
        {
            self.complianceType = complianceType
            self.compliantRuleCount = compliantRuleCount
            self.nonCompliantRuleCount = nonCompliantRuleCount
            self.totalRuleCount = totalRuleCount
        }
    }
}

extension ConfigClientTypes {

    /// Provides aggregate compliance of the conformance pack. Indicates whether a conformance pack is compliant based on the name of the conformance pack, account ID, and region. A conformance pack is compliant if all of the rules in a conformance packs are compliant. It is noncompliant if any of the rules are not compliant. The compliance status of a conformance pack is INSUFFICIENT_DATA only if all rules within a conformance pack cannot be evaluated due to insufficient data. If some of the rules in a conformance pack are compliant but the compliance status of other rules in that same conformance pack is INSUFFICIENT_DATA, the conformance pack shows compliant.
    public struct AggregateComplianceByConformancePack: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The compliance status of the conformance pack.
        public var compliance: ConfigClientTypes.AggregateConformancePackCompliance?
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            compliance: ConfigClientTypes.AggregateConformancePackCompliance? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.compliance = compliance
            self.conformancePackName = conformancePackName
        }
    }
}

extension ConfigClientTypes {

    /// The number of Config rules or Amazon Web Services resources that are compliant and noncompliant.
    public struct ComplianceSummary: Swift.Sendable {
        /// The time that Config created the compliance summary.
        public var complianceSummaryTimestamp: Foundation.Date?
        /// The number of Config rules or Amazon Web Services resources that are compliant, up to a maximum of 25 for rules and 100 for resources.
        public var compliantResourceCount: ConfigClientTypes.ComplianceContributorCount?
        /// The number of Config rules or Amazon Web Services resources that are noncompliant, up to a maximum of 25 for rules and 100 for resources.
        public var nonCompliantResourceCount: ConfigClientTypes.ComplianceContributorCount?

        public init(
            complianceSummaryTimestamp: Foundation.Date? = nil,
            compliantResourceCount: ConfigClientTypes.ComplianceContributorCount? = nil,
            nonCompliantResourceCount: ConfigClientTypes.ComplianceContributorCount? = nil
        )
        {
            self.complianceSummaryTimestamp = complianceSummaryTimestamp
            self.compliantResourceCount = compliantResourceCount
            self.nonCompliantResourceCount = nonCompliantResourceCount
        }
    }
}

extension ConfigClientTypes {

    /// Returns the number of compliant and noncompliant rules for one or more accounts and regions in an aggregator.
    public struct AggregateComplianceCount: Swift.Sendable {
        /// The number of compliant and noncompliant Config rules.
        public var complianceSummary: ConfigClientTypes.ComplianceSummary?
        /// The 12-digit account ID or region based on the GroupByKey value.
        public var groupName: Swift.String?

        public init(
            complianceSummary: ConfigClientTypes.ComplianceSummary? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }
    }
}

extension ConfigClientTypes {

    /// The number of conformance packs that are compliant and noncompliant.
    public struct AggregateConformancePackComplianceCount: Swift.Sendable {
        /// Number of compliant conformance packs.
        public var compliantConformancePackCount: Swift.Int
        /// Number of noncompliant conformance packs.
        public var nonCompliantConformancePackCount: Swift.Int

        public init(
            compliantConformancePackCount: Swift.Int = 0,
            nonCompliantConformancePackCount: Swift.Int = 0
        )
        {
            self.compliantConformancePackCount = compliantConformancePackCount
            self.nonCompliantConformancePackCount = nonCompliantConformancePackCount
        }
    }
}

extension ConfigClientTypes {

    /// Filters the conformance packs based on an account ID, region, compliance type, and the name of the conformance pack.
    public struct AggregateConformancePackComplianceFilters: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The compliance status of the conformance pack.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.conformancePackName = conformancePackName
        }
    }
}

extension ConfigClientTypes {

    /// Provides a summary of compliance based on either account ID or region.
    public struct AggregateConformancePackComplianceSummary: Swift.Sendable {
        /// Returns an AggregateConformancePackComplianceCount object.
        public var complianceSummary: ConfigClientTypes.AggregateConformancePackComplianceCount?
        /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
        public var groupName: Swift.String?

        public init(
            complianceSummary: ConfigClientTypes.AggregateConformancePackComplianceCount? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.groupName = groupName
        }
    }
}

extension ConfigClientTypes {

    /// Filters the results based on account ID and region.
    public struct AggregateConformancePackComplianceSummaryFilters: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID of the source account.
        public var accountId: Swift.String?
        /// The source Amazon Web Services Region from where the data is aggregated.
        public var awsRegion: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }
    }
}

extension ConfigClientTypes {

    public enum AggregateConformancePackComplianceSummaryGroupKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case awsRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateConformancePackComplianceSummaryGroupKey] {
            return [
                .accountId,
                .awsRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum AggregatedSourceStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case outdated
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedSourceStatusType] {
            return [
                .failed,
                .outdated,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .outdated: return "OUTDATED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum AggregatedSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregatedSourceType] {
            return [
                .account,
                .organization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The current sync status between the source and the aggregator account.
    public struct AggregatedSourceStatus: Swift.Sendable {
        /// The region authorized to collect aggregated data.
        public var awsRegion: Swift.String?
        /// The error code that Config returned when the source account aggregation last failed.
        public var lastErrorCode: Swift.String?
        /// The message indicating that the source account aggregation failed due to an error.
        public var lastErrorMessage: Swift.String?
        /// Filters the last updated status type.
        ///
        /// * Valid value FAILED indicates errors while moving data.
        ///
        /// * Valid value SUCCEEDED indicates the data was successfully moved.
        ///
        /// * Valid value OUTDATED indicates the data is not the most recent.
        public var lastUpdateStatus: ConfigClientTypes.AggregatedSourceStatusType?
        /// The time of the last update.
        public var lastUpdateTime: Foundation.Date?
        /// The source account ID or an organization.
        public var sourceId: Swift.String?
        /// The source account or an organization.
        public var sourceType: ConfigClientTypes.AggregatedSourceType?

        public init(
            awsRegion: Swift.String? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastUpdateStatus: ConfigClientTypes.AggregatedSourceStatusType? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            sourceId: Swift.String? = nil,
            sourceType: ConfigClientTypes.AggregatedSourceType? = nil
        )
        {
            self.awsRegion = awsRegion
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastUpdateStatus = lastUpdateStatus
            self.lastUpdateTime = lastUpdateTime
            self.sourceId = sourceId
            self.sourceType = sourceType
        }
    }
}

extension ConfigClientTypes {

    public enum EvaluationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case detective
        case proactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationMode] {
            return [
                .detective,
                .proactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .detective: return "DETECTIVE"
            case .proactive: return "PROACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Identifies an Config rule that evaluated an Amazon Web Services resource, and provides the type and ID of the resource that the rule evaluated.
    public struct EvaluationResultQualifier: Swift.Sendable {
        /// The name of the Config rule that was used in the evaluation.
        public var configRuleName: Swift.String?
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// The ID of the evaluated Amazon Web Services resource.
        public var resourceId: Swift.String?
        /// The type of Amazon Web Services resource that was evaluated.
        public var resourceType: Swift.String?

        public init(
            configRuleName: Swift.String? = nil,
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.configRuleName = configRuleName
            self.evaluationMode = evaluationMode
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    /// Uniquely identifies an evaluation result.
    public struct EvaluationResultIdentifier: Swift.Sendable {
        /// Identifies an Config rule used to evaluate an Amazon Web Services resource, and provides the type and ID of the evaluated resource.
        public var evaluationResultQualifier: ConfigClientTypes.EvaluationResultQualifier?
        /// The time of the event that triggered the evaluation of your Amazon Web Services resources. The time can indicate when Config delivered a configuration item change notification, or it can indicate when Config delivered the configuration snapshot, depending on which event triggered the evaluation.
        public var orderingTimestamp: Foundation.Date?
        /// A Unique ID for an evaluation result.
        public var resourceEvaluationId: Swift.String?

        public init(
            evaluationResultQualifier: ConfigClientTypes.EvaluationResultQualifier? = nil,
            orderingTimestamp: Foundation.Date? = nil,
            resourceEvaluationId: Swift.String? = nil
        )
        {
            self.evaluationResultQualifier = evaluationResultQualifier
            self.orderingTimestamp = orderingTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }
    }
}

extension ConfigClientTypes {

    /// The details of an Config evaluation for an account ID and region in an aggregator. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information.
    public struct AggregateEvaluationResult: Swift.Sendable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// Supplementary information about how the agrregate evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The source region from where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The resource compliance status. For the AggregationEvaluationResult data type, Config supports only the COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA value.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services resource.
        public var configRuleInvokedTime: Foundation.Date?
        /// Uniquely identifies the evaluation result.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the aggregate evaluation result.
        public var resultRecordedTime: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            annotation: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleInvokedTime: Foundation.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: Foundation.Date? = nil
        )
        {
            self.accountId = accountId
            self.annotation = annotation
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }
    }
}

extension ConfigClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acmpcacertificateauthority
        case acmpcacertificateauthorityactivation
        case apsrulegroupsnamespace
        case accessanalyzeranalyzer
        case accountpublicaccessblock
        case alarm
        case amazonmqbroker
        case amplifyapp
        case amplifybranch
        case api
        case appconfigapplication
        case appconfigconfigurationprofile
        case appconfigdeploymentstrategy
        case appconfigenvironment
        case appconfighostedconfigurationversion
        case appflowflow
        case appintegrationseventintegration
        case appmeshgatewayroute
        case appmeshmesh
        case appmeshroute
        case appmeshvirtualgateway
        case appmeshvirtualnode
        case appmeshvirtualrouter
        case appmeshvirtualservice
        case apprunnerservice
        case apprunnervpcconnector
        case appstreamapplication
        case appstreamdirectoryconfig
        case appstreamfleet
        case appstreamstack
        case appsyncgraphqlapi
        case application
        case applicationversion
        case associationcompliance
        case athenadatacatalog
        case athenapreparedstatement
        case athenaworkgroup
        case auditmanagerassessment
        case autoscalinggroup
        case autoscalingwarmpool
        case backupplan
        case backuprecoverypoint
        case backupreportplan
        case backupselection
        case backupvault
        case batchcomputeenvironment
        case batchjobqueue
        case batchschedulingpolicy
        case bucket
        case budgetsbudgetsaction
        case cassandrakeyspace
        case certificate
        case cloud9environmentec2
        case cloudformationproduct
        case cloudformationprovisionedproduct
        case cloudwatchmetricstream
        case cluster
        case clusterparametergroup
        case clustersecuritygroup
        case clustersnapshot
        case clustersubnetgroup
        case codeartifactrepository
        case codebuildreportgroup
        case codedeployapplication
        case codedeploydeploymentconfig
        case codedeploydeploymentgroup
        case codeguruprofilerprofilinggroup
        case codegurureviewerrepositoryassociation
        case cognitouserpool
        case cognitouserpoolclient
        case cognitouserpoolgroup
        case conformancepackcompliance
        case connectinstance
        case connectphonenumber
        case connectquickconnect
        case customergateway
        case customerprofilesdomain
        case customerprofilesobjecttype
        case dbcluster
        case dbclustersnapshot
        case dbinstance
        case dbsecuritygroup
        case dbsnapshot
        case dbsubnetgroup
        case dmscertificate
        case dmsendpoint
        case dmseventsubscription
        case dmsreplicationsubnetgroup
        case datasynclocationefs
        case datasynclocationfsxlustre
        case datasynclocationfsxwindows
        case datasynclocationhdfs
        case datasynclocationnfs
        case datasynclocationobjectstorage
        case datasynclocations3
        case datasynclocationsmb
        case datasynctask
        case detectivegraph
        case devicefarminstanceprofile
        case devicefarmproject
        case devicefarmtestgridproject
        case distribution
        case domain
        case ec2capacityreservation
        case ec2carriergateway
        case ec2clientvpnendpoint
        case ec2dhcpoptions
        case ec2ec2fleet
        case ec2ipam
        case ec2ipampool
        case ec2ipamscope
        case ec2networkinsightsaccessscope
        case ec2networkinsightsanalysis
        case ec2networkinsightspath
        case ec2prefixlist
        case ec2spotfleet
        case ec2subnetroutetableassociation
        case ec2trafficmirrorfilter
        case ec2trafficmirrorsession
        case ec2trafficmirrortarget
        case ec2transitgatewayconnect
        case ec2transitgatewaymulticastdomain
        case ecrpublicrepository
        case ecrpullthroughcacherule
        case ecrregistrypolicy
        case ecrrepository
        case ecscapacityprovider
        case ecscluster
        case ecsservice
        case ecstaskdefinition
        case ecstaskset
        case efsaccesspoint
        case efsfilesystem
        case eip
        case eksaddon
        case ekscluster
        case eksfargateprofile
        case eksidentityproviderconfig
        case emrsecurityconfiguration
        case egressonlyinternetgateway
        case encryptionconfig
        case environment
        case eventschemasdiscoverer
        case eventschemasregistry
        case eventschemasregistrypolicy
        case eventschemasschema
        case eventsubscription
        case eventsapidestination
        case eventsarchive
        case eventsconnection
        case eventsendpoint
        case eventseventbus
        case eventsrule
        case evidentlylaunch
        case evidentlyproject
        case fisexperimenttemplate
        case filedata
        case flowlog
        case forecastdataset
        case forecastdatasetgroup
        case frauddetectorentitytype
        case frauddetectorlabel
        case frauddetectoroutcome
        case frauddetectorvariable
        case function
        case globalacceleratoraccelerator
        case globalacceleratorendpointgroup
        case globalacceleratorlistener
        case glueclassifier
        case gluejob
        case gluemltransform
        case grafanaworkspace
        case greengrassv2componentversion
        case groundstationconfig
        case groundstationdataflowendpointgroup
        case groundstationmissionprofile
        case group
        case guarddutydetector
        case guarddutyfilter
        case guarddutyipset
        case guarddutythreatintelset
        case healthlakefhirdatastore
        case host
        case iaminstanceprofile
        case iamsamlprovider
        case iamservercertificate
        case ipsetv2
        case ivschannel
        case ivsplaybackkeypair
        case ivsrecordingconfiguration
        case imagebuildercontainerrecipe
        case imagebuilderdistributionconfiguration
        case imagebuilderimagepipeline
        case imagebuilderimagerecipe
        case imagebuilderinfrastructureconfiguration
        case inspectorv2filter
        case instance
        case internetgateway
        case iotaccountauditconfiguration
        case iotanalyticschannel
        case iotanalyticsdataset
        case iotanalyticsdatastore
        case iotanalyticspipeline
        case iotauthorizer
        case iotcacertificate
        case iotcustommetric
        case iotdimension
        case ioteventsalarmmodel
        case ioteventsdetectormodel
        case ioteventsinput
        case iotfleetmetric
        case iotjobtemplate
        case iotmitigationaction
        case iotpolicy
        case iotprovisioningtemplate
        case iotrolealias
        case iotscheduledaudit
        case iotsecurityprofile
        case iotsitewiseassetmodel
        case iotsitewisedashboard
        case iotsitewisegateway
        case iotsitewiseportal
        case iotsitewiseproject
        case iottwinmakercomponenttype
        case iottwinmakerentity
        case iottwinmakerscene
        case iottwinmakersyncjob
        case iottwinmakerworkspace
        case iotwirelessfuotatask
        case iotwirelessmulticastgroup
        case iotwirelessserviceprofile
        case kmsalias
        case kafkaconnectconnector
        case kendraindex
        case key
        case kinesisanalyticsv2application
        case kinesisfirehosedeliverystream
        case kinesisstream
        case kinesisstreamconsumer
        case kinesisvideosignalingchannel
        case kinesisvideostream
        case lambdacodesigningconfig
        case launchconfiguration
        case launchtemplate
        case lexbot
        case lexbotalias
        case lightsailbucket
        case lightsailcertificate
        case lightsaildisk
        case lightsailstaticip
        case listenerv2
        case loadbalancer
        case loadbalancerv2
        case logsdestination
        case lookoutmetricsalert
        case lookoutvisionproject
        case m2environment
        case mskbatchscramsecret
        case mskcluster
        case mskconfiguration
        case managedinstanceinventory
        case managedrulesetv2
        case mediaconnectflowentitlement
        case mediaconnectflowsource
        case mediaconnectflowvpcinterface
        case mediapackagepackagingconfiguration
        case mediapackagepackaginggroup
        case mediatailorplaybackconfiguration
        case natgateway
        case networkacl
        case networkfirewallfirewall
        case networkfirewallfirewallpolicy
        case networkfirewallrulegroup
        case networkinsightsaccessscopeanalysis
        case networkinterface
        case networkmanagerconnectpeer
        case networkmanagercustomergatewayassociation
        case networkmanagerdevice
        case networkmanagerglobalnetwork
        case networkmanagerlink
        case networkmanagerlinkassociation
        case networkmanagersite
        case networkmanagertransitgatewayregistration
        case opensearchdomain
        case panoramapackage
        case patchcompliance
        case personalizedataset
        case personalizedatasetgroup
        case personalizeschema
        case personalizesolution
        case pinpointapp
        case pinpointapplicationsettings
        case pinpointcampaign
        case pinpointemailchannel
        case pinpointemailtemplate
        case pinpointeventstream
        case pinpointinapptemplate
        case pinpointsegment
        case pipeline
        case policy
        case portfolio
        case project
        case protection
        case qldbledger
        case queue
        case quicksightdatasource
        case quicksighttemplate
        case quicksighttheme
        case rdsglobalcluster
        case rdsoptiongroup
        case rumappmonitor
        case ratebasedrule
        case redshiftendpointaccess
        case redshifteventsubscription
        case redshiftscheduledaction
        case regexpatternsetv2
        case regionalprotection
        case regionalratebasedrule
        case regionalrule
        case regionalrulegroup
        case regionalwebacl
        case registeredhainstance
        case resiliencehubapp
        case resiliencehubresiliencypolicy
        case resourcecompliance
        case resourceexplorer2index
        case restapi
        case robomakerrobotapplication
        case robomakerrobotapplicationversion
        case robomakersimulationapplication
        case role
        case route53hostedzone
        case route53recoverycontrolcluster
        case route53recoverycontrolcontrolpanel
        case route53recoverycontrolroutingcontrol
        case route53recoverycontrolsafetyrule
        case route53recoveryreadinesscell
        case route53recoveryreadinessreadinesscheck
        case route53recoveryreadinessrecoverygroup
        case route53recoveryreadinessresourceset
        case route53resolverfirewalldomainlist
        case route53resolverfirewallrulegroup
        case route53resolverfirewallrulegroupassociation
        case route53resolverresolverendpoint
        case route53resolverresolverqueryloggingconfig
        case route53resolverresolverqueryloggingconfigassociation
        case route53resolverresolverrule
        case route53resolverresolverruleassociation
        case routetable
        case rule
        case rulegroup
        case rulegroupv2
        case s3accesspoint
        case s3multiregionaccesspoint
        case s3storagelens
        case sesconfigurationset
        case sescontactlist
        case sesreceiptfilter
        case sesreceiptruleset
        case sestemplate
        case ssmdocument
        case sagemakerappimageconfig
        case sagemakercoderepository
        case sagemakerdomain
        case sagemakerfeaturegroup
        case sagemakerimage
        case sagemakermodel
        case sagemakernotebookinstancelifecycleconfig
        case sagemakerworkteam
        case scalingpolicy
        case scheduledaction
        case secret
        case securitygroup
        case servicediscoveryhttpnamespace
        case servicediscoveryinstance
        case servicediscoverypublicdnsnamespace
        case servicediscoveryservice
        case signersigningprofile
        case stack
        case stage
        case stagev2
        case stepfunctionsactivity
        case stepfunctionsstatemachine
        case streamingdistribution
        case subnet
        case table
        case topic
        case trail
        case transferagreement
        case transfercertificate
        case transferconnector
        case transferworkflow
        case transitgateway
        case transitgatewayattachment
        case transitgatewayroutetable
        case user
        case vpc
        case vpcendpoint
        case vpcendpointservice
        case vpcpeeringconnection
        case vpnconnection
        case vpngateway
        case volume
        case webacl
        case webaclv2
        case workspacesconnectionalias
        case workspacesworkspace
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .acmpcacertificateauthority,
                .acmpcacertificateauthorityactivation,
                .apsrulegroupsnamespace,
                .accessanalyzeranalyzer,
                .accountpublicaccessblock,
                .alarm,
                .amazonmqbroker,
                .amplifyapp,
                .amplifybranch,
                .api,
                .appconfigapplication,
                .appconfigconfigurationprofile,
                .appconfigdeploymentstrategy,
                .appconfigenvironment,
                .appconfighostedconfigurationversion,
                .appflowflow,
                .appintegrationseventintegration,
                .appmeshgatewayroute,
                .appmeshmesh,
                .appmeshroute,
                .appmeshvirtualgateway,
                .appmeshvirtualnode,
                .appmeshvirtualrouter,
                .appmeshvirtualservice,
                .apprunnerservice,
                .apprunnervpcconnector,
                .appstreamapplication,
                .appstreamdirectoryconfig,
                .appstreamfleet,
                .appstreamstack,
                .appsyncgraphqlapi,
                .application,
                .applicationversion,
                .associationcompliance,
                .athenadatacatalog,
                .athenapreparedstatement,
                .athenaworkgroup,
                .auditmanagerassessment,
                .autoscalinggroup,
                .autoscalingwarmpool,
                .backupplan,
                .backuprecoverypoint,
                .backupreportplan,
                .backupselection,
                .backupvault,
                .batchcomputeenvironment,
                .batchjobqueue,
                .batchschedulingpolicy,
                .bucket,
                .budgetsbudgetsaction,
                .cassandrakeyspace,
                .certificate,
                .cloud9environmentec2,
                .cloudformationproduct,
                .cloudformationprovisionedproduct,
                .cloudwatchmetricstream,
                .cluster,
                .clusterparametergroup,
                .clustersecuritygroup,
                .clustersnapshot,
                .clustersubnetgroup,
                .codeartifactrepository,
                .codebuildreportgroup,
                .codedeployapplication,
                .codedeploydeploymentconfig,
                .codedeploydeploymentgroup,
                .codeguruprofilerprofilinggroup,
                .codegurureviewerrepositoryassociation,
                .cognitouserpool,
                .cognitouserpoolclient,
                .cognitouserpoolgroup,
                .conformancepackcompliance,
                .connectinstance,
                .connectphonenumber,
                .connectquickconnect,
                .customergateway,
                .customerprofilesdomain,
                .customerprofilesobjecttype,
                .dbcluster,
                .dbclustersnapshot,
                .dbinstance,
                .dbsecuritygroup,
                .dbsnapshot,
                .dbsubnetgroup,
                .dmscertificate,
                .dmsendpoint,
                .dmseventsubscription,
                .dmsreplicationsubnetgroup,
                .datasynclocationefs,
                .datasynclocationfsxlustre,
                .datasynclocationfsxwindows,
                .datasynclocationhdfs,
                .datasynclocationnfs,
                .datasynclocationobjectstorage,
                .datasynclocations3,
                .datasynclocationsmb,
                .datasynctask,
                .detectivegraph,
                .devicefarminstanceprofile,
                .devicefarmproject,
                .devicefarmtestgridproject,
                .distribution,
                .domain,
                .ec2capacityreservation,
                .ec2carriergateway,
                .ec2clientvpnendpoint,
                .ec2dhcpoptions,
                .ec2ec2fleet,
                .ec2ipam,
                .ec2ipampool,
                .ec2ipamscope,
                .ec2networkinsightsaccessscope,
                .ec2networkinsightsanalysis,
                .ec2networkinsightspath,
                .ec2prefixlist,
                .ec2spotfleet,
                .ec2subnetroutetableassociation,
                .ec2trafficmirrorfilter,
                .ec2trafficmirrorsession,
                .ec2trafficmirrortarget,
                .ec2transitgatewayconnect,
                .ec2transitgatewaymulticastdomain,
                .ecrpublicrepository,
                .ecrpullthroughcacherule,
                .ecrregistrypolicy,
                .ecrrepository,
                .ecscapacityprovider,
                .ecscluster,
                .ecsservice,
                .ecstaskdefinition,
                .ecstaskset,
                .efsaccesspoint,
                .efsfilesystem,
                .eip,
                .eksaddon,
                .ekscluster,
                .eksfargateprofile,
                .eksidentityproviderconfig,
                .emrsecurityconfiguration,
                .egressonlyinternetgateway,
                .encryptionconfig,
                .environment,
                .eventschemasdiscoverer,
                .eventschemasregistry,
                .eventschemasregistrypolicy,
                .eventschemasschema,
                .eventsubscription,
                .eventsapidestination,
                .eventsarchive,
                .eventsconnection,
                .eventsendpoint,
                .eventseventbus,
                .eventsrule,
                .evidentlylaunch,
                .evidentlyproject,
                .fisexperimenttemplate,
                .filedata,
                .flowlog,
                .forecastdataset,
                .forecastdatasetgroup,
                .frauddetectorentitytype,
                .frauddetectorlabel,
                .frauddetectoroutcome,
                .frauddetectorvariable,
                .function,
                .globalacceleratoraccelerator,
                .globalacceleratorendpointgroup,
                .globalacceleratorlistener,
                .glueclassifier,
                .gluejob,
                .gluemltransform,
                .grafanaworkspace,
                .greengrassv2componentversion,
                .groundstationconfig,
                .groundstationdataflowendpointgroup,
                .groundstationmissionprofile,
                .group,
                .guarddutydetector,
                .guarddutyfilter,
                .guarddutyipset,
                .guarddutythreatintelset,
                .healthlakefhirdatastore,
                .host,
                .iaminstanceprofile,
                .iamsamlprovider,
                .iamservercertificate,
                .ipsetv2,
                .ivschannel,
                .ivsplaybackkeypair,
                .ivsrecordingconfiguration,
                .imagebuildercontainerrecipe,
                .imagebuilderdistributionconfiguration,
                .imagebuilderimagepipeline,
                .imagebuilderimagerecipe,
                .imagebuilderinfrastructureconfiguration,
                .inspectorv2filter,
                .instance,
                .internetgateway,
                .iotaccountauditconfiguration,
                .iotanalyticschannel,
                .iotanalyticsdataset,
                .iotanalyticsdatastore,
                .iotanalyticspipeline,
                .iotauthorizer,
                .iotcacertificate,
                .iotcustommetric,
                .iotdimension,
                .ioteventsalarmmodel,
                .ioteventsdetectormodel,
                .ioteventsinput,
                .iotfleetmetric,
                .iotjobtemplate,
                .iotmitigationaction,
                .iotpolicy,
                .iotprovisioningtemplate,
                .iotrolealias,
                .iotscheduledaudit,
                .iotsecurityprofile,
                .iotsitewiseassetmodel,
                .iotsitewisedashboard,
                .iotsitewisegateway,
                .iotsitewiseportal,
                .iotsitewiseproject,
                .iottwinmakercomponenttype,
                .iottwinmakerentity,
                .iottwinmakerscene,
                .iottwinmakersyncjob,
                .iottwinmakerworkspace,
                .iotwirelessfuotatask,
                .iotwirelessmulticastgroup,
                .iotwirelessserviceprofile,
                .kmsalias,
                .kafkaconnectconnector,
                .kendraindex,
                .key,
                .kinesisanalyticsv2application,
                .kinesisfirehosedeliverystream,
                .kinesisstream,
                .kinesisstreamconsumer,
                .kinesisvideosignalingchannel,
                .kinesisvideostream,
                .lambdacodesigningconfig,
                .launchconfiguration,
                .launchtemplate,
                .lexbot,
                .lexbotalias,
                .lightsailbucket,
                .lightsailcertificate,
                .lightsaildisk,
                .lightsailstaticip,
                .listenerv2,
                .loadbalancer,
                .loadbalancerv2,
                .logsdestination,
                .lookoutmetricsalert,
                .lookoutvisionproject,
                .m2environment,
                .mskbatchscramsecret,
                .mskcluster,
                .mskconfiguration,
                .managedinstanceinventory,
                .managedrulesetv2,
                .mediaconnectflowentitlement,
                .mediaconnectflowsource,
                .mediaconnectflowvpcinterface,
                .mediapackagepackagingconfiguration,
                .mediapackagepackaginggroup,
                .mediatailorplaybackconfiguration,
                .natgateway,
                .networkacl,
                .networkfirewallfirewall,
                .networkfirewallfirewallpolicy,
                .networkfirewallrulegroup,
                .networkinsightsaccessscopeanalysis,
                .networkinterface,
                .networkmanagerconnectpeer,
                .networkmanagercustomergatewayassociation,
                .networkmanagerdevice,
                .networkmanagerglobalnetwork,
                .networkmanagerlink,
                .networkmanagerlinkassociation,
                .networkmanagersite,
                .networkmanagertransitgatewayregistration,
                .opensearchdomain,
                .panoramapackage,
                .patchcompliance,
                .personalizedataset,
                .personalizedatasetgroup,
                .personalizeschema,
                .personalizesolution,
                .pinpointapp,
                .pinpointapplicationsettings,
                .pinpointcampaign,
                .pinpointemailchannel,
                .pinpointemailtemplate,
                .pinpointeventstream,
                .pinpointinapptemplate,
                .pinpointsegment,
                .pipeline,
                .policy,
                .portfolio,
                .project,
                .protection,
                .qldbledger,
                .queue,
                .quicksightdatasource,
                .quicksighttemplate,
                .quicksighttheme,
                .rdsglobalcluster,
                .rdsoptiongroup,
                .rumappmonitor,
                .ratebasedrule,
                .redshiftendpointaccess,
                .redshifteventsubscription,
                .redshiftscheduledaction,
                .regexpatternsetv2,
                .regionalprotection,
                .regionalratebasedrule,
                .regionalrule,
                .regionalrulegroup,
                .regionalwebacl,
                .registeredhainstance,
                .resiliencehubapp,
                .resiliencehubresiliencypolicy,
                .resourcecompliance,
                .resourceexplorer2index,
                .restapi,
                .robomakerrobotapplication,
                .robomakerrobotapplicationversion,
                .robomakersimulationapplication,
                .role,
                .route53hostedzone,
                .route53recoverycontrolcluster,
                .route53recoverycontrolcontrolpanel,
                .route53recoverycontrolroutingcontrol,
                .route53recoverycontrolsafetyrule,
                .route53recoveryreadinesscell,
                .route53recoveryreadinessreadinesscheck,
                .route53recoveryreadinessrecoverygroup,
                .route53recoveryreadinessresourceset,
                .route53resolverfirewalldomainlist,
                .route53resolverfirewallrulegroup,
                .route53resolverfirewallrulegroupassociation,
                .route53resolverresolverendpoint,
                .route53resolverresolverqueryloggingconfig,
                .route53resolverresolverqueryloggingconfigassociation,
                .route53resolverresolverrule,
                .route53resolverresolverruleassociation,
                .routetable,
                .rule,
                .rulegroup,
                .rulegroupv2,
                .s3accesspoint,
                .s3multiregionaccesspoint,
                .s3storagelens,
                .sesconfigurationset,
                .sescontactlist,
                .sesreceiptfilter,
                .sesreceiptruleset,
                .sestemplate,
                .ssmdocument,
                .sagemakerappimageconfig,
                .sagemakercoderepository,
                .sagemakerdomain,
                .sagemakerfeaturegroup,
                .sagemakerimage,
                .sagemakermodel,
                .sagemakernotebookinstancelifecycleconfig,
                .sagemakerworkteam,
                .scalingpolicy,
                .scheduledaction,
                .secret,
                .securitygroup,
                .servicediscoveryhttpnamespace,
                .servicediscoveryinstance,
                .servicediscoverypublicdnsnamespace,
                .servicediscoveryservice,
                .signersigningprofile,
                .stack,
                .stage,
                .stagev2,
                .stepfunctionsactivity,
                .stepfunctionsstatemachine,
                .streamingdistribution,
                .subnet,
                .table,
                .topic,
                .trail,
                .transferagreement,
                .transfercertificate,
                .transferconnector,
                .transferworkflow,
                .transitgateway,
                .transitgatewayattachment,
                .transitgatewayroutetable,
                .user,
                .vpc,
                .vpcendpoint,
                .vpcendpointservice,
                .vpcpeeringconnection,
                .vpnconnection,
                .vpngateway,
                .volume,
                .webacl,
                .webaclv2,
                .workspacesconnectionalias,
                .workspacesworkspace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acmpcacertificateauthority: return "AWS::ACMPCA::CertificateAuthority"
            case .acmpcacertificateauthorityactivation: return "AWS::ACMPCA::CertificateAuthorityActivation"
            case .apsrulegroupsnamespace: return "AWS::APS::RuleGroupsNamespace"
            case .accessanalyzeranalyzer: return "AWS::AccessAnalyzer::Analyzer"
            case .accountpublicaccessblock: return "AWS::S3::AccountPublicAccessBlock"
            case .alarm: return "AWS::CloudWatch::Alarm"
            case .amazonmqbroker: return "AWS::AmazonMQ::Broker"
            case .amplifyapp: return "AWS::Amplify::App"
            case .amplifybranch: return "AWS::Amplify::Branch"
            case .api: return "AWS::ApiGatewayV2::Api"
            case .appconfigapplication: return "AWS::AppConfig::Application"
            case .appconfigconfigurationprofile: return "AWS::AppConfig::ConfigurationProfile"
            case .appconfigdeploymentstrategy: return "AWS::AppConfig::DeploymentStrategy"
            case .appconfigenvironment: return "AWS::AppConfig::Environment"
            case .appconfighostedconfigurationversion: return "AWS::AppConfig::HostedConfigurationVersion"
            case .appflowflow: return "AWS::AppFlow::Flow"
            case .appintegrationseventintegration: return "AWS::AppIntegrations::EventIntegration"
            case .appmeshgatewayroute: return "AWS::AppMesh::GatewayRoute"
            case .appmeshmesh: return "AWS::AppMesh::Mesh"
            case .appmeshroute: return "AWS::AppMesh::Route"
            case .appmeshvirtualgateway: return "AWS::AppMesh::VirtualGateway"
            case .appmeshvirtualnode: return "AWS::AppMesh::VirtualNode"
            case .appmeshvirtualrouter: return "AWS::AppMesh::VirtualRouter"
            case .appmeshvirtualservice: return "AWS::AppMesh::VirtualService"
            case .apprunnerservice: return "AWS::AppRunner::Service"
            case .apprunnervpcconnector: return "AWS::AppRunner::VpcConnector"
            case .appstreamapplication: return "AWS::AppStream::Application"
            case .appstreamdirectoryconfig: return "AWS::AppStream::DirectoryConfig"
            case .appstreamfleet: return "AWS::AppStream::Fleet"
            case .appstreamstack: return "AWS::AppStream::Stack"
            case .appsyncgraphqlapi: return "AWS::AppSync::GraphQLApi"
            case .application: return "AWS::ElasticBeanstalk::Application"
            case .applicationversion: return "AWS::ElasticBeanstalk::ApplicationVersion"
            case .associationcompliance: return "AWS::SSM::AssociationCompliance"
            case .athenadatacatalog: return "AWS::Athena::DataCatalog"
            case .athenapreparedstatement: return "AWS::Athena::PreparedStatement"
            case .athenaworkgroup: return "AWS::Athena::WorkGroup"
            case .auditmanagerassessment: return "AWS::AuditManager::Assessment"
            case .autoscalinggroup: return "AWS::AutoScaling::AutoScalingGroup"
            case .autoscalingwarmpool: return "AWS::AutoScaling::WarmPool"
            case .backupplan: return "AWS::Backup::BackupPlan"
            case .backuprecoverypoint: return "AWS::Backup::RecoveryPoint"
            case .backupreportplan: return "AWS::Backup::ReportPlan"
            case .backupselection: return "AWS::Backup::BackupSelection"
            case .backupvault: return "AWS::Backup::BackupVault"
            case .batchcomputeenvironment: return "AWS::Batch::ComputeEnvironment"
            case .batchjobqueue: return "AWS::Batch::JobQueue"
            case .batchschedulingpolicy: return "AWS::Batch::SchedulingPolicy"
            case .bucket: return "AWS::S3::Bucket"
            case .budgetsbudgetsaction: return "AWS::Budgets::BudgetsAction"
            case .cassandrakeyspace: return "AWS::Cassandra::Keyspace"
            case .certificate: return "AWS::ACM::Certificate"
            case .cloud9environmentec2: return "AWS::Cloud9::EnvironmentEC2"
            case .cloudformationproduct: return "AWS::ServiceCatalog::CloudFormationProduct"
            case .cloudformationprovisionedproduct: return "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
            case .cloudwatchmetricstream: return "AWS::CloudWatch::MetricStream"
            case .cluster: return "AWS::Redshift::Cluster"
            case .clusterparametergroup: return "AWS::Redshift::ClusterParameterGroup"
            case .clustersecuritygroup: return "AWS::Redshift::ClusterSecurityGroup"
            case .clustersnapshot: return "AWS::Redshift::ClusterSnapshot"
            case .clustersubnetgroup: return "AWS::Redshift::ClusterSubnetGroup"
            case .codeartifactrepository: return "AWS::CodeArtifact::Repository"
            case .codebuildreportgroup: return "AWS::CodeBuild::ReportGroup"
            case .codedeployapplication: return "AWS::CodeDeploy::Application"
            case .codedeploydeploymentconfig: return "AWS::CodeDeploy::DeploymentConfig"
            case .codedeploydeploymentgroup: return "AWS::CodeDeploy::DeploymentGroup"
            case .codeguruprofilerprofilinggroup: return "AWS::CodeGuruProfiler::ProfilingGroup"
            case .codegurureviewerrepositoryassociation: return "AWS::CodeGuruReviewer::RepositoryAssociation"
            case .cognitouserpool: return "AWS::Cognito::UserPool"
            case .cognitouserpoolclient: return "AWS::Cognito::UserPoolClient"
            case .cognitouserpoolgroup: return "AWS::Cognito::UserPoolGroup"
            case .conformancepackcompliance: return "AWS::Config::ConformancePackCompliance"
            case .connectinstance: return "AWS::Connect::Instance"
            case .connectphonenumber: return "AWS::Connect::PhoneNumber"
            case .connectquickconnect: return "AWS::Connect::QuickConnect"
            case .customergateway: return "AWS::EC2::CustomerGateway"
            case .customerprofilesdomain: return "AWS::CustomerProfiles::Domain"
            case .customerprofilesobjecttype: return "AWS::CustomerProfiles::ObjectType"
            case .dbcluster: return "AWS::RDS::DBCluster"
            case .dbclustersnapshot: return "AWS::RDS::DBClusterSnapshot"
            case .dbinstance: return "AWS::RDS::DBInstance"
            case .dbsecuritygroup: return "AWS::RDS::DBSecurityGroup"
            case .dbsnapshot: return "AWS::RDS::DBSnapshot"
            case .dbsubnetgroup: return "AWS::RDS::DBSubnetGroup"
            case .dmscertificate: return "AWS::DMS::Certificate"
            case .dmsendpoint: return "AWS::DMS::Endpoint"
            case .dmseventsubscription: return "AWS::DMS::EventSubscription"
            case .dmsreplicationsubnetgroup: return "AWS::DMS::ReplicationSubnetGroup"
            case .datasynclocationefs: return "AWS::DataSync::LocationEFS"
            case .datasynclocationfsxlustre: return "AWS::DataSync::LocationFSxLustre"
            case .datasynclocationfsxwindows: return "AWS::DataSync::LocationFSxWindows"
            case .datasynclocationhdfs: return "AWS::DataSync::LocationHDFS"
            case .datasynclocationnfs: return "AWS::DataSync::LocationNFS"
            case .datasynclocationobjectstorage: return "AWS::DataSync::LocationObjectStorage"
            case .datasynclocations3: return "AWS::DataSync::LocationS3"
            case .datasynclocationsmb: return "AWS::DataSync::LocationSMB"
            case .datasynctask: return "AWS::DataSync::Task"
            case .detectivegraph: return "AWS::Detective::Graph"
            case .devicefarminstanceprofile: return "AWS::DeviceFarm::InstanceProfile"
            case .devicefarmproject: return "AWS::DeviceFarm::Project"
            case .devicefarmtestgridproject: return "AWS::DeviceFarm::TestGridProject"
            case .distribution: return "AWS::CloudFront::Distribution"
            case .domain: return "AWS::Elasticsearch::Domain"
            case .ec2capacityreservation: return "AWS::EC2::CapacityReservation"
            case .ec2carriergateway: return "AWS::EC2::CarrierGateway"
            case .ec2clientvpnendpoint: return "AWS::EC2::ClientVpnEndpoint"
            case .ec2dhcpoptions: return "AWS::EC2::DHCPOptions"
            case .ec2ec2fleet: return "AWS::EC2::EC2Fleet"
            case .ec2ipam: return "AWS::EC2::IPAM"
            case .ec2ipampool: return "AWS::EC2::IPAMPool"
            case .ec2ipamscope: return "AWS::EC2::IPAMScope"
            case .ec2networkinsightsaccessscope: return "AWS::EC2::NetworkInsightsAccessScope"
            case .ec2networkinsightsanalysis: return "AWS::EC2::NetworkInsightsAnalysis"
            case .ec2networkinsightspath: return "AWS::EC2::NetworkInsightsPath"
            case .ec2prefixlist: return "AWS::EC2::PrefixList"
            case .ec2spotfleet: return "AWS::EC2::SpotFleet"
            case .ec2subnetroutetableassociation: return "AWS::EC2::SubnetRouteTableAssociation"
            case .ec2trafficmirrorfilter: return "AWS::EC2::TrafficMirrorFilter"
            case .ec2trafficmirrorsession: return "AWS::EC2::TrafficMirrorSession"
            case .ec2trafficmirrortarget: return "AWS::EC2::TrafficMirrorTarget"
            case .ec2transitgatewayconnect: return "AWS::EC2::TransitGatewayConnect"
            case .ec2transitgatewaymulticastdomain: return "AWS::EC2::TransitGatewayMulticastDomain"
            case .ecrpublicrepository: return "AWS::ECR::PublicRepository"
            case .ecrpullthroughcacherule: return "AWS::ECR::PullThroughCacheRule"
            case .ecrregistrypolicy: return "AWS::ECR::RegistryPolicy"
            case .ecrrepository: return "AWS::ECR::Repository"
            case .ecscapacityprovider: return "AWS::ECS::CapacityProvider"
            case .ecscluster: return "AWS::ECS::Cluster"
            case .ecsservice: return "AWS::ECS::Service"
            case .ecstaskdefinition: return "AWS::ECS::TaskDefinition"
            case .ecstaskset: return "AWS::ECS::TaskSet"
            case .efsaccesspoint: return "AWS::EFS::AccessPoint"
            case .efsfilesystem: return "AWS::EFS::FileSystem"
            case .eip: return "AWS::EC2::EIP"
            case .eksaddon: return "AWS::EKS::Addon"
            case .ekscluster: return "AWS::EKS::Cluster"
            case .eksfargateprofile: return "AWS::EKS::FargateProfile"
            case .eksidentityproviderconfig: return "AWS::EKS::IdentityProviderConfig"
            case .emrsecurityconfiguration: return "AWS::EMR::SecurityConfiguration"
            case .egressonlyinternetgateway: return "AWS::EC2::EgressOnlyInternetGateway"
            case .encryptionconfig: return "AWS::XRay::EncryptionConfig"
            case .environment: return "AWS::ElasticBeanstalk::Environment"
            case .eventschemasdiscoverer: return "AWS::EventSchemas::Discoverer"
            case .eventschemasregistry: return "AWS::EventSchemas::Registry"
            case .eventschemasregistrypolicy: return "AWS::EventSchemas::RegistryPolicy"
            case .eventschemasschema: return "AWS::EventSchemas::Schema"
            case .eventsubscription: return "AWS::RDS::EventSubscription"
            case .eventsapidestination: return "AWS::Events::ApiDestination"
            case .eventsarchive: return "AWS::Events::Archive"
            case .eventsconnection: return "AWS::Events::Connection"
            case .eventsendpoint: return "AWS::Events::Endpoint"
            case .eventseventbus: return "AWS::Events::EventBus"
            case .eventsrule: return "AWS::Events::Rule"
            case .evidentlylaunch: return "AWS::Evidently::Launch"
            case .evidentlyproject: return "AWS::Evidently::Project"
            case .fisexperimenttemplate: return "AWS::FIS::ExperimentTemplate"
            case .filedata: return "AWS::SSM::FileData"
            case .flowlog: return "AWS::EC2::FlowLog"
            case .forecastdataset: return "AWS::Forecast::Dataset"
            case .forecastdatasetgroup: return "AWS::Forecast::DatasetGroup"
            case .frauddetectorentitytype: return "AWS::FraudDetector::EntityType"
            case .frauddetectorlabel: return "AWS::FraudDetector::Label"
            case .frauddetectoroutcome: return "AWS::FraudDetector::Outcome"
            case .frauddetectorvariable: return "AWS::FraudDetector::Variable"
            case .function: return "AWS::Lambda::Function"
            case .globalacceleratoraccelerator: return "AWS::GlobalAccelerator::Accelerator"
            case .globalacceleratorendpointgroup: return "AWS::GlobalAccelerator::EndpointGroup"
            case .globalacceleratorlistener: return "AWS::GlobalAccelerator::Listener"
            case .glueclassifier: return "AWS::Glue::Classifier"
            case .gluejob: return "AWS::Glue::Job"
            case .gluemltransform: return "AWS::Glue::MLTransform"
            case .grafanaworkspace: return "AWS::Grafana::Workspace"
            case .greengrassv2componentversion: return "AWS::GreengrassV2::ComponentVersion"
            case .groundstationconfig: return "AWS::GroundStation::Config"
            case .groundstationdataflowendpointgroup: return "AWS::GroundStation::DataflowEndpointGroup"
            case .groundstationmissionprofile: return "AWS::GroundStation::MissionProfile"
            case .group: return "AWS::IAM::Group"
            case .guarddutydetector: return "AWS::GuardDuty::Detector"
            case .guarddutyfilter: return "AWS::GuardDuty::Filter"
            case .guarddutyipset: return "AWS::GuardDuty::IPSet"
            case .guarddutythreatintelset: return "AWS::GuardDuty::ThreatIntelSet"
            case .healthlakefhirdatastore: return "AWS::HealthLake::FHIRDatastore"
            case .host: return "AWS::EC2::Host"
            case .iaminstanceprofile: return "AWS::IAM::InstanceProfile"
            case .iamsamlprovider: return "AWS::IAM::SAMLProvider"
            case .iamservercertificate: return "AWS::IAM::ServerCertificate"
            case .ipsetv2: return "AWS::WAFv2::IPSet"
            case .ivschannel: return "AWS::IVS::Channel"
            case .ivsplaybackkeypair: return "AWS::IVS::PlaybackKeyPair"
            case .ivsrecordingconfiguration: return "AWS::IVS::RecordingConfiguration"
            case .imagebuildercontainerrecipe: return "AWS::ImageBuilder::ContainerRecipe"
            case .imagebuilderdistributionconfiguration: return "AWS::ImageBuilder::DistributionConfiguration"
            case .imagebuilderimagepipeline: return "AWS::ImageBuilder::ImagePipeline"
            case .imagebuilderimagerecipe: return "AWS::ImageBuilder::ImageRecipe"
            case .imagebuilderinfrastructureconfiguration: return "AWS::ImageBuilder::InfrastructureConfiguration"
            case .inspectorv2filter: return "AWS::InspectorV2::Filter"
            case .instance: return "AWS::EC2::Instance"
            case .internetgateway: return "AWS::EC2::InternetGateway"
            case .iotaccountauditconfiguration: return "AWS::IoT::AccountAuditConfiguration"
            case .iotanalyticschannel: return "AWS::IoTAnalytics::Channel"
            case .iotanalyticsdataset: return "AWS::IoTAnalytics::Dataset"
            case .iotanalyticsdatastore: return "AWS::IoTAnalytics::Datastore"
            case .iotanalyticspipeline: return "AWS::IoTAnalytics::Pipeline"
            case .iotauthorizer: return "AWS::IoT::Authorizer"
            case .iotcacertificate: return "AWS::IoT::CACertificate"
            case .iotcustommetric: return "AWS::IoT::CustomMetric"
            case .iotdimension: return "AWS::IoT::Dimension"
            case .ioteventsalarmmodel: return "AWS::IoTEvents::AlarmModel"
            case .ioteventsdetectormodel: return "AWS::IoTEvents::DetectorModel"
            case .ioteventsinput: return "AWS::IoTEvents::Input"
            case .iotfleetmetric: return "AWS::IoT::FleetMetric"
            case .iotjobtemplate: return "AWS::IoT::JobTemplate"
            case .iotmitigationaction: return "AWS::IoT::MitigationAction"
            case .iotpolicy: return "AWS::IoT::Policy"
            case .iotprovisioningtemplate: return "AWS::IoT::ProvisioningTemplate"
            case .iotrolealias: return "AWS::IoT::RoleAlias"
            case .iotscheduledaudit: return "AWS::IoT::ScheduledAudit"
            case .iotsecurityprofile: return "AWS::IoT::SecurityProfile"
            case .iotsitewiseassetmodel: return "AWS::IoTSiteWise::AssetModel"
            case .iotsitewisedashboard: return "AWS::IoTSiteWise::Dashboard"
            case .iotsitewisegateway: return "AWS::IoTSiteWise::Gateway"
            case .iotsitewiseportal: return "AWS::IoTSiteWise::Portal"
            case .iotsitewiseproject: return "AWS::IoTSiteWise::Project"
            case .iottwinmakercomponenttype: return "AWS::IoTTwinMaker::ComponentType"
            case .iottwinmakerentity: return "AWS::IoTTwinMaker::Entity"
            case .iottwinmakerscene: return "AWS::IoTTwinMaker::Scene"
            case .iottwinmakersyncjob: return "AWS::IoTTwinMaker::SyncJob"
            case .iottwinmakerworkspace: return "AWS::IoTTwinMaker::Workspace"
            case .iotwirelessfuotatask: return "AWS::IoTWireless::FuotaTask"
            case .iotwirelessmulticastgroup: return "AWS::IoTWireless::MulticastGroup"
            case .iotwirelessserviceprofile: return "AWS::IoTWireless::ServiceProfile"
            case .kmsalias: return "AWS::KMS::Alias"
            case .kafkaconnectconnector: return "AWS::KafkaConnect::Connector"
            case .kendraindex: return "AWS::Kendra::Index"
            case .key: return "AWS::KMS::Key"
            case .kinesisanalyticsv2application: return "AWS::KinesisAnalyticsV2::Application"
            case .kinesisfirehosedeliverystream: return "AWS::KinesisFirehose::DeliveryStream"
            case .kinesisstream: return "AWS::Kinesis::Stream"
            case .kinesisstreamconsumer: return "AWS::Kinesis::StreamConsumer"
            case .kinesisvideosignalingchannel: return "AWS::KinesisVideo::SignalingChannel"
            case .kinesisvideostream: return "AWS::KinesisVideo::Stream"
            case .lambdacodesigningconfig: return "AWS::Lambda::CodeSigningConfig"
            case .launchconfiguration: return "AWS::AutoScaling::LaunchConfiguration"
            case .launchtemplate: return "AWS::EC2::LaunchTemplate"
            case .lexbot: return "AWS::Lex::Bot"
            case .lexbotalias: return "AWS::Lex::BotAlias"
            case .lightsailbucket: return "AWS::Lightsail::Bucket"
            case .lightsailcertificate: return "AWS::Lightsail::Certificate"
            case .lightsaildisk: return "AWS::Lightsail::Disk"
            case .lightsailstaticip: return "AWS::Lightsail::StaticIp"
            case .listenerv2: return "AWS::ElasticLoadBalancingV2::Listener"
            case .loadbalancer: return "AWS::ElasticLoadBalancing::LoadBalancer"
            case .loadbalancerv2: return "AWS::ElasticLoadBalancingV2::LoadBalancer"
            case .logsdestination: return "AWS::Logs::Destination"
            case .lookoutmetricsalert: return "AWS::LookoutMetrics::Alert"
            case .lookoutvisionproject: return "AWS::LookoutVision::Project"
            case .m2environment: return "AWS::M2::Environment"
            case .mskbatchscramsecret: return "AWS::MSK::BatchScramSecret"
            case .mskcluster: return "AWS::MSK::Cluster"
            case .mskconfiguration: return "AWS::MSK::Configuration"
            case .managedinstanceinventory: return "AWS::SSM::ManagedInstanceInventory"
            case .managedrulesetv2: return "AWS::WAFv2::ManagedRuleSet"
            case .mediaconnectflowentitlement: return "AWS::MediaConnect::FlowEntitlement"
            case .mediaconnectflowsource: return "AWS::MediaConnect::FlowSource"
            case .mediaconnectflowvpcinterface: return "AWS::MediaConnect::FlowVpcInterface"
            case .mediapackagepackagingconfiguration: return "AWS::MediaPackage::PackagingConfiguration"
            case .mediapackagepackaginggroup: return "AWS::MediaPackage::PackagingGroup"
            case .mediatailorplaybackconfiguration: return "AWS::MediaTailor::PlaybackConfiguration"
            case .natgateway: return "AWS::EC2::NatGateway"
            case .networkacl: return "AWS::EC2::NetworkAcl"
            case .networkfirewallfirewall: return "AWS::NetworkFirewall::Firewall"
            case .networkfirewallfirewallpolicy: return "AWS::NetworkFirewall::FirewallPolicy"
            case .networkfirewallrulegroup: return "AWS::NetworkFirewall::RuleGroup"
            case .networkinsightsaccessscopeanalysis: return "AWS::EC2::NetworkInsightsAccessScopeAnalysis"
            case .networkinterface: return "AWS::EC2::NetworkInterface"
            case .networkmanagerconnectpeer: return "AWS::NetworkManager::ConnectPeer"
            case .networkmanagercustomergatewayassociation: return "AWS::NetworkManager::CustomerGatewayAssociation"
            case .networkmanagerdevice: return "AWS::NetworkManager::Device"
            case .networkmanagerglobalnetwork: return "AWS::NetworkManager::GlobalNetwork"
            case .networkmanagerlink: return "AWS::NetworkManager::Link"
            case .networkmanagerlinkassociation: return "AWS::NetworkManager::LinkAssociation"
            case .networkmanagersite: return "AWS::NetworkManager::Site"
            case .networkmanagertransitgatewayregistration: return "AWS::NetworkManager::TransitGatewayRegistration"
            case .opensearchdomain: return "AWS::OpenSearch::Domain"
            case .panoramapackage: return "AWS::Panorama::Package"
            case .patchcompliance: return "AWS::SSM::PatchCompliance"
            case .personalizedataset: return "AWS::Personalize::Dataset"
            case .personalizedatasetgroup: return "AWS::Personalize::DatasetGroup"
            case .personalizeschema: return "AWS::Personalize::Schema"
            case .personalizesolution: return "AWS::Personalize::Solution"
            case .pinpointapp: return "AWS::Pinpoint::App"
            case .pinpointapplicationsettings: return "AWS::Pinpoint::ApplicationSettings"
            case .pinpointcampaign: return "AWS::Pinpoint::Campaign"
            case .pinpointemailchannel: return "AWS::Pinpoint::EmailChannel"
            case .pinpointemailtemplate: return "AWS::Pinpoint::EmailTemplate"
            case .pinpointeventstream: return "AWS::Pinpoint::EventStream"
            case .pinpointinapptemplate: return "AWS::Pinpoint::InAppTemplate"
            case .pinpointsegment: return "AWS::Pinpoint::Segment"
            case .pipeline: return "AWS::CodePipeline::Pipeline"
            case .policy: return "AWS::IAM::Policy"
            case .portfolio: return "AWS::ServiceCatalog::Portfolio"
            case .project: return "AWS::CodeBuild::Project"
            case .protection: return "AWS::Shield::Protection"
            case .qldbledger: return "AWS::QLDB::Ledger"
            case .queue: return "AWS::SQS::Queue"
            case .quicksightdatasource: return "AWS::QuickSight::DataSource"
            case .quicksighttemplate: return "AWS::QuickSight::Template"
            case .quicksighttheme: return "AWS::QuickSight::Theme"
            case .rdsglobalcluster: return "AWS::RDS::GlobalCluster"
            case .rdsoptiongroup: return "AWS::RDS::OptionGroup"
            case .rumappmonitor: return "AWS::RUM::AppMonitor"
            case .ratebasedrule: return "AWS::WAF::RateBasedRule"
            case .redshiftendpointaccess: return "AWS::Redshift::EndpointAccess"
            case .redshifteventsubscription: return "AWS::Redshift::EventSubscription"
            case .redshiftscheduledaction: return "AWS::Redshift::ScheduledAction"
            case .regexpatternsetv2: return "AWS::WAFv2::RegexPatternSet"
            case .regionalprotection: return "AWS::ShieldRegional::Protection"
            case .regionalratebasedrule: return "AWS::WAFRegional::RateBasedRule"
            case .regionalrule: return "AWS::WAFRegional::Rule"
            case .regionalrulegroup: return "AWS::WAFRegional::RuleGroup"
            case .regionalwebacl: return "AWS::WAFRegional::WebACL"
            case .registeredhainstance: return "AWS::EC2::RegisteredHAInstance"
            case .resiliencehubapp: return "AWS::ResilienceHub::App"
            case .resiliencehubresiliencypolicy: return "AWS::ResilienceHub::ResiliencyPolicy"
            case .resourcecompliance: return "AWS::Config::ResourceCompliance"
            case .resourceexplorer2index: return "AWS::ResourceExplorer2::Index"
            case .restapi: return "AWS::ApiGateway::RestApi"
            case .robomakerrobotapplication: return "AWS::RoboMaker::RobotApplication"
            case .robomakerrobotapplicationversion: return "AWS::RoboMaker::RobotApplicationVersion"
            case .robomakersimulationapplication: return "AWS::RoboMaker::SimulationApplication"
            case .role: return "AWS::IAM::Role"
            case .route53hostedzone: return "AWS::Route53::HostedZone"
            case .route53recoverycontrolcluster: return "AWS::Route53RecoveryControl::Cluster"
            case .route53recoverycontrolcontrolpanel: return "AWS::Route53RecoveryControl::ControlPanel"
            case .route53recoverycontrolroutingcontrol: return "AWS::Route53RecoveryControl::RoutingControl"
            case .route53recoverycontrolsafetyrule: return "AWS::Route53RecoveryControl::SafetyRule"
            case .route53recoveryreadinesscell: return "AWS::Route53RecoveryReadiness::Cell"
            case .route53recoveryreadinessreadinesscheck: return "AWS::Route53RecoveryReadiness::ReadinessCheck"
            case .route53recoveryreadinessrecoverygroup: return "AWS::Route53RecoveryReadiness::RecoveryGroup"
            case .route53recoveryreadinessresourceset: return "AWS::Route53RecoveryReadiness::ResourceSet"
            case .route53resolverfirewalldomainlist: return "AWS::Route53Resolver::FirewallDomainList"
            case .route53resolverfirewallrulegroup: return "AWS::Route53Resolver::FirewallRuleGroup"
            case .route53resolverfirewallrulegroupassociation: return "AWS::Route53Resolver::FirewallRuleGroupAssociation"
            case .route53resolverresolverendpoint: return "AWS::Route53Resolver::ResolverEndpoint"
            case .route53resolverresolverqueryloggingconfig: return "AWS::Route53Resolver::ResolverQueryLoggingConfig"
            case .route53resolverresolverqueryloggingconfigassociation: return "AWS::Route53Resolver::ResolverQueryLoggingConfigAssociation"
            case .route53resolverresolverrule: return "AWS::Route53Resolver::ResolverRule"
            case .route53resolverresolverruleassociation: return "AWS::Route53Resolver::ResolverRuleAssociation"
            case .routetable: return "AWS::EC2::RouteTable"
            case .rule: return "AWS::WAF::Rule"
            case .rulegroup: return "AWS::WAF::RuleGroup"
            case .rulegroupv2: return "AWS::WAFv2::RuleGroup"
            case .s3accesspoint: return "AWS::S3::AccessPoint"
            case .s3multiregionaccesspoint: return "AWS::S3::MultiRegionAccessPoint"
            case .s3storagelens: return "AWS::S3::StorageLens"
            case .sesconfigurationset: return "AWS::SES::ConfigurationSet"
            case .sescontactlist: return "AWS::SES::ContactList"
            case .sesreceiptfilter: return "AWS::SES::ReceiptFilter"
            case .sesreceiptruleset: return "AWS::SES::ReceiptRuleSet"
            case .sestemplate: return "AWS::SES::Template"
            case .ssmdocument: return "AWS::SSM::Document"
            case .sagemakerappimageconfig: return "AWS::SageMaker::AppImageConfig"
            case .sagemakercoderepository: return "AWS::SageMaker::CodeRepository"
            case .sagemakerdomain: return "AWS::SageMaker::Domain"
            case .sagemakerfeaturegroup: return "AWS::SageMaker::FeatureGroup"
            case .sagemakerimage: return "AWS::SageMaker::Image"
            case .sagemakermodel: return "AWS::SageMaker::Model"
            case .sagemakernotebookinstancelifecycleconfig: return "AWS::SageMaker::NotebookInstanceLifecycleConfig"
            case .sagemakerworkteam: return "AWS::SageMaker::Workteam"
            case .scalingpolicy: return "AWS::AutoScaling::ScalingPolicy"
            case .scheduledaction: return "AWS::AutoScaling::ScheduledAction"
            case .secret: return "AWS::SecretsManager::Secret"
            case .securitygroup: return "AWS::EC2::SecurityGroup"
            case .servicediscoveryhttpnamespace: return "AWS::ServiceDiscovery::HttpNamespace"
            case .servicediscoveryinstance: return "AWS::ServiceDiscovery::Instance"
            case .servicediscoverypublicdnsnamespace: return "AWS::ServiceDiscovery::PublicDnsNamespace"
            case .servicediscoveryservice: return "AWS::ServiceDiscovery::Service"
            case .signersigningprofile: return "AWS::Signer::SigningProfile"
            case .stack: return "AWS::CloudFormation::Stack"
            case .stage: return "AWS::ApiGateway::Stage"
            case .stagev2: return "AWS::ApiGatewayV2::Stage"
            case .stepfunctionsactivity: return "AWS::StepFunctions::Activity"
            case .stepfunctionsstatemachine: return "AWS::StepFunctions::StateMachine"
            case .streamingdistribution: return "AWS::CloudFront::StreamingDistribution"
            case .subnet: return "AWS::EC2::Subnet"
            case .table: return "AWS::DynamoDB::Table"
            case .topic: return "AWS::SNS::Topic"
            case .trail: return "AWS::CloudTrail::Trail"
            case .transferagreement: return "AWS::Transfer::Agreement"
            case .transfercertificate: return "AWS::Transfer::Certificate"
            case .transferconnector: return "AWS::Transfer::Connector"
            case .transferworkflow: return "AWS::Transfer::Workflow"
            case .transitgateway: return "AWS::EC2::TransitGateway"
            case .transitgatewayattachment: return "AWS::EC2::TransitGatewayAttachment"
            case .transitgatewayroutetable: return "AWS::EC2::TransitGatewayRouteTable"
            case .user: return "AWS::IAM::User"
            case .vpc: return "AWS::EC2::VPC"
            case .vpcendpoint: return "AWS::EC2::VPCEndpoint"
            case .vpcendpointservice: return "AWS::EC2::VPCEndpointService"
            case .vpcpeeringconnection: return "AWS::EC2::VPCPeeringConnection"
            case .vpnconnection: return "AWS::EC2::VPNConnection"
            case .vpngateway: return "AWS::EC2::VPNGateway"
            case .volume: return "AWS::EC2::Volume"
            case .webacl: return "AWS::WAF::WebACL"
            case .webaclv2: return "AWS::WAFv2::WebACL"
            case .workspacesconnectionalias: return "AWS::WorkSpaces::ConnectionAlias"
            case .workspacesworkspace: return "AWS::WorkSpaces::Workspace"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The details that identify a resource that is collected by Config aggregator, including the resource type, ID, (if available) the custom resource name, the source account, and source region.
    public struct AggregateResourceIdentifier: Swift.Sendable {
        /// The ID of the Amazon Web Services resource.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The name of the Amazon Web Services resource.
        public var resourceName: Swift.String?
        /// The type of the Amazon Web Services resource.
        /// This member is required.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// The 12-digit account ID of the source account.
        /// This member is required.
        public var sourceAccountId: Swift.String?
        /// The source region where data is aggregated.
        /// This member is required.
        public var sourceRegion: Swift.String?

        public init(
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            sourceAccountId: Swift.String? = nil,
            sourceRegion: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.sourceAccountId = sourceAccountId
            self.sourceRegion = sourceRegion
        }
    }
}

extension ConfigClientTypes {

    /// An object that represents the authorizations granted to aggregator accounts and regions.
    public struct AggregationAuthorization: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the aggregation object.
        public var aggregationAuthorizationArn: Swift.String?
        /// The 12-digit account ID of the account authorized to aggregate data.
        public var authorizedAccountId: Swift.String?
        /// The region authorized to collect aggregated data.
        public var authorizedAwsRegion: Swift.String?
        /// The time stamp when the aggregation authorization was created.
        public var creationTime: Foundation.Date?

        public init(
            aggregationAuthorizationArn: Swift.String? = nil,
            authorizedAccountId: Swift.String? = nil,
            authorizedAwsRegion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil
        )
        {
            self.aggregationAuthorizationArn = aggregationAuthorizationArn
            self.authorizedAccountId = authorizedAccountId
            self.authorizedAwsRegion = authorizedAwsRegion
            self.creationTime = creationTime
        }
    }
}

extension ConfigClientTypes {

    public enum ConfigurationItemStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ok
        case resourcedeleted
        case resourcedeletednotrecorded
        case resourcediscovered
        case resourcenotrecorded
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationItemStatus] {
            return [
                .ok,
                .resourcedeleted,
                .resourcedeletednotrecorded,
                .resourcediscovered,
                .resourcenotrecorded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ok: return "OK"
            case .resourcedeleted: return "ResourceDeleted"
            case .resourcedeletednotrecorded: return "ResourceDeletedNotRecorded"
            case .resourcediscovered: return "ResourceDiscovered"
            case .resourcenotrecorded: return "ResourceNotRecorded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum RecordingFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuous
        case daily
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingFrequency] {
            return [
                .continuous,
                .daily
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuous: return "CONTINUOUS"
            case .daily: return "DAILY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The detailed configurations of a specified resource.
    public struct BaseConfigurationItem: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID associated with the resource.
        public var accountId: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The Availability Zone associated with the resource.
        public var availabilityZone: Swift.String?
        /// The region where the resource resides.
        public var awsRegion: Swift.String?
        /// The description of the resource configuration.
        public var configuration: Swift.String?
        /// The time when the recording of configuration changes was initiated for the resource.
        public var configurationItemCaptureTime: Foundation.Date?
        /// The time when configuration changes for the resource were delivered. This field is optional and is not guaranteed to be present in a configuration item (CI). If you are using daily recording, this field will be populated. However, if you are using continuous recording, this field will be omitted since the delivery time is instantaneous as the CI is available right away. For more information on daily recording and continuous recording, see [Recording Frequency](https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-recording-frequency) in the Config Developer Guide.
        public var configurationItemDeliveryTime: Foundation.Date?
        /// The configuration item status. Valid values include:
        ///
        /// * OK  The resource configuration has been updated.
        ///
        /// * ResourceDiscovered  The resource was newly discovered.
        ///
        /// * ResourceNotRecorded  The resource was discovered, but its configuration was not recorded since the recorder doesn't record resources of this type.
        ///
        /// * ResourceDeleted  The resource was deleted
        ///
        /// * ResourceDeletedNotRecorded  The resource was deleted, but its configuration was not recorded since the recorder doesn't record resources of this type.
        public var configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public var configurationStateId: Swift.String?
        /// The recording frequency that Config uses to record configuration changes for the resource.
        public var recordingFrequency: ConfigClientTypes.RecordingFrequency?
        /// The time stamp when the resource was created.
        public var resourceCreationTime: Foundation.Date?
        /// The ID of the resource (for example., sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource, if available.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public var supplementaryConfiguration: [Swift.String: Swift.String]?
        /// The version number of the resource configuration.
        public var version: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            configuration: Swift.String? = nil,
            configurationItemCaptureTime: Foundation.Date? = nil,
            configurationItemDeliveryTime: Foundation.Date? = nil,
            configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus? = nil,
            configurationStateId: Swift.String? = nil,
            recordingFrequency: ConfigClientTypes.RecordingFrequency? = nil,
            resourceCreationTime: Foundation.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            supplementaryConfiguration: [Swift.String: Swift.String]? = nil,
            version: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemDeliveryTime = configurationItemDeliveryTime
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.recordingFrequency = recordingFrequency
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.version = version
        }
    }
}

/// You have specified a configuration aggregator that does not exist.
public struct NoSuchConfigurationAggregatorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchConfigurationAggregatorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested action is not valid. For PutStoredQuery, you will see this exception if there are missing required fields or if the input value fails the validation, or if you are trying to create more than 300 queries. For GetStoredQuery, ListStoredQuery, and DeleteStoredQuery you will see this exception if there are missing required fields or if the input value fails the validation.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetAggregateResourceConfigInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// A list of aggregate ResourceIdentifiers objects.
    /// This member is required.
    public var resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifiers = resourceIdentifiers
    }
}

public struct BatchGetAggregateResourceConfigOutput: Swift.Sendable {
    /// A list that contains the current configuration of one or more resources.
    public var baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    /// A list of resource identifiers that were not processed with current scope. The list is empty if all the resources are processed.
    public var unprocessedResourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init(
        baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]? = nil,
        unprocessedResourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceIdentifiers = unprocessedResourceIdentifiers
    }
}

/// There are no configuration recorders available to provide the role needed to describe your resources. Create a configuration recorder.
public struct NoAvailableConfigurationRecorderException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableConfigurationRecorderException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigClientTypes {

    /// The details that identify a resource within Config, including the resource type and resource ID.
    public struct ResourceKey: Swift.Sendable {
        /// The ID of the resource (for example., sg-xxxxxx).
        /// This member is required.
        public var resourceId: Swift.String?
        /// The resource type.
        /// This member is required.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init(
            resourceId: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct BatchGetResourceConfigInput: Swift.Sendable {
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init(
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.resourceKeys = resourceKeys
    }
}

public struct BatchGetResourceConfigOutput: Swift.Sendable {
    /// A list that contains the current configuration of one or more resources.
    public var baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]?
    /// A list of resource keys that were not processed with the current response. The unprocessesResourceKeys value is in the same form as ResourceKeys, so the value can be directly provided to a subsequent BatchGetResourceConfig operation. If there are no unprocessed resource keys, the response contains an empty unprocessedResourceKeys list.
    public var unprocessedResourceKeys: [ConfigClientTypes.ResourceKey]?

    public init(
        baseConfigurationItems: [ConfigClientTypes.BaseConfigurationItem]? = nil,
        unprocessedResourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.baseConfigurationItems = baseConfigurationItems
        self.unprocessedResourceKeys = unprocessedResourceKeys
    }
}

extension ConfigClientTypes {

    public enum ChronologicalOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forward
        case reverse
        case sdkUnknown(Swift.String)

        public static var allCases: [ChronologicalOrder] {
            return [
                .forward,
                .reverse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forward: return "Forward"
            case .reverse: return "Reverse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Indicates whether an Config rule is compliant. A rule is compliant if all of the resources that the rule evaluated comply with it. A rule is noncompliant if any of these resources do not comply.
    public struct ComplianceByConfigRule: Swift.Sendable {
        /// Indicates whether the Config rule is compliant.
        public var compliance: ConfigClientTypes.Compliance?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init(
            compliance: ConfigClientTypes.Compliance? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.compliance = compliance
            self.configRuleName = configRuleName
        }
    }
}

extension ConfigClientTypes {

    /// Indicates whether an Amazon Web Services resource that is evaluated according to one or more Config rules is compliant. A resource is compliant if it complies with all of the rules that evaluate it. A resource is noncompliant if it does not comply with one or more of these rules.
    public struct ComplianceByResource: Swift.Sendable {
        /// Indicates whether the Amazon Web Services resource complies with all of the Config rules that evaluated it.
        public var compliance: ConfigClientTypes.Compliance?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceId: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceType: Swift.String?

        public init(
            compliance: ConfigClientTypes.Compliance? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.compliance = compliance
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    /// The number of Amazon Web Services resources of a specific type that are compliant or noncompliant, up to a maximum of 100 for each.
    public struct ComplianceSummaryByResourceType: Swift.Sendable {
        /// The number of Amazon Web Services resources that are compliant or noncompliant, up to a maximum of 100 for each.
        public var complianceSummary: ConfigClientTypes.ComplianceSummary?
        /// The type of Amazon Web Services resource.
        public var resourceType: Swift.String?

        public init(
            complianceSummary: ConfigClientTypes.ComplianceSummary? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.complianceSummary = complianceSummary
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    public enum DeliveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case notApplicable
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryStatus] {
            return [
                .failure,
                .notApplicable,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "Failure"
            case .notApplicable: return "Not_Applicable"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Provides status of the delivery of the snapshot or the configuration history to the specified Amazon S3 bucket. Also provides the status of notifications about the Amazon S3 delivery to the specified Amazon SNS topic.
    public struct ConfigExportDeliveryInfo: Swift.Sendable {
        /// The time of the last attempted delivery.
        public var lastAttemptTime: Foundation.Date?
        /// The error code from the last attempted delivery.
        public var lastErrorCode: Swift.String?
        /// The error message from the last attempted delivery.
        public var lastErrorMessage: Swift.String?
        /// Status of the last attempted delivery.
        public var lastStatus: ConfigClientTypes.DeliveryStatus?
        /// The time of the last successful delivery.
        public var lastSuccessfulTime: Foundation.Date?
        /// The time that the next delivery occurs.
        public var nextDeliveryTime: Foundation.Date?

        public init(
            lastAttemptTime: Foundation.Date? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStatus: ConfigClientTypes.DeliveryStatus? = nil,
            lastSuccessfulTime: Foundation.Date? = nil,
            nextDeliveryTime: Foundation.Date? = nil
        )
        {
            self.lastAttemptTime = lastAttemptTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastSuccessfulTime = lastSuccessfulTime
            self.nextDeliveryTime = nextDeliveryTime
        }
    }
}

extension ConfigClientTypes {

    public enum ConfigRuleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case deletingResults
        case evaluating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRuleState] {
            return [
                .active,
                .deleting,
                .deletingResults,
                .evaluating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .deletingResults: return "DELETING_RESULTS"
            case .evaluating: return "EVALUATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The configuration object for Config rule evaluation mode. The supported valid values are Detective or Proactive.
    public struct EvaluationModeConfiguration: Swift.Sendable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var mode: ConfigClientTypes.EvaluationMode?

        public init(
            mode: ConfigClientTypes.EvaluationMode? = nil
        )
        {
            self.mode = mode
        }
    }
}

extension ConfigClientTypes {

    public enum MaximumExecutionFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneHour
        case sixHours
        case threeHours
        case twelveHours
        case twentyfourHours
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumExecutionFrequency] {
            return [
                .oneHour,
                .sixHours,
                .threeHours,
                .twelveHours,
                .twentyfourHours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneHour: return "One_Hour"
            case .sixHours: return "Six_Hours"
            case .threeHours: return "Three_Hours"
            case .twelveHours: return "Twelve_Hours"
            case .twentyfourHours: return "TwentyFour_Hours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Defines which resources trigger an evaluation for an Config rule. The scope can include one or more resource types, a combination of a tag key and value, or a combination of one resource type and one resource ID. Specify a scope to constrain which resources trigger an evaluation for a rule. Otherwise, evaluations for the rule are triggered when any resource in your recording group changes in configuration.
    public struct Scope: Swift.Sendable {
        /// The ID of the only Amazon Web Services resource that you want to trigger an evaluation for the rule. If you specify a resource ID, you must specify one resource type for ComplianceResourceTypes.
        public var complianceResourceId: Swift.String?
        /// The resource types of only those Amazon Web Services resources that you want to trigger an evaluation for the rule. You can only specify one type if you also specify a resource ID for ComplianceResourceId.
        public var complianceResourceTypes: [Swift.String]?
        /// The tag key that is applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule.
        public var tagKey: Swift.String?
        /// The tag value applied to only those Amazon Web Services resources that you want to trigger an evaluation for the rule. If you specify a value for TagValue, you must also specify a value for TagKey.
        public var tagValue: Swift.String?

        public init(
            complianceResourceId: Swift.String? = nil,
            complianceResourceTypes: [Swift.String]? = nil,
            tagKey: Swift.String? = nil,
            tagValue: Swift.String? = nil
        )
        {
            self.complianceResourceId = complianceResourceId
            self.complianceResourceTypes = complianceResourceTypes
            self.tagKey = tagKey
            self.tagValue = tagValue
        }
    }
}

extension ConfigClientTypes {

    /// Provides the runtime system, policy definition, and whether debug logging enabled. You can specify the following CustomPolicyDetails parameter values only for Config Custom Policy rules.
    public struct CustomPolicyDetails: Swift.Sendable {
        /// The boolean expression for enabling debug logging for your Config Custom Policy rule. The default value is false.
        public var enableDebugLogDelivery: Swift.Bool
        /// The runtime system for your Config Custom Policy rule. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        /// This member is required.
        public var policyRuntime: Swift.String?
        /// The policy definition containing the logic for your Config Custom Policy rule.
        /// This member is required.
        public var policyText: Swift.String?

        public init(
            enableDebugLogDelivery: Swift.Bool = false,
            policyRuntime: Swift.String? = nil,
            policyText: Swift.String? = nil
        )
        {
            self.enableDebugLogDelivery = enableDebugLogDelivery
            self.policyRuntime = policyRuntime
            self.policyText = policyText
        }
    }
}

extension ConfigClientTypes {

    public enum Owner: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case customLambda
        case customPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [Owner] {
            return [
                .aws,
                .customLambda,
                .customPolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .customLambda: return "CUSTOM_LAMBDA"
            case .customPolicy: return "CUSTOM_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum EventSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsConfig
        case sdkUnknown(Swift.String)

        public static var allCases: [EventSource] {
            return [
                .awsConfig
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsConfig: return "aws.config"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationitemchangenotification
        case configurationsnapshotdeliverycompleted
        case oversizedconfigurationitemchangenotification
        case schedulednotification
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .configurationitemchangenotification,
                .configurationsnapshotdeliverycompleted,
                .oversizedconfigurationitemchangenotification,
                .schedulednotification
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationitemchangenotification: return "ConfigurationItemChangeNotification"
            case .configurationsnapshotdeliverycompleted: return "ConfigurationSnapshotDeliveryCompleted"
            case .oversizedconfigurationitemchangenotification: return "OversizedConfigurationItemChangeNotification"
            case .schedulednotification: return "ScheduledNotification"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Provides the source and the message types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. You can specify the parameter values for SourceDetail only for custom rules.
    public struct SourceDetail: Swift.Sendable {
        /// The source of the event, such as an Amazon Web Services service, that triggers Config to evaluate your Amazon Web Services resources.
        public var eventSource: ConfigClientTypes.EventSource?
        /// The frequency at which you want Config to run evaluations for a custom rule with a periodic trigger. If you specify a value for MaximumExecutionFrequency, then MessageType must use the ScheduledNotification value. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter. Based on the valid value you choose, Config runs evaluations once for each valid value. For example, if you choose Three_Hours, Config runs evaluations once every three hours. In this case, Three_Hours is the frequency of this rule.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        ///
        /// * ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        ///
        /// * ConfigurationSnapshotDeliveryCompleted - Triggers a periodic evaluation when Config delivers a configuration snapshot.
        ///
        ///
        /// If you want your custom rule to be triggered by configuration changes, specify two SourceDetail objects, one for ConfigurationItemChangeNotification and one for OversizedConfigurationItemChangeNotification.
        public var messageType: ConfigClientTypes.MessageType?

        public init(
            eventSource: ConfigClientTypes.EventSource? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            messageType: ConfigClientTypes.MessageType? = nil
        )
        {
            self.eventSource = eventSource
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.messageType = messageType
        }
    }
}

extension ConfigClientTypes {

    /// Provides the CustomPolicyDetails, the rule owner (Amazon Web Services for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier, and the events that cause the evaluation of your Amazon Web Services resources.
    public struct Source: Swift.Sendable {
        /// Provides the runtime system, policy definition, and whether debug logging is enabled. Required when owner is set to CUSTOM_POLICY.
        public var customPolicyDetails: ConfigClientTypes.CustomPolicyDetails?
        /// Indicates whether Amazon Web Services or the customer owns and manages the Config rule. Config Managed Rules are predefined rules owned by Amazon Web Services. For more information, see [Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html) in the Config developer guide. Config Custom Rules are rules that you can develop either with Guard (CUSTOM_POLICY) or Lambda (CUSTOM_LAMBDA). For more information, see [Config Custom Rules ](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html) in the Config developer guide.
        /// This member is required.
        public var owner: ConfigClientTypes.Owner?
        /// Provides the source and the message types that cause Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic. If the owner is set to CUSTOM_POLICY, the only acceptable values for the Config rule trigger message type are ConfigurationItemChangeNotification and OversizedConfigurationItemChangeNotification.
        public var sourceDetails: [ConfigClientTypes.SourceDetail]?
        /// For Config Managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see [List of Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). For Config Custom Lambda rules, the identifier is the Amazon Resource Name (ARN) of the rule's Lambda function, such as arn:aws:lambda:us-east-2:123456789012:function:custom_rule_name. For Config Custom Policy rules, this field will be ignored.
        public var sourceIdentifier: Swift.String?

        public init(
            customPolicyDetails: ConfigClientTypes.CustomPolicyDetails? = nil,
            owner: ConfigClientTypes.Owner? = nil,
            sourceDetails: [ConfigClientTypes.SourceDetail]? = nil,
            sourceIdentifier: Swift.String? = nil
        )
        {
            self.customPolicyDetails = customPolicyDetails
            self.owner = owner
            self.sourceDetails = sourceDetails
            self.sourceIdentifier = sourceIdentifier
        }
    }
}

extension ConfigClientTypes {

    /// Config rules evaluate the configuration settings of your Amazon Web Services resources. A rule can run when Config detects a configuration change to an Amazon Web Services resource or at a periodic frequency that you choose (for example, every 24 hours). There are two types of rules: Config Managed Rules and Config Custom Rules. Config Managed Rules are predefined, customizable rules created by Config. For a list of managed rules, see [List of Config Managed Rules](https://docs.aws.amazon.com/config/latest/developerguide/managed-rules-by-aws-config.html). Config Custom Rules are rules that you create from scratch. There are two ways to create Config custom rules: with Lambda functions ([ Lambda Developer Guide](https://docs.aws.amazon.com/config/latest/developerguide/gettingstarted-concepts.html#gettingstarted-concepts-function)) and with Guard ([Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard)), a policy-as-code language. Config custom rules created with Lambda are called Config Custom Lambda Rules and Config custom rules created with Guard are called Config Custom Policy Rules. For more information about developing and using Config rules, see [Evaluating Resource with Config Rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config.html) in the Config Developer Guide. You can use the Amazon Web Services CLI and Amazon Web Services SDKs if you want to create a rule that triggers evaluations for your resources when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
    public struct ConfigRule: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Config rule.
        public var configRuleArn: Swift.String?
        /// The ID of the Config rule.
        public var configRuleId: Swift.String?
        /// The name that you assign to the Config rule. The name is required if you are adding a new rule.
        public var configRuleName: Swift.String?
        /// Indicates whether the Config rule is active or is currently being deleted by Config. It can also indicate the evaluation status for the Config rule. Config sets the state of the rule to EVALUATING temporarily after you use the StartConfigRulesEvaluation request to evaluate your resources against the Config rule. Config sets the state of the rule to DELETING_RESULTS temporarily after you use the DeleteEvaluationResults request to delete the current evaluation results for the Config rule. Config temporarily sets the state of a rule to DELETING after you use the DeleteConfigRule request to delete the rule. After Config deletes the rule, the rule and all of its evaluations are erased and are no longer available.
        public var configRuleState: ConfigClientTypes.ConfigRuleState?
        /// Service principal name of the service that created the rule. The field is populated only if the service-linked rule is created by a service. The field is empty if you create your own rule.
        public var createdBy: Swift.String?
        /// The description that you provide for the Config rule.
        public var description: Swift.String?
        /// The modes the Config rule can be evaluated in. The valid values are distinct objects. By default, the value is Detective evaluation mode only.
        public var evaluationModes: [ConfigClientTypes.EvaluationModeConfiguration]?
        /// A string, in JSON format, that is passed to the Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. You can specify a value for MaximumExecutionFrequency when:
        ///
        /// * This is for an Config managed rule that is triggered at a periodic frequency.
        ///
        /// * Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        ///
        ///
        /// By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// Defines which resources can trigger an evaluation for the rule. The scope can include one or more resource types, a combination of one resource type and one resource ID, or a combination of a tag key and value. Specify a scope to constrain the resources that can trigger an evaluation for the rule. If you do not specify a scope, evaluations are triggered when any resource in the recording group changes. The scope can be empty.
        public var scope: ConfigClientTypes.Scope?
        /// Provides the rule owner (Amazon Web Services for managed rules, CUSTOM_POLICY for Custom Policy rules, and CUSTOM_LAMBDA for Custom Lambda rules), the rule identifier, and the notifications that cause the function to evaluate your Amazon Web Services resources.
        /// This member is required.
        public var source: ConfigClientTypes.Source?

        public init(
            configRuleArn: Swift.String? = nil,
            configRuleId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            configRuleState: ConfigClientTypes.ConfigRuleState? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            evaluationModes: [ConfigClientTypes.EvaluationModeConfiguration]? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            scope: ConfigClientTypes.Scope? = nil,
            source: ConfigClientTypes.Source? = nil
        )
        {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.configRuleState = configRuleState
            self.createdBy = createdBy
            self.description = description
            self.evaluationModes = evaluationModes
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.scope = scope
            self.source = source
        }
    }
}

extension ConfigClientTypes {

    /// Filters the compliance results based on account ID, region, compliance type, and rule name.
    public struct ConfigRuleComplianceFilters: Swift.Sendable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region where the data is aggregated.
        public var awsRegion: Swift.String?
        /// The rule compliance status. For the ConfigRuleComplianceFilters data type, Config supports only COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and the INSUFFICIENT_DATA values.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
            self.complianceType = complianceType
            self.configRuleName = configRuleName
        }
    }
}

extension ConfigClientTypes {

    /// Filters the results based on the account IDs and regions.
    public struct ConfigRuleComplianceSummaryFilters: Swift.Sendable {
        /// The 12-digit account ID of the source account.
        public var accountId: Swift.String?
        /// The source region where the data is aggregated.
        public var awsRegion: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            awsRegion: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.awsRegion = awsRegion
        }
    }
}

extension ConfigClientTypes {

    public enum ConfigRuleComplianceSummaryGroupKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case awsRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigRuleComplianceSummaryGroupKey] {
            return [
                .accountId,
                .awsRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Status information for your Config Managed rules and Config Custom Policy rules. The status includes information such as the last time the rule ran, the last time it failed, and the related error for the last failure. This action does not return status information about Config Custom Lambda rules.
    public struct ConfigRuleEvaluationStatus: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Config rule.
        public var configRuleArn: Swift.String?
        /// The ID of the Config rule.
        public var configRuleId: Swift.String?
        /// The name of the Config rule.
        public var configRuleName: Swift.String?
        /// The time that you first activated the Config rule.
        public var firstActivatedTime: Foundation.Date?
        /// Indicates whether Config has evaluated your resources against the rule at least once.
        ///
        /// * true - Config has evaluated your Amazon Web Services resources against the rule at least once.
        ///
        /// * false - Config has not finished evaluating your Amazon Web Services resources against the rule at least once.
        public var firstEvaluationStarted: Swift.Bool
        /// The time that you last turned off the Config rule.
        public var lastDeactivatedTime: Foundation.Date?
        /// The status of the last attempted delivery of a debug log for your Config Custom Policy rules. Either Successful or Failed.
        public var lastDebugLogDeliveryStatus: Swift.String?
        /// The reason Config was not able to deliver a debug log. This is for the last failed attempt to retrieve a debug log for your Config Custom Policy rules.
        public var lastDebugLogDeliveryStatusReason: Swift.String?
        /// The time Config last attempted to deliver a debug log for your Config Custom Policy rules.
        public var lastDebugLogDeliveryTime: Foundation.Date?
        /// The error code that Config returned when the rule last failed.
        public var lastErrorCode: Swift.String?
        /// The error message that Config returned when the rule last failed.
        public var lastErrorMessage: Swift.String?
        /// The time that Config last failed to evaluate your Amazon Web Services resources against the rule.
        public var lastFailedEvaluationTime: Foundation.Date?
        /// The time that Config last failed to invoke the Config rule to evaluate your Amazon Web Services resources.
        public var lastFailedInvocationTime: Foundation.Date?
        /// The time that Config last successfully evaluated your Amazon Web Services resources against the rule.
        public var lastSuccessfulEvaluationTime: Foundation.Date?
        /// The time that Config last successfully invoked the Config rule to evaluate your Amazon Web Services resources.
        public var lastSuccessfulInvocationTime: Foundation.Date?

        public init(
            configRuleArn: Swift.String? = nil,
            configRuleId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            firstActivatedTime: Foundation.Date? = nil,
            firstEvaluationStarted: Swift.Bool = false,
            lastDeactivatedTime: Foundation.Date? = nil,
            lastDebugLogDeliveryStatus: Swift.String? = nil,
            lastDebugLogDeliveryStatusReason: Swift.String? = nil,
            lastDebugLogDeliveryTime: Foundation.Date? = nil,
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastFailedEvaluationTime: Foundation.Date? = nil,
            lastFailedInvocationTime: Foundation.Date? = nil,
            lastSuccessfulEvaluationTime: Foundation.Date? = nil,
            lastSuccessfulInvocationTime: Foundation.Date? = nil
        )
        {
            self.configRuleArn = configRuleArn
            self.configRuleId = configRuleId
            self.configRuleName = configRuleName
            self.firstActivatedTime = firstActivatedTime
            self.firstEvaluationStarted = firstEvaluationStarted
            self.lastDeactivatedTime = lastDeactivatedTime
            self.lastDebugLogDeliveryStatus = lastDebugLogDeliveryStatus
            self.lastDebugLogDeliveryStatusReason = lastDebugLogDeliveryStatusReason
            self.lastDebugLogDeliveryTime = lastDebugLogDeliveryTime
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastFailedEvaluationTime = lastFailedEvaluationTime
            self.lastFailedInvocationTime = lastFailedInvocationTime
            self.lastSuccessfulEvaluationTime = lastSuccessfulEvaluationTime
            self.lastSuccessfulInvocationTime = lastSuccessfulInvocationTime
        }
    }
}

extension ConfigClientTypes {

    /// Provides options for how often Config delivers configuration snapshots to the Amazon S3 bucket in your delivery channel. The frequency for a rule that triggers evaluations for your resources when Config delivers the configuration snapshot is set by one of two values, depending on which is less frequent:
    ///
    /// * The value for the deliveryFrequency parameter within the delivery channel configuration, which sets how often Config delivers configuration snapshots. This value also sets how often Config invokes evaluations for Config rules.
    ///
    /// * The value for the MaximumExecutionFrequency parameter, which sets the maximum frequency with which Config invokes evaluations for the rule. For more information, see [ConfigRule].
    ///
    ///
    /// If the deliveryFrequency value is less frequent than the MaximumExecutionFrequency value for a rule, Config invokes the rule only as often as the deliveryFrequency value.
    ///
    /// * For example, you want your rule to run evaluations when Config delivers the configuration snapshot.
    ///
    /// * You specify the MaximumExecutionFrequency value for Six_Hours.
    ///
    /// * You then specify the delivery channel deliveryFrequency value for TwentyFour_Hours.
    ///
    /// * Because the value for deliveryFrequency is less frequent than MaximumExecutionFrequency, Config invokes evaluations for the rule every 24 hours.
    ///
    ///
    /// You should set the MaximumExecutionFrequency value to be at least as frequent as the deliveryFrequency value. You can view the deliveryFrequency value by using the DescribeDeliveryChannnels action. To update the deliveryFrequency with which Config delivers your configuration snapshots, use the PutDeliveryChannel action.
    public struct ConfigSnapshotDeliveryProperties: Swift.Sendable {
        /// The frequency with which Config delivers configuration snapshots.
        public var deliveryFrequency: ConfigClientTypes.MaximumExecutionFrequency?

        public init(
            deliveryFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil
        )
        {
            self.deliveryFrequency = deliveryFrequency
        }
    }
}

extension ConfigClientTypes {

    /// A list that contains the status of the delivery of the configuration stream notification to the Amazon SNS topic.
    public struct ConfigStreamDeliveryInfo: Swift.Sendable {
        /// The error code from the last attempted delivery.
        public var lastErrorCode: Swift.String?
        /// The error message from the last attempted delivery.
        public var lastErrorMessage: Swift.String?
        /// Status of the last attempted delivery. Note Providing an SNS topic on a [DeliveryChannel](https://docs.aws.amazon.com/config/latest/APIReference/API_DeliveryChannel.html) for Config is optional. If the SNS delivery is turned off, the last status will be Not_Applicable.
        public var lastStatus: ConfigClientTypes.DeliveryStatus?
        /// The time from the last status change.
        public var lastStatusChangeTime: Foundation.Date?

        public init(
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStatus: ConfigClientTypes.DeliveryStatus? = nil,
            lastStatusChangeTime: Foundation.Date? = nil
        )
        {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
        }
    }
}

extension ConfigClientTypes {

    /// This object contains regions to set up the aggregator and an IAM role to retrieve organization details.
    public struct OrganizationAggregationSource: Swift.Sendable {
        /// If true, aggregate existing Config regions and future regions.
        public var allAwsRegions: Swift.Bool
        /// The source regions being aggregated.
        public var awsRegions: [Swift.String]?
        /// ARN of the IAM role used to retrieve Amazon Web Services Organization details associated with the aggregator account.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            allAwsRegions: Swift.Bool = false,
            awsRegions: [Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.allAwsRegions = allAwsRegions
            self.awsRegions = awsRegions
            self.roleArn = roleArn
        }
    }
}

extension ConfigClientTypes {

    /// The details about the configuration aggregator, including information about source accounts, regions, and metadata of the aggregator.
    public struct ConfigurationAggregator: Swift.Sendable {
        /// Provides a list of source accounts and regions to be aggregated.
        public var accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]?
        /// The Amazon Resource Name (ARN) of the aggregator.
        public var configurationAggregatorArn: Swift.String?
        /// The name of the aggregator.
        public var configurationAggregatorName: Swift.String?
        /// Amazon Web Services service that created the configuration aggregator.
        public var createdBy: Swift.String?
        /// The time stamp when the configuration aggregator was created.
        public var creationTime: Foundation.Date?
        /// The time of the last update.
        public var lastUpdatedTime: Foundation.Date?
        /// Provides an organization and list of regions to be aggregated.
        public var organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource?

        public init(
            accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]? = nil,
            configurationAggregatorArn: Swift.String? = nil,
            configurationAggregatorName: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource? = nil
        )
        {
            self.accountAggregationSources = accountAggregationSources
            self.configurationAggregatorArn = configurationAggregatorArn
            self.configurationAggregatorName = configurationAggregatorName
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.organizationAggregationSource = organizationAggregationSource
        }
    }
}

extension ConfigClientTypes {

    /// The relationship of the related resource to the main resource.
    public struct Relationship: Swift.Sendable {
        /// The type of relationship with the related resource.
        public var relationshipName: Swift.String?
        /// The ID of the related resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the related resource, if available.
        public var resourceName: Swift.String?
        /// The resource type of the related resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init(
            relationshipName: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.relationshipName = relationshipName
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    /// A list that contains detailed configurations of a specified resource.
    public struct ConfigurationItem: Swift.Sendable {
        /// The 12-digit Amazon Web Services account ID associated with the resource.
        public var accountId: Swift.String?
        /// Amazon Resource Name (ARN) associated with the resource.
        public var arn: Swift.String?
        /// The Availability Zone associated with the resource.
        public var availabilityZone: Swift.String?
        /// The region where the resource resides.
        public var awsRegion: Swift.String?
        /// The description of the resource configuration.
        public var configuration: Swift.String?
        /// The time when the recording of configuration changes was initiated for the resource.
        public var configurationItemCaptureTime: Foundation.Date?
        /// The time when configuration changes for the resource were delivered. This field is optional and is not guaranteed to be present in a configuration item (CI). If you are using daily recording, this field will be populated. However, if you are using continuous recording, this field will be omitted since the delivery time is instantaneous as the CI is available right away. For more information on daily recording and continuous recording, see [Recording Frequency](https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-recording-frequency) in the Config Developer Guide.
        public var configurationItemDeliveryTime: Foundation.Date?
        /// Unique MD5 hash that represents the configuration item's state. You can use MD5 hash to compare the states of two or more configuration items that are associated with the same resource.
        public var configurationItemMD5Hash: Swift.String?
        /// The configuration item status. Valid values include:
        ///
        /// * OK  The resource configuration has been updated
        ///
        /// * ResourceDiscovered  The resource was newly discovered
        ///
        /// * ResourceNotRecorded  The resource was discovered but its configuration was not recorded since the recorder doesn't record resources of this type
        ///
        /// * ResourceDeleted  The resource was deleted
        ///
        /// * ResourceDeletedNotRecorded  The resource was deleted but its configuration was not recorded since the recorder doesn't record resources of this type
        public var configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus?
        /// An identifier that indicates the ordering of the configuration items of a resource.
        public var configurationStateId: Swift.String?
        /// The recording frequency that Config uses to record configuration changes for the resource.
        public var recordingFrequency: ConfigClientTypes.RecordingFrequency?
        /// A list of CloudTrail event IDs. A populated field indicates that the current configuration was initiated by the events recorded in the CloudTrail log. For more information about CloudTrail, see [What Is CloudTrail](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/what_is_cloud_trail_top_level.html). An empty field indicates that the current configuration was not initiated by any event. As of Version 1.3, the relatedEvents field is empty. You can access the [LookupEvents API](https://docs.aws.amazon.com/awscloudtrail/latest/APIReference/API_LookupEvents.html) in the CloudTrail API Reference to retrieve the events for the resource.
        public var relatedEvents: [Swift.String]?
        /// A list of related Amazon Web Services resources.
        public var relationships: [ConfigClientTypes.Relationship]?
        /// The time stamp when the resource was created.
        public var resourceCreationTime: Foundation.Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource, if available.
        public var resourceName: Swift.String?
        /// The type of Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?
        /// Configuration attributes that Config returns for certain resource types to supplement the information returned for the configuration parameter.
        public var supplementaryConfiguration: [Swift.String: Swift.String]?
        /// A mapping of key value tags associated with the resource.
        public var tags: [Swift.String: Swift.String]?
        /// The version number of the resource configuration.
        public var version: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            configuration: Swift.String? = nil,
            configurationItemCaptureTime: Foundation.Date? = nil,
            configurationItemDeliveryTime: Foundation.Date? = nil,
            configurationItemMD5Hash: Swift.String? = nil,
            configurationItemStatus: ConfigClientTypes.ConfigurationItemStatus? = nil,
            configurationStateId: Swift.String? = nil,
            recordingFrequency: ConfigClientTypes.RecordingFrequency? = nil,
            relatedEvents: [Swift.String]? = nil,
            relationships: [ConfigClientTypes.Relationship]? = nil,
            resourceCreationTime: Foundation.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil,
            supplementaryConfiguration: [Swift.String: Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            version: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.awsRegion = awsRegion
            self.configuration = configuration
            self.configurationItemCaptureTime = configurationItemCaptureTime
            self.configurationItemDeliveryTime = configurationItemDeliveryTime
            self.configurationItemMD5Hash = configurationItemMD5Hash
            self.configurationItemStatus = configurationItemStatus
            self.configurationStateId = configurationStateId
            self.recordingFrequency = recordingFrequency
            self.relatedEvents = relatedEvents
            self.relationships = relationships
            self.resourceCreationTime = resourceCreationTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
            self.supplementaryConfiguration = supplementaryConfiguration
            self.tags = tags
            self.version = version
        }
    }
}

extension ConfigClientTypes {

    /// Specifies whether the configuration recorder excludes certain resource types from being recorded. Use the resourceTypes field to enter a comma-separated list of resource types you want to exclude from recording. By default, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically. How to use the exclusion recording strategy To use this option, you must set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to EXCLUSION_BY_RESOURCE_TYPES. Config will then record configuration changes for all supported resource types, except the resource types that you specify to exclude from being recorded. Global resource types and the exclusion recording strategy Unless specifically listed as exclusions, AWS::RDS::GlobalCluster will be recorded automatically in all supported Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:
    ///
    /// * Asia Pacific (Hyderabad)
    ///
    /// * Asia Pacific (Melbourne)
    ///
    /// * Canada West (Calgary)
    ///
    /// * Europe (Spain)
    ///
    /// * Europe (Zurich)
    ///
    /// * Israel (Tel Aviv)
    ///
    /// * Middle East (UAE)
    public struct ExclusionByResourceTypes: Swift.Sendable {
        /// A comma-separated list of resource types to exclude from recording by the configuration recorder.
        public var resourceTypes: [ConfigClientTypes.ResourceType]?

        public init(
            resourceTypes: [ConfigClientTypes.ResourceType]? = nil
        )
        {
            self.resourceTypes = resourceTypes
        }
    }
}

extension ConfigClientTypes {

    public enum RecordingStrategyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allSupportedResourceTypes
        case exclusionByResourceTypes
        case inclusionByResourceTypes
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingStrategyType] {
            return [
                .allSupportedResourceTypes,
                .exclusionByResourceTypes,
                .inclusionByResourceTypes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allSupportedResourceTypes: return "ALL_SUPPORTED_RESOURCE_TYPES"
            case .exclusionByResourceTypes: return "EXCLUSION_BY_RESOURCE_TYPES"
            case .inclusionByResourceTypes: return "INCLUSION_BY_RESOURCE_TYPES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Specifies the recording strategy of the configuration recorder.
    public struct RecordingStrategy: Swift.Sendable {
        /// The recording strategy for the configuration recorder.
        ///
        /// * If you set this option to ALL_SUPPORTED_RESOURCE_TYPES, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true. When Config adds support for a new resource type, Config automatically starts recording resources of that type. For a list of supported resource types, see [Supported Resource Types](https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources) in the Config developer guide.
        ///
        /// * If you set this option to INCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for only the resource types that you specify in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html).
        ///
        /// * If you set this option to EXCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for all supported resource types, except the resource types that you specify to exclude from being recorded in the resourceTypes field of [ExclusionByResourceTypes](https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html).
        ///
        ///
        /// Required and optional fields The recordingStrategy field is optional when you set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true. The recordingStrategy field is optional when you list resource types in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html). The recordingStrategy field is required if you list resource types to exclude from recording in the resourceTypes field of [ExclusionByResourceTypes](https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html). Overriding fields If you choose EXCLUSION_BY_RESOURCE_TYPES for the recording strategy, the exclusionByResourceTypes field will override other properties in the request. For example, even if you set includeGlobalResourceTypes to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the resourceTypes field of exclusionByResourceTypes. Global resource types and the exclusion recording strategy By default, if you choose the EXCLUSION_BY_RESOURCE_TYPES recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically. Unless specifically listed as exclusions, AWS::RDS::GlobalCluster will be recorded automatically in all supported Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:
        ///
        /// * Asia Pacific (Hyderabad)
        ///
        /// * Asia Pacific (Melbourne)
        ///
        /// * Canada West (Calgary)
        ///
        /// * Europe (Spain)
        ///
        /// * Europe (Zurich)
        ///
        /// * Israel (Tel Aviv)
        ///
        /// * Middle East (UAE)
        public var useOnly: ConfigClientTypes.RecordingStrategyType?

        public init(
            useOnly: ConfigClientTypes.RecordingStrategyType? = nil
        )
        {
            self.useOnly = useOnly
        }
    }
}

extension ConfigClientTypes {

    /// Specifies which resource types Config records for configuration changes. By default, Config records configuration changes for all current and future supported resource types in the Amazon Web Services Region where you have enabled Config, excluding the global IAM resource types: IAM users, groups, roles, and customer managed policies. In the recording group, you specify whether you want to record all supported current and future supported resource types or to include or exclude specific resources types. For a list of supported resource types, see [Supported Resource Types](https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources) in the Config developer guide. If you don't want Config to record all current and future supported resource types (excluding the global IAM resource types), use one of the following recording strategies:
    ///
    /// * Record all current and future resource types with exclusions (EXCLUSION_BY_RESOURCE_TYPES), or
    ///
    /// * Record specific resource types (INCLUSION_BY_RESOURCE_TYPES).
    ///
    ///
    /// If you use the recording strategy to Record all current and future resource types (ALL_SUPPORTED_RESOURCE_TYPES), you can use the flag includeGlobalResourceTypes to include the global IAM resource types in your recording. Aurora global clusters are recorded in all enabled Regions The AWS::RDS::GlobalCluster resource type will be recorded in all supported Config Regions where the configuration recorder is enabled. If you do not want to record AWS::RDS::GlobalCluster in all enabled Regions, use the EXCLUSION_BY_RESOURCE_TYPES or INCLUSION_BY_RESOURCE_TYPES recording strategy.
    public struct RecordingGroup: Swift.Sendable {
        /// Specifies whether Config records configuration changes for all supported resource types, excluding the global IAM resource types. If you set this field to true, when Config adds support for a new resource type, Config starts recording resources of that type automatically. If you set this field to true, you cannot enumerate specific resource types to record in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html), or to exclude in the resourceTypes field of [ExclusionByResourceTypes](https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html). Region availability Check [Resource Coverage by Region Availability](https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html) to see if a resource type is supported in the Amazon Web Services Region where you set up Config.
        public var allSupported: Swift.Bool
        /// An object that specifies how Config excludes resource types from being recorded by the configuration recorder. Required fields To use this option, you must set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to EXCLUSION_BY_RESOURCE_TYPES.
        public var exclusionByResourceTypes: ConfigClientTypes.ExclusionByResourceTypes?
        /// This option is a bundle which only applies to the global IAM resource types: IAM users, groups, roles, and customer managed policies. These global IAM resource types can only be recorded by Config in Regions where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:
        ///
        /// * Asia Pacific (Hyderabad)
        ///
        /// * Asia Pacific (Melbourne)
        ///
        /// * Canada West (Calgary)
        ///
        /// * Europe (Spain)
        ///
        /// * Europe (Zurich)
        ///
        /// * Israel (Tel Aviv)
        ///
        /// * Middle East (UAE)
        ///
        ///
        /// Aurora global clusters are recorded in all enabled Regions The AWS::RDS::GlobalCluster resource type will be recorded in all supported Config Regions where the configuration recorder is enabled, even if includeGlobalResourceTypes is setfalse. The includeGlobalResourceTypes option is a bundle which only applies to IAM users, groups, roles, and customer managed policies. If you do not want to record AWS::RDS::GlobalCluster in all enabled Regions, use one of the following recording strategies:
        ///
        /// * Record all current and future resource types with exclusions (EXCLUSION_BY_RESOURCE_TYPES), or
        ///
        /// * Record specific resource types (INCLUSION_BY_RESOURCE_TYPES).
        ///
        ///
        /// For more information, see [Selecting Which Resources are Recorded](https://docs.aws.amazon.com/config/latest/developerguide/select-resources.html#select-resources-all) in the Config developer guide. includeGlobalResourceTypes and the exclusion recording strategy The includeGlobalResourceTypes field has no impact on the EXCLUSION_BY_RESOURCE_TYPES recording strategy. This means that the global IAM resource types (IAM users, groups, roles, and customer managed policies) will not be automatically added as exclusions for exclusionByResourceTypes when includeGlobalResourceTypes is set to false. The includeGlobalResourceTypes field should only be used to modify the AllSupported field, as the default for the AllSupported field is to record configuration changes for all supported resource types excluding the global IAM resource types. To include the global IAM resource types when AllSupported is set to true, make sure to set includeGlobalResourceTypes to true. To exclude the global IAM resource types for the EXCLUSION_BY_RESOURCE_TYPES recording strategy, you need to manually add them to the resourceTypes field of exclusionByResourceTypes. Required and optional fields Before you set this field to true, set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true. Optionally, you can set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to ALL_SUPPORTED_RESOURCE_TYPES. Overriding fields If you set this field to false but list global IAM resource types in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html), Config will still record configuration changes for those specified resource types regardless of if you set the includeGlobalResourceTypes field to false. If you do not want to record configuration changes to the global IAM resource types (IAM users, groups, roles, and customer managed policies), make sure to not list them in the resourceTypes field in addition to setting the includeGlobalResourceTypes field to false.
        public var includeGlobalResourceTypes: Swift.Bool
        /// An object that specifies the recording strategy for the configuration recorder.
        ///
        /// * If you set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to ALL_SUPPORTED_RESOURCE_TYPES, Config records configuration changes for all supported resource types, excluding the global IAM resource types. You also must set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true. When Config adds support for a new resource type, Config automatically starts recording resources of that type.
        ///
        /// * If you set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to INCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for only the resource types you specify in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html).
        ///
        /// * If you set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to EXCLUSION_BY_RESOURCE_TYPES, Config records configuration changes for all supported resource types except the resource types that you specify to exclude from being recorded in the resourceTypes field of [ExclusionByResourceTypes](https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html).
        ///
        ///
        /// Required and optional fields The recordingStrategy field is optional when you set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true. The recordingStrategy field is optional when you list resource types in the resourceTypes field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html). The recordingStrategy field is required if you list resource types to exclude from recording in the resourceTypes field of [ExclusionByResourceTypes](https://docs.aws.amazon.com/config/latest/APIReference/API_ExclusionByResourceTypes.html). Overriding fields If you choose EXCLUSION_BY_RESOURCE_TYPES for the recording strategy, the exclusionByResourceTypes field will override other properties in the request. For example, even if you set includeGlobalResourceTypes to false, global IAM resource types will still be automatically recorded in this option unless those resource types are specifically listed as exclusions in the resourceTypes field of exclusionByResourceTypes. Global resources types and the resource exclusion recording strategy By default, if you choose the EXCLUSION_BY_RESOURCE_TYPES recording strategy, when Config adds support for a new resource type in the Region where you set up the configuration recorder, including global resource types, Config starts recording resources of that type automatically. Unless specifically listed as exclusions, AWS::RDS::GlobalCluster will be recorded automatically in all supported Config Regions were the configuration recorder is enabled. IAM users, groups, roles, and customer managed policies will be recorded in the Region where you set up the configuration recorder if that is a Region where Config was available before February 2022. You cannot be record the global IAM resouce types in Regions supported by Config after February 2022. This list where you cannot record the global IAM resource types includes the following Regions:
        ///
        /// * Asia Pacific (Hyderabad)
        ///
        /// * Asia Pacific (Melbourne)
        ///
        /// * Canada West (Calgary)
        ///
        /// * Europe (Spain)
        ///
        /// * Europe (Zurich)
        ///
        /// * Israel (Tel Aviv)
        ///
        /// * Middle East (UAE)
        public var recordingStrategy: ConfigClientTypes.RecordingStrategy?
        /// A comma-separated list that specifies which resource types Config records. For a list of valid resourceTypes values, see the Resource Type Value column in [Supported Amazon Web Services resource Types](https://docs.aws.amazon.com/config/latest/developerguide/resource-config-reference.html#supported-resources) in the Config developer guide. Required and optional fields Optionally, you can set the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to INCLUSION_BY_RESOURCE_TYPES. To record all configuration changes, set the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true, and either omit this field or don't specify any resource types in this field. If you set the allSupported field to false and specify values for resourceTypes, when Config adds support for a new type of resource, it will not record resources of that type unless you manually add that type to your recording group. Region availability Before specifying a resource type for Config to track, check [Resource Coverage by Region Availability](https://docs.aws.amazon.com/config/latest/developerguide/what-is-resource-config-coverage.html) to see if the resource type is supported in the Amazon Web Services Region where you set up Config. If a resource type is supported by Config in at least one Region, you can enable the recording of that resource type in all Regions supported by Config, even if the specified resource type is not supported in the Amazon Web Services Region where you set up Config.
        public var resourceTypes: [ConfigClientTypes.ResourceType]?

        public init(
            allSupported: Swift.Bool = false,
            exclusionByResourceTypes: ConfigClientTypes.ExclusionByResourceTypes? = nil,
            includeGlobalResourceTypes: Swift.Bool = false,
            recordingStrategy: ConfigClientTypes.RecordingStrategy? = nil,
            resourceTypes: [ConfigClientTypes.ResourceType]? = nil
        )
        {
            self.allSupported = allSupported
            self.exclusionByResourceTypes = exclusionByResourceTypes
            self.includeGlobalResourceTypes = includeGlobalResourceTypes
            self.recordingStrategy = recordingStrategy
            self.resourceTypes = resourceTypes
        }
    }
}

extension ConfigClientTypes {

    /// An object for you to specify your overrides for the recording mode.
    public struct RecordingModeOverride: Swift.Sendable {
        /// A description that you provide for the override.
        public var description: Swift.String?
        /// The recording frequency that will be applied to all the resource types specified in the override.
        ///
        /// * Continuous recording allows you to record configuration changes continuously whenever a change occurs.
        ///
        /// * Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded.
        ///
        ///
        /// Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous.
        /// This member is required.
        public var recordingFrequency: ConfigClientTypes.RecordingFrequency?
        /// A comma-separated list that specifies which resource types Config includes in the override. Daily recording is not supported for the following resource types:
        ///
        /// * AWS::Config::ResourceCompliance
        ///
        /// * AWS::Config::ConformancePackCompliance
        ///
        /// * AWS::Config::ConfigurationRecorder
        /// This member is required.
        public var resourceTypes: [ConfigClientTypes.ResourceType]?

        public init(
            description: Swift.String? = nil,
            recordingFrequency: ConfigClientTypes.RecordingFrequency? = nil,
            resourceTypes: [ConfigClientTypes.ResourceType]? = nil
        )
        {
            self.description = description
            self.recordingFrequency = recordingFrequency
            self.resourceTypes = resourceTypes
        }
    }
}

extension ConfigClientTypes {

    /// Specifies the default recording frequency that Config uses to record configuration changes. Config supports Continuous recording and Daily recording.
    ///
    /// * Continuous recording allows you to record configuration changes continuously whenever a change occurs.
    ///
    /// * Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded.
    ///
    ///
    /// Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous. You can also override the recording frequency for specific resource types.
    public struct RecordingMode: Swift.Sendable {
        /// The default recording frequency that Config uses to record configuration changes. Daily recording is not supported for the following resource types:
        ///
        /// * AWS::Config::ResourceCompliance
        ///
        /// * AWS::Config::ConformancePackCompliance
        ///
        /// * AWS::Config::ConfigurationRecorder
        ///
        ///
        /// For the allSupported (ALL_SUPPORTED_RESOURCE_TYPES) recording strategy, these resource types will be set to Continuous recording.
        /// This member is required.
        public var recordingFrequency: ConfigClientTypes.RecordingFrequency?
        /// An array of recordingModeOverride objects for you to specify your overrides for the recording mode. The recordingModeOverride object in the recordingModeOverrides array consists of three fields: a description, the new recordingFrequency, and an array of resourceTypes to override.
        public var recordingModeOverrides: [ConfigClientTypes.RecordingModeOverride]?

        public init(
            recordingFrequency: ConfigClientTypes.RecordingFrequency? = nil,
            recordingModeOverrides: [ConfigClientTypes.RecordingModeOverride]? = nil
        )
        {
            self.recordingFrequency = recordingFrequency
            self.recordingModeOverrides = recordingModeOverrides
        }
    }
}

extension ConfigClientTypes {

    /// Records configuration changes to your specified resource types. For more information about the configuration recorder, see [ Managing the Configuration Recorder ](https://docs.aws.amazon.com/config/latest/developerguide/stop-start-recorder.html) in the Config Developer Guide.
    public struct ConfigurationRecorder: Swift.Sendable {
        /// The name of the configuration recorder. Config automatically assigns the name of "default" when creating the configuration recorder. You cannot change the name of the configuration recorder after it has been created. To change the configuration recorder name, you must delete it and create a new configuration recorder with a new name.
        public var name: Swift.String?
        /// Specifies which resource types Config records for configuration changes. High Number of Config Evaluations You may notice increased activity in your account during your initial month recording with Config when compared to subsequent months. During the initial bootstrapping process, Config runs evaluations on all the resources in your account that you have selected for Config to record. If you are running ephemeral workloads, you may see increased activity from Config as it records configuration changes associated with creating and deleting these temporary resources. An ephemeral workload is a temporary use of computing resources that are loaded and run when needed. Examples include Amazon Elastic Compute Cloud (Amazon EC2) Spot Instances, Amazon EMR jobs, and Auto Scaling. If you want to avoid the increased activity from running ephemeral workloads, you can run these types of workloads in a separate account with Config turned off to avoid increased configuration recording and rule evaluations.
        public var recordingGroup: ConfigClientTypes.RecordingGroup?
        /// Specifies the default recording frequency that Config uses to record configuration changes. Config supports Continuous recording and Daily recording.
        ///
        /// * Continuous recording allows you to record configuration changes continuously whenever a change occurs.
        ///
        /// * Daily recording allows you to receive a configuration item (CI) representing the most recent state of your resources over the last 24-hour period, only if its different from the previous CI recorded.
        ///
        ///
        /// Firewall Manager depends on continuous recording to monitor your resources. If you are using Firewall Manager, it is recommended that you set the recording frequency to Continuous. You can also override the recording frequency for specific resource types.
        public var recordingMode: ConfigClientTypes.RecordingMode?
        /// Amazon Resource Name (ARN) of the IAM role assumed by Config and used by the configuration recorder. While the API model does not require this field, the server will reject a request without a defined roleARN for the configuration recorder. Pre-existing Config role If you have used an Amazon Web Services service that uses Config, such as Security Hub or Control Tower, and an Config role has already been created, make sure that the IAM role that you use when setting up Config keeps the same minimum permissions as the already created Config role. You must do this so that the other Amazon Web Services service continues to run as expected. For example, if Control Tower has an IAM role that allows Config to read Amazon Simple Storage Service (Amazon S3) objects, make sure that the same permissions are granted within the IAM role you use when setting up Config. Otherwise, it may interfere with how Control Tower operates. For more information about IAM roles for Config, see [ Identity and Access Management for Config ](https://docs.aws.amazon.com/config/latest/developerguide/security-iam.html) in the Config Developer Guide.
        public var roleARN: Swift.String?

        public init(
            name: Swift.String? = nil,
            recordingGroup: ConfigClientTypes.RecordingGroup? = nil,
            recordingMode: ConfigClientTypes.RecordingMode? = nil,
            roleARN: Swift.String? = nil
        )
        {
            self.name = name
            self.recordingGroup = recordingGroup
            self.recordingMode = recordingMode
            self.roleARN = roleARN
        }
    }
}

extension ConfigClientTypes {

    public enum RecorderStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecorderStatus] {
            return [
                .failure,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "Failure"
            case .pending: return "Pending"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The current status of the configuration recorder. For a detailed status of recording events over time, add your Config events to CloudWatch metrics and use CloudWatch metrics.
    public struct ConfigurationRecorderStatus: Swift.Sendable {
        /// The latest error code from when the recorder last failed.
        public var lastErrorCode: Swift.String?
        /// The latest error message from when the recorder last failed.
        public var lastErrorMessage: Swift.String?
        /// The time the recorder was last started.
        public var lastStartTime: Foundation.Date?
        /// The status of the latest recording event processed by the recorder.
        public var lastStatus: ConfigClientTypes.RecorderStatus?
        /// The time of the latest change in status of an recording event processed by the recorder.
        public var lastStatusChangeTime: Foundation.Date?
        /// The time the recorder was last stopped.
        public var lastStopTime: Foundation.Date?
        /// The name of the configuration recorder.
        public var name: Swift.String?
        /// Specifies whether or not the recorder is currently recording.
        public var recording: Swift.Bool

        public init(
            lastErrorCode: Swift.String? = nil,
            lastErrorMessage: Swift.String? = nil,
            lastStartTime: Foundation.Date? = nil,
            lastStatus: ConfigClientTypes.RecorderStatus? = nil,
            lastStatusChangeTime: Foundation.Date? = nil,
            lastStopTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            recording: Swift.Bool = false
        )
        {
            self.lastErrorCode = lastErrorCode
            self.lastErrorMessage = lastErrorMessage
            self.lastStartTime = lastStartTime
            self.lastStatus = lastStatus
            self.lastStatusChangeTime = lastStatusChangeTime
            self.lastStopTime = lastStopTime
            self.name = name
            self.recording = recording
        }
    }
}

extension ConfigClientTypes {

    /// Filters the conformance pack by compliance types and Config rule names.
    public struct ConformancePackComplianceFilters: Swift.Sendable {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public var configRuleNames: [Swift.String]?

        public init(
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleNames: [Swift.String]? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
        }
    }
}

extension ConfigClientTypes {

    /// A compliance score is the percentage of the number of compliant rule-resource combinations in a conformance pack compared to the number of total possible rule-resource combinations in the conformance pack. This metric provides you with a high-level view of the compliance state of your conformance packs. You can use it to identify, investigate, and understand the level of compliance in your conformance packs.
    public struct ConformancePackComplianceScore: Swift.Sendable {
        /// The name of the conformance pack.
        public var conformancePackName: Swift.String?
        /// The time that the conformance pack compliance score was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// Compliance score for the conformance pack. Conformance packs with no evaluation results will have a compliance score of INSUFFICIENT_DATA.
        public var score: Swift.String?

        public init(
            conformancePackName: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            score: Swift.String? = nil
        )
        {
            self.conformancePackName = conformancePackName
            self.lastUpdatedTime = lastUpdatedTime
            self.score = score
        }
    }
}

extension ConfigClientTypes {

    /// A list of filters to apply to the conformance pack compliance score result set.
    public struct ConformancePackComplianceScoresFilters: Swift.Sendable {
        /// The names of the conformance packs whose compliance scores you want to include in the conformance pack compliance score result set. You can include up to 25 conformance packs in the ConformancePackNames array of strings, each with a character limit of 256 characters for the conformance pack name.
        /// This member is required.
        public var conformancePackNames: [Swift.String]?

        public init(
            conformancePackNames: [Swift.String]? = nil
        )
        {
            self.conformancePackNames = conformancePackNames
        }
    }
}

extension ConfigClientTypes {

    /// Summary includes the name and status of the conformance pack.
    public struct ConformancePackComplianceSummary: Swift.Sendable {
        /// The status of the conformance pack.
        /// This member is required.
        public var conformancePackComplianceStatus: ConfigClientTypes.ConformancePackComplianceType?
        /// The name of the conformance pack name.
        /// This member is required.
        public var conformancePackName: Swift.String?

        public init(
            conformancePackComplianceStatus: ConfigClientTypes.ConformancePackComplianceType? = nil,
            conformancePackName: Swift.String? = nil
        )
        {
            self.conformancePackComplianceStatus = conformancePackComplianceStatus
            self.conformancePackName = conformancePackName
        }
    }
}

extension ConfigClientTypes {

    /// Input parameters in the form of key-value pairs for the conformance pack, both of which you define. Keys can have a maximum character length of 255 characters, and values can have a maximum length of 4096 characters.
    public struct ConformancePackInputParameter: Swift.Sendable {
        /// One part of a key-value pair.
        /// This member is required.
        public var parameterName: Swift.String?
        /// Another part of the key-value pair.
        /// This member is required.
        public var parameterValue: Swift.String?

        public init(
            parameterName: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }
    }
}

extension ConfigClientTypes {

    /// This API allows you to create a conformance pack template with an Amazon Web Services Systems Manager document (SSM document). To deploy a conformance pack using an SSM document, first create an SSM document with conformance pack content, and then provide the DocumentName in the [PutConformancePack API](https://docs.aws.amazon.com/config/latest/APIReference/API_PutConformancePack.html). You can also provide the DocumentVersion. The TemplateSSMDocumentDetails object contains the name of the SSM document and the version of the SSM document.
    public struct TemplateSSMDocumentDetails: Swift.Sendable {
        /// The name or Amazon Resource Name (ARN) of the SSM document to use to create a conformance pack. If you use the document name, Config checks only your account and Amazon Web Services Region for the SSM document.
        /// This member is required.
        public var documentName: Swift.String?
        /// The version of the SSM document to use to create a conformance pack. By default, Config uses the latest version. This field is optional.
        public var documentVersion: Swift.String?

        public init(
            documentName: Swift.String? = nil,
            documentVersion: Swift.String? = nil
        )
        {
            self.documentName = documentName
            self.documentVersion = documentVersion
        }
    }
}

extension ConfigClientTypes {

    /// Returns details of a conformance pack. A conformance pack is a collection of Config rules and remediation actions that can be easily deployed in an account and a region.
    public struct ConformancePackDetail: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the conformance pack.
        /// This member is required.
        public var conformancePackArn: Swift.String?
        /// ID of the conformance pack.
        /// This member is required.
        public var conformancePackId: Swift.String?
        /// A list of ConformancePackInputParameter objects.
        public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
        /// Name of the conformance pack.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// The Amazon Web Services service that created the conformance pack.
        public var createdBy: Swift.String?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
        public var deliveryS3Bucket: Swift.String?
        /// The prefix for the Amazon S3 bucket. This field is optional.
        public var deliveryS3KeyPrefix: Swift.String?
        /// The last time a conformation pack update was requested.
        public var lastUpdateRequestedTime: Foundation.Date?
        /// An object that contains the name or Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
        public var templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails?

        public init(
            conformancePackArn: Swift.String? = nil,
            conformancePackId: Swift.String? = nil,
            conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
            conformancePackName: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            deliveryS3Bucket: Swift.String? = nil,
            deliveryS3KeyPrefix: Swift.String? = nil,
            lastUpdateRequestedTime: Foundation.Date? = nil,
            templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails? = nil
        )
        {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackInputParameters = conformancePackInputParameters
            self.conformancePackName = conformancePackName
            self.createdBy = createdBy
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.templateSSMDocumentDetails = templateSSMDocumentDetails
        }
    }
}

extension ConfigClientTypes {

    /// Filters a conformance pack by Config rule names, compliance types, Amazon Web Services resource types, and resource IDs.
    public struct ConformancePackEvaluationFilters: Swift.Sendable {
        /// Filters the results by compliance. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Filters the results by Config rule names.
        public var configRuleNames: [Swift.String]?
        /// Filters the results by resource IDs. This is valid only when you provide resource type. If there is no resource type, you will see an error.
        public var resourceIds: [Swift.String]?
        /// Filters the results by the resource type (for example, "AWS::EC2::Instance").
        public var resourceType: Swift.String?

        public init(
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleNames: [Swift.String]? = nil,
            resourceIds: [Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleNames = configRuleNames
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    /// The details of a conformance pack evaluation. Provides Config rule and Amazon Web Services resource type that was evaluated, the compliance of the conformance pack, related time stamps, and supplementary information.
    public struct ConformancePackEvaluationResult: Swift.Sendable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The compliance type. The allowed values are COMPLIANT and NON_COMPLIANT. INSUFFICIENT_DATA is not supported.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// The time when Config rule evaluated Amazon Web Services resource.
        /// This member is required.
        public var configRuleInvokedTime: Foundation.Date?
        /// Uniquely identifies an evaluation result.
        /// This member is required.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the evaluation result.
        /// This member is required.
        public var resultRecordedTime: Foundation.Date?

        public init(
            annotation: Swift.String? = nil,
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleInvokedTime: Foundation.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: Foundation.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
        }
    }
}

extension ConfigClientTypes {

    /// Compliance information of one or more Config rules within a conformance pack. You can filter using Config rule names and compliance types.
    public struct ConformancePackRuleCompliance: Swift.Sendable {
        /// Compliance of the Config rule.
        public var complianceType: ConfigClientTypes.ConformancePackComplianceType?
        /// Name of the Config rule.
        public var configRuleName: Swift.String?
        /// Controls for the conformance pack. A control is a process to prevent or detect problems while meeting objectives. A control can align with a specific compliance regime or map to internal controls defined by an organization.
        public var controls: [Swift.String]?

        public init(
            complianceType: ConfigClientTypes.ConformancePackComplianceType? = nil,
            configRuleName: Swift.String? = nil,
            controls: [Swift.String]? = nil
        )
        {
            self.complianceType = complianceType
            self.configRuleName = configRuleName
            self.controls = controls
        }
    }
}

extension ConfigClientTypes {

    public enum ConformancePackState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case createFailed
        case createInProgress
        case deleteFailed
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConformancePackState] {
            return [
                .createComplete,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Status details of a conformance pack.
    public struct ConformancePackStatusDetail: Swift.Sendable {
        /// Amazon Resource Name (ARN) of comformance pack.
        /// This member is required.
        public var conformancePackArn: Swift.String?
        /// ID of the conformance pack.
        /// This member is required.
        public var conformancePackId: Swift.String?
        /// Name of the conformance pack.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// Indicates deployment status of conformance pack. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_IN_PROGRESS when a conformance pack creation is in progress for an account.
        ///
        /// * CREATE_COMPLETE when a conformance pack has been successfully created in your account.
        ///
        /// * CREATE_FAILED when a conformance pack creation failed in your account.
        ///
        /// * DELETE_IN_PROGRESS when a conformance pack deletion is in progress.
        ///
        /// * DELETE_FAILED when a conformance pack deletion failed in your account.
        /// This member is required.
        public var conformancePackState: ConfigClientTypes.ConformancePackState?
        /// The reason of conformance pack creation failure.
        public var conformancePackStatusReason: Swift.String?
        /// Last time when conformation pack creation and update was successful.
        public var lastUpdateCompletedTime: Foundation.Date?
        /// Last time when conformation pack creation and update was requested.
        /// This member is required.
        public var lastUpdateRequestedTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of CloudFormation stack.
        /// This member is required.
        public var stackArn: Swift.String?

        public init(
            conformancePackArn: Swift.String? = nil,
            conformancePackId: Swift.String? = nil,
            conformancePackName: Swift.String? = nil,
            conformancePackState: ConfigClientTypes.ConformancePackState? = nil,
            conformancePackStatusReason: Swift.String? = nil,
            lastUpdateCompletedTime: Foundation.Date? = nil,
            lastUpdateRequestedTime: Foundation.Date? = nil,
            stackArn: Swift.String? = nil
        )
        {
            self.conformancePackArn = conformancePackArn
            self.conformancePackId = conformancePackId
            self.conformancePackName = conformancePackName
            self.conformancePackState = conformancePackState
            self.conformancePackStatusReason = conformancePackStatusReason
            self.lastUpdateCompletedTime = lastUpdateCompletedTime
            self.lastUpdateRequestedTime = lastUpdateRequestedTime
            self.stackArn = stackArn
        }
    }
}

/// You have specified a template that is not valid or supported.
public struct ConformancePackTemplateValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConformancePackTemplateValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the specified parameters are not valid. Verify that your parameters are valid and try again.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAggregationAuthorizationInput: Swift.Sendable {
    /// The 12-digit account ID of the account authorized to aggregate data.
    /// This member is required.
    public var authorizedAccountId: Swift.String?
    /// The region authorized to collect aggregated data.
    /// This member is required.
    public var authorizedAwsRegion: Swift.String?

    public init(
        authorizedAccountId: Swift.String? = nil,
        authorizedAwsRegion: Swift.String? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
    }
}

/// The Config rule in the request is not valid. Verify that the rule is an Config Process Check rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
public struct NoSuchConfigRuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchConfigRuleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You see this exception in the following cases:
///
/// * For DeleteConfigRule, Config is deleting this rule. Try your request again later.
///
/// * For DeleteConfigRule, the rule is deleting your evaluation results. Try your request again later.
///
/// * For DeleteConfigRule, a remediation action is associated with the rule and Config cannot delete this rule. Delete the remediation action associated with the rule before deleting the rule and try your request again later.
///
/// * For PutConfigOrganizationRule, organization Config rule deletion is in progress. Try your request again later.
///
/// * For DeleteOrganizationConfigRule, organization Config rule creation is in progress. Try your request again later.
///
/// * For PutConformancePack and PutOrganizationConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.
///
/// * For DeleteConformancePack, a conformance pack creation, update, and deletion is in progress. Try your request again later.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct DeleteConfigRuleInput: Swift.Sendable {
    /// The name of the Config rule that you want to delete.
    /// This member is required.
    public var configRuleName: Swift.String?

    public init(
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

public struct DeleteConfigurationAggregatorInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
    }
}

/// You have specified a configuration recorder that does not exist.
public struct NoSuchConfigurationRecorderException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchConfigurationRecorderException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request object for the DeleteConfigurationRecorder action.
public struct DeleteConfigurationRecorderInput: Swift.Sendable {
    /// The name of the configuration recorder to be deleted. You can retrieve the name of your configuration recorder by using the DescribeConfigurationRecorders action.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init(
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

/// You specified one or more conformance packs that do not exist.
public struct NoSuchConformancePackException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchConformancePackException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteConformancePackInput: Swift.Sendable {
    /// Name of the conformance pack you want to delete.
    /// This member is required.
    public var conformancePackName: Swift.String?

    public init(
        conformancePackName: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
    }
}

/// You cannot delete the delivery channel you specified because the configuration recorder is running.
public struct LastDeliveryChannelDeleteFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LastDeliveryChannelDeleteFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have specified a delivery channel that does not exist.
public struct NoSuchDeliveryChannelException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchDeliveryChannelException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the [DeleteDeliveryChannel] action. The action accepts the following data, in JSON format.
public struct DeleteDeliveryChannelInput: Swift.Sendable {
    /// The name of the delivery channel to delete.
    /// This member is required.
    public var deliveryChannelName: Swift.String?

    public init(
        deliveryChannelName: Swift.String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

///
public struct DeleteEvaluationResultsInput: Swift.Sendable {
    /// The name of the Config rule for which you want to delete the evaluation results.
    /// This member is required.
    public var configRuleName: Swift.String?

    public init(
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

/// The output when you delete the evaluation results for the specified Config rule.
public struct DeleteEvaluationResultsOutput: Swift.Sendable {

    public init() { }
}

/// The Config rule in the request is not valid. Verify that the rule is an organization Config Process Check rule, that the rule name is correct, and that valid Amazon Resouce Names (ARNs) are used before trying again.
public struct NoSuchOrganizationConfigRuleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOrganizationConfigRuleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// For PutConfigurationAggregator API, you can see this exception for the following reasons:
///
/// * No permission to call EnableAWSServiceAccess API
///
/// * The configuration aggregator cannot be updated because your Amazon Web Services Organization management account or the delegated administrator role changed. Delete this aggregator and create a new one with the current Amazon Web Services Organization.
///
/// * The configuration aggregator is associated with a previous Amazon Web Services Organization and Config cannot aggregate data with current Amazon Web Services Organization. Delete this aggregator and create a new one with the current Amazon Web Services Organization.
///
/// * You are not a registered delegated administrator for Config with permissions to call ListDelegatedAdministrators API. Ensure that the management account registers delagated administrator for Config service principle name before the delegated administrator creates an aggregator.
///
///
/// For all OrganizationConfigRule and OrganizationConformancePack APIs, Config throws an exception if APIs are called from member accounts. All APIs must be called from organization management account.
public struct OrganizationAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteOrganizationConfigRuleInput: Swift.Sendable {
    /// The name of organization Config rule that you want to delete.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init(
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

/// Config organization conformance pack that you passed in the filter does not exist. For DeleteOrganizationConformancePack, you tried to delete an organization conformance pack that does not exist.
public struct NoSuchOrganizationConformancePackException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchOrganizationConformancePackException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteOrganizationConformancePackInput: Swift.Sendable {
    /// The name of organization conformance pack that you want to delete.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?

    public init(
        organizationConformancePackName: Swift.String? = nil
    )
    {
        self.organizationConformancePackName = organizationConformancePackName
    }
}

public struct DeletePendingAggregationRequestInput: Swift.Sendable {
    /// The 12-digit account ID of the account requesting to aggregate data.
    /// This member is required.
    public var requesterAccountId: Swift.String?
    /// The region requesting to aggregate data.
    /// This member is required.
    public var requesterAwsRegion: Swift.String?

    public init(
        requesterAccountId: Swift.String? = nil,
        requesterAwsRegion: Swift.String? = nil
    )
    {
        self.requesterAccountId = requesterAccountId
        self.requesterAwsRegion = requesterAwsRegion
    }
}

/// Indicates one of the following errors:
///
/// * For PutConfigRule, the rule cannot be created because the IAM role assigned to Config lacks permissions to perform the config:Put* action.
///
/// * For PutConfigRule, the Lambda function cannot be invoked. Check the function ARN, and check the function's permissions.
///
/// * For PutOrganizationConfigRule, organization Config rule cannot be created because you do not have permissions to call IAM GetRole action or create a service-linked role.
///
/// * For PutConformancePack and PutOrganizationConformancePack, a conformance pack cannot be created because you do not have the following permissions:
///
/// * You do not have permission to call IAM GetRole action or create a service-linked role.
///
/// * You do not have permission to read Amazon S3 bucket or call SSM:GetDocument.
public struct InsufficientPermissionsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientPermissionsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You specified an Config rule without a remediation configuration.
public struct NoSuchRemediationConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRemediationConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Remediation action is in progress. You can either cancel execution in Amazon Web Services Systems Manager or wait and try again later.
public struct RemediationInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RemediationInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteRemediationConfigurationInput: Swift.Sendable {
    /// The name of the Config rule for which you want to delete remediation configuration.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The type of a resource.
    public var resourceType: Swift.String?

    public init(
        configRuleName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceType = resourceType
    }
}

public struct DeleteRemediationConfigurationOutput: Swift.Sendable {

    public init() { }
}

/// You tried to delete a remediation exception that does not exist.
public struct NoSuchRemediationExceptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRemediationExceptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigClientTypes {

    /// The details that identify a resource within Config, including the resource type and resource ID.
    public struct RemediationExceptionResourceKey: Swift.Sendable {
        /// The ID of the resource (for example., sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The type of a resource.
        public var resourceType: Swift.String?

        public init(
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct DeleteRemediationExceptionsInput: Swift.Sendable {
    /// The name of the Config rule for which you want to delete remediation exception configuration.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init(
        configRuleName: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

extension ConfigClientTypes {

    /// List of each of the failed delete remediation exceptions with specific reasons.
    public struct FailedDeleteRemediationExceptionsBatch: Swift.Sendable {
        /// Returns remediation exception resource key object of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationExceptionResourceKey]?
        /// Returns a failure message for delete remediation exception. For example, Config creates an exception due to an internal error.
        public var failureMessage: Swift.String?

        public init(
            failedItems: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }
}

public struct DeleteRemediationExceptionsOutput: Swift.Sendable {
    /// Returns a list of failed delete remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
    public var failedBatches: [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]?

    public init(
        failedBatches: [ConfigClientTypes.FailedDeleteRemediationExceptionsBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

/// There is no configuration recorder running.
public struct NoRunningConfigurationRecorderException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoRunningConfigurationRecorderException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteResourceConfigInput: Swift.Sendable {
    /// Unique identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

/// You have specified a retention configuration that does not exist.
public struct NoSuchRetentionConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchRetentionConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteRetentionConfigurationInput: Swift.Sendable {
    /// The name of the retention configuration to delete.
    /// This member is required.
    public var retentionConfigurationName: Swift.String?

    public init(
        retentionConfigurationName: Swift.String? = nil
    )
    {
        self.retentionConfigurationName = retentionConfigurationName
    }
}

/// You have specified a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteStoredQueryInput: Swift.Sendable {
    /// The name of the query that you want to delete.
    /// This member is required.
    public var queryName: Swift.String?

    public init(
        queryName: Swift.String? = nil
    )
    {
        self.queryName = queryName
    }
}

public struct DeleteStoredQueryOutput: Swift.Sendable {

    public init() { }
}

/// The input for the [DeliverConfigSnapshot] action.
public struct DeliverConfigSnapshotInput: Swift.Sendable {
    /// The name of the delivery channel through which the snapshot is delivered.
    /// This member is required.
    public var deliveryChannelName: Swift.String?

    public init(
        deliveryChannelName: Swift.String? = nil
    )
    {
        self.deliveryChannelName = deliveryChannelName
    }
}

/// The output for the [DeliverConfigSnapshot] action, in JSON format.
public struct DeliverConfigSnapshotOutput: Swift.Sendable {
    /// The ID of the snapshot that is being created.
    public var configSnapshotId: Swift.String?

    public init(
        configSnapshotId: Swift.String? = nil
    )
    {
        self.configSnapshotId = configSnapshotId
    }
}

extension ConfigClientTypes {

    /// The channel through which Config delivers notifications and updated configuration states.
    public struct DeliveryChannel: Swift.Sendable {
        /// The options for how often Config delivers configuration snapshots to the Amazon S3 bucket.
        public var configSnapshotDeliveryProperties: ConfigClientTypes.ConfigSnapshotDeliveryProperties?
        /// The name of the delivery channel. By default, Config assigns the name "default" when creating the delivery channel. To change the delivery channel name, you must use the DeleteDeliveryChannel action to delete your current delivery channel, and then you must use the PutDeliveryChannel command to create a delivery channel that has the desired name.
        public var name: Swift.String?
        /// The name of the Amazon S3 bucket to which Config delivers configuration snapshots and configuration history files. If you specify a bucket that belongs to another Amazon Web Services account, that bucket must have policies that grant access permissions to Config. For more information, see [Permissions for the Amazon S3 Bucket](https://docs.aws.amazon.com/config/latest/developerguide/s3-bucket-policy.html) in the Config Developer Guide.
        public var s3BucketName: Swift.String?
        /// The prefix for the specified Amazon S3 bucket.
        public var s3KeyPrefix: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS ) KMS key (KMS key) used to encrypt objects delivered by Config. Must belong to the same Region as the destination S3 bucket.
        public var s3KmsKeyArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic to which Config sends notifications about configuration changes. If you choose a topic from another account, the topic must have policies that grant access permissions to Config. For more information, see [Permissions for the Amazon SNS Topic](https://docs.aws.amazon.com/config/latest/developerguide/sns-topic-policy.html) in the Config Developer Guide.
        public var snsTopicARN: Swift.String?

        public init(
            configSnapshotDeliveryProperties: ConfigClientTypes.ConfigSnapshotDeliveryProperties? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            s3KmsKeyArn: Swift.String? = nil,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.configSnapshotDeliveryProperties = configSnapshotDeliveryProperties
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.s3KmsKeyArn = s3KmsKeyArn
            self.snsTopicARN = snsTopicARN
        }
    }
}

extension ConfigClientTypes {

    /// The status of a specified delivery channel. Valid values: Success | Failure
    public struct DeliveryChannelStatus: Swift.Sendable {
        /// A list that contains the status of the delivery of the configuration history to the specified Amazon S3 bucket.
        public var configHistoryDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the snapshot to the specified Amazon S3 bucket.
        public var configSnapshotDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo?
        /// A list containing the status of the delivery of the configuration stream notification to the specified Amazon SNS topic.
        public var configStreamDeliveryInfo: ConfigClientTypes.ConfigStreamDeliveryInfo?
        /// The name of the delivery channel.
        public var name: Swift.String?

        public init(
            configHistoryDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo? = nil,
            configSnapshotDeliveryInfo: ConfigClientTypes.ConfigExportDeliveryInfo? = nil,
            configStreamDeliveryInfo: ConfigClientTypes.ConfigStreamDeliveryInfo? = nil,
            name: Swift.String? = nil
        )
        {
            self.configHistoryDeliveryInfo = configHistoryDeliveryInfo
            self.configSnapshotDeliveryInfo = configSnapshotDeliveryInfo
            self.configStreamDeliveryInfo = configStreamDeliveryInfo
            self.name = name
        }
    }
}

/// The specified limit is outside the allowable range.
public struct InvalidLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLimitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified next token is not valid. Specify the nextToken string that was returned in the previous response to get the next page of results.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAggregateComplianceByConfigRulesInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results by ConfigRuleComplianceFilters object.
    public var filters: ConfigClientTypes.ConfigRuleComplianceFilters?
    /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ConfigRuleComplianceFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeAggregateComplianceByConfigRulesOutput: Swift.Sendable {
    /// Returns a list of AggregateComplianceByConfigRule object.
    public var aggregateComplianceByConfigRules: [ConfigClientTypes.AggregateComplianceByConfigRule]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregateComplianceByConfigRules: [ConfigClientTypes.AggregateComplianceByConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceByConfigRules = aggregateComplianceByConfigRules
        self.nextToken = nextToken
    }
}

public struct DescribeAggregateComplianceByConformancePacksInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the result by AggregateConformancePackComplianceFilters object.
    public var filters: ConfigClientTypes.AggregateConformancePackComplianceFilters?
    /// The maximum number of conformance packs compliance details returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.AggregateConformancePackComplianceFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeAggregateComplianceByConformancePacksOutput: Swift.Sendable {
    /// Returns the AggregateComplianceByConformancePack object.
    public var aggregateComplianceByConformancePacks: [ConfigClientTypes.AggregateComplianceByConformancePack]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregateComplianceByConformancePacks: [ConfigClientTypes.AggregateComplianceByConformancePack]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceByConformancePacks = aggregateComplianceByConformancePacks
        self.nextToken = nextToken
    }
}

public struct DescribeAggregationAuthorizationsInput: Swift.Sendable {
    /// The maximum number of AggregationAuthorizations returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeAggregationAuthorizationsOutput: Swift.Sendable {
    /// Returns a list of authorizations granted to various aggregator accounts and regions.
    public var aggregationAuthorizations: [ConfigClientTypes.AggregationAuthorization]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregationAuthorizations: [ConfigClientTypes.AggregationAuthorization]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationAuthorizations = aggregationAuthorizations
        self.nextToken = nextToken
    }
}

///
public struct DescribeComplianceByConfigRuleInput: Swift.Sendable {
    /// Filters the results by compliance.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// Specify one or more Config rule names to filter the results by rule.
    public var configRuleNames: [Swift.String]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        configRuleNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleNames = configRuleNames
        self.nextToken = nextToken
    }
}

///
public struct DescribeComplianceByConfigRuleOutput: Swift.Sendable {
    /// Indicates whether each of the specified Config rules is compliant.
    public var complianceByConfigRules: [ConfigClientTypes.ComplianceByConfigRule]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        complianceByConfigRules: [ConfigClientTypes.ComplianceByConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceByConfigRules = complianceByConfigRules
        self.nextToken = nextToken
    }
}

///
public struct DescribeComplianceByResourceInput: Swift.Sendable {
    /// Filters the results by compliance.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The ID of the Amazon Web Services resource for which you want compliance information. You can specify only one resource ID. If you specify a resource ID, you must also specify a type for ResourceType.
    public var resourceId: Swift.String?
    /// The types of Amazon Web Services resources for which you want compliance information (for example, AWS::EC2::Instance). For this action, you can specify that the resource type is an Amazon Web Services account by specifying AWS::::Account.
    public var resourceType: Swift.String?

    public init(
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

///
public struct DescribeComplianceByResourceOutput: Swift.Sendable {
    /// Indicates whether the specified Amazon Web Services resource complies with all of the Config rules that evaluate it.
    public var complianceByResources: [ConfigClientTypes.ComplianceByResource]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        complianceByResources: [ConfigClientTypes.ComplianceByResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceByResources = complianceByResources
        self.nextToken = nextToken
    }
}

///
public struct DescribeConfigRuleEvaluationStatusInput: Swift.Sendable {
    /// The name of the Config managed rules for which you want status information. If you do not specify any names, Config returns status information for all Config managed rules that you use.
    public var configRuleNames: [Swift.String]?
    /// The number of rule evaluation results that you want returned. This parameter is required if the rule limit for your account is more than the default of 1000 rules. For information about requesting a rule limit increase, see [Config Limits](http://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_config) in the Amazon Web Services General Reference Guide.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configRuleNames: [Swift.String]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

///
public struct DescribeConfigRuleEvaluationStatusOutput: Swift.Sendable {
    /// Status information about your Config managed rules.
    public var configRulesEvaluationStatus: [ConfigClientTypes.ConfigRuleEvaluationStatus]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configRulesEvaluationStatus: [ConfigClientTypes.ConfigRuleEvaluationStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRulesEvaluationStatus = configRulesEvaluationStatus
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// Returns a filtered list of Detective or Proactive Config rules. By default, if the filter is not defined, this API returns an unfiltered list. For more information on Detective or Proactive Config rules, see [ Evaluation Mode ](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config-rules.html) in the Config Developer Guide.
    public struct DescribeConfigRulesFilters: Swift.Sendable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?

        public init(
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil
        )
        {
            self.evaluationMode = evaluationMode
        }
    }
}

///
public struct DescribeConfigRulesInput: Swift.Sendable {
    /// The names of the Config rules for which you want details. If you do not specify any names, Config returns details for all your rules.
    public var configRuleNames: [Swift.String]?
    /// Returns a list of Detective or Proactive Config rules. By default, this API returns an unfiltered list. For more information on Detective or Proactive Config rules, see [ Evaluation Mode ](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config-rules.html) in the Config Developer Guide.
    public var filters: ConfigClientTypes.DescribeConfigRulesFilters?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configRuleNames: [Swift.String]? = nil,
        filters: ConfigClientTypes.DescribeConfigRulesFilters? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRuleNames = configRuleNames
        self.filters = filters
        self.nextToken = nextToken
    }
}

///
public struct DescribeConfigRulesOutput: Swift.Sendable {
    /// The details about your Config rules.
    public var configRules: [ConfigClientTypes.ConfigRule]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configRules: [ConfigClientTypes.ConfigRule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configRules = configRules
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationAggregatorsInput: Swift.Sendable {
    /// The name of the configuration aggregators.
    public var configurationAggregatorNames: [Swift.String]?
    /// The maximum number of configuration aggregators returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorNames: [Swift.String]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorNames = configurationAggregatorNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationAggregatorsOutput: Swift.Sendable {
    /// Returns a ConfigurationAggregators object.
    public var configurationAggregators: [ConfigClientTypes.ConfigurationAggregator]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregators: [ConfigClientTypes.ConfigurationAggregator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregators = configurationAggregators
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The maximum number of AggregatorSourceStatus returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Filters the status type.
    ///
    /// * Valid value FAILED indicates errors while moving data.
    ///
    /// * Valid value SUCCEEDED indicates the data was successfully moved.
    ///
    /// * Valid value OUTDATED indicates the data is not the most recent.
    public var updateStatus: [ConfigClientTypes.AggregatedSourceStatusType]?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        updateStatus: [ConfigClientTypes.AggregatedSourceStatusType]? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
        self.updateStatus = updateStatus
    }
}

public struct DescribeConfigurationAggregatorSourcesStatusOutput: Swift.Sendable {
    /// Returns an AggregatedSourceStatus object.
    public var aggregatedSourceStatusList: [ConfigClientTypes.AggregatedSourceStatus]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregatedSourceStatusList: [ConfigClientTypes.AggregatedSourceStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedSourceStatusList = aggregatedSourceStatusList
        self.nextToken = nextToken
    }
}

/// The input for the [DescribeConfigurationRecorders] action.
public struct DescribeConfigurationRecordersInput: Swift.Sendable {
    /// A list of configuration recorder names.
    public var configurationRecorderNames: [Swift.String]?

    public init(
        configurationRecorderNames: [Swift.String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

/// The output for the [DescribeConfigurationRecorders] action.
public struct DescribeConfigurationRecordersOutput: Swift.Sendable {
    /// A list that contains the descriptions of the specified configuration recorders.
    public var configurationRecorders: [ConfigClientTypes.ConfigurationRecorder]?

    public init(
        configurationRecorders: [ConfigClientTypes.ConfigurationRecorder]? = nil
    )
    {
        self.configurationRecorders = configurationRecorders
    }
}

/// The input for the [DescribeConfigurationRecorderStatus] action.
public struct DescribeConfigurationRecorderStatusInput: Swift.Sendable {
    /// The name(s) of the configuration recorder. If the name is not specified, the action returns the current status of all the configuration recorders associated with the account.
    public var configurationRecorderNames: [Swift.String]?

    public init(
        configurationRecorderNames: [Swift.String]? = nil
    )
    {
        self.configurationRecorderNames = configurationRecorderNames
    }
}

/// The output for the [DescribeConfigurationRecorderStatus] action, in JSON format.
public struct DescribeConfigurationRecorderStatusOutput: Swift.Sendable {
    /// A list that contains status of the specified recorders.
    public var configurationRecordersStatus: [ConfigClientTypes.ConfigurationRecorderStatus]?

    public init(
        configurationRecordersStatus: [ConfigClientTypes.ConfigurationRecorderStatus]? = nil
    )
    {
        self.configurationRecordersStatus = configurationRecordersStatus
    }
}

/// Config rule that you passed in the filter does not exist.
public struct NoSuchConfigRuleInConformancePackException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchConfigRuleInConformancePackException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeConformancePackComplianceInput: Swift.Sendable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// A ConformancePackComplianceFilters object.
    public var filters: ConfigClientTypes.ConformancePackComplianceFilters?
    /// The maximum number of Config rules within a conformance pack are returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackName: Swift.String? = nil,
        filters: ConfigClientTypes.ConformancePackComplianceFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeConformancePackComplianceOutput: Swift.Sendable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// Returns a list of ConformancePackRuleCompliance objects.
    /// This member is required.
    public var conformancePackRuleComplianceList: [ConfigClientTypes.ConformancePackRuleCompliance]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackName: Swift.String? = nil,
        conformancePackRuleComplianceList: [ConfigClientTypes.ConformancePackRuleCompliance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleComplianceList = conformancePackRuleComplianceList
        self.nextToken = nextToken
    }
}

public struct DescribeConformancePacksInput: Swift.Sendable {
    /// Comma-separated list of conformance pack names for which you want details. If you do not specify any names, Config returns details for all your conformance packs.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeConformancePacksOutput: Swift.Sendable {
    /// Returns a list of ConformancePackDetail objects.
    public var conformancePackDetails: [ConfigClientTypes.ConformancePackDetail]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackDetails: [ConfigClientTypes.ConformancePackDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackDetails = conformancePackDetails
        self.nextToken = nextToken
    }
}

public struct DescribeConformancePackStatusInput: Swift.Sendable {
    /// Comma-separated list of conformance pack names.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs status returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct DescribeConformancePackStatusOutput: Swift.Sendable {
    /// A list of ConformancePackStatusDetail objects.
    public var conformancePackStatusDetails: [ConfigClientTypes.ConformancePackStatusDetail]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackStatusDetails: [ConfigClientTypes.ConformancePackStatusDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackStatusDetails = conformancePackStatusDetails
        self.nextToken = nextToken
    }
}

/// The input for the [DescribeDeliveryChannels] action.
public struct DescribeDeliveryChannelsInput: Swift.Sendable {
    /// A list of delivery channel names.
    public var deliveryChannelNames: [Swift.String]?

    public init(
        deliveryChannelNames: [Swift.String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

/// The output for the [DescribeDeliveryChannels] action.
public struct DescribeDeliveryChannelsOutput: Swift.Sendable {
    /// A list that contains the descriptions of the specified delivery channel.
    public var deliveryChannels: [ConfigClientTypes.DeliveryChannel]?

    public init(
        deliveryChannels: [ConfigClientTypes.DeliveryChannel]? = nil
    )
    {
        self.deliveryChannels = deliveryChannels
    }
}

/// The input for the [DeliveryChannelStatus] action.
public struct DescribeDeliveryChannelStatusInput: Swift.Sendable {
    /// A list of delivery channel names.
    public var deliveryChannelNames: [Swift.String]?

    public init(
        deliveryChannelNames: [Swift.String]? = nil
    )
    {
        self.deliveryChannelNames = deliveryChannelNames
    }
}

/// The output for the [DescribeDeliveryChannelStatus] action.
public struct DescribeDeliveryChannelStatusOutput: Swift.Sendable {
    /// A list that contains the status of a specified delivery channel.
    public var deliveryChannelsStatus: [ConfigClientTypes.DeliveryChannelStatus]?

    public init(
        deliveryChannelsStatus: [ConfigClientTypes.DeliveryChannelStatus]? = nil
    )
    {
        self.deliveryChannelsStatus = deliveryChannelsStatus
    }
}

public struct DescribeOrganizationConfigRulesInput: Swift.Sendable {
    /// The maximum number of organization Config rules returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization Config rules for which you want details. If you do not specify any names, Config returns details for all your organization Config rules.
    public var organizationConfigRuleNames: [Swift.String]?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

extension ConfigClientTypes {

    public enum OrganizationConfigRuleTriggerTypeNoSN: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationItemChangeNotification
        case oversizedConfigurationItemChangeNotifcation
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigRuleTriggerTypeNoSN] {
            return [
                .configurationItemChangeNotification,
                .oversizedConfigurationItemChangeNotifcation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationItemChangeNotification: return "ConfigurationItemChangeNotification"
            case .oversizedConfigurationItemChangeNotifcation: return "OversizedConfigurationItemChangeNotification"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// metadata for your organization Config Custom Policy rule including the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that trigger Config to evaluate Amazon Web Services resources against a rule.
    public struct OrganizationCustomPolicyRuleMetadataNoPolicy: Swift.Sendable {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public var debugLogDeliveryAccounts: [Swift.String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change triggered notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        public var policyRuntime: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init(
            debugLogDeliveryAccounts: [Swift.String]? = nil,
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil,
            policyRuntime: Swift.String? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }
}

extension ConfigClientTypes {

    public enum OrganizationConfigRuleTriggerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationItemChangeNotification
        case oversizedConfigurationItemChangeNotifcation
        case scheduledNotification
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigRuleTriggerType] {
            return [
                .configurationItemChangeNotification,
                .oversizedConfigurationItemChangeNotifcation,
                .scheduledNotification
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationItemChangeNotification: return "ConfigurationItemChangeNotification"
            case .oversizedConfigurationItemChangeNotifcation: return "OversizedConfigurationItemChangeNotification"
            case .scheduledNotification: return "ScheduledNotification"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// An object that specifies organization custom rule metadata such as resource type, resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public struct OrganizationCustomRuleMetadata: Swift.Sendable {
        /// The description that you provide for your organization Config rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The lambda function ARN.
        /// This member is required.
        public var lambdaFunctionArn: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your custom rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties]. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that triggers Config to run an evaluation for a rule. You can specify the following notification types:
        ///
        /// * ConfigurationItemChangeNotification - Triggers an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Triggers an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        ///
        /// * ScheduledNotification - Triggers a periodic evaluation at the frequency specified for MaximumExecutionFrequency.
        /// This member is required.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerType]?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerType]? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.description = description
            self.inputParameters = inputParameters
            self.lambdaFunctionArn = lambdaFunctionArn
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }
}

extension ConfigClientTypes {

    /// An object that specifies organization managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public struct OrganizationManagedRuleMetadata: Swift.Sendable {
        /// The description that you provide for your organization Config rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config rule Lambda function.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. This is for an Config managed rule that is triggered at a periodic frequency. By default, rules with a periodic trigger are evaluated every 24 hours. To change the frequency, specify a valid value for the MaximumExecutionFrequency parameter.
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// For organization config managed rules, a predefined identifier from a list. For example, IAM_PASSWORD_POLICY is a managed rule. To reference a managed rule, see [Using Config managed rules](https://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_use-managed-rules.html).
        /// This member is required.
        public var ruleIdentifier: Swift.String?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            ruleIdentifier: Swift.String? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.ruleIdentifier = ruleIdentifier
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }
}

extension ConfigClientTypes {

    /// An organization Config rule that has information about Config rules that Config creates in member accounts.
    public struct OrganizationConfigRule: Swift.Sendable {
        /// A comma-separated list of accounts excluded from organization Config rule.
        public var excludedAccounts: [Swift.String]?
        /// The timestamp of the last update.
        public var lastUpdateTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of organization Config rule.
        /// This member is required.
        public var organizationConfigRuleArn: Swift.String?
        /// The name that you assign to organization Config rule.
        /// This member is required.
        public var organizationConfigRuleName: Swift.String?
        /// An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
        public var organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy?
        /// An OrganizationCustomRuleMetadata object.
        public var organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata?
        /// An OrganizationManagedRuleMetadata object.
        public var organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata?

        public init(
            excludedAccounts: [Swift.String]? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            organizationConfigRuleArn: Swift.String? = nil,
            organizationConfigRuleName: Swift.String? = nil,
            organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy? = nil,
            organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata? = nil,
            organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata? = nil
        )
        {
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleArn = organizationConfigRuleArn
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
            self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
            self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
        }
    }
}

public struct DescribeOrganizationConfigRulesOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of OrganizationConfigRule objects.
    public var organizationConfigRules: [ConfigClientTypes.OrganizationConfigRule]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConfigRules: [ConfigClientTypes.OrganizationConfigRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRules = organizationConfigRules
    }
}

public struct DescribeOrganizationConfigRuleStatusesInput: Swift.Sendable {
    /// The maximum number of OrganizationConfigRuleStatuses returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization Config rules for which you want status details. If you do not specify any names, Config returns details for all your organization Config rules.
    public var organizationConfigRuleNames: [Swift.String]?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleNames = organizationConfigRuleNames
    }
}

extension ConfigClientTypes {

    public enum OrganizationRuleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationRuleStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Returns the status for an organization Config rule in an organization.
    public struct OrganizationConfigRuleStatus: Swift.Sendable {
        /// An error code that is returned when organization Config rule creation or deletion has failed.
        public var errorCode: Swift.String?
        /// An error message indicating that organization Config rule creation or deletion failed due to an error.
        public var errorMessage: Swift.String?
        /// The timestamp of the last update.
        public var lastUpdateTime: Foundation.Date?
        /// The name that you assign to organization Config rule.
        /// This member is required.
        public var organizationConfigRuleName: Swift.String?
        /// Indicates deployment status of an organization Config rule. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in all the member accounts. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in all the member accounts. Additionally, Config rule status is updated when one or more member accounts join or leave an organization. Config rule status is deleted when the management account deletes OrganizationConfigRule in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when an organization Config rule has been successfully created in all the member accounts.
        ///
        /// * CREATE_IN_PROGRESS when an organization Config rule creation is in progress.
        ///
        /// * CREATE_FAILED when an organization Config rule creation failed in one or more member accounts within that organization.
        ///
        /// * DELETE_FAILED when an organization Config rule deletion failed in one or more member accounts within that organization.
        ///
        /// * DELETE_IN_PROGRESS when an organization Config rule deletion is in progress.
        ///
        /// * DELETE_SUCCESSFUL when an organization Config rule has been successfully deleted from all the member accounts.
        ///
        /// * UPDATE_SUCCESSFUL when an organization Config rule has been successfully updated in all the member accounts.
        ///
        /// * UPDATE_IN_PROGRESS when an organization Config rule update is in progress.
        ///
        /// * UPDATE_FAILED when an organization Config rule update failed in one or more member accounts within that organization.
        /// This member is required.
        public var organizationRuleStatus: ConfigClientTypes.OrganizationRuleStatus?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            organizationConfigRuleName: Swift.String? = nil,
            organizationRuleStatus: ConfigClientTypes.OrganizationRuleStatus? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConfigRuleName = organizationConfigRuleName
            self.organizationRuleStatus = organizationRuleStatus
        }
    }
}

public struct DescribeOrganizationConfigRuleStatusesOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConfigRuleStatus objects.
    public var organizationConfigRuleStatuses: [ConfigClientTypes.OrganizationConfigRuleStatus]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConfigRuleStatuses: [ConfigClientTypes.OrganizationConfigRuleStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleStatuses = organizationConfigRuleStatuses
    }
}

public struct DescribeOrganizationConformancePacksInput: Swift.Sendable {
    /// The maximum number of organization config packs returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name that you assign to an organization conformance pack.
    public var organizationConformancePackNames: [Swift.String]?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

extension ConfigClientTypes {

    /// An organization conformance pack that has information about conformance packs that Config creates in member accounts.
    public struct OrganizationConformancePack: Swift.Sendable {
        /// A list of ConformancePackInputParameter objects.
        public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
        /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
        public var deliveryS3Bucket: Swift.String?
        /// Any folder structure you want to add to an Amazon S3 bucket. This field is optional.
        public var deliveryS3KeyPrefix: Swift.String?
        /// A comma-separated list of accounts excluded from organization conformance pack.
        public var excludedAccounts: [Swift.String]?
        /// Last time when organization conformation pack was updated.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// Amazon Resource Name (ARN) of organization conformance pack.
        /// This member is required.
        public var organizationConformancePackArn: Swift.String?
        /// The name you assign to an organization conformance pack.
        /// This member is required.
        public var organizationConformancePackName: Swift.String?

        public init(
            conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
            deliveryS3Bucket: Swift.String? = nil,
            deliveryS3KeyPrefix: Swift.String? = nil,
            excludedAccounts: [Swift.String]? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            organizationConformancePackArn: Swift.String? = nil,
            organizationConformancePackName: Swift.String? = nil
        )
        {
            self.conformancePackInputParameters = conformancePackInputParameters
            self.deliveryS3Bucket = deliveryS3Bucket
            self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
            self.excludedAccounts = excludedAccounts
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackArn = organizationConformancePackArn
            self.organizationConformancePackName = organizationConformancePackName
        }
    }
}

public struct DescribeOrganizationConformancePacksOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of OrganizationConformancePacks objects.
    public var organizationConformancePacks: [ConfigClientTypes.OrganizationConformancePack]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConformancePacks: [ConfigClientTypes.OrganizationConformancePack]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePacks = organizationConformancePacks
    }
}

public struct DescribeOrganizationConformancePackStatusesInput: Swift.Sendable {
    /// The maximum number of OrganizationConformancePackStatuses returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The names of organization conformance packs for which you want status details. If you do not specify any names, Config returns details for all your organization conformance packs.
    public var organizationConformancePackNames: [Swift.String]?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackNames: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackNames = organizationConformancePackNames
    }
}

extension ConfigClientTypes {

    public enum OrganizationResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Returns the status for an organization conformance pack in an organization.
    public struct OrganizationConformancePackStatus: Swift.Sendable {
        /// An error code that is returned when organization conformance pack creation or deletion has failed in a member account.
        public var errorCode: Swift.String?
        /// An error message indicating that organization conformance pack creation or deletion failed due to an error.
        public var errorMessage: Swift.String?
        /// The timestamp of the last update.
        public var lastUpdateTime: Foundation.Date?
        /// The name that you assign to organization conformance pack.
        /// This member is required.
        public var organizationConformancePackName: Swift.String?
        /// Indicates deployment status of an organization conformance pack. When management account calls PutOrganizationConformancePack for the first time, conformance pack status is created in all the member accounts. When management account calls PutOrganizationConformancePack for the second time, conformance pack status is updated in all the member accounts. Additionally, conformance pack status is updated when one or more member accounts join or leave an organization. Conformance pack status is deleted when the management account deletes OrganizationConformancePack in all the member accounts and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when an organization conformance pack has been successfully created in all the member accounts.
        ///
        /// * CREATE_IN_PROGRESS when an organization conformance pack creation is in progress.
        ///
        /// * CREATE_FAILED when an organization conformance pack creation failed in one or more member accounts within that organization.
        ///
        /// * DELETE_FAILED when an organization conformance pack deletion failed in one or more member accounts within that organization.
        ///
        /// * DELETE_IN_PROGRESS when an organization conformance pack deletion is in progress.
        ///
        /// * DELETE_SUCCESSFUL when an organization conformance pack has been successfully deleted from all the member accounts.
        ///
        /// * UPDATE_SUCCESSFUL when an organization conformance pack has been successfully updated in all the member accounts.
        ///
        /// * UPDATE_IN_PROGRESS when an organization conformance pack update is in progress.
        ///
        /// * UPDATE_FAILED when an organization conformance pack update failed in one or more member accounts within that organization.
        /// This member is required.
        public var status: ConfigClientTypes.OrganizationResourceStatus?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            organizationConformancePackName: Swift.String? = nil,
            status: ConfigClientTypes.OrganizationResourceStatus? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.organizationConformancePackName = organizationConformancePackName
            self.status = status
        }
    }
}

public struct DescribeOrganizationConformancePackStatusesOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConformancePackStatus objects.
    public var organizationConformancePackStatuses: [ConfigClientTypes.OrganizationConformancePackStatus]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConformancePackStatuses: [ConfigClientTypes.OrganizationConformancePackStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackStatuses = organizationConformancePackStatuses
    }
}

public struct DescribePendingAggregationRequestsInput: Swift.Sendable {
    /// The maximum number of evaluation results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// An object that represents the account ID and region of an aggregator account that is requesting authorization but is not yet authorized.
    public struct PendingAggregationRequest: Swift.Sendable {
        /// The 12-digit account ID of the account requesting to aggregate data.
        public var requesterAccountId: Swift.String?
        /// The region requesting to aggregate data.
        public var requesterAwsRegion: Swift.String?

        public init(
            requesterAccountId: Swift.String? = nil,
            requesterAwsRegion: Swift.String? = nil
        )
        {
            self.requesterAccountId = requesterAccountId
            self.requesterAwsRegion = requesterAwsRegion
        }
    }
}

public struct DescribePendingAggregationRequestsOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a PendingAggregationRequests object.
    public var pendingAggregationRequests: [ConfigClientTypes.PendingAggregationRequest]?

    public init(
        nextToken: Swift.String? = nil,
        pendingAggregationRequests: [ConfigClientTypes.PendingAggregationRequest]? = nil
    )
    {
        self.nextToken = nextToken
        self.pendingAggregationRequests = pendingAggregationRequests
    }
}

public struct DescribeRemediationConfigurationsInput: Swift.Sendable {
    /// A list of Config rule names of remediation configurations for which you want details.
    /// This member is required.
    public var configRuleNames: [Swift.String]?

    public init(
        configRuleNames: [Swift.String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

extension ConfigClientTypes {

    /// Amazon Web Services Systems Manager (SSM) specific remediation controls.
    public struct SsmControls: Swift.Sendable {
        /// The maximum percentage of remediation actions allowed to run in parallel on the non-compliant resources for that specific rule. You can specify a percentage, such as 10%. The default value is 10.
        public var concurrentExecutionRatePercentage: Swift.Int?
        /// The percentage of errors that are allowed before SSM stops running automations on non-compliant resources for that specific rule. You can specify a percentage of errors, for example 10%. If you do not specifiy a percentage, the default is 50%. For example, if you set the ErrorPercentage to 40% for 10 non-compliant resources, then SSM stops running the automations when the fifth error is received.
        public var errorPercentage: Swift.Int?

        public init(
            concurrentExecutionRatePercentage: Swift.Int? = nil,
            errorPercentage: Swift.Int? = nil
        )
        {
            self.concurrentExecutionRatePercentage = concurrentExecutionRatePercentage
            self.errorPercentage = errorPercentage
        }
    }
}

extension ConfigClientTypes {

    /// The controls that Config uses for executing remediations.
    public struct ExecutionControls: Swift.Sendable {
        /// A SsmControls object.
        public var ssmControls: ConfigClientTypes.SsmControls?

        public init(
            ssmControls: ConfigClientTypes.SsmControls? = nil
        )
        {
            self.ssmControls = ssmControls
        }
    }
}

extension ConfigClientTypes {

    public enum ResourceValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resourceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceValueType] {
            return [
                .resourceId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resourceId: return "RESOURCE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// The dynamic value of the resource.
    public struct ResourceValue: Swift.Sendable {
        /// The value is a resource ID.
        /// This member is required.
        public var value: ConfigClientTypes.ResourceValueType?

        public init(
            value: ConfigClientTypes.ResourceValueType? = nil
        )
        {
            self.value = value
        }
    }
}

extension ConfigClientTypes {

    /// The static value of the resource.
    public struct StaticValue: Swift.Sendable {
        /// A list of values. For example, the ARN of the assumed role.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }
}

extension ConfigClientTypes {

    /// The value is either a dynamic (resource) value or a static value. You must select either a dynamic value or a static value.
    public struct RemediationParameterValue: Swift.Sendable {
        /// The value is dynamic and changes at run-time.
        public var resourceValue: ConfigClientTypes.ResourceValue?
        /// The value is static and does not change at run-time.
        public var staticValue: ConfigClientTypes.StaticValue?

        public init(
            resourceValue: ConfigClientTypes.ResourceValue? = nil,
            staticValue: ConfigClientTypes.StaticValue? = nil
        )
        {
            self.resourceValue = resourceValue
            self.staticValue = staticValue
        }
    }
}

extension ConfigClientTypes {

    public enum RemediationTargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssmDocument
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationTargetType] {
            return [
                .ssmDocument
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssmDocument: return "SSM_DOCUMENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// An object that represents the details about the remediation configuration that includes the remediation action, parameters, and data to execute the action.
    public struct RemediationConfiguration: Swift.Sendable {
        /// Amazon Resource Name (ARN) of remediation configuration.
        public var arn: Swift.String?
        /// The remediation is triggered automatically.
        public var automatic: Swift.Bool
        /// The name of the Config rule.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// Name of the service that owns the service-linked rule, if applicable.
        public var createdByService: Swift.String?
        /// An ExecutionControls object.
        public var executionControls: ConfigClientTypes.ExecutionControls?
        /// The maximum number of failed attempts for auto-remediation. If you do not select a number, the default is 5. For example, if you specify MaximumAutomaticAttempts as 5 with RetryAttemptSeconds as 50 seconds, Config will put a RemediationException on your behalf for the failing resource after the 5th failed attempt within 50 seconds.
        public var maximumAutomaticAttempts: Swift.Int?
        /// An object of the RemediationParameterValue.
        public var parameters: [Swift.String: ConfigClientTypes.RemediationParameterValue]?
        /// The type of a resource.
        public var resourceType: Swift.String?
        /// Time window to determine whether or not to add a remediation exception to prevent infinite remediation attempts. If MaximumAutomaticAttempts remediation attempts have been made under RetryAttemptSeconds, a remediation exception will be added to the resource. If you do not select a number, the default is 60 seconds. For example, if you specify RetryAttemptSeconds as 50 seconds and MaximumAutomaticAttempts as 5, Config will run auto-remediations 5 times within 50 seconds before adding a remediation exception to the resource.
        public var retryAttemptSeconds: Swift.Int?
        /// Target ID is the name of the SSM document.
        /// This member is required.
        public var targetId: Swift.String?
        /// The type of the target. Target executes remediation. For example, SSM document.
        /// This member is required.
        public var targetType: ConfigClientTypes.RemediationTargetType?
        /// Version of the target. For example, version of the SSM document. If you make backward incompatible changes to the SSM document, you must call PutRemediationConfiguration API again to ensure the remediations can run.
        public var targetVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            automatic: Swift.Bool = false,
            configRuleName: Swift.String? = nil,
            createdByService: Swift.String? = nil,
            executionControls: ConfigClientTypes.ExecutionControls? = nil,
            maximumAutomaticAttempts: Swift.Int? = nil,
            parameters: [Swift.String: ConfigClientTypes.RemediationParameterValue]? = nil,
            resourceType: Swift.String? = nil,
            retryAttemptSeconds: Swift.Int? = nil,
            targetId: Swift.String? = nil,
            targetType: ConfigClientTypes.RemediationTargetType? = nil,
            targetVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.automatic = automatic
            self.configRuleName = configRuleName
            self.createdByService = createdByService
            self.executionControls = executionControls
            self.maximumAutomaticAttempts = maximumAutomaticAttempts
            self.parameters = parameters
            self.resourceType = resourceType
            self.retryAttemptSeconds = retryAttemptSeconds
            self.targetId = targetId
            self.targetType = targetType
            self.targetVersion = targetVersion
        }
    }
}

public struct DescribeRemediationConfigurationsOutput: Swift.Sendable {
    /// Returns a remediation configuration object.
    public var remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?

    public init(
        remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

public struct DescribeRemediationExceptionsInput: Swift.Sendable {
    /// The name of the Config rule.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of RemediationExceptionResourceKey returned on each page. The default is 25. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init(
        configRuleName: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

extension ConfigClientTypes {

    /// An object that represents the details about the remediation exception. The details include the rule name, an explanation of an exception, the time when the exception will be deleted, the resource ID, and resource type.
    public struct RemediationException: Swift.Sendable {
        /// The name of the Config rule.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// The time when the remediation exception will be deleted.
        public var expirationTime: Foundation.Date?
        /// An explanation of an remediation exception.
        public var message: Swift.String?
        /// The ID of the resource (for example., sg-xxxxxx).
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of a resource.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            configRuleName: Swift.String? = nil,
            expirationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.configRuleName = configRuleName
            self.expirationTime = expirationTime
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct DescribeRemediationExceptionsOutput: Swift.Sendable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of remediation exception objects.
    public var remediationExceptions: [ConfigClientTypes.RemediationException]?

    public init(
        nextToken: Swift.String? = nil,
        remediationExceptions: [ConfigClientTypes.RemediationException]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExceptions = remediationExceptions
    }
}

public struct DescribeRemediationExecutionStatusInput: Swift.Sendable {
    /// A list of Config rule names.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of RemediationExecutionStatuses returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init(
        configRuleName: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
        self.resourceKeys = resourceKeys
    }
}

extension ConfigClientTypes {

    public enum RemediationExecutionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case queued
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationExecutionState] {
            return [
                .failed,
                .inProgress,
                .queued,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum RemediationExecutionStepState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationExecutionStepState] {
            return [
                .failed,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Name of the step from the SSM document.
    public struct RemediationExecutionStep: Swift.Sendable {
        /// An error message if the step was interrupted during execution.
        public var errorMessage: Swift.String?
        /// The details of the step.
        public var name: Swift.String?
        /// The time when the step started.
        public var startTime: Foundation.Date?
        /// The valid status of the step.
        public var state: ConfigClientTypes.RemediationExecutionStepState?
        /// The time when the step stopped.
        public var stopTime: Foundation.Date?

        public init(
            errorMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: ConfigClientTypes.RemediationExecutionStepState? = nil,
            stopTime: Foundation.Date? = nil
        )
        {
            self.errorMessage = errorMessage
            self.name = name
            self.startTime = startTime
            self.state = state
            self.stopTime = stopTime
        }
    }
}

extension ConfigClientTypes {

    /// Provides details of the current status of the invoked remediation action for that resource.
    public struct RemediationExecutionStatus: Swift.Sendable {
        /// Start time when the remediation was executed.
        public var invocationTime: Foundation.Date?
        /// The time when the remediation execution was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The details that identify a resource within Config, including the resource type and resource ID.
        public var resourceKey: ConfigClientTypes.ResourceKey?
        /// ENUM of the values.
        public var state: ConfigClientTypes.RemediationExecutionState?
        /// Details of every step.
        public var stepDetails: [ConfigClientTypes.RemediationExecutionStep]?

        public init(
            invocationTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            resourceKey: ConfigClientTypes.ResourceKey? = nil,
            state: ConfigClientTypes.RemediationExecutionState? = nil,
            stepDetails: [ConfigClientTypes.RemediationExecutionStep]? = nil
        )
        {
            self.invocationTime = invocationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceKey = resourceKey
            self.state = state
            self.stepDetails = stepDetails
        }
    }
}

public struct DescribeRemediationExecutionStatusOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of remediation execution statuses objects.
    public var remediationExecutionStatuses: [ConfigClientTypes.RemediationExecutionStatus]?

    public init(
        nextToken: Swift.String? = nil,
        remediationExecutionStatuses: [ConfigClientTypes.RemediationExecutionStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.remediationExecutionStatuses = remediationExecutionStatuses
    }
}

public struct DescribeRetentionConfigurationsInput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of names of retention configurations for which you want details. If you do not specify a name, Config returns details for all the retention configurations for that account. Currently, Config supports only one retention configuration per region in your account.
    public var retentionConfigurationNames: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        retentionConfigurationNames: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurationNames = retentionConfigurationNames
    }
}

extension ConfigClientTypes {

    /// An object with the name of the retention configuration and the retention period in days. The object stores the configuration for data retention in Config.
    public struct RetentionConfiguration: Swift.Sendable {
        /// The name of the retention configuration object.
        /// This member is required.
        public var name: Swift.String?
        /// Number of days Config stores your historical information. Currently, only applicable to the configuration item history.
        /// This member is required.
        public var retentionPeriodInDays: Swift.Int?

        public init(
            name: Swift.String? = nil,
            retentionPeriodInDays: Swift.Int? = nil
        )
        {
            self.name = name
            self.retentionPeriodInDays = retentionPeriodInDays
        }
    }
}

public struct DescribeRetentionConfigurationsOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a retention configuration object.
    public var retentionConfigurations: [ConfigClientTypes.RetentionConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        retentionConfigurations: [ConfigClientTypes.RetentionConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.retentionConfigurations = retentionConfigurations
    }
}

extension ConfigClientTypes {

    /// Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.
    public struct Evaluation: Swift.Sendable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        /// This member is required.
        public var complianceResourceId: Swift.String?
        /// The type of Amazon Web Services resource that was evaluated.
        /// This member is required.
        public var complianceResourceType: Swift.String?
        /// Indicates whether the Amazon Web Services resource complies with the Config rule that it was evaluated against. For the Evaluation data type, Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. Config does not support the INSUFFICIENT_DATA value for this data type. Similarly, Config does not accept INSUFFICIENT_DATA as the value for ComplianceType from a PutEvaluations request. For example, an Lambda function for a custom Config rule cannot pass an INSUFFICIENT_DATA value to Config.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time of the event in Config that triggered the evaluation. For event-based evaluations, the time indicates when Config created the configuration item that triggered the evaluation. For periodic evaluations, the time indicates when Config triggered the evaluation at the frequency that you specified (for example, every 24 hours).
        /// This member is required.
        public var orderingTimestamp: Foundation.Date?

        public init(
            annotation: Swift.String? = nil,
            complianceResourceId: Swift.String? = nil,
            complianceResourceType: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            orderingTimestamp: Foundation.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }
    }
}

extension ConfigClientTypes {

    /// Use EvaluationContext to group independently initiated proactive resource evaluations. For example, CFN Stack. If you want to check just a resource definition, you do not need to provide evaluation context.
    public struct EvaluationContext: Swift.Sendable {
        /// A unique EvaluationContextIdentifier ID for an EvaluationContext.
        public var evaluationContextIdentifier: Swift.String?

        public init(
            evaluationContextIdentifier: Swift.String? = nil
        )
        {
            self.evaluationContextIdentifier = evaluationContextIdentifier
        }
    }
}

extension ConfigClientTypes {

    /// The details of an Config evaluation. Provides the Amazon Web Services resource that was evaluated, the compliance of the resource, related time stamps, and supplementary information.
    public struct EvaluationResult: Swift.Sendable {
        /// Supplementary information about how the evaluation determined the compliance.
        public var annotation: Swift.String?
        /// Indicates whether the Amazon Web Services resource complies with the Config rule that evaluated it. For the EvaluationResult data type, Config supports only the COMPLIANT, NON_COMPLIANT, and NOT_APPLICABLE values. Config does not support the INSUFFICIENT_DATA value for the EvaluationResult data type.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the Config rule evaluated the Amazon Web Services resource.
        public var configRuleInvokedTime: Foundation.Date?
        /// Uniquely identifies the evaluation result.
        public var evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier?
        /// The time when Config recorded the evaluation result.
        public var resultRecordedTime: Foundation.Date?
        /// An encrypted token that associates an evaluation with an Config rule. The token identifies the rule, the Amazon Web Services resource being evaluated, and the event that triggered the evaluation.
        public var resultToken: Swift.String?

        public init(
            annotation: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            configRuleInvokedTime: Foundation.Date? = nil,
            evaluationResultIdentifier: ConfigClientTypes.EvaluationResultIdentifier? = nil,
            resultRecordedTime: Foundation.Date? = nil,
            resultToken: Swift.String? = nil
        )
        {
            self.annotation = annotation
            self.complianceType = complianceType
            self.configRuleInvokedTime = configRuleInvokedTime
            self.evaluationResultIdentifier = evaluationResultIdentifier
            self.resultRecordedTime = resultRecordedTime
            self.resultToken = resultToken
        }
    }
}

extension ConfigClientTypes {

    public enum ResourceEvaluationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceEvaluationStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Returns status details of an evaluation.
    public struct EvaluationStatus: Swift.Sendable {
        /// An explanation for failed execution status.
        public var failureReason: Swift.String?
        /// The status of an execution. The valid values are In_Progress, Succeeded or Failed.
        /// This member is required.
        public var status: ConfigClientTypes.ResourceEvaluationStatus?

        public init(
            failureReason: Swift.String? = nil,
            status: ConfigClientTypes.ResourceEvaluationStatus? = nil
        )
        {
            self.failureReason = failureReason
            self.status = status
        }
    }
}

extension ConfigClientTypes {

    /// Identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that it was evaluated against.
    public struct ExternalEvaluation: Swift.Sendable {
        /// Supplementary information about the reason of compliance. For example, this task was completed on a specific date.
        public var annotation: Swift.String?
        /// The evaluated compliance resource ID. Config accepts only Amazon Web Services account ID.
        /// This member is required.
        public var complianceResourceId: Swift.String?
        /// The evaluated compliance resource type. Config accepts AWS::::Account resource type.
        /// This member is required.
        public var complianceResourceType: Swift.String?
        /// The compliance of the Amazon Web Services resource. The valid values are COMPLIANT, NON_COMPLIANT,  and NOT_APPLICABLE.
        /// This member is required.
        public var complianceType: ConfigClientTypes.ComplianceType?
        /// The time when the compliance was recorded.
        /// This member is required.
        public var orderingTimestamp: Foundation.Date?

        public init(
            annotation: Swift.String? = nil,
            complianceResourceId: Swift.String? = nil,
            complianceResourceType: Swift.String? = nil,
            complianceType: ConfigClientTypes.ComplianceType? = nil,
            orderingTimestamp: Foundation.Date? = nil
        )
        {
            self.annotation = annotation
            self.complianceResourceId = complianceResourceId
            self.complianceResourceType = complianceResourceType
            self.complianceType = complianceType
            self.orderingTimestamp = orderingTimestamp
        }
    }
}

extension ConfigClientTypes {

    /// List of each of the failed remediations with specific reasons.
    public struct FailedRemediationBatch: Swift.Sendable {
        /// Returns remediation configurations of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationConfiguration]?
        /// Returns a failure message. For example, the resource is already compliant.
        public var failureMessage: Swift.String?

        public init(
            failedItems: [ConfigClientTypes.RemediationConfiguration]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }
}

extension ConfigClientTypes {

    /// List of each of the failed remediation exceptions with specific reasons.
    public struct FailedRemediationExceptionBatch: Swift.Sendable {
        /// Returns remediation exception resource key object of the failed items.
        public var failedItems: [ConfigClientTypes.RemediationException]?
        /// Returns a failure message. For example, the auto-remediation has failed.
        public var failureMessage: Swift.String?

        public init(
            failedItems: [ConfigClientTypes.RemediationException]? = nil,
            failureMessage: Swift.String? = nil
        )
        {
            self.failedItems = failedItems
            self.failureMessage = failureMessage
        }
    }
}

extension ConfigClientTypes {

    /// Details about the fields such as name of the field.
    public struct FieldInfo: Swift.Sendable {
        /// Name of the field.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleInput: Swift.Sendable {
    /// The 12-digit account ID of the source account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The source region from where the data is aggregated.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// The resource compliance status. For the GetAggregateComplianceDetailsByConfigRuleRequest data type, Config supports only the COMPLIANT and NON_COMPLIANT. Config does not support the NOT_APPLICABLE and INSUFFICIENT_DATA values.
    public var complianceType: ConfigClientTypes.ComplianceType?
    /// The name of the Config rule for which you want compliance information.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The maximum number of evaluation results returned on each page. The default is 50. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        awsRegion: Swift.String? = nil,
        complianceType: ConfigClientTypes.ComplianceType? = nil,
        configRuleName: Swift.String? = nil,
        configurationAggregatorName: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.awsRegion = awsRegion
        self.complianceType = complianceType
        self.configRuleName = configRuleName
        self.configurationAggregatorName = configurationAggregatorName
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct GetAggregateComplianceDetailsByConfigRuleOutput: Swift.Sendable {
    /// Returns an AggregateEvaluationResults object.
    public var aggregateEvaluationResults: [ConfigClientTypes.AggregateEvaluationResult]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregateEvaluationResults: [ConfigClientTypes.AggregateEvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateEvaluationResults = aggregateEvaluationResults
        self.nextToken = nextToken
    }
}

public struct GetAggregateConfigRuleComplianceSummaryInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ConfigRuleComplianceSummaryFilters object.
    public var filters: ConfigClientTypes.ConfigRuleComplianceSummaryFilters?
    /// Groups the result based on ACCOUNT_ID or AWS_REGION.
    public var groupByKey: ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey?
    /// The maximum number of evaluation results returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ConfigRuleComplianceSummaryFilters? = nil,
        groupByKey: ConfigClientTypes.ConfigRuleComplianceSummaryGroupKey? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct GetAggregateConfigRuleComplianceSummaryOutput: Swift.Sendable {
    /// Returns a list of AggregateComplianceCounts object.
    public var aggregateComplianceCounts: [ConfigClientTypes.AggregateComplianceCount]?
    /// Groups the result based on ACCOUNT_ID or AWS_REGION.
    public var groupByKey: Swift.String?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregateComplianceCounts: [ConfigClientTypes.AggregateComplianceCount]? = nil,
        groupByKey: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateComplianceCounts = aggregateComplianceCounts
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

public struct GetAggregateConformancePackComplianceSummaryInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the AggregateConformancePackComplianceSummaryFilters object.
    public var filters: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters?
    /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
    public var groupByKey: ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey?
    /// The maximum number of results returned on each page. The default is maximum. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters? = nil,
        groupByKey: ConfigClientTypes.AggregateConformancePackComplianceSummaryGroupKey? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct GetAggregateConformancePackComplianceSummaryOutput: Swift.Sendable {
    /// Returns a list of AggregateConformancePackComplianceSummary object.
    public var aggregateConformancePackComplianceSummaries: [ConfigClientTypes.AggregateConformancePackComplianceSummary]?
    /// Groups the result based on Amazon Web Services account ID or Amazon Web Services Region.
    public var groupByKey: Swift.String?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        aggregateConformancePackComplianceSummaries: [ConfigClientTypes.AggregateConformancePackComplianceSummary]? = nil,
        groupByKey: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateConformancePackComplianceSummaries = aggregateConformancePackComplianceSummaries
        self.groupByKey = groupByKey
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// Filters the resource count based on account ID, region, and resource type.
    public struct ResourceCountFilters: Swift.Sendable {
        /// The 12-digit ID of the account.
        public var accountId: Swift.String?
        /// The region where the account is located.
        public var region: Swift.String?
        /// The type of the Amazon Web Services resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init(
            accountId: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.accountId = accountId
            self.region = region
            self.resourceType = resourceType
        }
    }
}

extension ConfigClientTypes {

    public enum ResourceCountGroupKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountId
        case awsRegion
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCountGroupKey] {
            return [
                .accountId,
                .awsRegion,
                .resourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .awsRegion: return "AWS_REGION"
            case .resourceType: return "RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAggregateDiscoveredResourceCountsInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ResourceCountFilters object.
    public var filters: ConfigClientTypes.ResourceCountFilters?
    /// The key to group the resource counts.
    public var groupByKey: ConfigClientTypes.ResourceCountGroupKey?
    /// The maximum number of [GroupedResourceCount] objects returned on each page. The default is 1000. You cannot specify a number greater than 1000. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ResourceCountFilters? = nil,
        groupByKey: ConfigClientTypes.ResourceCountGroupKey? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.groupByKey = groupByKey
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// The count of resources that are grouped by the group name.
    public struct GroupedResourceCount: Swift.Sendable {
        /// The name of the group that can be region, account ID, or resource type. For example, region1, region2 if the region was chosen as GroupByKey.
        /// This member is required.
        public var groupName: Swift.String?
        /// The number of resources in the group.
        /// This member is required.
        public var resourceCount: Swift.Int

        public init(
            groupName: Swift.String? = nil,
            resourceCount: Swift.Int = 0
        )
        {
            self.groupName = groupName
            self.resourceCount = resourceCount
        }
    }
}

public struct GetAggregateDiscoveredResourceCountsOutput: Swift.Sendable {
    /// The key passed into the request object. If GroupByKey is not provided, the result will be empty.
    public var groupByKey: Swift.String?
    /// Returns a list of GroupedResourceCount objects.
    public var groupedResourceCounts: [ConfigClientTypes.GroupedResourceCount]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The total number of resources that are present in an aggregator with the filters that you provide.
    /// This member is required.
    public var totalDiscoveredResources: Swift.Int

    public init(
        groupByKey: Swift.String? = nil,
        groupedResourceCounts: [ConfigClientTypes.GroupedResourceCount]? = nil,
        nextToken: Swift.String? = nil,
        totalDiscoveredResources: Swift.Int = 0
    )
    {
        self.groupByKey = groupByKey
        self.groupedResourceCounts = groupedResourceCounts
        self.nextToken = nextToken
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

/// The configuration item size is outside the allowable range.
public struct OversizedConfigurationItemException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OversizedConfigurationItemException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have specified a resource that is either unknown or has not been discovered.
public struct ResourceNotDiscoveredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotDiscoveredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetAggregateResourceConfigInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// An object that identifies aggregate resource.
    /// This member is required.
    public var resourceIdentifier: ConfigClientTypes.AggregateResourceIdentifier?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        resourceIdentifier: ConfigClientTypes.AggregateResourceIdentifier? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct GetAggregateResourceConfigOutput: Swift.Sendable {
    /// Returns a ConfigurationItem object.
    public var configurationItem: ConfigClientTypes.ConfigurationItem?

    public init(
        configurationItem: ConfigClientTypes.ConfigurationItem? = nil
    )
    {
        self.configurationItem = configurationItem
    }
}

///
public struct GetComplianceDetailsByConfigRuleInput: Swift.Sendable {
    /// Filters the results by compliance. INSUFFICIENT_DATA is a valid ComplianceType that is returned when an Config rule cannot be evaluated. However, INSUFFICIENT_DATA cannot be used as a ComplianceType for filtering results.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The name of the Config rule for which you want compliance information.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The maximum number of evaluation results returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        configRuleName: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.configRuleName = configRuleName
        self.limit = limit
        self.nextToken = nextToken
    }
}

///
public struct GetComplianceDetailsByConfigRuleOutput: Swift.Sendable {
    /// Indicates whether the Amazon Web Services resource complies with the specified Config rule.
    public var evaluationResults: [ConfigClientTypes.EvaluationResult]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        evaluationResults: [ConfigClientTypes.EvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

///
public struct GetComplianceDetailsByResourceInput: Swift.Sendable {
    /// Filters the results by compliance. INSUFFICIENT_DATA is a valid ComplianceType that is returned when an Config rule cannot be evaluated. However, INSUFFICIENT_DATA cannot be used as a ComplianceType for filtering results.
    public var complianceTypes: [ConfigClientTypes.ComplianceType]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The unique ID of Amazon Web Services resource execution for which you want to retrieve evaluation results. You need to only provide either a ResourceEvaluationID or a ResourceID and ResourceType.
    public var resourceEvaluationId: Swift.String?
    /// The ID of the Amazon Web Services resource for which you want compliance information.
    public var resourceId: Swift.String?
    /// The type of the Amazon Web Services resource for which you want compliance information.
    public var resourceType: Swift.String?

    public init(
        complianceTypes: [ConfigClientTypes.ComplianceType]? = nil,
        nextToken: Swift.String? = nil,
        resourceEvaluationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.complianceTypes = complianceTypes
        self.nextToken = nextToken
        self.resourceEvaluationId = resourceEvaluationId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

///
public struct GetComplianceDetailsByResourceOutput: Swift.Sendable {
    /// Indicates whether the specified Amazon Web Services resource complies each Config rule.
    public var evaluationResults: [ConfigClientTypes.EvaluationResult]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        evaluationResults: [ConfigClientTypes.EvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.evaluationResults = evaluationResults
        self.nextToken = nextToken
    }
}

///
public struct GetComplianceSummaryByConfigRuleOutput: Swift.Sendable {
    /// The number of Config rules that are compliant and the number that are noncompliant, up to a maximum of 25 for each.
    public var complianceSummary: ConfigClientTypes.ComplianceSummary?

    public init(
        complianceSummary: ConfigClientTypes.ComplianceSummary? = nil
    )
    {
        self.complianceSummary = complianceSummary
    }
}

///
public struct GetComplianceSummaryByResourceTypeInput: Swift.Sendable {
    /// Specify one or more resource types to get the number of resources that are compliant and the number that are noncompliant for each resource type. For this request, you can specify an Amazon Web Services resource type such as AWS::EC2::Instance. You can specify that the resource type is an Amazon Web Services account by specifying AWS::::Account.
    public var resourceTypes: [Swift.String]?

    public init(
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.resourceTypes = resourceTypes
    }
}

///
public struct GetComplianceSummaryByResourceTypeOutput: Swift.Sendable {
    /// The number of resources that are compliant and the number that are noncompliant. If one or more resource types were provided with the request, the numbers are returned for each resource type. The maximum number returned is 100.
    public var complianceSummariesByResourceType: [ConfigClientTypes.ComplianceSummaryByResourceType]?

    public init(
        complianceSummariesByResourceType: [ConfigClientTypes.ComplianceSummaryByResourceType]? = nil
    )
    {
        self.complianceSummariesByResourceType = complianceSummariesByResourceType
    }
}

public struct GetConformancePackComplianceDetailsInput: Swift.Sendable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// A ConformancePackEvaluationFilters object.
    public var filters: ConfigClientTypes.ConformancePackEvaluationFilters?
    /// The maximum number of evaluation results returned on each page. If you do no specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackName: Swift.String? = nil,
        filters: ConfigClientTypes.ConformancePackEvaluationFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct GetConformancePackComplianceDetailsOutput: Swift.Sendable {
    /// Name of the conformance pack.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// Returns a list of ConformancePackEvaluationResult objects.
    public var conformancePackRuleEvaluationResults: [ConfigClientTypes.ConformancePackEvaluationResult]?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackName: Swift.String? = nil,
        conformancePackRuleEvaluationResults: [ConfigClientTypes.ConformancePackEvaluationResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackName = conformancePackName
        self.conformancePackRuleEvaluationResults = conformancePackRuleEvaluationResults
        self.nextToken = nextToken
    }
}

public struct GetConformancePackComplianceSummaryInput: Swift.Sendable {
    /// Names of conformance packs.
    /// This member is required.
    public var conformancePackNames: [Swift.String]?
    /// The maximum number of conformance packs returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackNames: [Swift.String]? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackNames = conformancePackNames
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct GetConformancePackComplianceSummaryOutput: Swift.Sendable {
    /// A list of ConformancePackComplianceSummary objects.
    public var conformancePackComplianceSummaryList: [ConfigClientTypes.ConformancePackComplianceSummary]?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackComplianceSummaryList: [ConfigClientTypes.ConformancePackComplianceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackComplianceSummaryList = conformancePackComplianceSummaryList
        self.nextToken = nextToken
    }
}

public struct GetCustomRulePolicyInput: Swift.Sendable {
    /// The name of your Config Custom Policy rule.
    public var configRuleName: Swift.String?

    public init(
        configRuleName: Swift.String? = nil
    )
    {
        self.configRuleName = configRuleName
    }
}

public struct GetCustomRulePolicyOutput: Swift.Sendable {
    /// The policy definition containing the logic for your Config Custom Policy rule.
    public var policyText: Swift.String?

    public init(
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

public struct GetDiscoveredResourceCountsInput: Swift.Sendable {
    /// The maximum number of [ResourceCount] objects returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The comma-separated list that specifies the resource types that you want Config to return (for example, "AWS::EC2::Instance", "AWS::IAM::User"). If a value for resourceTypes is not specified, Config returns all resource types that Config is recording in the region for your account. If the configuration recorder is turned off, Config returns an empty list of [ResourceCount] objects. If the configuration recorder is not recording a specific resource type (for example, S3 buckets), that resource type is not returned in the list of [ResourceCount] objects.
    public var resourceTypes: [Swift.String]?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceTypes: [Swift.String]? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

extension ConfigClientTypes {

    /// An object that contains the resource type and the number of resources.
    public struct ResourceCount: Swift.Sendable {
        /// The number of resources.
        public var count: Swift.Int
        /// The resource type (for example, "AWS::EC2::Instance").
        public var resourceType: ConfigClientTypes.ResourceType?

        public init(
            count: Swift.Int = 0,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.count = count
            self.resourceType = resourceType
        }
    }
}

public struct GetDiscoveredResourceCountsOutput: Swift.Sendable {
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The list of ResourceCount objects. Each object is listed in descending order by the number of resources.
    public var resourceCounts: [ConfigClientTypes.ResourceCount]?
    /// The total number of resources that Config is recording in the region for your account. If you specify resource types in the request, Config returns only the total number of resources for those resource types. Example
    ///
    /// * Config is recording three resource types in the US East (Ohio) Region for your account: 25 EC2 instances, 20 IAM users, and 15 S3 buckets, for a total of 60 resources.
    ///
    /// * You make a call to the GetDiscoveredResourceCounts action and specify the resource type, "AWS::EC2::Instances", in the request.
    ///
    /// * Config returns 25 for totalDiscoveredResources.
    public var totalDiscoveredResources: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        resourceCounts: [ConfigClientTypes.ResourceCount]? = nil,
        totalDiscoveredResources: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.resourceCounts = resourceCounts
        self.totalDiscoveredResources = totalDiscoveredResources
    }
}

extension ConfigClientTypes {

    public enum MemberAccountRuleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberAccountRuleStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Status filter object to filter results based on specific member account ID or status type for an organization Config rule.
    public struct StatusDetailFilters: Swift.Sendable {
        /// The 12-digit account ID of the member account within an organization.
        public var accountId: Swift.String?
        /// Indicates deployment status for Config rule in the member account. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when Config rule has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when Config rule is being created in the member account.
        ///
        /// * CREATE_FAILED when Config rule creation has failed in the member account.
        ///
        /// * DELETE_FAILED when Config rule deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when Config rule is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when Config rule has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when Config rule has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when Config rule is being updated in the member account.
        ///
        /// * UPDATE_FAILED when Config rule deletion has failed in the member account.
        public var memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus?

        public init(
            accountId: Swift.String? = nil,
            memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus? = nil
        )
        {
            self.accountId = accountId
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }
    }
}

public struct GetOrganizationConfigRuleDetailedStatusInput: Swift.Sendable {
    /// A StatusDetailFilters object.
    public var filters: ConfigClientTypes.StatusDetailFilters?
    /// The maximum number of OrganizationConfigRuleDetailedStatus returned on each page. If you do not specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name of your organization Config rule for which you want status details for member accounts.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init(
        filters: ConfigClientTypes.StatusDetailFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

extension ConfigClientTypes {

    /// Organization Config rule creation or deletion status in each member account. This includes the name of the rule, the status, error code and error message when the rule creation or deletion failed.
    public struct MemberAccountStatus: Swift.Sendable {
        /// The 12-digit account ID of a member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The name of Config rule deployed in the member account.
        /// This member is required.
        public var configRuleName: Swift.String?
        /// An error code that is returned when Config rule creation or deletion failed in the member account.
        public var errorCode: Swift.String?
        /// An error message indicating that Config rule account creation or deletion has failed due to an error in the member account.
        public var errorMessage: Swift.String?
        /// The timestamp of the last status update.
        public var lastUpdateTime: Foundation.Date?
        /// Indicates deployment status for Config rule in the member account. When management account calls PutOrganizationConfigRule action for the first time, Config rule status is created in the member account. When management account calls PutOrganizationConfigRule action for the second time, Config rule status is updated in the member account. Config rule status is deleted when the management account deletes OrganizationConfigRule and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the rule to:
        ///
        /// * CREATE_SUCCESSFUL when Config rule has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when Config rule is being created in the member account.
        ///
        /// * CREATE_FAILED when Config rule creation has failed in the member account.
        ///
        /// * DELETE_FAILED when Config rule deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when Config rule is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when Config rule has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when Config rule has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when Config rule is being updated in the member account.
        ///
        /// * UPDATE_FAILED when Config rule deletion has failed in the member account.
        /// This member is required.
        public var memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus?

        public init(
            accountId: Swift.String? = nil,
            configRuleName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            memberAccountRuleStatus: ConfigClientTypes.MemberAccountRuleStatus? = nil
        )
        {
            self.accountId = accountId
            self.configRuleName = configRuleName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.memberAccountRuleStatus = memberAccountRuleStatus
        }
    }
}

public struct GetOrganizationConfigRuleDetailedStatusOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of MemberAccountStatus objects.
    public var organizationConfigRuleDetailedStatus: [ConfigClientTypes.MemberAccountStatus]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConfigRuleDetailedStatus: [ConfigClientTypes.MemberAccountStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConfigRuleDetailedStatus = organizationConfigRuleDetailedStatus
    }
}

extension ConfigClientTypes {

    public enum OrganizationResourceDetailedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccessful
        case deleteFailed
        case deleteInProgress
        case deleteSuccessful
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationResourceDetailedStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccessful,
                .deleteFailed,
                .deleteInProgress,
                .deleteSuccessful,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccessful: return "CREATE_SUCCESSFUL"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .deleteSuccessful: return "DELETE_SUCCESSFUL"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Status filter object to filter results based on specific member account ID or status type for an organization conformance pack.
    public struct OrganizationResourceDetailedStatusFilters: Swift.Sendable {
        /// The 12-digit account ID of the member account within an organization.
        public var accountId: Swift.String?
        /// Indicates deployment status for conformance pack in a member account. When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when conformance pack has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when conformance pack is being created in the member account.
        ///
        /// * CREATE_FAILED when conformance pack creation has failed in the member account.
        ///
        /// * DELETE_FAILED when conformance pack deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.
        ///
        /// * UPDATE_FAILED when conformance pack deletion has failed in the member account.
        public var status: ConfigClientTypes.OrganizationResourceDetailedStatus?

        public init(
            accountId: Swift.String? = nil,
            status: ConfigClientTypes.OrganizationResourceDetailedStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }
}

public struct GetOrganizationConformancePackDetailedStatusInput: Swift.Sendable {
    /// An OrganizationResourceDetailedStatusFilters object.
    public var filters: ConfigClientTypes.OrganizationResourceDetailedStatusFilters?
    /// The maximum number of OrganizationConformancePackDetailedStatuses returned on each page. If you do not specify a number, Config uses the default. The default is 100.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The name of organization conformance pack for which you want status details for member accounts.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?

    public init(
        filters: ConfigClientTypes.OrganizationResourceDetailedStatusFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        organizationConformancePackName: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.organizationConformancePackName = organizationConformancePackName
    }
}

extension ConfigClientTypes {

    /// Organization conformance pack creation or deletion status in each member account. This includes the name of the conformance pack, the status, error code and error message when the conformance pack creation or deletion failed.
    public struct OrganizationConformancePackDetailedStatus: Swift.Sendable {
        /// The 12-digit account ID of a member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The name of conformance pack deployed in the member account.
        /// This member is required.
        public var conformancePackName: Swift.String?
        /// An error code that is returned when conformance pack creation or deletion failed in the member account.
        public var errorCode: Swift.String?
        /// An error message indicating that conformance pack account creation or deletion has failed due to an error in the member account.
        public var errorMessage: Swift.String?
        /// The timestamp of the last status update.
        public var lastUpdateTime: Foundation.Date?
        /// Indicates deployment status for conformance pack in a member account. When management account calls PutOrganizationConformancePack action for the first time, conformance pack status is created in the member account. When management account calls PutOrganizationConformancePack action for the second time, conformance pack status is updated in the member account. Conformance pack status is deleted when the management account deletes OrganizationConformancePack and disables service access for config-multiaccountsetup.amazonaws.com. Config sets the state of the conformance pack to:
        ///
        /// * CREATE_SUCCESSFUL when conformance pack has been created in the member account.
        ///
        /// * CREATE_IN_PROGRESS when conformance pack is being created in the member account.
        ///
        /// * CREATE_FAILED when conformance pack creation has failed in the member account.
        ///
        /// * DELETE_FAILED when conformance pack deletion has failed in the member account.
        ///
        /// * DELETE_IN_PROGRESS when conformance pack is being deleted in the member account.
        ///
        /// * DELETE_SUCCESSFUL when conformance pack has been deleted in the member account.
        ///
        /// * UPDATE_SUCCESSFUL when conformance pack has been updated in the member account.
        ///
        /// * UPDATE_IN_PROGRESS when conformance pack is being updated in the member account.
        ///
        /// * UPDATE_FAILED when conformance pack deletion has failed in the member account.
        /// This member is required.
        public var status: ConfigClientTypes.OrganizationResourceDetailedStatus?

        public init(
            accountId: Swift.String? = nil,
            conformancePackName: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            status: ConfigClientTypes.OrganizationResourceDetailedStatus? = nil
        )
        {
            self.accountId = accountId
            self.conformancePackName = conformancePackName
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastUpdateTime = lastUpdateTime
            self.status = status
        }
    }
}

public struct GetOrganizationConformancePackDetailedStatusOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// A list of OrganizationConformancePackDetailedStatus objects.
    public var organizationConformancePackDetailedStatuses: [ConfigClientTypes.OrganizationConformancePackDetailedStatus]?

    public init(
        nextToken: Swift.String? = nil,
        organizationConformancePackDetailedStatuses: [ConfigClientTypes.OrganizationConformancePackDetailedStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationConformancePackDetailedStatuses = organizationConformancePackDetailedStatuses
    }
}

public struct GetOrganizationCustomRulePolicyInput: Swift.Sendable {
    /// The name of your organization Config Custom Policy rule.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?

    public init(
        organizationConfigRuleName: Swift.String? = nil
    )
    {
        self.organizationConfigRuleName = organizationConfigRuleName
    }
}

public struct GetOrganizationCustomRulePolicyOutput: Swift.Sendable {
    /// The policy definition containing the logic for your organization Config Custom Policy rule.
    public var policyText: Swift.String?

    public init(
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

/// The specified time range is not valid. The earlier time is not chronologically before the later time.
public struct InvalidTimeRangeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTimeRangeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the [GetResourceConfigHistory] action.
public struct GetResourceConfigHistoryInput: Swift.Sendable {
    /// The chronological order for configuration items listed. By default, the results are listed in reverse chronological order.
    public var chronologicalOrder: ConfigClientTypes.ChronologicalOrder?
    /// The chronologically earliest time in the time range for which the history requested. If not specified, the action returns paginated results that contain configuration items that start when the first configuration item was recorded.
    public var earlierTime: Foundation.Date?
    /// The chronologically latest time in the time range for which the history requested. If not specified, current time is taken.
    public var laterTime: Foundation.Date?
    /// The maximum number of configuration items returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The ID of the resource (for example., sg-xxxxxx).
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init(
        chronologicalOrder: ConfigClientTypes.ChronologicalOrder? = nil,
        earlierTime: Foundation.Date? = nil,
        laterTime: Foundation.Date? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.chronologicalOrder = chronologicalOrder
        self.earlierTime = earlierTime
        self.laterTime = laterTime
        self.limit = limit
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

/// The output for the [GetResourceConfigHistory] action.
public struct GetResourceConfigHistoryOutput: Swift.Sendable {
    /// A list that contains the configuration history of one or more resources.
    public var configurationItems: [ConfigClientTypes.ConfigurationItem]?
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationItems: [ConfigClientTypes.ConfigurationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationItems = configurationItems
        self.nextToken = nextToken
    }
}

public struct GetResourceEvaluationSummaryInput: Swift.Sendable {
    /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
    /// This member is required.
    public var resourceEvaluationId: Swift.String?

    public init(
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.resourceEvaluationId = resourceEvaluationId
    }
}

extension ConfigClientTypes {

    public enum ResourceConfigurationSchemaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cfnResourceSchema
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceConfigurationSchemaType] {
            return [
                .cfnResourceSchema
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cfnResourceSchema: return "CFN_RESOURCE_SCHEMA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    /// Returns information about the resource being evaluated.
    public struct ResourceDetails: Swift.Sendable {
        /// The resource definition to be evaluated as per the resource configuration schema type.
        /// This member is required.
        public var resourceConfiguration: Swift.String?
        /// The schema type of the resource configuration. You can find the [Resource type schema](https://docs.aws.amazon.com/cloudformation-cli/latest/userguide/resource-type-schema.html), or CFN_RESOURCE_SCHEMA, in "Amazon Web Services public extensions" within the CloudFormation registry or with the following CLI commmand: aws cloudformation describe-type --type-name "AWS::S3::Bucket" --type RESOURCE. For more information, see [Managing extensions through the CloudFormation registry](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry.html#registry-view) and [Amazon Web Services resource and property types reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html) in the CloudFormation User Guide.
        public var resourceConfigurationSchemaType: ConfigClientTypes.ResourceConfigurationSchemaType?
        /// A unique resource ID for an evaluation.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of resource being evaluated.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            resourceConfiguration: Swift.String? = nil,
            resourceConfigurationSchemaType: ConfigClientTypes.ResourceConfigurationSchemaType? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resourceConfiguration = resourceConfiguration
            self.resourceConfigurationSchemaType = resourceConfigurationSchemaType
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct GetResourceEvaluationSummaryOutput: Swift.Sendable {
    /// The compliance status of the resource evaluation summary.
    public var compliance: ConfigClientTypes.ComplianceType?
    /// Returns an EvaluationContext object.
    public var evaluationContext: ConfigClientTypes.EvaluationContext?
    /// Lists results of the mode that you requested to retrieve the resource evaluation summary. The valid values are Detective or Proactive.
    public var evaluationMode: ConfigClientTypes.EvaluationMode?
    /// The start timestamp when Config rule starts evaluating compliance for the provided resource details.
    public var evaluationStartTimestamp: Foundation.Date?
    /// Returns an EvaluationStatus object.
    public var evaluationStatus: ConfigClientTypes.EvaluationStatus?
    /// Returns a ResourceDetails object.
    public var resourceDetails: ConfigClientTypes.ResourceDetails?
    /// The unique ResourceEvaluationId of Amazon Web Services resource execution for which you want to retrieve the evaluation summary.
    public var resourceEvaluationId: Swift.String?

    public init(
        compliance: ConfigClientTypes.ComplianceType? = nil,
        evaluationContext: ConfigClientTypes.EvaluationContext? = nil,
        evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
        evaluationStartTimestamp: Foundation.Date? = nil,
        evaluationStatus: ConfigClientTypes.EvaluationStatus? = nil,
        resourceDetails: ConfigClientTypes.ResourceDetails? = nil,
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.compliance = compliance
        self.evaluationContext = evaluationContext
        self.evaluationMode = evaluationMode
        self.evaluationStartTimestamp = evaluationStartTimestamp
        self.evaluationStatus = evaluationStatus
        self.resourceDetails = resourceDetails
        self.resourceEvaluationId = resourceEvaluationId
    }
}

public struct GetStoredQueryInput: Swift.Sendable {
    /// The name of the query.
    /// This member is required.
    public var queryName: Swift.String?

    public init(
        queryName: Swift.String? = nil
    )
    {
        self.queryName = queryName
    }
}

extension ConfigClientTypes {

    /// Provides the details of a stored query.
    public struct StoredQuery: Swift.Sendable {
        /// A unique description for the query.
        public var description: Swift.String?
        /// The expression of the query. For example, SELECT resourceId, resourceType, supplementaryConfiguration.BucketVersioningConfiguration.status WHERE resourceType = 'AWS::S3::Bucket' AND supplementaryConfiguration.BucketVersioningConfiguration.status = 'Off'.
        public var expression: Swift.String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        public var queryArn: Swift.String?
        /// The ID of the query.
        public var queryId: Swift.String?
        /// The name of the query.
        /// This member is required.
        public var queryName: Swift.String?

        public init(
            description: Swift.String? = nil,
            expression: Swift.String? = nil,
            queryArn: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryName: Swift.String? = nil
        )
        {
            self.description = description
            self.expression = expression
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }
    }
}

public struct GetStoredQueryOutput: Swift.Sendable {
    /// Returns a StoredQuery object.
    public var storedQuery: ConfigClientTypes.StoredQuery?

    public init(
        storedQuery: ConfigClientTypes.StoredQuery? = nil
    )
    {
        self.storedQuery = storedQuery
    }
}

/// Using the same client token with one or more different parameters. Specify a new client token with the parameter changes and try again.
public struct IdempotentParameterMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatch" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your Amazon S3 bucket policy does not permit Config to write to it.
public struct InsufficientDeliveryPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientDeliveryPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have provided a name for the configuration recorder that is not valid.
public struct InvalidConfigurationRecorderNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfigurationRecorderNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified delivery channel name is not valid.
public struct InvalidDeliveryChannelNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeliveryChannelNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The syntax of the query is incorrect.
public struct InvalidExpressionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidExpressionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates one of the following errors:
///
/// * You have provided a combination of parameter values that is not valid. For example:
///
/// * Setting the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true, but providing a non-empty list for the resourceTypesfield of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html).
///
/// * Setting the allSupported field of [RecordingGroup](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingGroup.html) to true, but also setting the useOnly field of [RecordingStrategy](https://docs.aws.amazon.com/config/latest/APIReference/API_RecordingStrategy.html) to EXCLUSION_BY_RESOURCE_TYPES.
///
///
///
///
/// * Every parameter is either null, false, or empty.
///
/// * You have reached the limit of the number of resource types you can provide for the recording group.
///
/// * You have provided resource types or a recording strategy that are not valid.
public struct InvalidRecordingGroupException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRecordingGroupException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified ResultToken is not valid.
public struct InvalidResultTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResultTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have provided a null or empty Amazon Resource Name (ARN) for the IAM role assumed by Config and used by the configuration recorder.
public struct InvalidRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRoleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Amazon S3 key prefix is not valid.
public struct InvalidS3KeyPrefixException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3KeyPrefixException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Amazon KMS Key ARN is not valid.
public struct InvalidS3KmsKeyArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidS3KmsKeyArnException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Amazon SNS topic does not exist.
public struct InvalidSNSTopicARNException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSNSTopicARNException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// For StartConfigRulesEvaluation API, this exception is thrown if an evaluation is in progress or if you call the [StartConfigRulesEvaluation] API more than once per minute. For PutConfigurationAggregator API, this exception is thrown if the number of accounts and aggregators exceeds the limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigClientTypes {

    /// Filters the results by resource account ID, region, resource ID, and resource name.
    public struct ResourceFilters: Swift.Sendable {
        /// The 12-digit source account ID.
        public var accountId: Swift.String?
        /// The source region.
        public var region: Swift.String?
        /// The ID of the resource.
        public var resourceId: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.region = region
            self.resourceId = resourceId
            self.resourceName = resourceName
        }
    }
}

public struct ListAggregateDiscoveredResourcesInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// Filters the results based on the ResourceFilters object.
    public var filters: ConfigClientTypes.ResourceFilters?
    /// The maximum number of resource identifiers returned on each page. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The type of resources that you want Config to list in the response.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        filters: ConfigClientTypes.ResourceFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

public struct ListAggregateDiscoveredResourcesOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a list of ResourceIdentifiers objects.
    public var resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]?

    public init(
        nextToken: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.AggregateResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

extension ConfigClientTypes {

    public enum SortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case score
        case sdkUnknown(Swift.String)

        public static var allCases: [SortBy] {
            return [
                .score
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .score: return "SCORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConfigClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListConformancePackComplianceScoresInput: Swift.Sendable {
    /// Filters the results based on the ConformancePackComplianceScoresFilters.
    public var filters: ConfigClientTypes.ConformancePackComplianceScoresFilters?
    /// The maximum number of conformance pack compliance scores returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string in a prior request that you can use to get the paginated response for the next set of conformance pack compliance scores.
    public var nextToken: Swift.String?
    /// Sorts your conformance pack compliance scores in either ascending or descending order, depending on SortOrder. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack. Enter SCORE, to sort conformance pack compliance scores by the numerical value of the compliance score.
    public var sortBy: ConfigClientTypes.SortBy?
    /// Determines the order in which conformance pack compliance scores are sorted. Either in ascending or descending order. By default, conformance pack compliance scores are sorted in alphabetical order by name of the conformance pack. Conformance pack compliance scores are sorted in reverse alphabetical order if you enter DESCENDING. You can sort conformance pack compliance scores by the numerical value of the compliance score by entering SCORE in the SortBy action. When compliance scores are sorted by SCORE, conformance packs with a compliance score of INSUFFICIENT_DATA will be last when sorting by ascending order and first when sorting by descending order.
    public var sortOrder: ConfigClientTypes.SortOrder?

    public init(
        filters: ConfigClientTypes.ConformancePackComplianceScoresFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        sortBy: ConfigClientTypes.SortBy? = nil,
        sortOrder: ConfigClientTypes.SortOrder? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListConformancePackComplianceScoresOutput: Swift.Sendable {
    /// A list of ConformancePackComplianceScore objects.
    /// This member is required.
    public var conformancePackComplianceScores: [ConfigClientTypes.ConformancePackComplianceScore]?
    /// The nextToken string that you can use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        conformancePackComplianceScores: [ConfigClientTypes.ConformancePackComplianceScore]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conformancePackComplianceScores = conformancePackComplianceScores
        self.nextToken = nextToken
    }
}

///
public struct ListDiscoveredResourcesInput: Swift.Sendable {
    /// Specifies whether Config includes deleted resources in the results. By default, deleted resources are not included.
    public var includeDeletedResources: Swift.Bool?
    /// The maximum number of resource identifiers returned on each page. The default is 100. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The IDs of only those resources that you want Config to list in the response. If you do not specify this parameter, Config lists all resources of the specified type that it has discovered. You can list a minimum of 1 resourceID and a maximum of 20 resourceIds.
    public var resourceIds: [Swift.String]?
    /// The custom name of only those resources that you want Config to list in the response. If you do not specify this parameter, Config lists all resources of the specified type that it has discovered.
    public var resourceName: Swift.String?
    /// The type of resources that you want Config to list in the response.
    /// This member is required.
    public var resourceType: ConfigClientTypes.ResourceType?

    public init(
        includeDeletedResources: Swift.Bool? = false,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceIds: [Swift.String]? = nil,
        resourceName: Swift.String? = nil,
        resourceType: ConfigClientTypes.ResourceType? = nil
    )
    {
        self.includeDeletedResources = includeDeletedResources
        self.limit = limit
        self.nextToken = nextToken
        self.resourceIds = resourceIds
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

extension ConfigClientTypes {

    /// The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the custom resource name.
    public struct ResourceIdentifier: Swift.Sendable {
        /// The time that the resource was deleted.
        public var resourceDeletionTime: Foundation.Date?
        /// The ID of the resource (for example, sg-xxxxxx).
        public var resourceId: Swift.String?
        /// The custom name of the resource (if available).
        public var resourceName: Swift.String?
        /// The type of resource.
        public var resourceType: ConfigClientTypes.ResourceType?

        public init(
            resourceDeletionTime: Foundation.Date? = nil,
            resourceId: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            resourceType: ConfigClientTypes.ResourceType? = nil
        )
        {
            self.resourceDeletionTime = resourceDeletionTime
            self.resourceId = resourceId
            self.resourceName = resourceName
            self.resourceType = resourceType
        }
    }
}

///
public struct ListDiscoveredResourcesOutput: Swift.Sendable {
    /// The string that you use in a subsequent request to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The details that identify a resource that is discovered by Config, including the resource type, ID, and (if available) the custom resource name.
    public var resourceIdentifiers: [ConfigClientTypes.ResourceIdentifier]?

    public init(
        nextToken: Swift.String? = nil,
        resourceIdentifiers: [ConfigClientTypes.ResourceIdentifier]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdentifiers = resourceIdentifiers
    }
}

extension ConfigClientTypes {

    /// Filters evaluation results based on start and end times.
    public struct TimeWindow: Swift.Sendable {
        /// The end time of an execution. The end time must be after the start date.
        public var endTime: Foundation.Date?
        /// The start time of an execution.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension ConfigClientTypes {

    /// Returns details of a resource evaluation based on the selected filter.
    public struct ResourceEvaluationFilters: Swift.Sendable {
        /// Filters evaluations for a given infrastructure deployment. For example: CFN Stack.
        public var evaluationContextIdentifier: Swift.String?
        /// Filters all resource evaluations results based on an evaluation mode. Currently, DECTECTIVE is not supported as a valid value. Ignore other documentation stating otherwise.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// Returns a TimeWindow object.
        public var timeWindow: ConfigClientTypes.TimeWindow?

        public init(
            evaluationContextIdentifier: Swift.String? = nil,
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            timeWindow: ConfigClientTypes.TimeWindow? = nil
        )
        {
            self.evaluationContextIdentifier = evaluationContextIdentifier
            self.evaluationMode = evaluationMode
            self.timeWindow = timeWindow
        }
    }
}

public struct ListResourceEvaluationsInput: Swift.Sendable {
    /// Returns a ResourceEvaluationFilters object.
    public var filters: ConfigClientTypes.ResourceEvaluationFilters?
    /// The maximum number of evaluations returned on each page. The default is 10. You cannot specify a number greater than 100. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        filters: ConfigClientTypes.ResourceEvaluationFilters? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.limit = limit
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// Returns details of a resource evaluation.
    public struct ResourceEvaluation: Swift.Sendable {
        /// The mode of an evaluation. The valid values are Detective or Proactive.
        public var evaluationMode: ConfigClientTypes.EvaluationMode?
        /// The starting time of an execution.
        public var evaluationStartTimestamp: Foundation.Date?
        /// The ResourceEvaluationId of a evaluation.
        public var resourceEvaluationId: Swift.String?

        public init(
            evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
            evaluationStartTimestamp: Foundation.Date? = nil,
            resourceEvaluationId: Swift.String? = nil
        )
        {
            self.evaluationMode = evaluationMode
            self.evaluationStartTimestamp = evaluationStartTimestamp
            self.resourceEvaluationId = resourceEvaluationId
        }
    }
}

public struct ListResourceEvaluationsOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns a ResourceEvaluations object.
    public var resourceEvaluations: [ConfigClientTypes.ResourceEvaluation]?

    public init(
        nextToken: Swift.String? = nil,
        resourceEvaluations: [ConfigClientTypes.ResourceEvaluation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceEvaluations = resourceEvaluations
    }
}

public struct ListStoredQueriesInput: Swift.Sendable {
    /// The maximum number of results to be returned with a single call.
    public var maxResults: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ConfigClientTypes {

    /// Returns details of a specific query.
    public struct StoredQueryMetadata: Swift.Sendable {
        /// A unique description for the query.
        public var description: Swift.String?
        /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
        /// This member is required.
        public var queryArn: Swift.String?
        /// The ID of the query.
        /// This member is required.
        public var queryId: Swift.String?
        /// The name of the query.
        /// This member is required.
        public var queryName: Swift.String?

        public init(
            description: Swift.String? = nil,
            queryArn: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryName: Swift.String? = nil
        )
        {
            self.description = description
            self.queryArn = queryArn
            self.queryId = queryId
            self.queryName = queryName
        }
    }
}

public struct ListStoredQueriesOutput: Swift.Sendable {
    /// If the previous paginated request didn't return all of the remaining results, the response object's NextToken parameter value is set to a token. To retrieve the next set of results, call this action again and assign that token to the request object's NextToken parameter. If there are no remaining results, the previous response object's NextToken parameter is set to null.
    public var nextToken: Swift.String?
    /// A list of StoredQueryMetadata objects.
    public var storedQueryMetadata: [ConfigClientTypes.StoredQueryMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        storedQueryMetadata: [ConfigClientTypes.StoredQueryMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.storedQueryMetadata = storedQueryMetadata
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The maximum number of tags returned on each page. The limit maximum is 50. You cannot specify a number greater than 50. If you specify 0, Config uses the default.
    public var limit: Swift.Int?
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension ConfigClientTypes {

    /// The tags for the resource. The metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Sendable {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The nextToken string returned on a previous page that you use to get the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// The tags for the resource.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

/// You have reached the limit of active custom resource types in your account. There is a limit of 100,000. Delete unused resources using [DeleteResourceConfig](https://docs.aws.amazon.com/config/latest/APIReference/API_DeleteResourceConfig.html).
public struct MaxActiveResourcesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxActiveResourcesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Failed to add the Config rule because the account already contains the maximum number of 1000 rules. Consider deleting any deactivated rules before you add new rules.
public struct MaxNumberOfConfigRulesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfConfigRulesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of configuration recorders you can create.
public struct MaxNumberOfConfigurationRecordersExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfConfigurationRecordersExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of conformance packs you can create in an account. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfConformancePacksExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfConformancePacksExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of delivery channels you can create.
public struct MaxNumberOfDeliveryChannelsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfDeliveryChannelsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of organization Config rules you can create. For more information, see see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfOrganizationConfigRulesExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfOrganizationConfigRulesExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of organization conformance packs you can create in an account. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct MaxNumberOfOrganizationConformancePacksExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfOrganizationConformancePacksExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Failed to add the retention configuration because a retention configuration with that name already exists.
public struct MaxNumberOfRetentionConfigurationsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MaxNumberOfRetentionConfigurationsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There is no delivery channel available to record configurations.
public struct NoAvailableDeliveryChannelException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableDeliveryChannelException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Organization is no longer available.
public struct NoAvailableOrganizationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAvailableOrganizationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified Amazon S3 bucket does not exist.
public struct NoSuchBucketException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoSuchBucketException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Config resource cannot be created because your organization does not have all features enabled.
public struct OrganizationAllFeaturesNotEnabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationAllFeaturesNotEnabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have specified a template that is not valid or supported.
public struct OrganizationConformancePackTemplateValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationConformancePackTemplateValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigClientTypes {

    /// An object that specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
    public struct OrganizationCustomPolicyRuleMetadata: Swift.Sendable {
        /// A list of accounts that you can enable debug logging for your organization Config Custom Policy rule. List is null when debug logging is enabled for all accounts.
        public var debugLogDeliveryAccounts: [Swift.String]?
        /// The description that you provide for your organization Config Custom Policy rule.
        public var description: Swift.String?
        /// A string, in JSON format, that is passed to your organization Config Custom Policy rule.
        public var inputParameters: Swift.String?
        /// The maximum frequency with which Config runs evaluations for a rule. Your Config Custom Policy rule is triggered when Config delivers the configuration snapshot. For more information, see [ConfigSnapshotDeliveryProperties].
        public var maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency?
        /// The type of notification that initiates Config to run an evaluation for a rule. For Config Custom Policy rules, Config supports change-initiated notification types:
        ///
        /// * ConfigurationItemChangeNotification - Initiates an evaluation when Config delivers a configuration item as a result of a resource change.
        ///
        /// * OversizedConfigurationItemChangeNotification - Initiates an evaluation when Config delivers an oversized configuration item. Config may generate this notification type when a resource changes and the notification exceeds the maximum size allowed by Amazon SNS.
        public var organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]?
        /// The runtime system for your organization Config Custom Policy rules. Guard is a policy-as-code language that allows you to write policies that are enforced by Config Custom Policy rules. For more information about Guard, see the [Guard GitHub Repository](https://github.com/aws-cloudformation/cloudformation-guard).
        /// This member is required.
        public var policyRuntime: Swift.String?
        /// The policy definition containing the logic for your organization Config Custom Policy rule.
        /// This member is required.
        public var policyText: Swift.String?
        /// The ID of the Amazon Web Services resource that was evaluated.
        public var resourceIdScope: Swift.String?
        /// The type of the Amazon Web Services resource that was evaluated.
        public var resourceTypesScope: [Swift.String]?
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        public var tagKeyScope: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as a descriptor within a tag category (key).
        public var tagValueScope: Swift.String?

        public init(
            debugLogDeliveryAccounts: [Swift.String]? = nil,
            description: Swift.String? = nil,
            inputParameters: Swift.String? = nil,
            maximumExecutionFrequency: ConfigClientTypes.MaximumExecutionFrequency? = nil,
            organizationConfigRuleTriggerTypes: [ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN]? = nil,
            policyRuntime: Swift.String? = nil,
            policyText: Swift.String? = nil,
            resourceIdScope: Swift.String? = nil,
            resourceTypesScope: [Swift.String]? = nil,
            tagKeyScope: Swift.String? = nil,
            tagValueScope: Swift.String? = nil
        )
        {
            self.debugLogDeliveryAccounts = debugLogDeliveryAccounts
            self.description = description
            self.inputParameters = inputParameters
            self.maximumExecutionFrequency = maximumExecutionFrequency
            self.organizationConfigRuleTriggerTypes = organizationConfigRuleTriggerTypes
            self.policyRuntime = policyRuntime
            self.policyText = policyText
            self.resourceIdScope = resourceIdScope
            self.resourceTypesScope = resourceTypesScope
            self.tagKeyScope = tagKeyScope
            self.tagValueScope = tagValueScope
        }
    }
}

public struct PutAggregationAuthorizationInput: Swift.Sendable {
    /// The 12-digit account ID of the account authorized to aggregate data.
    /// This member is required.
    public var authorizedAccountId: Swift.String?
    /// The region authorized to collect aggregated data.
    /// This member is required.
    public var authorizedAwsRegion: Swift.String?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        authorizedAccountId: Swift.String? = nil,
        authorizedAwsRegion: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.authorizedAccountId = authorizedAccountId
        self.authorizedAwsRegion = authorizedAwsRegion
        self.tags = tags
    }
}

public struct PutAggregationAuthorizationOutput: Swift.Sendable {
    /// Returns an AggregationAuthorization object.
    public var aggregationAuthorization: ConfigClientTypes.AggregationAuthorization?

    public init(
        aggregationAuthorization: ConfigClientTypes.AggregationAuthorization? = nil
    )
    {
        self.aggregationAuthorization = aggregationAuthorization
    }
}

public struct PutConfigRuleInput: Swift.Sendable {
    /// The rule that you want to add to your account.
    /// This member is required.
    public var configRule: ConfigClientTypes.ConfigRule?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        configRule: ConfigClientTypes.ConfigRule? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.configRule = configRule
        self.tags = tags
    }
}

public struct PutConfigurationAggregatorInput: Swift.Sendable {
    /// A list of AccountAggregationSource object.
    public var accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]?
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// An OrganizationAggregationSource object.
    public var organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource?
    /// An array of tag object.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        accountAggregationSources: [ConfigClientTypes.AccountAggregationSource]? = nil,
        configurationAggregatorName: Swift.String? = nil,
        organizationAggregationSource: ConfigClientTypes.OrganizationAggregationSource? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.accountAggregationSources = accountAggregationSources
        self.configurationAggregatorName = configurationAggregatorName
        self.organizationAggregationSource = organizationAggregationSource
        self.tags = tags
    }
}

public struct PutConfigurationAggregatorOutput: Swift.Sendable {
    /// Returns a ConfigurationAggregator object.
    public var configurationAggregator: ConfigClientTypes.ConfigurationAggregator?

    public init(
        configurationAggregator: ConfigClientTypes.ConfigurationAggregator? = nil
    )
    {
        self.configurationAggregator = configurationAggregator
    }
}

/// The input for the [PutConfigurationRecorder] action.
public struct PutConfigurationRecorderInput: Swift.Sendable {
    /// An object for the configuration recorder to record configuration changes for specified resource types.
    /// This member is required.
    public var configurationRecorder: ConfigClientTypes.ConfigurationRecorder?

    public init(
        configurationRecorder: ConfigClientTypes.ConfigurationRecorder? = nil
    )
    {
        self.configurationRecorder = configurationRecorder
    }
}

public struct PutConformancePackInput: Swift.Sendable {
    /// A list of ConformancePackInputParameter objects.
    public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    /// The unique name of the conformance pack you want to deploy.
    /// This member is required.
    public var conformancePackName: Swift.String?
    /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional.
    public var deliveryS3Bucket: Swift.String?
    /// The prefix for the Amazon S3 bucket. This field is optional.
    public var deliveryS3KeyPrefix: Swift.String?
    /// A string containing the full conformance pack template body. The structure containing the template body has a minimum length of 1 byte and a maximum length of 51,200 bytes. You can use a YAML template with two resource types: Config rule (AWS::Config::ConfigRule) and remediation action (AWS::Config::RemediationConfiguration).
    public var templateBody: Swift.String?
    /// The location of the file containing the template body (s3://bucketname/prefix). The uri must point to a conformance pack template (max size: 300 KB) that is located in an Amazon S3 bucket in the same Region as the conformance pack. You must have access to read Amazon S3 bucket. In addition, in order to ensure a successful deployment, the template object must not be in an [archived storage class](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-class-intro.html) if this parameter is passed.
    public var templateS3Uri: Swift.String?
    /// An object of type TemplateSSMDocumentDetails, which contains the name or the Amazon Resource Name (ARN) of the Amazon Web Services Systems Manager document (SSM document) and the version of the SSM document that is used to create a conformance pack.
    public var templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails?

    public init(
        conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
        conformancePackName: Swift.String? = nil,
        deliveryS3Bucket: Swift.String? = nil,
        deliveryS3KeyPrefix: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateS3Uri: Swift.String? = nil,
        templateSSMDocumentDetails: ConfigClientTypes.TemplateSSMDocumentDetails? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.conformancePackName = conformancePackName
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
        self.templateSSMDocumentDetails = templateSSMDocumentDetails
    }
}

public struct PutConformancePackOutput: Swift.Sendable {
    /// ARN of the conformance pack.
    public var conformancePackArn: Swift.String?

    public init(
        conformancePackArn: Swift.String? = nil
    )
    {
        self.conformancePackArn = conformancePackArn
    }
}

/// The input for the [PutDeliveryChannel] action.
public struct PutDeliveryChannelInput: Swift.Sendable {
    /// The configuration delivery channel object that delivers the configuration information to an Amazon S3 bucket and to an Amazon SNS topic.
    /// This member is required.
    public var deliveryChannel: ConfigClientTypes.DeliveryChannel?

    public init(
        deliveryChannel: ConfigClientTypes.DeliveryChannel? = nil
    )
    {
        self.deliveryChannel = deliveryChannel
    }
}

///
public struct PutEvaluationsInput: Swift.Sendable {
    /// The assessments that the Lambda function performs. Each evaluation identifies an Amazon Web Services resource and indicates whether it complies with the Config rule that invokes the Lambda function.
    public var evaluations: [ConfigClientTypes.Evaluation]?
    /// An encrypted token that associates an evaluation with an Config rule. Identifies the rule and the event that triggered the evaluation.
    /// This member is required.
    public var resultToken: Swift.String?
    /// Use this parameter to specify a test run for PutEvaluations. You can verify whether your Lambda function will deliver evaluation results to Config. No updates occur to your existing evaluations, and evaluation results are not sent to Config. When TestMode is true, PutEvaluations doesn't require a valid value for the ResultToken parameter, but the value cannot be null.
    public var testMode: Swift.Bool?

    public init(
        evaluations: [ConfigClientTypes.Evaluation]? = nil,
        resultToken: Swift.String? = nil,
        testMode: Swift.Bool? = false
    )
    {
        self.evaluations = evaluations
        self.resultToken = resultToken
        self.testMode = testMode
    }
}

///
public struct PutEvaluationsOutput: Swift.Sendable {
    /// Requests that failed because of a client or server error.
    public var failedEvaluations: [ConfigClientTypes.Evaluation]?

    public init(
        failedEvaluations: [ConfigClientTypes.Evaluation]? = nil
    )
    {
        self.failedEvaluations = failedEvaluations
    }
}

public struct PutExternalEvaluationInput: Swift.Sendable {
    /// The name of the Config rule.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// An ExternalEvaluation object that provides details about compliance.
    /// This member is required.
    public var externalEvaluation: ConfigClientTypes.ExternalEvaluation?

    public init(
        configRuleName: Swift.String? = nil,
        externalEvaluation: ConfigClientTypes.ExternalEvaluation? = nil
    )
    {
        self.configRuleName = configRuleName
        self.externalEvaluation = externalEvaluation
    }
}

public struct PutExternalEvaluationOutput: Swift.Sendable {

    public init() { }
}

public struct PutOrganizationConfigRuleInput: Swift.Sendable {
    /// A comma-separated list of accounts that you want to exclude from an organization Config rule.
    public var excludedAccounts: [Swift.String]?
    /// The name that you assign to an organization Config rule.
    /// This member is required.
    public var organizationConfigRuleName: Swift.String?
    /// An OrganizationCustomPolicyRuleMetadata object. This object specifies metadata for your organization's Config Custom Policy rule. The metadata includes the runtime system in use, which accounts have debug logging enabled, and other custom rule metadata, such as resource type, resource ID of Amazon Web Services resource, and organization trigger types that initiate Config to evaluate Amazon Web Services resources against a rule.
    public var organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata?
    /// An OrganizationCustomRuleMetadata object. This object specifies organization custom rule metadata such as resource type, resource ID of Amazon Web Services resource, Lambda function ARN, and organization trigger types that trigger Config to evaluate your Amazon Web Services resources against a rule. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public var organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata?
    /// An OrganizationManagedRuleMetadata object. This object specifies organization managed rule metadata such as resource type and ID of Amazon Web Services resource along with the rule identifier. It also provides the frequency with which you want Config to run evaluations for the rule if the trigger type is periodic.
    public var organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata?

    public init(
        excludedAccounts: [Swift.String]? = nil,
        organizationConfigRuleName: Swift.String? = nil,
        organizationCustomPolicyRuleMetadata: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata? = nil,
        organizationCustomRuleMetadata: ConfigClientTypes.OrganizationCustomRuleMetadata? = nil,
        organizationManagedRuleMetadata: ConfigClientTypes.OrganizationManagedRuleMetadata? = nil
    )
    {
        self.excludedAccounts = excludedAccounts
        self.organizationConfigRuleName = organizationConfigRuleName
        self.organizationCustomPolicyRuleMetadata = organizationCustomPolicyRuleMetadata
        self.organizationCustomRuleMetadata = organizationCustomRuleMetadata
        self.organizationManagedRuleMetadata = organizationManagedRuleMetadata
    }
}

public struct PutOrganizationConfigRuleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an organization Config rule.
    public var organizationConfigRuleArn: Swift.String?

    public init(
        organizationConfigRuleArn: Swift.String? = nil
    )
    {
        self.organizationConfigRuleArn = organizationConfigRuleArn
    }
}

public struct PutOrganizationConformancePackInput: Swift.Sendable {
    /// A list of ConformancePackInputParameter objects.
    public var conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]?
    /// The name of the Amazon S3 bucket where Config stores conformance pack templates. This field is optional. If used, it must be prefixed with awsconfigconforms.
    public var deliveryS3Bucket: Swift.String?
    /// The prefix for the Amazon S3 bucket. This field is optional.
    public var deliveryS3KeyPrefix: Swift.String?
    /// A list of Amazon Web Services accounts to be excluded from an organization conformance pack while deploying a conformance pack.
    public var excludedAccounts: [Swift.String]?
    /// Name of the organization conformance pack you want to create.
    /// This member is required.
    public var organizationConformancePackName: Swift.String?
    /// A string containing full conformance pack template body. Structure containing the template body with a minimum length of 1 byte and a maximum length of 51,200 bytes.
    public var templateBody: Swift.String?
    /// Location of file containing the template body. The uri must point to the conformance pack template (max size: 300 KB). You must have access to read Amazon S3 bucket. In addition, in order to ensure a successful deployment, the template object must not be in an [archived storage class](https://docs.aws.amazon.com/AmazonS3/latest/userguide/storage-class-intro.html) if this parameter is passed.
    public var templateS3Uri: Swift.String?

    public init(
        conformancePackInputParameters: [ConfigClientTypes.ConformancePackInputParameter]? = nil,
        deliveryS3Bucket: Swift.String? = nil,
        deliveryS3KeyPrefix: Swift.String? = nil,
        excludedAccounts: [Swift.String]? = nil,
        organizationConformancePackName: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateS3Uri: Swift.String? = nil
    )
    {
        self.conformancePackInputParameters = conformancePackInputParameters
        self.deliveryS3Bucket = deliveryS3Bucket
        self.deliveryS3KeyPrefix = deliveryS3KeyPrefix
        self.excludedAccounts = excludedAccounts
        self.organizationConformancePackName = organizationConformancePackName
        self.templateBody = templateBody
        self.templateS3Uri = templateS3Uri
    }
}

public struct PutOrganizationConformancePackOutput: Swift.Sendable {
    /// ARN of the organization conformance pack.
    public var organizationConformancePackArn: Swift.String?

    public init(
        organizationConformancePackArn: Swift.String? = nil
    )
    {
        self.organizationConformancePackArn = organizationConformancePackArn
    }
}

public struct PutRemediationConfigurationsInput: Swift.Sendable {
    /// A list of remediation configuration objects.
    /// This member is required.
    public var remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]?

    public init(
        remediationConfigurations: [ConfigClientTypes.RemediationConfiguration]? = nil
    )
    {
        self.remediationConfigurations = remediationConfigurations
    }
}

public struct PutRemediationConfigurationsOutput: Swift.Sendable {
    /// Returns a list of failed remediation batch objects.
    public var failedBatches: [ConfigClientTypes.FailedRemediationBatch]?

    public init(
        failedBatches: [ConfigClientTypes.FailedRemediationBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

public struct PutRemediationExceptionsInput: Swift.Sendable {
    /// The name of the Config rule for which you want to create remediation exception.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// The exception is automatically deleted after the expiration date.
    public var expirationTime: Foundation.Date?
    /// The message contains an explanation of the exception.
    public var message: Swift.String?
    /// An exception list of resource exception keys to be processed with the current request. Config adds exception for each resource key. For example, Config adds 3 exceptions for 3 resource keys.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]?

    public init(
        configRuleName: Swift.String? = nil,
        expirationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.RemediationExceptionResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.expirationTime = expirationTime
        self.message = message
        self.resourceKeys = resourceKeys
    }
}

public struct PutRemediationExceptionsOutput: Swift.Sendable {
    /// Returns a list of failed remediation exceptions batch objects. Each object in the batch consists of a list of failed items and failure messages.
    public var failedBatches: [ConfigClientTypes.FailedRemediationExceptionBatch]?

    public init(
        failedBatches: [ConfigClientTypes.FailedRemediationExceptionBatch]? = nil
    )
    {
        self.failedBatches = failedBatches
    }
}

public struct PutResourceConfigInput: Swift.Sendable {
    /// The configuration object of the resource in valid JSON format. It must match the schema registered with CloudFormation. The configuration JSON must not exceed 64 KB.
    /// This member is required.
    public var configuration: Swift.String?
    /// Unique identifier of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Name of the resource.
    public var resourceName: Swift.String?
    /// The type of the resource. The custom resource type must be registered with CloudFormation. You cannot use the organization names amzn, amazon, alexa, custom with custom resource types. It is the first part of the ResourceType up to the first ::.
    /// This member is required.
    public var resourceType: Swift.String?
    /// Version of the schema registered for the ResourceType in CloudFormation.
    /// This member is required.
    public var schemaVersionId: Swift.String?
    /// Tags associated with the resource. This field is not to be confused with the Amazon Web Services-wide tag feature for Amazon Web Services resources. Tags for PutResourceConfig are tags that you supply for the configuration items of your custom resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configuration: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        schemaVersionId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configuration = configuration
        self.resourceId = resourceId
        self.resourceName = resourceName
        self.resourceType = resourceType
        self.schemaVersionId = schemaVersionId
        self.tags = tags
    }
}

public struct PutRetentionConfigurationInput: Swift.Sendable {
    /// Number of days Config stores your historical information. Currently, only applicable to the configuration item history.
    /// This member is required.
    public var retentionPeriodInDays: Swift.Int?

    public init(
        retentionPeriodInDays: Swift.Int? = nil
    )
    {
        self.retentionPeriodInDays = retentionPeriodInDays
    }
}

public struct PutRetentionConfigurationOutput: Swift.Sendable {
    /// Returns a retention configuration object.
    public var retentionConfiguration: ConfigClientTypes.RetentionConfiguration?

    public init(
        retentionConfiguration: ConfigClientTypes.RetentionConfiguration? = nil
    )
    {
        self.retentionConfiguration = retentionConfiguration
    }
}

/// Two users are trying to modify the same query at the same time. Wait for a moment and try again.
public struct ResourceConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit of the number of tags you can use. For more information, see [ Service Limits ](https://docs.aws.amazon.com/config/latest/developerguide/configlimits.html) in the Config Developer Guide.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Error executing the command
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutStoredQueryInput: Swift.Sendable {
    /// A list of StoredQuery objects. The mandatory fields are QueryName and Expression. When you are creating a query, you must provide a query name and an expression. When you are updating a query, you must provide a query name but updating the description is optional.
    /// This member is required.
    public var storedQuery: ConfigClientTypes.StoredQuery?
    /// A list of Tags object.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        storedQuery: ConfigClientTypes.StoredQuery? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.storedQuery = storedQuery
        self.tags = tags
    }
}

public struct PutStoredQueryOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the query. For example, arn:partition:service:region:account-id:resource-type/resource-name/resource-id.
    public var queryArn: Swift.String?

    public init(
        queryArn: Swift.String? = nil
    )
    {
        self.queryArn = queryArn
    }
}

extension ConfigClientTypes {

    /// Details about the query.
    public struct QueryInfo: Swift.Sendable {
        /// Returns a FieldInfo object.
        public var selectFields: [ConfigClientTypes.FieldInfo]?

        public init(
            selectFields: [ConfigClientTypes.FieldInfo]? = nil
        )
        {
            self.selectFields = selectFields
        }
    }
}

public struct SelectAggregateResourceConfigInput: Swift.Sendable {
    /// The name of the configuration aggregator.
    /// This member is required.
    public var configurationAggregatorName: Swift.String?
    /// The SQL query SELECT command.
    /// This member is required.
    public var expression: Swift.String?
    /// The maximum number of query results returned on each page.
    public var limit: Swift.Int?
    /// The maximum number of query results returned on each page. Config also allows the Limit request parameter.
    public var maxResults: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        configurationAggregatorName: Swift.String? = nil,
        expression: Swift.String? = nil,
        limit: Swift.Int? = 0,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationAggregatorName = configurationAggregatorName
        self.expression = expression
        self.limit = limit
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SelectAggregateResourceConfigOutput: Swift.Sendable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Details about the query.
    public var queryInfo: ConfigClientTypes.QueryInfo?
    /// Returns the results for the SQL query.
    public var results: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        queryInfo: ConfigClientTypes.QueryInfo? = nil,
        results: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

public struct SelectResourceConfigInput: Swift.Sendable {
    /// The SQL query SELECT command.
    /// This member is required.
    public var expression: Swift.String?
    /// The maximum number of query results returned on each page.
    public var limit: Swift.Int?
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?

    public init(
        expression: Swift.String? = nil,
        limit: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.expression = expression
        self.limit = limit
        self.nextToken = nextToken
    }
}

public struct SelectResourceConfigOutput: Swift.Sendable {
    /// The nextToken string returned in a previous request that you use to request the next page of results in a paginated response.
    public var nextToken: Swift.String?
    /// Returns the QueryInfo object.
    public var queryInfo: ConfigClientTypes.QueryInfo?
    /// Returns the results for the SQL query.
    public var results: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        queryInfo: ConfigClientTypes.QueryInfo? = nil,
        results: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryInfo = queryInfo
        self.results = results
    }
}

///
public struct StartConfigRulesEvaluationInput: Swift.Sendable {
    /// The list of names of Config rules that you want to run evaluations for.
    public var configRuleNames: [Swift.String]?

    public init(
        configRuleNames: [Swift.String]? = nil
    )
    {
        self.configRuleNames = configRuleNames
    }
}

/// The output when you start the evaluation for the specified Config rule.
public struct StartConfigRulesEvaluationOutput: Swift.Sendable {

    public init() { }
}

/// The input for the [StartConfigurationRecorder] action.
public struct StartConfigurationRecorderInput: Swift.Sendable {
    /// The name of the recorder object that records each configuration change made to the resources.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init(
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

public struct StartRemediationExecutionInput: Swift.Sendable {
    /// The list of names of Config rules that you want to run remediation execution for.
    /// This member is required.
    public var configRuleName: Swift.String?
    /// A list of resource keys to be processed with the current request. Each element in the list consists of the resource type and resource ID.
    /// This member is required.
    public var resourceKeys: [ConfigClientTypes.ResourceKey]?

    public init(
        configRuleName: Swift.String? = nil,
        resourceKeys: [ConfigClientTypes.ResourceKey]? = nil
    )
    {
        self.configRuleName = configRuleName
        self.resourceKeys = resourceKeys
    }
}

public struct StartRemediationExecutionOutput: Swift.Sendable {
    /// For resources that have failed to start execution, the API returns a resource key object.
    public var failedItems: [ConfigClientTypes.ResourceKey]?
    /// Returns a failure message. For example, the resource is already compliant.
    public var failureMessage: Swift.String?

    public init(
        failedItems: [ConfigClientTypes.ResourceKey]? = nil,
        failureMessage: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.failureMessage = failureMessage
    }
}

public struct StartResourceEvaluationInput: Swift.Sendable {
    /// A client token is a unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request using one of these actions, specify a client token in the request. Avoid reusing the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, other than the Region or Availability Zone, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Returns an EvaluationContext object.
    public var evaluationContext: ConfigClientTypes.EvaluationContext?
    /// The mode of an evaluation. The valid values for this API are DETECTIVE and PROACTIVE.
    /// This member is required.
    public var evaluationMode: ConfigClientTypes.EvaluationMode?
    /// The timeout for an evaluation. The default is 900 seconds. You cannot specify a number greater than 3600. If you specify 0, Config uses the default.
    public var evaluationTimeout: Swift.Int?
    /// Returns a ResourceDetails object.
    /// This member is required.
    public var resourceDetails: ConfigClientTypes.ResourceDetails?

    public init(
        clientToken: Swift.String? = nil,
        evaluationContext: ConfigClientTypes.EvaluationContext? = nil,
        evaluationMode: ConfigClientTypes.EvaluationMode? = nil,
        evaluationTimeout: Swift.Int? = 0,
        resourceDetails: ConfigClientTypes.ResourceDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.evaluationContext = evaluationContext
        self.evaluationMode = evaluationMode
        self.evaluationTimeout = evaluationTimeout
        self.resourceDetails = resourceDetails
    }
}

public struct StartResourceEvaluationOutput: Swift.Sendable {
    /// A unique ResourceEvaluationId that is associated with a single execution.
    public var resourceEvaluationId: Swift.String?

    public init(
        resourceEvaluationId: Swift.String? = nil
    )
    {
        self.resourceEvaluationId = resourceEvaluationId
    }
}

/// The input for the [StopConfigurationRecorder] action.
public struct StopConfigurationRecorderInput: Swift.Sendable {
    /// The name of the recorder object that records each configuration change made to the resources.
    /// This member is required.
    public var configurationRecorderName: Swift.String?

    public init(
        configurationRecorderName: Swift.String? = nil
    )
    {
        self.configurationRecorderName = configurationRecorderName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag object.
    /// This member is required.
    public var tags: [ConfigClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ConfigClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are ConfigRule, ConfigurationAggregator and AggregatorAuthorization.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension BatchGetAggregateResourceConfigInput {

    static func urlPathProvider(_ value: BatchGetAggregateResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetResourceConfigInput {

    static func urlPathProvider(_ value: BatchGetResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAggregationAuthorizationInput {

    static func urlPathProvider(_ value: DeleteAggregationAuthorizationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConfigRuleInput {

    static func urlPathProvider(_ value: DeleteConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConfigurationAggregatorInput {

    static func urlPathProvider(_ value: DeleteConfigurationAggregatorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConfigurationRecorderInput {

    static func urlPathProvider(_ value: DeleteConfigurationRecorderInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConformancePackInput {

    static func urlPathProvider(_ value: DeleteConformancePackInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDeliveryChannelInput {

    static func urlPathProvider(_ value: DeleteDeliveryChannelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEvaluationResultsInput {

    static func urlPathProvider(_ value: DeleteEvaluationResultsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOrganizationConfigRuleInput {

    static func urlPathProvider(_ value: DeleteOrganizationConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOrganizationConformancePackInput {

    static func urlPathProvider(_ value: DeleteOrganizationConformancePackInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePendingAggregationRequestInput {

    static func urlPathProvider(_ value: DeletePendingAggregationRequestInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRemediationConfigurationInput {

    static func urlPathProvider(_ value: DeleteRemediationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRemediationExceptionsInput {

    static func urlPathProvider(_ value: DeleteRemediationExceptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceConfigInput {

    static func urlPathProvider(_ value: DeleteResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRetentionConfigurationInput {

    static func urlPathProvider(_ value: DeleteRetentionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStoredQueryInput {

    static func urlPathProvider(_ value: DeleteStoredQueryInput) -> Swift.String? {
        return "/"
    }
}

extension DeliverConfigSnapshotInput {

    static func urlPathProvider(_ value: DeliverConfigSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAggregateComplianceByConfigRulesInput {

    static func urlPathProvider(_ value: DescribeAggregateComplianceByConfigRulesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAggregateComplianceByConformancePacksInput {

    static func urlPathProvider(_ value: DescribeAggregateComplianceByConformancePacksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAggregationAuthorizationsInput {

    static func urlPathProvider(_ value: DescribeAggregationAuthorizationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeComplianceByConfigRuleInput {

    static func urlPathProvider(_ value: DescribeComplianceByConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeComplianceByResourceInput {

    static func urlPathProvider(_ value: DescribeComplianceByResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigRuleEvaluationStatusInput {

    static func urlPathProvider(_ value: DescribeConfigRuleEvaluationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigRulesInput {

    static func urlPathProvider(_ value: DescribeConfigRulesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationAggregatorsInput {

    static func urlPathProvider(_ value: DescribeConfigurationAggregatorsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationAggregatorSourcesStatusInput {

    static func urlPathProvider(_ value: DescribeConfigurationAggregatorSourcesStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationRecordersInput {

    static func urlPathProvider(_ value: DescribeConfigurationRecordersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationRecorderStatusInput {

    static func urlPathProvider(_ value: DescribeConfigurationRecorderStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConformancePackComplianceInput {

    static func urlPathProvider(_ value: DescribeConformancePackComplianceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConformancePacksInput {

    static func urlPathProvider(_ value: DescribeConformancePacksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConformancePackStatusInput {

    static func urlPathProvider(_ value: DescribeConformancePackStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDeliveryChannelsInput {

    static func urlPathProvider(_ value: DescribeDeliveryChannelsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDeliveryChannelStatusInput {

    static func urlPathProvider(_ value: DescribeDeliveryChannelStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrganizationConfigRulesInput {

    static func urlPathProvider(_ value: DescribeOrganizationConfigRulesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrganizationConfigRuleStatusesInput {

    static func urlPathProvider(_ value: DescribeOrganizationConfigRuleStatusesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrganizationConformancePacksInput {

    static func urlPathProvider(_ value: DescribeOrganizationConformancePacksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrganizationConformancePackStatusesInput {

    static func urlPathProvider(_ value: DescribeOrganizationConformancePackStatusesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePendingAggregationRequestsInput {

    static func urlPathProvider(_ value: DescribePendingAggregationRequestsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRemediationConfigurationsInput {

    static func urlPathProvider(_ value: DescribeRemediationConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRemediationExceptionsInput {

    static func urlPathProvider(_ value: DescribeRemediationExceptionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRemediationExecutionStatusInput {

    static func urlPathProvider(_ value: DescribeRemediationExecutionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRetentionConfigurationsInput {

    static func urlPathProvider(_ value: DescribeRetentionConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAggregateComplianceDetailsByConfigRuleInput {

    static func urlPathProvider(_ value: GetAggregateComplianceDetailsByConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetAggregateConfigRuleComplianceSummaryInput {

    static func urlPathProvider(_ value: GetAggregateConfigRuleComplianceSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetAggregateConformancePackComplianceSummaryInput {

    static func urlPathProvider(_ value: GetAggregateConformancePackComplianceSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetAggregateDiscoveredResourceCountsInput {

    static func urlPathProvider(_ value: GetAggregateDiscoveredResourceCountsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAggregateResourceConfigInput {

    static func urlPathProvider(_ value: GetAggregateResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension GetComplianceDetailsByConfigRuleInput {

    static func urlPathProvider(_ value: GetComplianceDetailsByConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetComplianceDetailsByResourceInput {

    static func urlPathProvider(_ value: GetComplianceDetailsByResourceInput) -> Swift.String? {
        return "/"
    }
}

extension GetComplianceSummaryByConfigRuleInput {

    static func urlPathProvider(_ value: GetComplianceSummaryByConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension GetComplianceSummaryByResourceTypeInput {

    static func urlPathProvider(_ value: GetComplianceSummaryByResourceTypeInput) -> Swift.String? {
        return "/"
    }
}

extension GetConformancePackComplianceDetailsInput {

    static func urlPathProvider(_ value: GetConformancePackComplianceDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetConformancePackComplianceSummaryInput {

    static func urlPathProvider(_ value: GetConformancePackComplianceSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetCustomRulePolicyInput {

    static func urlPathProvider(_ value: GetCustomRulePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetDiscoveredResourceCountsInput {

    static func urlPathProvider(_ value: GetDiscoveredResourceCountsInput) -> Swift.String? {
        return "/"
    }
}

extension GetOrganizationConfigRuleDetailedStatusInput {

    static func urlPathProvider(_ value: GetOrganizationConfigRuleDetailedStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetOrganizationConformancePackDetailedStatusInput {

    static func urlPathProvider(_ value: GetOrganizationConformancePackDetailedStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetOrganizationCustomRulePolicyInput {

    static func urlPathProvider(_ value: GetOrganizationCustomRulePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceConfigHistoryInput {

    static func urlPathProvider(_ value: GetResourceConfigHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceEvaluationSummaryInput {

    static func urlPathProvider(_ value: GetResourceEvaluationSummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetStoredQueryInput {

    static func urlPathProvider(_ value: GetStoredQueryInput) -> Swift.String? {
        return "/"
    }
}

extension ListAggregateDiscoveredResourcesInput {

    static func urlPathProvider(_ value: ListAggregateDiscoveredResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListConformancePackComplianceScoresInput {

    static func urlPathProvider(_ value: ListConformancePackComplianceScoresInput) -> Swift.String? {
        return "/"
    }
}

extension ListDiscoveredResourcesInput {

    static func urlPathProvider(_ value: ListDiscoveredResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceEvaluationsInput {

    static func urlPathProvider(_ value: ListResourceEvaluationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListStoredQueriesInput {

    static func urlPathProvider(_ value: ListStoredQueriesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutAggregationAuthorizationInput {

    static func urlPathProvider(_ value: PutAggregationAuthorizationInput) -> Swift.String? {
        return "/"
    }
}

extension PutConfigRuleInput {

    static func urlPathProvider(_ value: PutConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension PutConfigurationAggregatorInput {

    static func urlPathProvider(_ value: PutConfigurationAggregatorInput) -> Swift.String? {
        return "/"
    }
}

extension PutConfigurationRecorderInput {

    static func urlPathProvider(_ value: PutConfigurationRecorderInput) -> Swift.String? {
        return "/"
    }
}

extension PutConformancePackInput {

    static func urlPathProvider(_ value: PutConformancePackInput) -> Swift.String? {
        return "/"
    }
}

extension PutDeliveryChannelInput {

    static func urlPathProvider(_ value: PutDeliveryChannelInput) -> Swift.String? {
        return "/"
    }
}

extension PutEvaluationsInput {

    static func urlPathProvider(_ value: PutEvaluationsInput) -> Swift.String? {
        return "/"
    }
}

extension PutExternalEvaluationInput {

    static func urlPathProvider(_ value: PutExternalEvaluationInput) -> Swift.String? {
        return "/"
    }
}

extension PutOrganizationConfigRuleInput {

    static func urlPathProvider(_ value: PutOrganizationConfigRuleInput) -> Swift.String? {
        return "/"
    }
}

extension PutOrganizationConformancePackInput {

    static func urlPathProvider(_ value: PutOrganizationConformancePackInput) -> Swift.String? {
        return "/"
    }
}

extension PutRemediationConfigurationsInput {

    static func urlPathProvider(_ value: PutRemediationConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension PutRemediationExceptionsInput {

    static func urlPathProvider(_ value: PutRemediationExceptionsInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourceConfigInput {

    static func urlPathProvider(_ value: PutResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension PutRetentionConfigurationInput {

    static func urlPathProvider(_ value: PutRetentionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutStoredQueryInput {

    static func urlPathProvider(_ value: PutStoredQueryInput) -> Swift.String? {
        return "/"
    }
}

extension SelectAggregateResourceConfigInput {

    static func urlPathProvider(_ value: SelectAggregateResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension SelectResourceConfigInput {

    static func urlPathProvider(_ value: SelectResourceConfigInput) -> Swift.String? {
        return "/"
    }
}

extension StartConfigRulesEvaluationInput {

    static func urlPathProvider(_ value: StartConfigRulesEvaluationInput) -> Swift.String? {
        return "/"
    }
}

extension StartConfigurationRecorderInput {

    static func urlPathProvider(_ value: StartConfigurationRecorderInput) -> Swift.String? {
        return "/"
    }
}

extension StartRemediationExecutionInput {

    static func urlPathProvider(_ value: StartRemediationExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartResourceEvaluationInput {

    static func urlPathProvider(_ value: StartResourceEvaluationInput) -> Swift.String? {
        return "/"
    }
}

extension StopConfigurationRecorderInput {

    static func urlPathProvider(_ value: StopConfigurationRecorderInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetAggregateResourceConfigInput {

    static func write(value: BatchGetAggregateResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["ResourceIdentifiers"].writeList(value.resourceIdentifiers, memberWritingClosure: ConfigClientTypes.AggregateResourceIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetResourceConfigInput {

    static func write(value: BatchGetResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.ResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAggregationAuthorizationInput {

    static func write(value: DeleteAggregationAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedAccountId"].write(value.authorizedAccountId)
        try writer["AuthorizedAwsRegion"].write(value.authorizedAwsRegion)
    }
}

extension DeleteConfigRuleInput {

    static func write(value: DeleteConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
    }
}

extension DeleteConfigurationAggregatorInput {

    static func write(value: DeleteConfigurationAggregatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
    }
}

extension DeleteConfigurationRecorderInput {

    static func write(value: DeleteConfigurationRecorderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorderName"].write(value.configurationRecorderName)
    }
}

extension DeleteConformancePackInput {

    static func write(value: DeleteConformancePackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackName"].write(value.conformancePackName)
    }
}

extension DeleteDeliveryChannelInput {

    static func write(value: DeleteDeliveryChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryChannelName"].write(value.deliveryChannelName)
    }
}

extension DeleteEvaluationResultsInput {

    static func write(value: DeleteEvaluationResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
    }
}

extension DeleteOrganizationConfigRuleInput {

    static func write(value: DeleteOrganizationConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationConfigRuleName"].write(value.organizationConfigRuleName)
    }
}

extension DeleteOrganizationConformancePackInput {

    static func write(value: DeleteOrganizationConformancePackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationConformancePackName"].write(value.organizationConformancePackName)
    }
}

extension DeletePendingAggregationRequestInput {

    static func write(value: DeletePendingAggregationRequestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RequesterAccountId"].write(value.requesterAccountId)
        try writer["RequesterAwsRegion"].write(value.requesterAwsRegion)
    }
}

extension DeleteRemediationConfigurationInput {

    static func write(value: DeleteRemediationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension DeleteRemediationExceptionsInput {

    static func write(value: DeleteRemediationExceptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ResourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.RemediationExceptionResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteResourceConfigInput {

    static func write(value: DeleteResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension DeleteRetentionConfigurationInput {

    static func write(value: DeleteRetentionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionConfigurationName"].write(value.retentionConfigurationName)
    }
}

extension DeleteStoredQueryInput {

    static func write(value: DeleteStoredQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryName"].write(value.queryName)
    }
}

extension DeliverConfigSnapshotInput {

    static func write(value: DeliverConfigSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryChannelName"].write(value.deliveryChannelName)
    }
}

extension DescribeAggregateComplianceByConfigRulesInput {

    static func write(value: DescribeAggregateComplianceByConfigRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ConfigRuleComplianceFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAggregateComplianceByConformancePacksInput {

    static func write(value: DescribeAggregateComplianceByConformancePacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.AggregateConformancePackComplianceFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAggregationAuthorizationsInput {

    static func write(value: DescribeAggregationAuthorizationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeComplianceByConfigRuleInput {

    static func write(value: DescribeComplianceByConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceTypes"].writeList(value.complianceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ComplianceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeComplianceByResourceInput {

    static func write(value: DescribeComplianceByResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceTypes"].writeList(value.complianceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ComplianceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension DescribeConfigRuleEvaluationStatusInput {

    static func write(value: DescribeConfigRuleEvaluationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConfigRulesInput {

    static func write(value: DescribeConfigRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.DescribeConfigRulesFilters.write(value:to:))
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConfigurationAggregatorsInput {

    static func write(value: DescribeConfigurationAggregatorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorNames"].writeList(value.configurationAggregatorNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConfigurationAggregatorSourcesStatusInput {

    static func write(value: DescribeConfigurationAggregatorSourcesStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["UpdateStatus"].writeList(value.updateStatus, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.AggregatedSourceStatusType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeConfigurationRecordersInput {

    static func write(value: DescribeConfigurationRecordersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorderNames"].writeList(value.configurationRecorderNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeConfigurationRecorderStatusInput {

    static func write(value: DescribeConfigurationRecorderStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorderNames"].writeList(value.configurationRecorderNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeConformancePackComplianceInput {

    static func write(value: DescribeConformancePackComplianceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackName"].write(value.conformancePackName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ConformancePackComplianceFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConformancePacksInput {

    static func write(value: DescribeConformancePacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackNames"].writeList(value.conformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConformancePackStatusInput {

    static func write(value: DescribeConformancePackStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackNames"].writeList(value.conformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeDeliveryChannelsInput {

    static func write(value: DescribeDeliveryChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryChannelNames"].writeList(value.deliveryChannelNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeDeliveryChannelStatusInput {

    static func write(value: DescribeDeliveryChannelStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryChannelNames"].writeList(value.deliveryChannelNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOrganizationConfigRulesInput {

    static func write(value: DescribeOrganizationConfigRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConfigRuleNames"].writeList(value.organizationConfigRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOrganizationConfigRuleStatusesInput {

    static func write(value: DescribeOrganizationConfigRuleStatusesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConfigRuleNames"].writeList(value.organizationConfigRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOrganizationConformancePacksInput {

    static func write(value: DescribeOrganizationConformancePacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConformancePackNames"].writeList(value.organizationConformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOrganizationConformancePackStatusesInput {

    static func write(value: DescribeOrganizationConformancePackStatusesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConformancePackNames"].writeList(value.organizationConformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribePendingAggregationRequestsInput {

    static func write(value: DescribePendingAggregationRequestsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeRemediationConfigurationsInput {

    static func write(value: DescribeRemediationConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRemediationExceptionsInput {

    static func write(value: DescribeRemediationExceptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.RemediationExceptionResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRemediationExecutionStatusInput {

    static func write(value: DescribeRemediationExecutionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.ResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRetentionConfigurationsInput {

    static func write(value: DescribeRetentionConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["RetentionConfigurationNames"].writeList(value.retentionConfigurationNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetAggregateComplianceDetailsByConfigRuleInput {

    static func write(value: GetAggregateComplianceDetailsByConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetAggregateConfigRuleComplianceSummaryInput {

    static func write(value: GetAggregateConfigRuleComplianceSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ConfigRuleComplianceSummaryFilters.write(value:to:))
        try writer["GroupByKey"].write(value.groupByKey)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetAggregateConformancePackComplianceSummaryInput {

    static func write(value: GetAggregateConformancePackComplianceSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters.write(value:to:))
        try writer["GroupByKey"].write(value.groupByKey)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetAggregateDiscoveredResourceCountsInput {

    static func write(value: GetAggregateDiscoveredResourceCountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ResourceCountFilters.write(value:to:))
        try writer["GroupByKey"].write(value.groupByKey)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetAggregateResourceConfigInput {

    static func write(value: GetAggregateResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier, with: ConfigClientTypes.AggregateResourceIdentifier.write(value:to:))
    }
}

extension GetComplianceDetailsByConfigRuleInput {

    static func write(value: GetComplianceDetailsByConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceTypes"].writeList(value.complianceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ComplianceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetComplianceDetailsByResourceInput {

    static func write(value: GetComplianceDetailsByResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceTypes"].writeList(value.complianceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ComplianceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceEvaluationId"].write(value.resourceEvaluationId)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension GetComplianceSummaryByConfigRuleInput {

    static func write(value: GetComplianceSummaryByConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetComplianceSummaryByResourceTypeInput {

    static func write(value: GetComplianceSummaryByResourceTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetConformancePackComplianceDetailsInput {

    static func write(value: GetConformancePackComplianceDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackName"].write(value.conformancePackName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ConformancePackEvaluationFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetConformancePackComplianceSummaryInput {

    static func write(value: GetConformancePackComplianceSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackNames"].writeList(value.conformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetCustomRulePolicyInput {

    static func write(value: GetCustomRulePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
    }
}

extension GetDiscoveredResourceCountsInput {

    static func write(value: GetDiscoveredResourceCountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["limit"].write(value.limit)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetOrganizationConfigRuleDetailedStatusInput {

    static func write(value: GetOrganizationConfigRuleDetailedStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.StatusDetailFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConfigRuleName"].write(value.organizationConfigRuleName)
    }
}

extension GetOrganizationConformancePackDetailedStatusInput {

    static func write(value: GetOrganizationConformancePackDetailedStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.OrganizationResourceDetailedStatusFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationConformancePackName"].write(value.organizationConformancePackName)
    }
}

extension GetOrganizationCustomRulePolicyInput {

    static func write(value: GetOrganizationCustomRulePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationConfigRuleName"].write(value.organizationConfigRuleName)
    }
}

extension GetResourceConfigHistoryInput {

    static func write(value: GetResourceConfigHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chronologicalOrder"].write(value.chronologicalOrder)
        try writer["earlierTime"].writeTimestamp(value.earlierTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["laterTime"].writeTimestamp(value.laterTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["limit"].write(value.limit)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceId"].write(value.resourceId)
        try writer["resourceType"].write(value.resourceType)
    }
}

extension GetResourceEvaluationSummaryInput {

    static func write(value: GetResourceEvaluationSummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceEvaluationId"].write(value.resourceEvaluationId)
    }
}

extension GetStoredQueryInput {

    static func write(value: GetStoredQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryName"].write(value.queryName)
    }
}

extension ListAggregateDiscoveredResourcesInput {

    static func write(value: ListAggregateDiscoveredResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ResourceFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListConformancePackComplianceScoresInput {

    static func write(value: ListConformancePackComplianceScoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ConformancePackComplianceScoresFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension ListDiscoveredResourcesInput {

    static func write(value: ListDiscoveredResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includeDeletedResources"].write(value.includeDeletedResources)
        try writer["limit"].write(value.limit)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceIds"].writeList(value.resourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceName"].write(value.resourceName)
        try writer["resourceType"].write(value.resourceType)
    }
}

extension ListResourceEvaluationsInput {

    static func write(value: ListResourceEvaluationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ConfigClientTypes.ResourceEvaluationFilters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListStoredQueriesInput {

    static func write(value: ListStoredQueriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutAggregationAuthorizationInput {

    static func write(value: PutAggregationAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedAccountId"].write(value.authorizedAccountId)
        try writer["AuthorizedAwsRegion"].write(value.authorizedAwsRegion)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ConfigClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutConfigRuleInput {

    static func write(value: PutConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRule"].write(value.configRule, with: ConfigClientTypes.ConfigRule.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ConfigClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutConfigurationAggregatorInput {

    static func write(value: PutConfigurationAggregatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAggregationSources"].writeList(value.accountAggregationSources, memberWritingClosure: ConfigClientTypes.AccountAggregationSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["OrganizationAggregationSource"].write(value.organizationAggregationSource, with: ConfigClientTypes.OrganizationAggregationSource.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ConfigClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutConfigurationRecorderInput {

    static func write(value: PutConfigurationRecorderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorder"].write(value.configurationRecorder, with: ConfigClientTypes.ConfigurationRecorder.write(value:to:))
    }
}

extension PutConformancePackInput {

    static func write(value: PutConformancePackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackInputParameters"].writeList(value.conformancePackInputParameters, memberWritingClosure: ConfigClientTypes.ConformancePackInputParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConformancePackName"].write(value.conformancePackName)
        try writer["DeliveryS3Bucket"].write(value.deliveryS3Bucket)
        try writer["DeliveryS3KeyPrefix"].write(value.deliveryS3KeyPrefix)
        try writer["TemplateBody"].write(value.templateBody)
        try writer["TemplateS3Uri"].write(value.templateS3Uri)
        try writer["TemplateSSMDocumentDetails"].write(value.templateSSMDocumentDetails, with: ConfigClientTypes.TemplateSSMDocumentDetails.write(value:to:))
    }
}

extension PutDeliveryChannelInput {

    static func write(value: PutDeliveryChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryChannel"].write(value.deliveryChannel, with: ConfigClientTypes.DeliveryChannel.write(value:to:))
    }
}

extension PutEvaluationsInput {

    static func write(value: PutEvaluationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Evaluations"].writeList(value.evaluations, memberWritingClosure: ConfigClientTypes.Evaluation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResultToken"].write(value.resultToken)
        try writer["TestMode"].write(value.testMode)
    }
}

extension PutExternalEvaluationInput {

    static func write(value: PutExternalEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ExternalEvaluation"].write(value.externalEvaluation, with: ConfigClientTypes.ExternalEvaluation.write(value:to:))
    }
}

extension PutOrganizationConfigRuleInput {

    static func write(value: PutOrganizationConfigRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExcludedAccounts"].writeList(value.excludedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationConfigRuleName"].write(value.organizationConfigRuleName)
        try writer["OrganizationCustomPolicyRuleMetadata"].write(value.organizationCustomPolicyRuleMetadata, with: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata.write(value:to:))
        try writer["OrganizationCustomRuleMetadata"].write(value.organizationCustomRuleMetadata, with: ConfigClientTypes.OrganizationCustomRuleMetadata.write(value:to:))
        try writer["OrganizationManagedRuleMetadata"].write(value.organizationManagedRuleMetadata, with: ConfigClientTypes.OrganizationManagedRuleMetadata.write(value:to:))
    }
}

extension PutOrganizationConformancePackInput {

    static func write(value: PutOrganizationConformancePackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackInputParameters"].writeList(value.conformancePackInputParameters, memberWritingClosure: ConfigClientTypes.ConformancePackInputParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeliveryS3Bucket"].write(value.deliveryS3Bucket)
        try writer["DeliveryS3KeyPrefix"].write(value.deliveryS3KeyPrefix)
        try writer["ExcludedAccounts"].writeList(value.excludedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationConformancePackName"].write(value.organizationConformancePackName)
        try writer["TemplateBody"].write(value.templateBody)
        try writer["TemplateS3Uri"].write(value.templateS3Uri)
    }
}

extension PutRemediationConfigurationsInput {

    static func write(value: PutRemediationConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RemediationConfigurations"].writeList(value.remediationConfigurations, memberWritingClosure: ConfigClientTypes.RemediationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutRemediationExceptionsInput {

    static func write(value: PutRemediationExceptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ExpirationTime"].writeTimestamp(value.expirationTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Message"].write(value.message)
        try writer["ResourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.RemediationExceptionResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutResourceConfigInput {

    static func write(value: PutResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceName"].write(value.resourceName)
        try writer["ResourceType"].write(value.resourceType)
        try writer["SchemaVersionId"].write(value.schemaVersionId)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutRetentionConfigurationInput {

    static func write(value: PutRetentionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RetentionPeriodInDays"].write(value.retentionPeriodInDays)
    }
}

extension PutStoredQueryInput {

    static func write(value: PutStoredQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StoredQuery"].write(value.storedQuery, with: ConfigClientTypes.StoredQuery.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ConfigClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SelectAggregateResourceConfigInput {

    static func write(value: SelectAggregateResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationAggregatorName"].write(value.configurationAggregatorName)
        try writer["Expression"].write(value.expression)
        try writer["Limit"].write(value.limit)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SelectResourceConfigInput {

    static func write(value: SelectResourceConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expression"].write(value.expression)
        try writer["Limit"].write(value.limit)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension StartConfigRulesEvaluationInput {

    static func write(value: StartConfigRulesEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartConfigurationRecorderInput {

    static func write(value: StartConfigurationRecorderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorderName"].write(value.configurationRecorderName)
    }
}

extension StartRemediationExecutionInput {

    static func write(value: StartRemediationExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ResourceKeys"].writeList(value.resourceKeys, memberWritingClosure: ConfigClientTypes.ResourceKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartResourceEvaluationInput {

    static func write(value: StartResourceEvaluationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["EvaluationContext"].write(value.evaluationContext, with: ConfigClientTypes.EvaluationContext.write(value:to:))
        try writer["EvaluationMode"].write(value.evaluationMode)
        try writer["EvaluationTimeout"].write(value.evaluationTimeout)
        try writer["ResourceDetails"].write(value.resourceDetails, with: ConfigClientTypes.ResourceDetails.write(value:to:))
    }
}

extension StopConfigurationRecorderInput {

    static func write(value: StopConfigurationRecorderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationRecorderName"].write(value.configurationRecorderName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ConfigClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetAggregateResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAggregateResourceConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAggregateResourceConfigOutput()
        value.baseConfigurationItems = try reader["BaseConfigurationItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.BaseConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedResourceIdentifiers = try reader["UnprocessedResourceIdentifiers"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateResourceIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetResourceConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetResourceConfigOutput()
        value.baseConfigurationItems = try reader["baseConfigurationItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.BaseConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedResourceKeys = try reader["unprocessedResourceKeys"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ResourceKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteAggregationAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAggregationAuthorizationOutput {
        return DeleteAggregationAuthorizationOutput()
    }
}

extension DeleteConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigRuleOutput {
        return DeleteConfigRuleOutput()
    }
}

extension DeleteConfigurationAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigurationAggregatorOutput {
        return DeleteConfigurationAggregatorOutput()
    }
}

extension DeleteConfigurationRecorderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigurationRecorderOutput {
        return DeleteConfigurationRecorderOutput()
    }
}

extension DeleteConformancePackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConformancePackOutput {
        return DeleteConformancePackOutput()
    }
}

extension DeleteDeliveryChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeliveryChannelOutput {
        return DeleteDeliveryChannelOutput()
    }
}

extension DeleteEvaluationResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEvaluationResultsOutput {
        return DeleteEvaluationResultsOutput()
    }
}

extension DeleteOrganizationConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOrganizationConfigRuleOutput {
        return DeleteOrganizationConfigRuleOutput()
    }
}

extension DeleteOrganizationConformancePackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOrganizationConformancePackOutput {
        return DeleteOrganizationConformancePackOutput()
    }
}

extension DeletePendingAggregationRequestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePendingAggregationRequestOutput {
        return DeletePendingAggregationRequestOutput()
    }
}

extension DeleteRemediationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRemediationConfigurationOutput {
        return DeleteRemediationConfigurationOutput()
    }
}

extension DeleteRemediationExceptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRemediationExceptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRemediationExceptionsOutput()
        value.failedBatches = try reader["FailedBatches"].readListIfPresent(memberReadingClosure: ConfigClientTypes.FailedDeleteRemediationExceptionsBatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceConfigOutput {
        return DeleteResourceConfigOutput()
    }
}

extension DeleteRetentionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRetentionConfigurationOutput {
        return DeleteRetentionConfigurationOutput()
    }
}

extension DeleteStoredQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStoredQueryOutput {
        return DeleteStoredQueryOutput()
    }
}

extension DeliverConfigSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeliverConfigSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeliverConfigSnapshotOutput()
        value.configSnapshotId = try reader["configSnapshotId"].readIfPresent()
        return value
    }
}

extension DescribeAggregateComplianceByConfigRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAggregateComplianceByConfigRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAggregateComplianceByConfigRulesOutput()
        value.aggregateComplianceByConfigRules = try reader["AggregateComplianceByConfigRules"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateComplianceByConfigRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAggregateComplianceByConformancePacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAggregateComplianceByConformancePacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAggregateComplianceByConformancePacksOutput()
        value.aggregateComplianceByConformancePacks = try reader["AggregateComplianceByConformancePacks"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateComplianceByConformancePack.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAggregationAuthorizationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAggregationAuthorizationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAggregationAuthorizationsOutput()
        value.aggregationAuthorizations = try reader["AggregationAuthorizations"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregationAuthorization.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeComplianceByConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComplianceByConfigRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComplianceByConfigRuleOutput()
        value.complianceByConfigRules = try reader["ComplianceByConfigRules"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ComplianceByConfigRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeComplianceByResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeComplianceByResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeComplianceByResourceOutput()
        value.complianceByResources = try reader["ComplianceByResources"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ComplianceByResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigRuleEvaluationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigRuleEvaluationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigRuleEvaluationStatusOutput()
        value.configRulesEvaluationStatus = try reader["ConfigRulesEvaluationStatus"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigRuleEvaluationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigRulesOutput()
        value.configRules = try reader["ConfigRules"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigurationAggregatorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationAggregatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationAggregatorsOutput()
        value.configurationAggregators = try reader["ConfigurationAggregators"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigurationAggregator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigurationAggregatorSourcesStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationAggregatorSourcesStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationAggregatorSourcesStatusOutput()
        value.aggregatedSourceStatusList = try reader["AggregatedSourceStatusList"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregatedSourceStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigurationRecordersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationRecordersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationRecordersOutput()
        value.configurationRecorders = try reader["ConfigurationRecorders"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigurationRecorder.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeConfigurationRecorderStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationRecorderStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationRecorderStatusOutput()
        value.configurationRecordersStatus = try reader["ConfigurationRecordersStatus"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigurationRecorderStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeConformancePackComplianceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConformancePackComplianceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConformancePackComplianceOutput()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.conformancePackRuleComplianceList = try reader["ConformancePackRuleComplianceList"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackRuleCompliance.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConformancePacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConformancePacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConformancePacksOutput()
        value.conformancePackDetails = try reader["ConformancePackDetails"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConformancePackStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConformancePackStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConformancePackStatusOutput()
        value.conformancePackStatusDetails = try reader["ConformancePackStatusDetails"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeDeliveryChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeliveryChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeliveryChannelsOutput()
        value.deliveryChannels = try reader["DeliveryChannels"].readListIfPresent(memberReadingClosure: ConfigClientTypes.DeliveryChannel.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeDeliveryChannelStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeliveryChannelStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeliveryChannelStatusOutput()
        value.deliveryChannelsStatus = try reader["DeliveryChannelsStatus"].readListIfPresent(memberReadingClosure: ConfigClientTypes.DeliveryChannelStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOrganizationConfigRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConfigRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConfigRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConfigRules = try reader["OrganizationConfigRules"].readListIfPresent(memberReadingClosure: ConfigClientTypes.OrganizationConfigRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOrganizationConfigRuleStatusesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConfigRuleStatusesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConfigRuleStatusesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConfigRuleStatuses = try reader["OrganizationConfigRuleStatuses"].readListIfPresent(memberReadingClosure: ConfigClientTypes.OrganizationConfigRuleStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOrganizationConformancePacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConformancePacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConformancePacksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConformancePacks = try reader["OrganizationConformancePacks"].readListIfPresent(memberReadingClosure: ConfigClientTypes.OrganizationConformancePack.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOrganizationConformancePackStatusesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConformancePackStatusesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConformancePackStatusesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConformancePackStatuses = try reader["OrganizationConformancePackStatuses"].readListIfPresent(memberReadingClosure: ConfigClientTypes.OrganizationConformancePackStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePendingAggregationRequestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePendingAggregationRequestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePendingAggregationRequestsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pendingAggregationRequests = try reader["PendingAggregationRequests"].readListIfPresent(memberReadingClosure: ConfigClientTypes.PendingAggregationRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRemediationConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRemediationConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRemediationConfigurationsOutput()
        value.remediationConfigurations = try reader["RemediationConfigurations"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRemediationExceptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRemediationExceptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRemediationExceptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.remediationExceptions = try reader["RemediationExceptions"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationException.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRemediationExecutionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRemediationExecutionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRemediationExecutionStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.remediationExecutionStatuses = try reader["RemediationExecutionStatuses"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationExecutionStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRetentionConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRetentionConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRetentionConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.retentionConfigurations = try reader["RetentionConfigurations"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RetentionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAggregateComplianceDetailsByConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAggregateComplianceDetailsByConfigRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAggregateComplianceDetailsByConfigRuleOutput()
        value.aggregateEvaluationResults = try reader["AggregateEvaluationResults"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateEvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetAggregateConfigRuleComplianceSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAggregateConfigRuleComplianceSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAggregateConfigRuleComplianceSummaryOutput()
        value.aggregateComplianceCounts = try reader["AggregateComplianceCounts"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateComplianceCount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupByKey = try reader["GroupByKey"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetAggregateConformancePackComplianceSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAggregateConformancePackComplianceSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAggregateConformancePackComplianceSummaryOutput()
        value.aggregateConformancePackComplianceSummaries = try reader["AggregateConformancePackComplianceSummaries"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateConformancePackComplianceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupByKey = try reader["GroupByKey"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetAggregateDiscoveredResourceCountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAggregateDiscoveredResourceCountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAggregateDiscoveredResourceCountsOutput()
        value.groupByKey = try reader["GroupByKey"].readIfPresent()
        value.groupedResourceCounts = try reader["GroupedResourceCounts"].readListIfPresent(memberReadingClosure: ConfigClientTypes.GroupedResourceCount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.totalDiscoveredResources = try reader["TotalDiscoveredResources"].readIfPresent() ?? 0
        return value
    }
}

extension GetAggregateResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAggregateResourceConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAggregateResourceConfigOutput()
        value.configurationItem = try reader["ConfigurationItem"].readIfPresent(with: ConfigClientTypes.ConfigurationItem.read(from:))
        return value
    }
}

extension GetComplianceDetailsByConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComplianceDetailsByConfigRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComplianceDetailsByConfigRuleOutput()
        value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: ConfigClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetComplianceDetailsByResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComplianceDetailsByResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComplianceDetailsByResourceOutput()
        value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: ConfigClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetComplianceSummaryByConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComplianceSummaryByConfigRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComplianceSummaryByConfigRuleOutput()
        value.complianceSummary = try reader["ComplianceSummary"].readIfPresent(with: ConfigClientTypes.ComplianceSummary.read(from:))
        return value
    }
}

extension GetComplianceSummaryByResourceTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComplianceSummaryByResourceTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComplianceSummaryByResourceTypeOutput()
        value.complianceSummariesByResourceType = try reader["ComplianceSummariesByResourceType"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ComplianceSummaryByResourceType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetConformancePackComplianceDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConformancePackComplianceDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConformancePackComplianceDetailsOutput()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.conformancePackRuleEvaluationResults = try reader["ConformancePackRuleEvaluationResults"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackEvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetConformancePackComplianceSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConformancePackComplianceSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConformancePackComplianceSummaryOutput()
        value.conformancePackComplianceSummaryList = try reader["ConformancePackComplianceSummaryList"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackComplianceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetCustomRulePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomRulePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomRulePolicyOutput()
        value.policyText = try reader["PolicyText"].readIfPresent()
        return value
    }
}

extension GetDiscoveredResourceCountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDiscoveredResourceCountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDiscoveredResourceCountsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resourceCounts = try reader["resourceCounts"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ResourceCount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalDiscoveredResources = try reader["totalDiscoveredResources"].readIfPresent() ?? 0
        return value
    }
}

extension GetOrganizationConfigRuleDetailedStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrganizationConfigRuleDetailedStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrganizationConfigRuleDetailedStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConfigRuleDetailedStatus = try reader["OrganizationConfigRuleDetailedStatus"].readListIfPresent(memberReadingClosure: ConfigClientTypes.MemberAccountStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetOrganizationConformancePackDetailedStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrganizationConformancePackDetailedStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrganizationConformancePackDetailedStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationConformancePackDetailedStatuses = try reader["OrganizationConformancePackDetailedStatuses"].readListIfPresent(memberReadingClosure: ConfigClientTypes.OrganizationConformancePackDetailedStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetOrganizationCustomRulePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOrganizationCustomRulePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrganizationCustomRulePolicyOutput()
        value.policyText = try reader["PolicyText"].readIfPresent()
        return value
    }
}

extension GetResourceConfigHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceConfigHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceConfigHistoryOutput()
        value.configurationItems = try reader["configurationItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConfigurationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetResourceEvaluationSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceEvaluationSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceEvaluationSummaryOutput()
        value.compliance = try reader["Compliance"].readIfPresent()
        value.evaluationContext = try reader["EvaluationContext"].readIfPresent(with: ConfigClientTypes.EvaluationContext.read(from:))
        value.evaluationMode = try reader["EvaluationMode"].readIfPresent()
        value.evaluationStartTimestamp = try reader["EvaluationStartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.evaluationStatus = try reader["EvaluationStatus"].readIfPresent(with: ConfigClientTypes.EvaluationStatus.read(from:))
        value.resourceDetails = try reader["ResourceDetails"].readIfPresent(with: ConfigClientTypes.ResourceDetails.read(from:))
        value.resourceEvaluationId = try reader["ResourceEvaluationId"].readIfPresent()
        return value
    }
}

extension GetStoredQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStoredQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStoredQueryOutput()
        value.storedQuery = try reader["StoredQuery"].readIfPresent(with: ConfigClientTypes.StoredQuery.read(from:))
        return value
    }
}

extension ListAggregateDiscoveredResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAggregateDiscoveredResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAggregateDiscoveredResourcesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceIdentifiers = try reader["ResourceIdentifiers"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AggregateResourceIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListConformancePackComplianceScoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConformancePackComplianceScoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConformancePackComplianceScoresOutput()
        value.conformancePackComplianceScores = try reader["ConformancePackComplianceScores"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackComplianceScore.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDiscoveredResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDiscoveredResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDiscoveredResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resourceIdentifiers = try reader["resourceIdentifiers"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ResourceIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceEvaluationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceEvaluationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceEvaluationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceEvaluations = try reader["ResourceEvaluations"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ResourceEvaluation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStoredQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStoredQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStoredQueriesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.storedQueryMetadata = try reader["StoredQueryMetadata"].readListIfPresent(memberReadingClosure: ConfigClientTypes.StoredQueryMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ConfigClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutAggregationAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAggregationAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAggregationAuthorizationOutput()
        value.aggregationAuthorization = try reader["AggregationAuthorization"].readIfPresent(with: ConfigClientTypes.AggregationAuthorization.read(from:))
        return value
    }
}

extension PutConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutConfigRuleOutput {
        return PutConfigRuleOutput()
    }
}

extension PutConfigurationAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutConfigurationAggregatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutConfigurationAggregatorOutput()
        value.configurationAggregator = try reader["ConfigurationAggregator"].readIfPresent(with: ConfigClientTypes.ConfigurationAggregator.read(from:))
        return value
    }
}

extension PutConfigurationRecorderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutConfigurationRecorderOutput {
        return PutConfigurationRecorderOutput()
    }
}

extension PutConformancePackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutConformancePackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutConformancePackOutput()
        value.conformancePackArn = try reader["ConformancePackArn"].readIfPresent()
        return value
    }
}

extension PutDeliveryChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDeliveryChannelOutput {
        return PutDeliveryChannelOutput()
    }
}

extension PutEvaluationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEvaluationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEvaluationsOutput()
        value.failedEvaluations = try reader["FailedEvaluations"].readListIfPresent(memberReadingClosure: ConfigClientTypes.Evaluation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutExternalEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutExternalEvaluationOutput {
        return PutExternalEvaluationOutput()
    }
}

extension PutOrganizationConfigRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutOrganizationConfigRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutOrganizationConfigRuleOutput()
        value.organizationConfigRuleArn = try reader["OrganizationConfigRuleArn"].readIfPresent()
        return value
    }
}

extension PutOrganizationConformancePackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutOrganizationConformancePackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutOrganizationConformancePackOutput()
        value.organizationConformancePackArn = try reader["OrganizationConformancePackArn"].readIfPresent()
        return value
    }
}

extension PutRemediationConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRemediationConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRemediationConfigurationsOutput()
        value.failedBatches = try reader["FailedBatches"].readListIfPresent(memberReadingClosure: ConfigClientTypes.FailedRemediationBatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutRemediationExceptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRemediationExceptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRemediationExceptionsOutput()
        value.failedBatches = try reader["FailedBatches"].readListIfPresent(memberReadingClosure: ConfigClientTypes.FailedRemediationExceptionBatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourceConfigOutput {
        return PutResourceConfigOutput()
    }
}

extension PutRetentionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRetentionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRetentionConfigurationOutput()
        value.retentionConfiguration = try reader["RetentionConfiguration"].readIfPresent(with: ConfigClientTypes.RetentionConfiguration.read(from:))
        return value
    }
}

extension PutStoredQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutStoredQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutStoredQueryOutput()
        value.queryArn = try reader["QueryArn"].readIfPresent()
        return value
    }
}

extension SelectAggregateResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SelectAggregateResourceConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SelectAggregateResourceConfigOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queryInfo = try reader["QueryInfo"].readIfPresent(with: ConfigClientTypes.QueryInfo.read(from:))
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SelectResourceConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SelectResourceConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SelectResourceConfigOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queryInfo = try reader["QueryInfo"].readIfPresent(with: ConfigClientTypes.QueryInfo.read(from:))
        value.results = try reader["Results"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartConfigRulesEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartConfigRulesEvaluationOutput {
        return StartConfigRulesEvaluationOutput()
    }
}

extension StartConfigurationRecorderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartConfigurationRecorderOutput {
        return StartConfigurationRecorderOutput()
    }
}

extension StartRemediationExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRemediationExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRemediationExecutionOutput()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ResourceKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        return value
    }
}

extension StartResourceEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartResourceEvaluationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartResourceEvaluationOutput()
        value.resourceEvaluationId = try reader["ResourceEvaluationId"].readIfPresent()
        return value
    }
}

extension StopConfigurationRecorderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopConfigurationRecorderOutput {
        return StopConfigurationRecorderOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum BatchGetAggregateResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAggregationAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigurationAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigurationRecorderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationRecorderException": return try NoSuchConfigurationRecorderException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConformancePackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConformancePackException": return try NoSuchConformancePackException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeliveryChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LastDeliveryChannelDeleteFailedException": return try LastDeliveryChannelDeleteFailedException.makeError(baseError: baseError)
            case "NoSuchDeliveryChannelException": return try NoSuchDeliveryChannelException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEvaluationResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOrganizationConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchOrganizationConfigRuleException": return try NoSuchOrganizationConfigRuleException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOrganizationConformancePackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchOrganizationConformancePackException": return try NoSuchOrganizationConformancePackException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePendingAggregationRequestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRemediationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchRemediationConfigurationException": return try NoSuchRemediationConfigurationException.makeError(baseError: baseError)
            case "RemediationInProgressException": return try RemediationInProgressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRemediationExceptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchRemediationExceptionException": return try NoSuchRemediationExceptionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoRunningConfigurationRecorderException": return try NoRunningConfigurationRecorderException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRetentionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchRetentionConfigurationException": return try NoSuchRetentionConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStoredQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeliverConfigSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "NoRunningConfigurationRecorderException": return try NoRunningConfigurationRecorderException.makeError(baseError: baseError)
            case "NoSuchDeliveryChannelException": return try NoSuchDeliveryChannelException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAggregateComplianceByConfigRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAggregateComplianceByConformancePacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAggregationAuthorizationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComplianceByConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeComplianceByResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigRuleEvaluationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationAggregatorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationAggregatorSourcesStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationRecordersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationRecorderException": return try NoSuchConfigurationRecorderException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationRecorderStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationRecorderException": return try NoSuchConfigurationRecorderException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConformancePackComplianceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleInConformancePackException": return try NoSuchConfigRuleInConformancePackException.makeError(baseError: baseError)
            case "NoSuchConformancePackException": return try NoSuchConformancePackException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConformancePacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConformancePackException": return try NoSuchConformancePackException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConformancePackStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeliveryChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchDeliveryChannelException": return try NoSuchDeliveryChannelException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeliveryChannelStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchDeliveryChannelException": return try NoSuchDeliveryChannelException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConfigRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConfigRuleException": return try NoSuchOrganizationConfigRuleException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConfigRuleStatusesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConfigRuleException": return try NoSuchOrganizationConfigRuleException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConformancePacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConformancePackException": return try NoSuchOrganizationConformancePackException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConformancePackStatusesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConformancePackException": return try NoSuchOrganizationConformancePackException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePendingAggregationRequestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRemediationConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRemediationExceptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRemediationExecutionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchRemediationConfigurationException": return try NoSuchRemediationConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRetentionConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchRetentionConfigurationException": return try NoSuchRetentionConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAggregateComplianceDetailsByConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAggregateConfigRuleComplianceSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAggregateConformancePackComplianceSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAggregateDiscoveredResourceCountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAggregateResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "OversizedConfigurationItemException": return try OversizedConfigurationItemException.makeError(baseError: baseError)
            case "ResourceNotDiscoveredException": return try ResourceNotDiscoveredException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComplianceDetailsByConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComplianceDetailsByResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComplianceSummaryByConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComplianceSummaryByResourceTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConformancePackComplianceDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleInConformancePackException": return try NoSuchConfigRuleInConformancePackException.makeError(baseError: baseError)
            case "NoSuchConformancePackException": return try NoSuchConformancePackException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConformancePackComplianceSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConformancePackException": return try NoSuchConformancePackException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomRulePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDiscoveredResourceCountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrganizationConfigRuleDetailedStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConfigRuleException": return try NoSuchOrganizationConfigRuleException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrganizationConformancePackDetailedStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchOrganizationConformancePackException": return try NoSuchOrganizationConformancePackException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOrganizationCustomRulePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchOrganizationConfigRuleException": return try NoSuchOrganizationConfigRuleException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceConfigHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidTimeRangeException": return try InvalidTimeRangeException.makeError(baseError: baseError)
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "ResourceNotDiscoveredException": return try ResourceNotDiscoveredException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceEvaluationSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStoredQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAggregateDiscoveredResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConformancePackComplianceScoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDiscoveredResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceEvaluationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidTimeRangeException": return try InvalidTimeRangeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStoredQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAggregationAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MaxNumberOfConfigRulesExceededException": return try MaxNumberOfConfigRulesExceededException.makeError(baseError: baseError)
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutConfigurationAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            case "OrganizationAllFeaturesNotEnabledException": return try OrganizationAllFeaturesNotEnabledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutConfigurationRecorderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidConfigurationRecorderNameException": return try InvalidConfigurationRecorderNameException.makeError(baseError: baseError)
            case "InvalidRecordingGroupException": return try InvalidRecordingGroupException.makeError(baseError: baseError)
            case "InvalidRoleException": return try InvalidRoleException.makeError(baseError: baseError)
            case "MaxNumberOfConfigurationRecordersExceededException": return try MaxNumberOfConfigurationRecordersExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutConformancePackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConformancePackTemplateValidationException": return try ConformancePackTemplateValidationException.makeError(baseError: baseError)
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MaxNumberOfConformancePacksExceededException": return try MaxNumberOfConformancePacksExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDeliveryChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientDeliveryPolicyException": return try InsufficientDeliveryPolicyException.makeError(baseError: baseError)
            case "InvalidDeliveryChannelNameException": return try InvalidDeliveryChannelNameException.makeError(baseError: baseError)
            case "InvalidS3KeyPrefixException": return try InvalidS3KeyPrefixException.makeError(baseError: baseError)
            case "InvalidS3KmsKeyArnException": return try InvalidS3KmsKeyArnException.makeError(baseError: baseError)
            case "InvalidSNSTopicARNException": return try InvalidSNSTopicARNException.makeError(baseError: baseError)
            case "MaxNumberOfDeliveryChannelsExceededException": return try MaxNumberOfDeliveryChannelsExceededException.makeError(baseError: baseError)
            case "NoAvailableConfigurationRecorderException": return try NoAvailableConfigurationRecorderException.makeError(baseError: baseError)
            case "NoSuchBucketException": return try NoSuchBucketException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEvaluationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidResultTokenException": return try InvalidResultTokenException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutExternalEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutOrganizationConfigRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MaxNumberOfOrganizationConfigRulesExceededException": return try MaxNumberOfOrganizationConfigRulesExceededException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            case "OrganizationAllFeaturesNotEnabledException": return try OrganizationAllFeaturesNotEnabledException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutOrganizationConformancePackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "MaxNumberOfOrganizationConformancePacksExceededException": return try MaxNumberOfOrganizationConformancePacksExceededException.makeError(baseError: baseError)
            case "NoAvailableOrganizationException": return try NoAvailableOrganizationException.makeError(baseError: baseError)
            case "OrganizationAccessDeniedException": return try OrganizationAccessDeniedException.makeError(baseError: baseError)
            case "OrganizationAllFeaturesNotEnabledException": return try OrganizationAllFeaturesNotEnabledException.makeError(baseError: baseError)
            case "OrganizationConformancePackTemplateValidationException": return try OrganizationConformancePackTemplateValidationException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRemediationConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRemediationExceptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "MaxActiveResourcesExceededException": return try MaxActiveResourcesExceededException.makeError(baseError: baseError)
            case "NoRunningConfigurationRecorderException": return try NoRunningConfigurationRecorderException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRetentionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "MaxNumberOfRetentionConfigurationsExceededException": return try MaxNumberOfRetentionConfigurationsExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutStoredQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceConcurrentModificationException": return try ResourceConcurrentModificationException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SelectAggregateResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidExpressionException": return try InvalidExpressionException.makeError(baseError: baseError)
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "NoSuchConfigurationAggregatorException": return try NoSuchConfigurationAggregatorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SelectResourceConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidExpressionException": return try InvalidExpressionException.makeError(baseError: baseError)
            case "InvalidLimitException": return try InvalidLimitException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartConfigRulesEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NoSuchConfigRuleException": return try NoSuchConfigRuleException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartConfigurationRecorderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoAvailableDeliveryChannelException": return try NoAvailableDeliveryChannelException.makeError(baseError: baseError)
            case "NoSuchConfigurationRecorderException": return try NoSuchConfigurationRecorderException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRemediationExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InsufficientPermissionsException": return try InsufficientPermissionsException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "NoSuchRemediationConfigurationException": return try NoSuchRemediationConfigurationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartResourceEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IdempotentParameterMismatch": return try IdempotentParameterMismatch.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopConfigurationRecorderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "NoSuchConfigurationRecorderException": return try NoSuchConfigurationRecorderException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchConfigurationAggregatorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchConfigurationAggregatorException {
        let reader = baseError.errorBodyReader
        var value = NoSuchConfigurationAggregatorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAvailableConfigurationRecorderException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAvailableConfigurationRecorderException {
        let reader = baseError.errorBodyReader
        var value = NoAvailableConfigurationRecorderException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchConfigRuleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchConfigRuleException {
        let reader = baseError.errorBodyReader
        var value = NoSuchConfigRuleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchConfigurationRecorderException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchConfigurationRecorderException {
        let reader = baseError.errorBodyReader
        var value = NoSuchConfigurationRecorderException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchConformancePackException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchConformancePackException {
        let reader = baseError.errorBodyReader
        var value = NoSuchConformancePackException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchDeliveryChannelException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchDeliveryChannelException {
        let reader = baseError.errorBodyReader
        var value = NoSuchDeliveryChannelException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LastDeliveryChannelDeleteFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LastDeliveryChannelDeleteFailedException {
        let reader = baseError.errorBodyReader
        var value = LastDeliveryChannelDeleteFailedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = OrganizationAccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchOrganizationConfigRuleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchOrganizationConfigRuleException {
        let reader = baseError.errorBodyReader
        var value = NoSuchOrganizationConfigRuleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchOrganizationConformancePackException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchOrganizationConformancePackException {
        let reader = baseError.errorBodyReader
        var value = NoSuchOrganizationConformancePackException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientPermissionsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientPermissionsException {
        let reader = baseError.errorBodyReader
        var value = InsufficientPermissionsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RemediationInProgressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RemediationInProgressException {
        let reader = baseError.errorBodyReader
        var value = RemediationInProgressException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchRemediationConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchRemediationConfigurationException {
        let reader = baseError.errorBodyReader
        var value = NoSuchRemediationConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchRemediationExceptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchRemediationExceptionException {
        let reader = baseError.errorBodyReader
        var value = NoSuchRemediationExceptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoRunningConfigurationRecorderException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoRunningConfigurationRecorderException {
        let reader = baseError.errorBodyReader
        var value = NoRunningConfigurationRecorderException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchRetentionConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchRetentionConfigurationException {
        let reader = baseError.errorBodyReader
        var value = NoSuchRetentionConfigurationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidLimitException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidLimitException {
        let reader = baseError.errorBodyReader
        var value = InvalidLimitException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchConfigRuleInConformancePackException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchConfigRuleInConformancePackException {
        let reader = baseError.errorBodyReader
        var value = NoSuchConfigRuleInConformancePackException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OversizedConfigurationItemException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OversizedConfigurationItemException {
        let reader = baseError.errorBodyReader
        var value = OversizedConfigurationItemException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotDiscoveredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotDiscoveredException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotDiscoveredException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTimeRangeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTimeRangeException {
        let reader = baseError.errorBodyReader
        var value = InvalidTimeRangeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfConfigRulesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfConfigRulesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfConfigRulesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRoleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRoleException {
        let reader = baseError.errorBodyReader
        var value = InvalidRoleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAvailableOrganizationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAvailableOrganizationException {
        let reader = baseError.errorBodyReader
        var value = NoAvailableOrganizationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationAllFeaturesNotEnabledException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationAllFeaturesNotEnabledException {
        let reader = baseError.errorBodyReader
        var value = OrganizationAllFeaturesNotEnabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRecordingGroupException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRecordingGroupException {
        let reader = baseError.errorBodyReader
        var value = InvalidRecordingGroupException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConfigurationRecorderNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidConfigurationRecorderNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidConfigurationRecorderNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfConfigurationRecordersExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfConfigurationRecordersExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfConfigurationRecordersExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfConformancePacksExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfConformancePacksExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfConformancePacksExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConformancePackTemplateValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConformancePackTemplateValidationException {
        let reader = baseError.errorBodyReader
        var value = ConformancePackTemplateValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidS3KmsKeyArnException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidS3KmsKeyArnException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3KmsKeyArnException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSNSTopicARNException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSNSTopicARNException {
        let reader = baseError.errorBodyReader
        var value = InvalidSNSTopicARNException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientDeliveryPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientDeliveryPolicyException {
        let reader = baseError.errorBodyReader
        var value = InsufficientDeliveryPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDeliveryChannelNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDeliveryChannelNameException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeliveryChannelNameException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoSuchBucketException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoSuchBucketException {
        let reader = baseError.errorBodyReader
        var value = NoSuchBucketException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfDeliveryChannelsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfDeliveryChannelsExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfDeliveryChannelsExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidS3KeyPrefixException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidS3KeyPrefixException {
        let reader = baseError.errorBodyReader
        var value = InvalidS3KeyPrefixException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResultTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResultTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidResultTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfOrganizationConfigRulesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfOrganizationConfigRulesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfOrganizationConfigRulesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationConformancePackTemplateValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationConformancePackTemplateValidationException {
        let reader = baseError.errorBodyReader
        var value = OrganizationConformancePackTemplateValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfOrganizationConformancePacksExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfOrganizationConformancePacksExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfOrganizationConformancePacksExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxActiveResourcesExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxActiveResourcesExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxActiveResourcesExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MaxNumberOfRetentionConfigurationsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MaxNumberOfRetentionConfigurationsExceededException {
        let reader = baseError.errorBodyReader
        var value = MaxNumberOfRetentionConfigurationsExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ResourceConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidExpressionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidExpressionException {
        let reader = baseError.errorBodyReader
        var value = InvalidExpressionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAvailableDeliveryChannelException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAvailableDeliveryChannelException {
        let reader = baseError.errorBodyReader
        var value = NoAvailableDeliveryChannelException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotentParameterMismatch {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotentParameterMismatch {
        let reader = baseError.errorBodyReader
        var value = IdempotentParameterMismatch()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConfigClientTypes.BaseConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.BaseConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.BaseConfigurationItem()
        value.version = try reader["version"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.configurationItemCaptureTime = try reader["configurationItemCaptureTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configurationItemStatus = try reader["configurationItemStatus"].readIfPresent()
        value.configurationStateId = try reader["configurationStateId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceName = try reader["resourceName"].readIfPresent()
        value.awsRegion = try reader["awsRegion"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.resourceCreationTime = try reader["resourceCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configuration = try reader["configuration"].readIfPresent()
        value.supplementaryConfiguration = try reader["supplementaryConfiguration"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recordingFrequency = try reader["recordingFrequency"].readIfPresent()
        value.configurationItemDeliveryTime = try reader["configurationItemDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.AggregateResourceIdentifier {

    static func write(value: ConfigClientTypes.AggregateResourceIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceName"].write(value.resourceName)
        try writer["ResourceType"].write(value.resourceType)
        try writer["SourceAccountId"].write(value.sourceAccountId)
        try writer["SourceRegion"].write(value.sourceRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateResourceIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateResourceIdentifier()
        value.sourceAccountId = try reader["SourceAccountId"].readIfPresent() ?? ""
        value.sourceRegion = try reader["SourceRegion"].readIfPresent() ?? ""
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceName = try reader["ResourceName"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ResourceKey {

    static func write(value: ConfigClientTypes.ResourceKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceId"].write(value.resourceId)
        try writer["resourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceKey()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        return value
    }
}

extension ConfigClientTypes.FailedDeleteRemediationExceptionsBatch {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.FailedDeleteRemediationExceptionsBatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.FailedDeleteRemediationExceptionsBatch()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationExceptionResourceKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.RemediationExceptionResourceKey {

    static func write(value: ConfigClientTypes.RemediationExceptionResourceKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationExceptionResourceKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationExceptionResourceKey()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.AggregateComplianceByConfigRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateComplianceByConfigRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateComplianceByConfigRule()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.compliance = try reader["Compliance"].readIfPresent(with: ConfigClientTypes.Compliance.read(from:))
        value.accountId = try reader["AccountId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.Compliance {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Compliance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Compliance()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.complianceContributorCount = try reader["ComplianceContributorCount"].readIfPresent(with: ConfigClientTypes.ComplianceContributorCount.read(from:))
        return value
    }
}

extension ConfigClientTypes.ComplianceContributorCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ComplianceContributorCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ComplianceContributorCount()
        value.cappedCount = try reader["CappedCount"].readIfPresent() ?? 0
        value.capExceeded = try reader["CapExceeded"].readIfPresent() ?? false
        return value
    }
}

extension ConfigClientTypes.AggregateComplianceByConformancePack {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateComplianceByConformancePack {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateComplianceByConformancePack()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent()
        value.compliance = try reader["Compliance"].readIfPresent(with: ConfigClientTypes.AggregateConformancePackCompliance.read(from:))
        value.accountId = try reader["AccountId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.AggregateConformancePackCompliance {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateConformancePackCompliance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateConformancePackCompliance()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.compliantRuleCount = try reader["CompliantRuleCount"].readIfPresent() ?? 0
        value.nonCompliantRuleCount = try reader["NonCompliantRuleCount"].readIfPresent() ?? 0
        value.totalRuleCount = try reader["TotalRuleCount"].readIfPresent() ?? 0
        return value
    }
}

extension ConfigClientTypes.AggregationAuthorization {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregationAuthorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregationAuthorization()
        value.aggregationAuthorizationArn = try reader["AggregationAuthorizationArn"].readIfPresent()
        value.authorizedAccountId = try reader["AuthorizedAccountId"].readIfPresent()
        value.authorizedAwsRegion = try reader["AuthorizedAwsRegion"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ComplianceByConfigRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ComplianceByConfigRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ComplianceByConfigRule()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.compliance = try reader["Compliance"].readIfPresent(with: ConfigClientTypes.Compliance.read(from:))
        return value
    }
}

extension ConfigClientTypes.ComplianceByResource {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ComplianceByResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ComplianceByResource()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.compliance = try reader["Compliance"].readIfPresent(with: ConfigClientTypes.Compliance.read(from:))
        return value
    }
}

extension ConfigClientTypes.ConfigRuleEvaluationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigRuleEvaluationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigRuleEvaluationStatus()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.configRuleArn = try reader["ConfigRuleArn"].readIfPresent()
        value.configRuleId = try reader["ConfigRuleId"].readIfPresent()
        value.lastSuccessfulInvocationTime = try reader["LastSuccessfulInvocationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastFailedInvocationTime = try reader["LastFailedInvocationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulEvaluationTime = try reader["LastSuccessfulEvaluationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastFailedEvaluationTime = try reader["LastFailedEvaluationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstActivatedTime = try reader["FirstActivatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastDeactivatedTime = try reader["LastDeactivatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastErrorCode = try reader["LastErrorCode"].readIfPresent()
        value.lastErrorMessage = try reader["LastErrorMessage"].readIfPresent()
        value.firstEvaluationStarted = try reader["FirstEvaluationStarted"].readIfPresent() ?? false
        value.lastDebugLogDeliveryStatus = try reader["LastDebugLogDeliveryStatus"].readIfPresent()
        value.lastDebugLogDeliveryStatusReason = try reader["LastDebugLogDeliveryStatusReason"].readIfPresent()
        value.lastDebugLogDeliveryTime = try reader["LastDebugLogDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ConfigRule {

    static func write(value: ConfigClientTypes.ConfigRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigRuleArn"].write(value.configRuleArn)
        try writer["ConfigRuleId"].write(value.configRuleId)
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["ConfigRuleState"].write(value.configRuleState)
        try writer["CreatedBy"].write(value.createdBy)
        try writer["Description"].write(value.description)
        try writer["EvaluationModes"].writeList(value.evaluationModes, memberWritingClosure: ConfigClientTypes.EvaluationModeConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InputParameters"].write(value.inputParameters)
        try writer["MaximumExecutionFrequency"].write(value.maximumExecutionFrequency)
        try writer["Scope"].write(value.scope, with: ConfigClientTypes.Scope.write(value:to:))
        try writer["Source"].write(value.source, with: ConfigClientTypes.Source.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigRule()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.configRuleArn = try reader["ConfigRuleArn"].readIfPresent()
        value.configRuleId = try reader["ConfigRuleId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.scope = try reader["Scope"].readIfPresent(with: ConfigClientTypes.Scope.read(from:))
        value.source = try reader["Source"].readIfPresent(with: ConfigClientTypes.Source.read(from:))
        value.inputParameters = try reader["InputParameters"].readIfPresent()
        value.maximumExecutionFrequency = try reader["MaximumExecutionFrequency"].readIfPresent()
        value.configRuleState = try reader["ConfigRuleState"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.evaluationModes = try reader["EvaluationModes"].readListIfPresent(memberReadingClosure: ConfigClientTypes.EvaluationModeConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.EvaluationModeConfiguration {

    static func write(value: ConfigClientTypes.EvaluationModeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationModeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationModeConfiguration()
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.Source {

    static func write(value: ConfigClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomPolicyDetails"].write(value.customPolicyDetails, with: ConfigClientTypes.CustomPolicyDetails.write(value:to:))
        try writer["Owner"].write(value.owner)
        try writer["SourceDetails"].writeList(value.sourceDetails, memberWritingClosure: ConfigClientTypes.SourceDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceIdentifier"].write(value.sourceIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Source()
        value.owner = try reader["Owner"].readIfPresent() ?? .sdkUnknown("")
        value.sourceIdentifier = try reader["SourceIdentifier"].readIfPresent()
        value.sourceDetails = try reader["SourceDetails"].readListIfPresent(memberReadingClosure: ConfigClientTypes.SourceDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customPolicyDetails = try reader["CustomPolicyDetails"].readIfPresent(with: ConfigClientTypes.CustomPolicyDetails.read(from:))
        return value
    }
}

extension ConfigClientTypes.CustomPolicyDetails {

    static func write(value: ConfigClientTypes.CustomPolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableDebugLogDelivery"].write(value.enableDebugLogDelivery)
        try writer["PolicyRuntime"].write(value.policyRuntime)
        try writer["PolicyText"].write(value.policyText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.CustomPolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.CustomPolicyDetails()
        value.policyRuntime = try reader["PolicyRuntime"].readIfPresent() ?? ""
        value.policyText = try reader["PolicyText"].readIfPresent() ?? ""
        value.enableDebugLogDelivery = try reader["EnableDebugLogDelivery"].readIfPresent() ?? false
        return value
    }
}

extension ConfigClientTypes.SourceDetail {

    static func write(value: ConfigClientTypes.SourceDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventSource"].write(value.eventSource)
        try writer["MaximumExecutionFrequency"].write(value.maximumExecutionFrequency)
        try writer["MessageType"].write(value.messageType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.SourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.SourceDetail()
        value.eventSource = try reader["EventSource"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.maximumExecutionFrequency = try reader["MaximumExecutionFrequency"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.Scope {

    static func write(value: ConfigClientTypes.Scope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceResourceId"].write(value.complianceResourceId)
        try writer["ComplianceResourceTypes"].writeList(value.complianceResourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValue"].write(value.tagValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Scope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Scope()
        value.complianceResourceTypes = try reader["ComplianceResourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tagKey = try reader["TagKey"].readIfPresent()
        value.tagValue = try reader["TagValue"].readIfPresent()
        value.complianceResourceId = try reader["ComplianceResourceId"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConfigurationAggregator {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigurationAggregator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigurationAggregator()
        value.configurationAggregatorName = try reader["ConfigurationAggregatorName"].readIfPresent()
        value.configurationAggregatorArn = try reader["ConfigurationAggregatorArn"].readIfPresent()
        value.accountAggregationSources = try reader["AccountAggregationSources"].readListIfPresent(memberReadingClosure: ConfigClientTypes.AccountAggregationSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationAggregationSource = try reader["OrganizationAggregationSource"].readIfPresent(with: ConfigClientTypes.OrganizationAggregationSource.read(from:))
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.OrganizationAggregationSource {

    static func write(value: ConfigClientTypes.OrganizationAggregationSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllAwsRegions"].write(value.allAwsRegions)
        try writer["AwsRegions"].writeList(value.awsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationAggregationSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationAggregationSource()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.awsRegions = try reader["AwsRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allAwsRegions = try reader["AllAwsRegions"].readIfPresent() ?? false
        return value
    }
}

extension ConfigClientTypes.AccountAggregationSource {

    static func write(value: ConfigClientTypes.AccountAggregationSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllAwsRegions"].write(value.allAwsRegions)
        try writer["AwsRegions"].writeList(value.awsRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AccountAggregationSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AccountAggregationSource()
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allAwsRegions = try reader["AllAwsRegions"].readIfPresent() ?? false
        value.awsRegions = try reader["AwsRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.AggregatedSourceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregatedSourceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregatedSourceStatus()
        value.sourceId = try reader["SourceId"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.lastUpdateStatus = try reader["LastUpdateStatus"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastErrorCode = try reader["LastErrorCode"].readIfPresent()
        value.lastErrorMessage = try reader["LastErrorMessage"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConfigurationRecorder {

    static func write(value: ConfigClientTypes.ConfigurationRecorder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["recordingGroup"].write(value.recordingGroup, with: ConfigClientTypes.RecordingGroup.write(value:to:))
        try writer["recordingMode"].write(value.recordingMode, with: ConfigClientTypes.RecordingMode.write(value:to:))
        try writer["roleARN"].write(value.roleARN)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigurationRecorder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigurationRecorder()
        value.name = try reader["name"].readIfPresent()
        value.roleARN = try reader["roleARN"].readIfPresent()
        value.recordingGroup = try reader["recordingGroup"].readIfPresent(with: ConfigClientTypes.RecordingGroup.read(from:))
        value.recordingMode = try reader["recordingMode"].readIfPresent(with: ConfigClientTypes.RecordingMode.read(from:))
        return value
    }
}

extension ConfigClientTypes.RecordingMode {

    static func write(value: ConfigClientTypes.RecordingMode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recordingFrequency"].write(value.recordingFrequency)
        try writer["recordingModeOverrides"].writeList(value.recordingModeOverrides, memberWritingClosure: ConfigClientTypes.RecordingModeOverride.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RecordingMode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RecordingMode()
        value.recordingFrequency = try reader["recordingFrequency"].readIfPresent() ?? .sdkUnknown("")
        value.recordingModeOverrides = try reader["recordingModeOverrides"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RecordingModeOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.RecordingModeOverride {

    static func write(value: ConfigClientTypes.RecordingModeOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["recordingFrequency"].write(value.recordingFrequency)
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RecordingModeOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RecordingModeOverride()
        value.description = try reader["description"].readIfPresent()
        value.resourceTypes = try reader["resourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ConfigClientTypes.ResourceType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.recordingFrequency = try reader["recordingFrequency"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConfigClientTypes.RecordingGroup {

    static func write(value: ConfigClientTypes.RecordingGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allSupported"].write(value.allSupported)
        try writer["exclusionByResourceTypes"].write(value.exclusionByResourceTypes, with: ConfigClientTypes.ExclusionByResourceTypes.write(value:to:))
        try writer["includeGlobalResourceTypes"].write(value.includeGlobalResourceTypes)
        try writer["recordingStrategy"].write(value.recordingStrategy, with: ConfigClientTypes.RecordingStrategy.write(value:to:))
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RecordingGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RecordingGroup()
        value.allSupported = try reader["allSupported"].readIfPresent() ?? false
        value.includeGlobalResourceTypes = try reader["includeGlobalResourceTypes"].readIfPresent() ?? false
        value.resourceTypes = try reader["resourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ConfigClientTypes.ResourceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exclusionByResourceTypes = try reader["exclusionByResourceTypes"].readIfPresent(with: ConfigClientTypes.ExclusionByResourceTypes.read(from:))
        value.recordingStrategy = try reader["recordingStrategy"].readIfPresent(with: ConfigClientTypes.RecordingStrategy.read(from:))
        return value
    }
}

extension ConfigClientTypes.RecordingStrategy {

    static func write(value: ConfigClientTypes.RecordingStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["useOnly"].write(value.useOnly)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RecordingStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RecordingStrategy()
        value.useOnly = try reader["useOnly"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ExclusionByResourceTypes {

    static func write(value: ConfigClientTypes.ExclusionByResourceTypes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ExclusionByResourceTypes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ExclusionByResourceTypes()
        value.resourceTypes = try reader["resourceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ConfigClientTypes.ResourceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.ConfigurationRecorderStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigurationRecorderStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigurationRecorderStatus()
        value.name = try reader["name"].readIfPresent()
        value.lastStartTime = try reader["lastStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastStopTime = try reader["lastStopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.recording = try reader["recording"].readIfPresent() ?? false
        value.lastStatus = try reader["lastStatus"].readIfPresent()
        value.lastErrorCode = try reader["lastErrorCode"].readIfPresent()
        value.lastErrorMessage = try reader["lastErrorMessage"].readIfPresent()
        value.lastStatusChangeTime = try reader["lastStatusChangeTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ConformancePackRuleCompliance {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackRuleCompliance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackRuleCompliance()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.controls = try reader["Controls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.ConformancePackDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackDetail()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.conformancePackArn = try reader["ConformancePackArn"].readIfPresent() ?? ""
        value.conformancePackId = try reader["ConformancePackId"].readIfPresent() ?? ""
        value.deliveryS3Bucket = try reader["DeliveryS3Bucket"].readIfPresent()
        value.deliveryS3KeyPrefix = try reader["DeliveryS3KeyPrefix"].readIfPresent()
        value.conformancePackInputParameters = try reader["ConformancePackInputParameters"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackInputParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdateRequestedTime = try reader["LastUpdateRequestedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.templateSSMDocumentDetails = try reader["TemplateSSMDocumentDetails"].readIfPresent(with: ConfigClientTypes.TemplateSSMDocumentDetails.read(from:))
        return value
    }
}

extension ConfigClientTypes.TemplateSSMDocumentDetails {

    static func write(value: ConfigClientTypes.TemplateSSMDocumentDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DocumentName"].write(value.documentName)
        try writer["DocumentVersion"].write(value.documentVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.TemplateSSMDocumentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.TemplateSSMDocumentDetails()
        value.documentName = try reader["DocumentName"].readIfPresent() ?? ""
        value.documentVersion = try reader["DocumentVersion"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConformancePackInputParameter {

    static func write(value: ConfigClientTypes.ConformancePackInputParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterName"].write(value.parameterName)
        try writer["ParameterValue"].write(value.parameterValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackInputParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackInputParameter()
        value.parameterName = try reader["ParameterName"].readIfPresent() ?? ""
        value.parameterValue = try reader["ParameterValue"].readIfPresent() ?? ""
        return value
    }
}

extension ConfigClientTypes.ConformancePackStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackStatusDetail()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.conformancePackId = try reader["ConformancePackId"].readIfPresent() ?? ""
        value.conformancePackArn = try reader["ConformancePackArn"].readIfPresent() ?? ""
        value.conformancePackState = try reader["ConformancePackState"].readIfPresent() ?? .sdkUnknown("")
        value.stackArn = try reader["StackArn"].readIfPresent() ?? ""
        value.conformancePackStatusReason = try reader["ConformancePackStatusReason"].readIfPresent()
        value.lastUpdateRequestedTime = try reader["LastUpdateRequestedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateCompletedTime = try reader["LastUpdateCompletedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.DeliveryChannel {

    static func write(value: ConfigClientTypes.DeliveryChannel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configSnapshotDeliveryProperties"].write(value.configSnapshotDeliveryProperties, with: ConfigClientTypes.ConfigSnapshotDeliveryProperties.write(value:to:))
        try writer["name"].write(value.name)
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["s3KmsKeyArn"].write(value.s3KmsKeyArn)
        try writer["snsTopicARN"].write(value.snsTopicARN)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.DeliveryChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.DeliveryChannel()
        value.name = try reader["name"].readIfPresent()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["s3KeyPrefix"].readIfPresent()
        value.s3KmsKeyArn = try reader["s3KmsKeyArn"].readIfPresent()
        value.snsTopicARN = try reader["snsTopicARN"].readIfPresent()
        value.configSnapshotDeliveryProperties = try reader["configSnapshotDeliveryProperties"].readIfPresent(with: ConfigClientTypes.ConfigSnapshotDeliveryProperties.read(from:))
        return value
    }
}

extension ConfigClientTypes.ConfigSnapshotDeliveryProperties {

    static func write(value: ConfigClientTypes.ConfigSnapshotDeliveryProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryFrequency"].write(value.deliveryFrequency)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigSnapshotDeliveryProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigSnapshotDeliveryProperties()
        value.deliveryFrequency = try reader["deliveryFrequency"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.DeliveryChannelStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.DeliveryChannelStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.DeliveryChannelStatus()
        value.name = try reader["name"].readIfPresent()
        value.configSnapshotDeliveryInfo = try reader["configSnapshotDeliveryInfo"].readIfPresent(with: ConfigClientTypes.ConfigExportDeliveryInfo.read(from:))
        value.configHistoryDeliveryInfo = try reader["configHistoryDeliveryInfo"].readIfPresent(with: ConfigClientTypes.ConfigExportDeliveryInfo.read(from:))
        value.configStreamDeliveryInfo = try reader["configStreamDeliveryInfo"].readIfPresent(with: ConfigClientTypes.ConfigStreamDeliveryInfo.read(from:))
        return value
    }
}

extension ConfigClientTypes.ConfigStreamDeliveryInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigStreamDeliveryInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigStreamDeliveryInfo()
        value.lastStatus = try reader["lastStatus"].readIfPresent()
        value.lastErrorCode = try reader["lastErrorCode"].readIfPresent()
        value.lastErrorMessage = try reader["lastErrorMessage"].readIfPresent()
        value.lastStatusChangeTime = try reader["lastStatusChangeTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ConfigExportDeliveryInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigExportDeliveryInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigExportDeliveryInfo()
        value.lastStatus = try reader["lastStatus"].readIfPresent()
        value.lastErrorCode = try reader["lastErrorCode"].readIfPresent()
        value.lastErrorMessage = try reader["lastErrorMessage"].readIfPresent()
        value.lastAttemptTime = try reader["lastAttemptTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulTime = try reader["lastSuccessfulTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextDeliveryTime = try reader["nextDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.OrganizationConfigRule {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationConfigRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationConfigRule()
        value.organizationConfigRuleName = try reader["OrganizationConfigRuleName"].readIfPresent() ?? ""
        value.organizationConfigRuleArn = try reader["OrganizationConfigRuleArn"].readIfPresent() ?? ""
        value.organizationManagedRuleMetadata = try reader["OrganizationManagedRuleMetadata"].readIfPresent(with: ConfigClientTypes.OrganizationManagedRuleMetadata.read(from:))
        value.organizationCustomRuleMetadata = try reader["OrganizationCustomRuleMetadata"].readIfPresent(with: ConfigClientTypes.OrganizationCustomRuleMetadata.read(from:))
        value.excludedAccounts = try reader["ExcludedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.organizationCustomPolicyRuleMetadata = try reader["OrganizationCustomPolicyRuleMetadata"].readIfPresent(with: ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy.read(from:))
        return value
    }
}

extension ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationCustomPolicyRuleMetadataNoPolicy()
        value.description = try reader["Description"].readIfPresent()
        value.organizationConfigRuleTriggerTypes = try reader["OrganizationConfigRuleTriggerTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputParameters = try reader["InputParameters"].readIfPresent()
        value.maximumExecutionFrequency = try reader["MaximumExecutionFrequency"].readIfPresent()
        value.resourceTypesScope = try reader["ResourceTypesScope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceIdScope = try reader["ResourceIdScope"].readIfPresent()
        value.tagKeyScope = try reader["TagKeyScope"].readIfPresent()
        value.tagValueScope = try reader["TagValueScope"].readIfPresent()
        value.policyRuntime = try reader["PolicyRuntime"].readIfPresent()
        value.debugLogDeliveryAccounts = try reader["DebugLogDeliveryAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.OrganizationCustomRuleMetadata {

    static func write(value: ConfigClientTypes.OrganizationCustomRuleMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InputParameters"].write(value.inputParameters)
        try writer["LambdaFunctionArn"].write(value.lambdaFunctionArn)
        try writer["MaximumExecutionFrequency"].write(value.maximumExecutionFrequency)
        try writer["OrganizationConfigRuleTriggerTypes"].writeList(value.organizationConfigRuleTriggerTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.OrganizationConfigRuleTriggerType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceIdScope"].write(value.resourceIdScope)
        try writer["ResourceTypesScope"].writeList(value.resourceTypesScope, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagKeyScope"].write(value.tagKeyScope)
        try writer["TagValueScope"].write(value.tagValueScope)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationCustomRuleMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationCustomRuleMetadata()
        value.description = try reader["Description"].readIfPresent()
        value.lambdaFunctionArn = try reader["LambdaFunctionArn"].readIfPresent() ?? ""
        value.organizationConfigRuleTriggerTypes = try reader["OrganizationConfigRuleTriggerTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ConfigClientTypes.OrganizationConfigRuleTriggerType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.inputParameters = try reader["InputParameters"].readIfPresent()
        value.maximumExecutionFrequency = try reader["MaximumExecutionFrequency"].readIfPresent()
        value.resourceTypesScope = try reader["ResourceTypesScope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceIdScope = try reader["ResourceIdScope"].readIfPresent()
        value.tagKeyScope = try reader["TagKeyScope"].readIfPresent()
        value.tagValueScope = try reader["TagValueScope"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.OrganizationManagedRuleMetadata {

    static func write(value: ConfigClientTypes.OrganizationManagedRuleMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InputParameters"].write(value.inputParameters)
        try writer["MaximumExecutionFrequency"].write(value.maximumExecutionFrequency)
        try writer["ResourceIdScope"].write(value.resourceIdScope)
        try writer["ResourceTypesScope"].writeList(value.resourceTypesScope, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
        try writer["TagKeyScope"].write(value.tagKeyScope)
        try writer["TagValueScope"].write(value.tagValueScope)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationManagedRuleMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationManagedRuleMetadata()
        value.description = try reader["Description"].readIfPresent()
        value.ruleIdentifier = try reader["RuleIdentifier"].readIfPresent() ?? ""
        value.inputParameters = try reader["InputParameters"].readIfPresent()
        value.maximumExecutionFrequency = try reader["MaximumExecutionFrequency"].readIfPresent()
        value.resourceTypesScope = try reader["ResourceTypesScope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceIdScope = try reader["ResourceIdScope"].readIfPresent()
        value.tagKeyScope = try reader["TagKeyScope"].readIfPresent()
        value.tagValueScope = try reader["TagValueScope"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.OrganizationConfigRuleStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationConfigRuleStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationConfigRuleStatus()
        value.organizationConfigRuleName = try reader["OrganizationConfigRuleName"].readIfPresent() ?? ""
        value.organizationRuleStatus = try reader["OrganizationRuleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.OrganizationConformancePack {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationConformancePack {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationConformancePack()
        value.organizationConformancePackName = try reader["OrganizationConformancePackName"].readIfPresent() ?? ""
        value.organizationConformancePackArn = try reader["OrganizationConformancePackArn"].readIfPresent() ?? ""
        value.deliveryS3Bucket = try reader["DeliveryS3Bucket"].readIfPresent()
        value.deliveryS3KeyPrefix = try reader["DeliveryS3KeyPrefix"].readIfPresent()
        value.conformancePackInputParameters = try reader["ConformancePackInputParameters"].readListIfPresent(memberReadingClosure: ConfigClientTypes.ConformancePackInputParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludedAccounts = try reader["ExcludedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ConfigClientTypes.OrganizationConformancePackStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationConformancePackStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationConformancePackStatus()
        value.organizationConformancePackName = try reader["OrganizationConformancePackName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.PendingAggregationRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.PendingAggregationRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.PendingAggregationRequest()
        value.requesterAccountId = try reader["RequesterAccountId"].readIfPresent()
        value.requesterAwsRegion = try reader["RequesterAwsRegion"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.RemediationConfiguration {

    static func write(value: ConfigClientTypes.RemediationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Automatic"].write(value.automatic)
        try writer["ConfigRuleName"].write(value.configRuleName)
        try writer["CreatedByService"].write(value.createdByService)
        try writer["ExecutionControls"].write(value.executionControls, with: ConfigClientTypes.ExecutionControls.write(value:to:))
        try writer["MaximumAutomaticAttempts"].write(value.maximumAutomaticAttempts)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: ConfigClientTypes.RemediationParameterValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
        try writer["RetryAttemptSeconds"].write(value.retryAttemptSeconds)
        try writer["TargetId"].write(value.targetId)
        try writer["TargetType"].write(value.targetType)
        try writer["TargetVersion"].write(value.targetVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationConfiguration()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent() ?? ""
        value.targetType = try reader["TargetType"].readIfPresent() ?? .sdkUnknown("")
        value.targetId = try reader["TargetId"].readIfPresent() ?? ""
        value.targetVersion = try reader["TargetVersion"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: ConfigClientTypes.RemediationParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.automatic = try reader["Automatic"].readIfPresent() ?? false
        value.executionControls = try reader["ExecutionControls"].readIfPresent(with: ConfigClientTypes.ExecutionControls.read(from:))
        value.maximumAutomaticAttempts = try reader["MaximumAutomaticAttempts"].readIfPresent()
        value.retryAttemptSeconds = try reader["RetryAttemptSeconds"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdByService = try reader["CreatedByService"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ExecutionControls {

    static func write(value: ConfigClientTypes.ExecutionControls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SsmControls"].write(value.ssmControls, with: ConfigClientTypes.SsmControls.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ExecutionControls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ExecutionControls()
        value.ssmControls = try reader["SsmControls"].readIfPresent(with: ConfigClientTypes.SsmControls.read(from:))
        return value
    }
}

extension ConfigClientTypes.SsmControls {

    static func write(value: ConfigClientTypes.SsmControls?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConcurrentExecutionRatePercentage"].write(value.concurrentExecutionRatePercentage)
        try writer["ErrorPercentage"].write(value.errorPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.SsmControls {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.SsmControls()
        value.concurrentExecutionRatePercentage = try reader["ConcurrentExecutionRatePercentage"].readIfPresent()
        value.errorPercentage = try reader["ErrorPercentage"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.RemediationParameterValue {

    static func write(value: ConfigClientTypes.RemediationParameterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceValue"].write(value.resourceValue, with: ConfigClientTypes.ResourceValue.write(value:to:))
        try writer["StaticValue"].write(value.staticValue, with: ConfigClientTypes.StaticValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationParameterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationParameterValue()
        value.resourceValue = try reader["ResourceValue"].readIfPresent(with: ConfigClientTypes.ResourceValue.read(from:))
        value.staticValue = try reader["StaticValue"].readIfPresent(with: ConfigClientTypes.StaticValue.read(from:))
        return value
    }
}

extension ConfigClientTypes.StaticValue {

    static func write(value: ConfigClientTypes.StaticValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.StaticValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.StaticValue()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ConfigClientTypes.ResourceValue {

    static func write(value: ConfigClientTypes.ResourceValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceValue()
        value.value = try reader["Value"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConfigClientTypes.RemediationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationException()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent()
        value.expirationTime = try reader["ExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.RemediationExecutionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationExecutionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationExecutionStatus()
        value.resourceKey = try reader["ResourceKey"].readIfPresent(with: ConfigClientTypes.ResourceKey.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stepDetails = try reader["StepDetails"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationExecutionStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.invocationTime = try reader["InvocationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.RemediationExecutionStep {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RemediationExecutionStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RemediationExecutionStep()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopTime = try reader["StopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.RetentionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.RetentionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.RetentionConfiguration()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.retentionPeriodInDays = try reader["RetentionPeriodInDays"].readIfPresent() ?? 0
        return value
    }
}

extension ConfigClientTypes.AggregateEvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateEvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateEvaluationResult()
        value.evaluationResultIdentifier = try reader["EvaluationResultIdentifier"].readIfPresent(with: ConfigClientTypes.EvaluationResultIdentifier.read(from:))
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.resultRecordedTime = try reader["ResultRecordedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configRuleInvokedTime = try reader["ConfigRuleInvokedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.annotation = try reader["Annotation"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.EvaluationResultIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationResultIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationResultIdentifier()
        value.evaluationResultQualifier = try reader["EvaluationResultQualifier"].readIfPresent(with: ConfigClientTypes.EvaluationResultQualifier.read(from:))
        value.orderingTimestamp = try reader["OrderingTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceEvaluationId = try reader["ResourceEvaluationId"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.EvaluationResultQualifier {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationResultQualifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationResultQualifier()
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.evaluationMode = try reader["EvaluationMode"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.AggregateComplianceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateComplianceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateComplianceCount()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.complianceSummary = try reader["ComplianceSummary"].readIfPresent(with: ConfigClientTypes.ComplianceSummary.read(from:))
        return value
    }
}

extension ConfigClientTypes.ComplianceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ComplianceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ComplianceSummary()
        value.compliantResourceCount = try reader["CompliantResourceCount"].readIfPresent(with: ConfigClientTypes.ComplianceContributorCount.read(from:))
        value.nonCompliantResourceCount = try reader["NonCompliantResourceCount"].readIfPresent(with: ConfigClientTypes.ComplianceContributorCount.read(from:))
        value.complianceSummaryTimestamp = try reader["ComplianceSummaryTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.AggregateConformancePackComplianceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateConformancePackComplianceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateConformancePackComplianceSummary()
        value.complianceSummary = try reader["ComplianceSummary"].readIfPresent(with: ConfigClientTypes.AggregateConformancePackComplianceCount.read(from:))
        value.groupName = try reader["GroupName"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.AggregateConformancePackComplianceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.AggregateConformancePackComplianceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.AggregateConformancePackComplianceCount()
        value.compliantConformancePackCount = try reader["CompliantConformancePackCount"].readIfPresent() ?? 0
        value.nonCompliantConformancePackCount = try reader["NonCompliantConformancePackCount"].readIfPresent() ?? 0
        return value
    }
}

extension ConfigClientTypes.GroupedResourceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.GroupedResourceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.GroupedResourceCount()
        value.groupName = try reader["GroupName"].readIfPresent() ?? ""
        value.resourceCount = try reader["ResourceCount"].readIfPresent() ?? 0
        return value
    }
}

extension ConfigClientTypes.ConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConfigurationItem()
        value.version = try reader["version"].readIfPresent()
        value.accountId = try reader["accountId"].readIfPresent()
        value.configurationItemCaptureTime = try reader["configurationItemCaptureTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configurationItemStatus = try reader["configurationItemStatus"].readIfPresent()
        value.configurationStateId = try reader["configurationStateId"].readIfPresent()
        value.configurationItemMD5Hash = try reader["configurationItemMD5Hash"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceName = try reader["resourceName"].readIfPresent()
        value.awsRegion = try reader["awsRegion"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.resourceCreationTime = try reader["resourceCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.relatedEvents = try reader["relatedEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.relationships = try reader["relationships"].readListIfPresent(memberReadingClosure: ConfigClientTypes.Relationship.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["configuration"].readIfPresent()
        value.supplementaryConfiguration = try reader["supplementaryConfiguration"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recordingFrequency = try reader["recordingFrequency"].readIfPresent()
        value.configurationItemDeliveryTime = try reader["configurationItemDeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.Relationship {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Relationship {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Relationship()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceName = try reader["resourceName"].readIfPresent()
        value.relationshipName = try reader["relationshipName"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.EvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationResult()
        value.evaluationResultIdentifier = try reader["EvaluationResultIdentifier"].readIfPresent(with: ConfigClientTypes.EvaluationResultIdentifier.read(from:))
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.resultRecordedTime = try reader["ResultRecordedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configRuleInvokedTime = try reader["ConfigRuleInvokedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.annotation = try reader["Annotation"].readIfPresent()
        value.resultToken = try reader["ResultToken"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ComplianceSummaryByResourceType {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ComplianceSummaryByResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ComplianceSummaryByResourceType()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.complianceSummary = try reader["ComplianceSummary"].readIfPresent(with: ConfigClientTypes.ComplianceSummary.read(from:))
        return value
    }
}

extension ConfigClientTypes.ConformancePackEvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackEvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackEvaluationResult()
        value.complianceType = try reader["ComplianceType"].readIfPresent() ?? .sdkUnknown("")
        value.evaluationResultIdentifier = try reader["EvaluationResultIdentifier"].readIfPresent(with: ConfigClientTypes.EvaluationResultIdentifier.read(from:))
        value.configRuleInvokedTime = try reader["ConfigRuleInvokedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resultRecordedTime = try reader["ResultRecordedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.annotation = try reader["Annotation"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConformancePackComplianceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackComplianceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackComplianceSummary()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.conformancePackComplianceStatus = try reader["ConformancePackComplianceStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ConfigClientTypes.ResourceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceCount()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        return value
    }
}

extension ConfigClientTypes.MemberAccountStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.MemberAccountStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.MemberAccountStatus()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.configRuleName = try reader["ConfigRuleName"].readIfPresent() ?? ""
        value.memberAccountRuleStatus = try reader["MemberAccountRuleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.OrganizationConformancePackDetailedStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.OrganizationConformancePackDetailedStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.OrganizationConformancePackDetailedStatus()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.EvaluationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationStatus()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.failureReason = try reader["FailureReason"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.EvaluationContext {

    static func write(value: ConfigClientTypes.EvaluationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationContextIdentifier"].write(value.evaluationContextIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.EvaluationContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.EvaluationContext()
        value.evaluationContextIdentifier = try reader["EvaluationContextIdentifier"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ResourceDetails {

    static func write(value: ConfigClientTypes.ResourceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceConfiguration"].write(value.resourceConfiguration)
        try writer["ResourceConfigurationSchemaType"].write(value.resourceConfigurationSchemaType)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceDetails()
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.resourceConfiguration = try reader["ResourceConfiguration"].readIfPresent() ?? ""
        value.resourceConfigurationSchemaType = try reader["ResourceConfigurationSchemaType"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.StoredQuery {

    static func write(value: ConfigClientTypes.StoredQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Expression"].write(value.expression)
        try writer["QueryArn"].write(value.queryArn)
        try writer["QueryId"].write(value.queryId)
        try writer["QueryName"].write(value.queryName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.StoredQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.StoredQuery()
        value.queryId = try reader["QueryId"].readIfPresent()
        value.queryArn = try reader["QueryArn"].readIfPresent()
        value.queryName = try reader["QueryName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.expression = try reader["Expression"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConformancePackComplianceScore {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ConformancePackComplianceScore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ConformancePackComplianceScore()
        value.score = try reader["Score"].readIfPresent()
        value.conformancePackName = try reader["ConformancePackName"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ResourceIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceIdentifier()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceName = try reader["resourceName"].readIfPresent()
        value.resourceDeletionTime = try reader["resourceDeletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.ResourceEvaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.ResourceEvaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.ResourceEvaluation()
        value.resourceEvaluationId = try reader["ResourceEvaluationId"].readIfPresent()
        value.evaluationMode = try reader["EvaluationMode"].readIfPresent()
        value.evaluationStartTimestamp = try reader["EvaluationStartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ConfigClientTypes.StoredQueryMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.StoredQueryMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.StoredQueryMetadata()
        value.queryId = try reader["QueryId"].readIfPresent() ?? ""
        value.queryArn = try reader["QueryArn"].readIfPresent() ?? ""
        value.queryName = try reader["QueryName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.Tag {

    static func write(value: ConfigClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.Evaluation {

    static func write(value: ConfigClientTypes.Evaluation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Annotation"].write(value.annotation)
        try writer["ComplianceResourceId"].write(value.complianceResourceId)
        try writer["ComplianceResourceType"].write(value.complianceResourceType)
        try writer["ComplianceType"].write(value.complianceType)
        try writer["OrderingTimestamp"].writeTimestamp(value.orderingTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.Evaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.Evaluation()
        value.complianceResourceType = try reader["ComplianceResourceType"].readIfPresent() ?? ""
        value.complianceResourceId = try reader["ComplianceResourceId"].readIfPresent() ?? ""
        value.complianceType = try reader["ComplianceType"].readIfPresent() ?? .sdkUnknown("")
        value.annotation = try reader["Annotation"].readIfPresent()
        value.orderingTimestamp = try reader["OrderingTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ConfigClientTypes.FailedRemediationBatch {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.FailedRemediationBatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.FailedRemediationBatch()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.FailedRemediationExceptionBatch {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.FailedRemediationExceptionBatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.FailedRemediationExceptionBatch()
        value.failureMessage = try reader["FailureMessage"].readIfPresent()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: ConfigClientTypes.RemediationException.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.QueryInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.QueryInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.QueryInfo()
        value.selectFields = try reader["SelectFields"].readListIfPresent(memberReadingClosure: ConfigClientTypes.FieldInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConfigClientTypes.FieldInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ConfigClientTypes.FieldInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ConfigClientTypes.FieldInfo()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ConfigClientTypes.ConfigRuleComplianceFilters {

    static func write(value: ConfigClientTypes.ConfigRuleComplianceFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ConfigRuleName"].write(value.configRuleName)
    }
}

extension ConfigClientTypes.AggregateConformancePackComplianceFilters {

    static func write(value: ConfigClientTypes.AggregateConformancePackComplianceFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ConformancePackName"].write(value.conformancePackName)
    }
}

extension ConfigClientTypes.DescribeConfigRulesFilters {

    static func write(value: ConfigClientTypes.DescribeConfigRulesFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationMode"].write(value.evaluationMode)
    }
}

extension ConfigClientTypes.ConformancePackComplianceFilters {

    static func write(value: ConfigClientTypes.ConformancePackComplianceFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConfigClientTypes.ConfigRuleComplianceSummaryFilters {

    static func write(value: ConfigClientTypes.ConfigRuleComplianceSummaryFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AwsRegion"].write(value.awsRegion)
    }
}

extension ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters {

    static func write(value: ConfigClientTypes.AggregateConformancePackComplianceSummaryFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AwsRegion"].write(value.awsRegion)
    }
}

extension ConfigClientTypes.ResourceCountFilters {

    static func write(value: ConfigClientTypes.ResourceCountFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Region"].write(value.region)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ConfigClientTypes.ConformancePackEvaluationFilters {

    static func write(value: ConfigClientTypes.ConformancePackEvaluationFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceType"].write(value.complianceType)
        try writer["ConfigRuleNames"].writeList(value.configRuleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceIds"].writeList(value.resourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ConfigClientTypes.StatusDetailFilters {

    static func write(value: ConfigClientTypes.StatusDetailFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MemberAccountRuleStatus"].write(value.memberAccountRuleStatus)
    }
}

extension ConfigClientTypes.OrganizationResourceDetailedStatusFilters {

    static func write(value: ConfigClientTypes.OrganizationResourceDetailedStatusFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Status"].write(value.status)
    }
}

extension ConfigClientTypes.ResourceFilters {

    static func write(value: ConfigClientTypes.ResourceFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Region"].write(value.region)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceName"].write(value.resourceName)
    }
}

extension ConfigClientTypes.ConformancePackComplianceScoresFilters {

    static func write(value: ConfigClientTypes.ConformancePackComplianceScoresFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConformancePackNames"].writeList(value.conformancePackNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConfigClientTypes.ResourceEvaluationFilters {

    static func write(value: ConfigClientTypes.ResourceEvaluationFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EvaluationContextIdentifier"].write(value.evaluationContextIdentifier)
        try writer["EvaluationMode"].write(value.evaluationMode)
        try writer["TimeWindow"].write(value.timeWindow, with: ConfigClientTypes.TimeWindow.write(value:to:))
    }
}

extension ConfigClientTypes.TimeWindow {

    static func write(value: ConfigClientTypes.TimeWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ConfigClientTypes.ExternalEvaluation {

    static func write(value: ConfigClientTypes.ExternalEvaluation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Annotation"].write(value.annotation)
        try writer["ComplianceResourceId"].write(value.complianceResourceId)
        try writer["ComplianceResourceType"].write(value.complianceResourceType)
        try writer["ComplianceType"].write(value.complianceType)
        try writer["OrderingTimestamp"].writeTimestamp(value.orderingTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ConfigClientTypes.OrganizationCustomPolicyRuleMetadata {

    static func write(value: ConfigClientTypes.OrganizationCustomPolicyRuleMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DebugLogDeliveryAccounts"].writeList(value.debugLogDeliveryAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["InputParameters"].write(value.inputParameters)
        try writer["MaximumExecutionFrequency"].write(value.maximumExecutionFrequency)
        try writer["OrganizationConfigRuleTriggerTypes"].writeList(value.organizationConfigRuleTriggerTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ConfigClientTypes.OrganizationConfigRuleTriggerTypeNoSN>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicyRuntime"].write(value.policyRuntime)
        try writer["PolicyText"].write(value.policyText)
        try writer["ResourceIdScope"].write(value.resourceIdScope)
        try writer["ResourceTypesScope"].writeList(value.resourceTypesScope, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagKeyScope"].write(value.tagKeyScope)
        try writer["TagValueScope"].write(value.tagValueScope)
    }
}

public enum ConfigClientTypes {}
