//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension TnbClient {
    /// Paginate over `[ListSolFunctionInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolFunctionInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolFunctionInstancesOutput`
    public func listSolFunctionInstancesPaginated(input: ListSolFunctionInstancesInput) -> ClientRuntime.PaginatorSequence<ListSolFunctionInstancesInput, ListSolFunctionInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListSolFunctionInstancesInput, ListSolFunctionInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSolFunctionInstances(input:))
    }
}

extension ListSolFunctionInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolFunctionInstancesInput {
        return ListSolFunctionInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSolFunctionInstancesInput, OperationStackOutput == ListSolFunctionInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSolFunctionInstancesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolFunctionInstanceInfo]`
    /// - Returns: `[TnbClientTypes.ListSolFunctionInstanceInfo]`
    public func functionInstances() async throws -> [TnbClientTypes.ListSolFunctionInstanceInfo] {
        return try await self.asyncCompactMap { item in item.functionInstances }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolFunctionPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolFunctionPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolFunctionPackagesOutput`
    public func listSolFunctionPackagesPaginated(input: ListSolFunctionPackagesInput) -> ClientRuntime.PaginatorSequence<ListSolFunctionPackagesInput, ListSolFunctionPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListSolFunctionPackagesInput, ListSolFunctionPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSolFunctionPackages(input:))
    }
}

extension ListSolFunctionPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolFunctionPackagesInput {
        return ListSolFunctionPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSolFunctionPackagesInput, OperationStackOutput == ListSolFunctionPackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSolFunctionPackagesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolFunctionPackageInfo]`
    /// - Returns: `[TnbClientTypes.ListSolFunctionPackageInfo]`
    public func functionPackages() async throws -> [TnbClientTypes.ListSolFunctionPackageInfo] {
        return try await self.asyncCompactMap { item in item.functionPackages }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkInstancesOutput`
    public func listSolNetworkInstancesPaginated(input: ListSolNetworkInstancesInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkInstancesInput, ListSolNetworkInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkInstancesInput, ListSolNetworkInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSolNetworkInstances(input:))
    }
}

extension ListSolNetworkInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkInstancesInput {
        return ListSolNetworkInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSolNetworkInstancesInput, OperationStackOutput == ListSolNetworkInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkInstancesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkInstanceInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkInstanceInfo]`
    public func networkInstances() async throws -> [TnbClientTypes.ListSolNetworkInstanceInfo] {
        return try await self.asyncCompactMap { item in item.networkInstances }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkOperationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkOperationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkOperationsOutput`
    public func listSolNetworkOperationsPaginated(input: ListSolNetworkOperationsInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkOperationsInput, ListSolNetworkOperationsOutput> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkOperationsInput, ListSolNetworkOperationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSolNetworkOperations(input:))
    }
}

extension ListSolNetworkOperationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkOperationsInput {
        return ListSolNetworkOperationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSolNetworkOperationsInput, OperationStackOutput == ListSolNetworkOperationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkOperationsPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkOperationsInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkOperationsInfo]`
    public func networkOperations() async throws -> [TnbClientTypes.ListSolNetworkOperationsInfo] {
        return try await self.asyncCompactMap { item in item.networkOperations }
    }
}
extension TnbClient {
    /// Paginate over `[ListSolNetworkPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSolNetworkPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSolNetworkPackagesOutput`
    public func listSolNetworkPackagesPaginated(input: ListSolNetworkPackagesInput) -> ClientRuntime.PaginatorSequence<ListSolNetworkPackagesInput, ListSolNetworkPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListSolNetworkPackagesInput, ListSolNetworkPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSolNetworkPackages(input:))
    }
}

extension ListSolNetworkPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSolNetworkPackagesInput {
        return ListSolNetworkPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSolNetworkPackagesInput, OperationStackOutput == ListSolNetworkPackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSolNetworkPackagesPaginated`
    /// to access the nested member `[TnbClientTypes.ListSolNetworkPackageInfo]`
    /// - Returns: `[TnbClientTypes.ListSolNetworkPackageInfo]`
    public func networkPackages() async throws -> [TnbClientTypes.ListSolNetworkPackageInfo] {
        return try await self.asyncCompactMap { item in item.networkPackages }
    }
}
