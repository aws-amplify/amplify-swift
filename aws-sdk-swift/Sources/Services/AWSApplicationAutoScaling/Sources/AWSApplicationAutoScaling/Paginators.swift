//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ApplicationAutoScalingClient {
    /// Paginate over `[DescribeScalableTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScalableTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScalableTargetsOutput`
    public func describeScalableTargetsPaginated(input: DescribeScalableTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeScalableTargetsInput, DescribeScalableTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScalableTargetsInput, DescribeScalableTargetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScalableTargets(input:))
    }
}

extension DescribeScalableTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalableTargetsInput {
        return DescribeScalableTargetsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceIds: self.resourceIds,
            scalableDimension: self.scalableDimension,
            serviceNamespace: self.serviceNamespace
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScalableTargetsInput, OperationStackOutput == DescribeScalableTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScalableTargetsPaginated`
    /// to access the nested member `[ApplicationAutoScalingClientTypes.ScalableTarget]`
    /// - Returns: `[ApplicationAutoScalingClientTypes.ScalableTarget]`
    public func scalableTargets() async throws -> [ApplicationAutoScalingClientTypes.ScalableTarget] {
        return try await self.asyncCompactMap { item in item.scalableTargets }
    }
}
extension ApplicationAutoScalingClient {
    /// Paginate over `[DescribeScalingActivitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScalingActivitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScalingActivitiesOutput`
    public func describeScalingActivitiesPaginated(input: DescribeScalingActivitiesInput) -> ClientRuntime.PaginatorSequence<DescribeScalingActivitiesInput, DescribeScalingActivitiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScalingActivitiesInput, DescribeScalingActivitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScalingActivities(input:))
    }
}

extension DescribeScalingActivitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalingActivitiesInput {
        return DescribeScalingActivitiesInput(
            includeNotScaledActivities: self.includeNotScaledActivities,
            maxResults: self.maxResults,
            nextToken: token,
            resourceId: self.resourceId,
            scalableDimension: self.scalableDimension,
            serviceNamespace: self.serviceNamespace
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScalingActivitiesInput, OperationStackOutput == DescribeScalingActivitiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScalingActivitiesPaginated`
    /// to access the nested member `[ApplicationAutoScalingClientTypes.ScalingActivity]`
    /// - Returns: `[ApplicationAutoScalingClientTypes.ScalingActivity]`
    public func scalingActivities() async throws -> [ApplicationAutoScalingClientTypes.ScalingActivity] {
        return try await self.asyncCompactMap { item in item.scalingActivities }
    }
}
extension ApplicationAutoScalingClient {
    /// Paginate over `[DescribeScalingPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScalingPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScalingPoliciesOutput`
    public func describeScalingPoliciesPaginated(input: DescribeScalingPoliciesInput) -> ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScalingPolicies(input:))
    }
}

extension DescribeScalingPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalingPoliciesInput {
        return DescribeScalingPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            policyNames: self.policyNames,
            resourceId: self.resourceId,
            scalableDimension: self.scalableDimension,
            serviceNamespace: self.serviceNamespace
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScalingPoliciesInput, OperationStackOutput == DescribeScalingPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScalingPoliciesPaginated`
    /// to access the nested member `[ApplicationAutoScalingClientTypes.ScalingPolicy]`
    /// - Returns: `[ApplicationAutoScalingClientTypes.ScalingPolicy]`
    public func scalingPolicies() async throws -> [ApplicationAutoScalingClientTypes.ScalingPolicy] {
        return try await self.asyncCompactMap { item in item.scalingPolicies }
    }
}
extension ApplicationAutoScalingClient {
    /// Paginate over `[DescribeScheduledActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduledActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledActionsOutput`
    public func describeScheduledActionsPaginated(input: DescribeScheduledActionsInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScheduledActions(input:))
    }
}

extension DescribeScheduledActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledActionsInput {
        return DescribeScheduledActionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceId: self.resourceId,
            scalableDimension: self.scalableDimension,
            scheduledActionNames: self.scheduledActionNames,
            serviceNamespace: self.serviceNamespace
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScheduledActionsInput, OperationStackOutput == DescribeScheduledActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScheduledActionsPaginated`
    /// to access the nested member `[ApplicationAutoScalingClientTypes.ScheduledAction]`
    /// - Returns: `[ApplicationAutoScalingClientTypes.ScheduledAction]`
    public func scheduledActions() async throws -> [ApplicationAutoScalingClientTypes.ScheduledAction] {
        return try await self.asyncCompactMap { item in item.scheduledActions }
    }
}
