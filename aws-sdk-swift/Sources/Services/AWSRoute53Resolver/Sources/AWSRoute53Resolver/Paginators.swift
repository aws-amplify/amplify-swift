//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension Route53ResolverClient {
    /// Paginate over `[ListFirewallConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallConfigsOutput`
    public func listFirewallConfigsPaginated(input: ListFirewallConfigsInput) -> ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallConfigsInput, ListFirewallConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallConfigs(input:))
    }
}

extension ListFirewallConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallConfigsInput {
        return ListFirewallConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallConfigsInput, OperationStackOutput == ListFirewallConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallConfig]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallConfig]`
    public func firewallConfigs() async throws -> [Route53ResolverClientTypes.FirewallConfig] {
        return try await self.asyncCompactMap { item in item.firewallConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainListsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainListsOutput`
    public func listFirewallDomainListsPaginated(input: ListFirewallDomainListsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainListsInput, ListFirewallDomainListsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallDomainLists(input:))
    }
}

extension ListFirewallDomainListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainListsInput {
        return ListFirewallDomainListsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallDomainListsInput, OperationStackOutput == ListFirewallDomainListsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainListsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallDomainListMetadata]`
    public func firewallDomainLists() async throws -> [Route53ResolverClientTypes.FirewallDomainListMetadata] {
        return try await self.asyncCompactMap { item in item.firewallDomainLists }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallDomainsOutput`
    public func listFirewallDomainsPaginated(input: ListFirewallDomainsInput) -> ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallDomainsInput, ListFirewallDomainsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallDomains(input:))
    }
}

extension ListFirewallDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallDomainsInput {
        return ListFirewallDomainsInput(
            firewallDomainListId: self.firewallDomainListId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallDomainsInput, OperationStackOutput == ListFirewallDomainsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallDomainsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func domains() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupAssociationsOutput`
    public func listFirewallRuleGroupAssociationsPaginated(input: ListFirewallRuleGroupAssociationsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupAssociationsInput, ListFirewallRuleGroupAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallRuleGroupAssociations(input:))
    }
}

extension ListFirewallRuleGroupAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupAssociationsInput {
        return ListFirewallRuleGroupAssociationsInput(
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority,
            status: self.status,
            vpcId: self.vpcId
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallRuleGroupAssociationsInput, OperationStackOutput == ListFirewallRuleGroupAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupAssociation]`
    public func firewallRuleGroupAssociations() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupAssociation] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroupAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRuleGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRuleGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRuleGroupsOutput`
    public func listFirewallRuleGroupsPaginated(input: ListFirewallRuleGroupsInput) -> ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRuleGroupsInput, ListFirewallRuleGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallRuleGroups(input:))
    }
}

extension ListFirewallRuleGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRuleGroupsInput {
        return ListFirewallRuleGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallRuleGroupsInput, OperationStackOutput == ListFirewallRuleGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRuleGroupsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRuleGroupMetadata]`
    public func firewallRuleGroups() async throws -> [Route53ResolverClientTypes.FirewallRuleGroupMetadata] {
        return try await self.asyncCompactMap { item in item.firewallRuleGroups }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListFirewallRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFirewallRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFirewallRulesOutput`
    public func listFirewallRulesPaginated(input: ListFirewallRulesInput) -> ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListFirewallRulesInput, ListFirewallRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFirewallRules(input:))
    }
}

extension ListFirewallRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFirewallRulesInput {
        return ListFirewallRulesInput(
            action: self.action,
            firewallRuleGroupId: self.firewallRuleGroupId,
            maxResults: self.maxResults,
            nextToken: token,
            priority: self.priority
        )}
}

extension PaginatorSequence where OperationStackInput == ListFirewallRulesInput, OperationStackOutput == ListFirewallRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFirewallRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.FirewallRule]`
    /// - Returns: `[Route53ResolverClientTypes.FirewallRule]`
    public func firewallRules() async throws -> [Route53ResolverClientTypes.FirewallRule] {
        return try await self.asyncCompactMap { item in item.firewallRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListOutpostResolversOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOutpostResolversInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOutpostResolversOutput`
    public func listOutpostResolversPaginated(input: ListOutpostResolversInput) -> ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutput> {
        return ClientRuntime.PaginatorSequence<ListOutpostResolversInput, ListOutpostResolversOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOutpostResolvers(input:))
    }
}

extension ListOutpostResolversInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOutpostResolversInput {
        return ListOutpostResolversInput(
            maxResults: self.maxResults,
            nextToken: token,
            outpostArn: self.outpostArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListOutpostResolversInput, OperationStackOutput == ListOutpostResolversOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOutpostResolversPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.OutpostResolver]`
    /// - Returns: `[Route53ResolverClientTypes.OutpostResolver]`
    public func outpostResolvers() async throws -> [Route53ResolverClientTypes.OutpostResolver] {
        return try await self.asyncCompactMap { item in item.outpostResolvers }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverConfigsOutput`
    public func listResolverConfigsPaginated(input: ListResolverConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverConfigsInput, ListResolverConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverConfigs(input:))
    }
}

extension ListResolverConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverConfigsInput {
        return ListResolverConfigsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverConfigsInput, OperationStackOutput == ListResolverConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverConfig]`
    public func resolverConfigs() async throws -> [Route53ResolverClientTypes.ResolverConfig] {
        return try await self.asyncCompactMap { item in item.resolverConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverDnssecConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverDnssecConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverDnssecConfigsOutput`
    public func listResolverDnssecConfigsPaginated(input: ListResolverDnssecConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverDnssecConfigsInput, ListResolverDnssecConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverDnssecConfigs(input:))
    }
}

extension ListResolverDnssecConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverDnssecConfigsInput {
        return ListResolverDnssecConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverDnssecConfigsInput, OperationStackOutput == ListResolverDnssecConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverDnssecConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverDnssecConfig]`
    public func resolverDnssecConfigs() async throws -> [Route53ResolverClientTypes.ResolverDnssecConfig] {
        return try await self.asyncCompactMap { item in item.resolverDnssecConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointIpAddressesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointIpAddressesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointIpAddressesOutput`
    public func listResolverEndpointIpAddressesPaginated(input: ListResolverEndpointIpAddressesInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointIpAddressesInput, ListResolverEndpointIpAddressesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverEndpointIpAddresses(input:))
    }
}

extension ListResolverEndpointIpAddressesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointIpAddressesInput {
        return ListResolverEndpointIpAddressesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resolverEndpointId: self.resolverEndpointId
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverEndpointIpAddressesInput, OperationStackOutput == ListResolverEndpointIpAddressesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointIpAddressesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.IpAddressResponse]`
    /// - Returns: `[Route53ResolverClientTypes.IpAddressResponse]`
    public func ipAddresses() async throws -> [Route53ResolverClientTypes.IpAddressResponse] {
        return try await self.asyncCompactMap { item in item.ipAddresses }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverEndpointsOutput`
    public func listResolverEndpointsPaginated(input: ListResolverEndpointsInput) -> ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverEndpointsInput, ListResolverEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverEndpoints(input:))
    }
}

extension ListResolverEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverEndpointsInput {
        return ListResolverEndpointsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverEndpointsInput, OperationStackOutput == ListResolverEndpointsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverEndpointsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverEndpoint]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverEndpoint]`
    public func resolverEndpoints() async throws -> [Route53ResolverClientTypes.ResolverEndpoint] {
        return try await self.asyncCompactMap { item in item.resolverEndpoints }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigAssociationsOutput`
    public func listResolverQueryLogConfigAssociationsPaginated(input: ListResolverQueryLogConfigAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigAssociationsInput, ListResolverQueryLogConfigAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverQueryLogConfigAssociations(input:))
    }
}

extension ListResolverQueryLogConfigAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigAssociationsInput {
        return ListResolverQueryLogConfigAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverQueryLogConfigAssociationsInput, OperationStackOutput == ListResolverQueryLogConfigAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfigAssociation]`
    public func resolverQueryLogConfigAssociations() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfigAssociation] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverQueryLogConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverQueryLogConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverQueryLogConfigsOutput`
    public func listResolverQueryLogConfigsPaginated(input: ListResolverQueryLogConfigsInput) -> ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverQueryLogConfigsInput, ListResolverQueryLogConfigsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverQueryLogConfigs(input:))
    }
}

extension ListResolverQueryLogConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverQueryLogConfigsInput {
        return ListResolverQueryLogConfigsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverQueryLogConfigsInput, OperationStackOutput == ListResolverQueryLogConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverQueryLogConfigsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverQueryLogConfig]`
    public func resolverQueryLogConfigs() async throws -> [Route53ResolverClientTypes.ResolverQueryLogConfig] {
        return try await self.asyncCompactMap { item in item.resolverQueryLogConfigs }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRuleAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRuleAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRuleAssociationsOutput`
    public func listResolverRuleAssociationsPaginated(input: ListResolverRuleAssociationsInput) -> ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverRuleAssociationsInput, ListResolverRuleAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverRuleAssociations(input:))
    }
}

extension ListResolverRuleAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRuleAssociationsInput {
        return ListResolverRuleAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverRuleAssociationsInput, OperationStackOutput == ListResolverRuleAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRuleAssociationsPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRuleAssociation]`
    public func resolverRuleAssociations() async throws -> [Route53ResolverClientTypes.ResolverRuleAssociation] {
        return try await self.asyncCompactMap { item in item.resolverRuleAssociations }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListResolverRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResolverRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResolverRulesOutput`
    public func listResolverRulesPaginated(input: ListResolverRulesInput) -> ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListResolverRulesInput, ListResolverRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResolverRules(input:))
    }
}

extension ListResolverRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResolverRulesInput {
        return ListResolverRulesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResolverRulesInput, OperationStackOutput == ListResolverRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResolverRulesPaginated`
    /// to access the nested member `[Route53ResolverClientTypes.ResolverRule]`
    /// - Returns: `[Route53ResolverClientTypes.ResolverRule]`
    public func resolverRules() async throws -> [Route53ResolverClientTypes.ResolverRule] {
        return try await self.asyncCompactMap { item in item.resolverRules }
    }
}
extension Route53ResolverClient {
    /// Paginate over `[ListTagsForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutput`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListTagsForResourceInput, OperationStackOutput == ListTagsForResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[Route53ResolverClientTypes.Tag]`
    /// - Returns: `[Route53ResolverClientTypes.Tag]`
    public func tags() async throws -> [Route53ResolverClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
