//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct DeleteChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePlaybackRestrictionPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRecordingConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStreamKeyOutput: Swift.Sendable {

    public init() { }
}

public struct PutMetadataOutput: Swift.Sendable {

    public init() { }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

public struct BatchGetChannelInput: Swift.Sendable {
    /// Array of ARNs, one per channel.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

extension IvsClientTypes {

    public enum ChannelLatencyMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lowlatency
        case normallatency
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelLatencyMode] {
            return [
                .lowlatency,
                .normallatency
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lowlatency: return "LOW"
            case .normallatency: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    public enum TranscodePreset: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case constrainedbandwidthtranscodepreset
        case higherbandwidthtranscodepreset
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscodePreset] {
            return [
                .constrainedbandwidthtranscodepreset,
                .higherbandwidthtranscodepreset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .constrainedbandwidthtranscodepreset: return "CONSTRAINED_BANDWIDTH_DELIVERY"
            case .higherbandwidthtranscodepreset: return "HIGHER_BANDWIDTH_DELIVERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// Specifies information needed to stream using the SRT protocol.
    public struct Srt: Swift.Sendable {
        /// The endpoint to be used when streaming with IVS using the SRT protocol.
        public var endpoint: Swift.String?
        /// Auto-generated passphrase to enable encryption. This field is applicable only if the end user has not enabled the insecureIngest option for the channel.
        public var passphrase: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            passphrase: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.passphrase = passphrase
        }
    }
}

extension IvsClientTypes.Srt: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Srt(endpoint: \(Swift.String(describing: endpoint)), passphrase: \"CONTENT_REDACTED\")"}
}

extension IvsClientTypes {

    public enum ChannelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case advancedhdchanneltype
        case advancedsdchanneltype
        case basicchanneltype
        case standardchanneltype
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .advancedhdchanneltype,
                .advancedsdchanneltype,
                .basicchanneltype,
                .standardchanneltype
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .advancedhdchanneltype: return "ADVANCED_HD"
            case .advancedsdchanneltype: return "ADVANCED_SD"
            case .basicchanneltype: return "BASIC"
            case .standardchanneltype: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// Object specifying a channel.
    public struct Channel: Swift.Sendable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Channel ingest endpoint, part of the definition of an ingest server, used when you set up streaming software.
        public var ingestEndpoint: Swift.String?
        /// Whether the channel allows insecure RTMP ingest. Default: false.
        public var insecureIngest: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW.
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Playback-restriction-policy ARN. A valid ARN value here both specifies the ARN and enables playback restriction. Default: "" (empty string, no playback restriction policy is applied).
        public var playbackRestrictionPolicyArn: Swift.String?
        /// Channel playback URL.
        public var playbackUrl: Swift.String?
        /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
        public var preset: IvsClientTypes.TranscodePreset?
        /// Recording-configuration ARN. A valid ARN value here both specifies the ARN and enables recording. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Specifies the endpoint and optional passphrase for streaming with the SRT protocol.
        public var srt: IvsClientTypes.Srt?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
        public var type: IvsClientTypes.ChannelType?

        public init(
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            ingestEndpoint: Swift.String? = nil,
            insecureIngest: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            playbackRestrictionPolicyArn: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            preset: IvsClientTypes.TranscodePreset? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            srt: IvsClientTypes.Srt? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.ingestEndpoint = ingestEndpoint
            self.insecureIngest = insecureIngest
            self.latencyMode = latencyMode
            self.name = name
            self.playbackRestrictionPolicyArn = playbackRestrictionPolicyArn
            self.playbackUrl = playbackUrl
            self.preset = preset
            self.recordingConfigurationArn = recordingConfigurationArn
            self.srt = srt
            self.tags = tags
            self.type = type
        }
    }
}

extension IvsClientTypes {

    /// Error related to a specific channel, specified by its ARN.
    public struct BatchError: Swift.Sendable {
        /// ARN of an IVS resource; e.g., channel.
        public var arn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }
}

public struct BatchGetChannelOutput: Swift.Sendable {
    ///
    public var channels: [IvsClientTypes.Channel]?
    /// Each error object is related to a specific ARN in the request.
    public var errors: [IvsClientTypes.BatchError]?

    public init(
        channels: [IvsClientTypes.Channel]? = nil,
        errors: [IvsClientTypes.BatchError]? = nil
    )
    {
        self.channels = channels
        self.errors = errors
    }
}

public struct BatchGetStreamKeyInput: Swift.Sendable {
    /// Array of ARNs, one per stream key.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

extension IvsClientTypes {

    /// Object specifying a stream key.
    public struct StreamKey: Swift.Sendable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Stream-key value.
        public var value: Swift.String?

        public init(
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
            self.value = value
        }
    }
}

extension IvsClientTypes.StreamKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamKey(arn: \(Swift.String(describing: arn)), channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)), value: \"CONTENT_REDACTED\")"}
}

public struct BatchGetStreamKeyOutput: Swift.Sendable {
    ///
    public var errors: [IvsClientTypes.BatchError]?
    ///
    public var streamKeys: [IvsClientTypes.StreamKey]?

    public init(
        errors: [IvsClientTypes.BatchError]? = nil,
        streamKeys: [IvsClientTypes.StreamKey]? = nil
    )
    {
        self.errors = errors
        self.streamKeys = streamKeys
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request was denied due to request throttling.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IvsClientTypes {

    /// A viewer session to revoke in the call to [BatchStartViewerSessionRevocation].
    public struct BatchStartViewerSessionRevocationViewerSession: Swift.Sendable {
        /// The ARN of the channel associated with the viewer session to revoke.
        /// This member is required.
        public var channelArn: Swift.String?
        /// The ID of the viewer associated with the viewer session to revoke. Do not use this field for personally identifying, confidential, or sensitive information.
        /// This member is required.
        public var viewerId: Swift.String?
        /// An optional filter on which versions of the viewer session to revoke. All versions less than or equal to the specified version will be revoked. Default: 0.
        public var viewerSessionVersionsLessThanOrEqualTo: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            viewerId: Swift.String? = nil,
            viewerSessionVersionsLessThanOrEqualTo: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.viewerId = viewerId
            self.viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualTo
        }
    }
}

public struct BatchStartViewerSessionRevocationInput: Swift.Sendable {
    /// Array of viewer sessions, one per channel-ARN and viewer-ID pair.
    /// This member is required.
    public var viewerSessions: [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]?

    public init(
        viewerSessions: [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]? = nil
    )
    {
        self.viewerSessions = viewerSessions
    }
}

extension IvsClientTypes {

    /// Error for a request in the batch for BatchStartViewerSessionRevocation. Each error is related to a specific channel-ARN and viewer-ID pair.
    public struct BatchStartViewerSessionRevocationError: Swift.Sendable {
        /// Channel ARN.
        /// This member is required.
        public var channelArn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?
        /// The ID of the viewer session to revoke.
        /// This member is required.
        public var viewerId: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            viewerId: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.code = code
            self.message = message
            self.viewerId = viewerId
        }
    }
}

public struct BatchStartViewerSessionRevocationOutput: Swift.Sendable {
    /// Each error object is related to a specific channelArn and viewerId pair in the request.
    public var errors: [IvsClientTypes.BatchStartViewerSessionRevocationError]?

    public init(
        errors: [IvsClientTypes.BatchStartViewerSessionRevocationError]? = nil
    )
    {
        self.errors = errors
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

public struct CreateChannelInput: Swift.Sendable {
    /// Whether the channel is private (enabled for playback authorization). Default: false.
    public var authorized: Swift.Bool
    /// Whether the channel allows insecure RTMP and SRT ingest. Default: false.
    public var insecureIngest: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW.
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Playback-restriction-policy ARN. A valid ARN value here both specifies the ARN and enables playback restriction. Default: "" (empty string, no playback restriction policy is applied).
    public var playbackRestrictionPolicyArn: Swift.String?
    /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
    public var preset: IvsClientTypes.TranscodePreset?
    /// Recording-configuration ARN. A valid ARN value here both specifies the ARN and enables recording. Default: "" (empty string, recording is disabled).
    public var recordingConfigurationArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
    public var type: IvsClientTypes.ChannelType?

    public init(
        authorized: Swift.Bool = false,
        insecureIngest: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        playbackRestrictionPolicyArn: Swift.String? = nil,
        preset: IvsClientTypes.TranscodePreset? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.authorized = authorized
        self.insecureIngest = insecureIngest
        self.latencyMode = latencyMode
        self.name = name
        self.playbackRestrictionPolicyArn = playbackRestrictionPolicyArn
        self.preset = preset
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

public struct CreateChannelOutput: Swift.Sendable {
    ///
    public var channel: IvsClientTypes.Channel?
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        channel: IvsClientTypes.Channel? = nil,
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.channel = channel
        self.streamKey = streamKey
    }
}

public struct CreatePlaybackRestrictionPolicyInput: Swift.Sendable {
    /// A list of country codes that control geoblocking restriction. Allowed values are the officially assigned [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes. Default: All countries (an empty array).
    public var allowedCountries: [Swift.String]?
    /// A list of origin sites that control CORS restriction. Allowed values are the same as valid values of the Origin header defined at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). Default: All origins (an empty array).
    public var allowedOrigins: [Swift.String]?
    /// Whether channel playback is constrained by origin site. Default: false.
    public var enableStrictOriginEnforcement: Swift.Bool?
    /// Playback-restriction-policy name. The value does not need to be unique.
    public var name: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedCountries: [Swift.String]? = nil,
        allowedOrigins: [Swift.String]? = nil,
        enableStrictOriginEnforcement: Swift.Bool? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.allowedCountries = allowedCountries
        self.allowedOrigins = allowedOrigins
        self.enableStrictOriginEnforcement = enableStrictOriginEnforcement
        self.name = name
        self.tags = tags
    }
}

extension IvsClientTypes {

    /// An object representing a policy to constrain playback by country and/or origin sites.
    public struct PlaybackRestrictionPolicy: Swift.Sendable {
        /// A list of country codes that control geoblocking restriction. Allowed values are the officially assigned [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes. Default: All countries (an empty array).
        /// This member is required.
        public var allowedCountries: [Swift.String]?
        /// A list of origin sites that control CORS restriction. Allowed values are the same as valid values of the Origin header defined at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). Default: All origins (an empty array).
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// Playback-restriction-policy ARN
        /// This member is required.
        public var arn: Swift.String?
        /// Whether channel playback is constrained by origin site. Default: false.
        public var enableStrictOriginEnforcement: Swift.Bool?
        /// Playback-restriction-policy name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            allowedCountries: [Swift.String]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            enableStrictOriginEnforcement: Swift.Bool? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.allowedCountries = allowedCountries
            self.allowedOrigins = allowedOrigins
            self.arn = arn
            self.enableStrictOriginEnforcement = enableStrictOriginEnforcement
            self.name = name
            self.tags = tags
        }
    }
}

public struct CreatePlaybackRestrictionPolicyOutput: Swift.Sendable {
    ///
    public var playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy?

    public init(
        playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy? = nil
    )
    {
        self.playbackRestrictionPolicy = playbackRestrictionPolicy
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IvsClientTypes {

    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration: Swift.Sendable {
        /// Location (S3 bucket name) where recorded videos will be stored.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }
}

extension IvsClientTypes {

    /// A complex type that describes a location where recorded videos will be stored. Each member represents a type of destination configuration. For recording, you define one and only one type of destination configuration.
    public struct DestinationConfiguration: Swift.Sendable {
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IvsClientTypes.S3DestinationConfiguration?

        public init(
            s3: IvsClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension IvsClientTypes {

    public enum RenditionConfigurationRendition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullHd
        case hd
        case lowestResolution
        case sd
        case sdkUnknown(Swift.String)

        public static var allCases: [RenditionConfigurationRendition] {
            return [
                .fullHd,
                .hd,
                .lowestResolution,
                .sd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullHd: return "FULL_HD"
            case .hd: return "HD"
            case .lowestResolution: return "LOWEST_RESOLUTION"
            case .sd: return "SD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    public enum RenditionConfigurationRenditionSelection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case custom
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RenditionConfigurationRenditionSelection] {
            return [
                .all,
                .custom,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// Object that describes which renditions should be recorded for a stream.
    public struct RenditionConfiguration: Swift.Sendable {
        /// Indicates which set of renditions are recorded for a stream. For BASIC channels, the CUSTOM value has no effect. If CUSTOM is specified, a set of renditions must be specified in the renditions field. Default: ALL.
        public var renditionSelection: IvsClientTypes.RenditionConfigurationRenditionSelection?
        /// Indicates which renditions are recorded for a stream, if renditionSelection is CUSTOM; otherwise, this field is irrelevant. The selected renditions are recorded if they are available during the stream. If a selected rendition is unavailable, the best available rendition is recorded. For details on the resolution dimensions of each rendition, see [Auto-Record to Amazon S3](https://docs.aws.amazon.com/ivs/latest/userguide/record-to-s3.html).
        public var renditions: [IvsClientTypes.RenditionConfigurationRendition]?

        public init(
            renditionSelection: IvsClientTypes.RenditionConfigurationRenditionSelection? = nil,
            renditions: [IvsClientTypes.RenditionConfigurationRendition]? = nil
        )
        {
            self.renditionSelection = renditionSelection
            self.renditions = renditions
        }
    }
}

extension IvsClientTypes {

    public enum RecordingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case interval
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingMode] {
            return [
                .disabled,
                .interval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .interval: return "INTERVAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    public enum ThumbnailConfigurationResolution: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullHd
        case hd
        case lowestResolution
        case sd
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailConfigurationResolution] {
            return [
                .fullHd,
                .hd,
                .lowestResolution,
                .sd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullHd: return "FULL_HD"
            case .hd: return "HD"
            case .lowestResolution: return "LOWEST_RESOLUTION"
            case .sd: return "SD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    public enum ThumbnailConfigurationStorage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latest
        case sequential
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailConfigurationStorage] {
            return [
                .latest,
                .sequential
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .sequential: return "SEQUENTIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// An object representing a configuration of thumbnails for recorded video.
    public struct ThumbnailConfiguration: Swift.Sendable {
        /// Thumbnail recording mode. Default: INTERVAL.
        public var recordingMode: IvsClientTypes.RecordingMode?
        /// Indicates the desired resolution of recorded thumbnails. Thumbnails are recorded at the selected resolution if the corresponding rendition is available during the stream; otherwise, they are recorded at source resolution. For more information about resolution values and their corresponding height and width dimensions, see [Auto-Record to Amazon S3](https://docs.aws.amazon.com/ivs/latest/userguide/record-to-s3.html). Default: Null (source resolution is returned).
        public var resolution: IvsClientTypes.ThumbnailConfigurationResolution?
        /// Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails directory. LATEST saves the latest thumbnail in media/latest_thumbnail/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        public var storage: [IvsClientTypes.ThumbnailConfigurationStorage]?
        /// The targeted thumbnail-generation interval in seconds. This is configurable (and required) only if recordingMode is INTERVAL. Default: 60. Important: For the BASIC channel type, setting a value for targetIntervalSeconds does not guarantee that thumbnails are generated at the specified interval. For thumbnails to be generated at the targetIntervalSeconds interval, the IDR/Keyframe value for the input video must be less than the targetIntervalSeconds value. See [ Amazon IVS Streaming Configuration](https://docs.aws.amazon.com/ivs/latest/userguide/streaming-config.html) for information on setting IDR/Keyframe to the recommended value in video-encoder settings.
        public var targetIntervalSeconds: Swift.Int?

        public init(
            recordingMode: IvsClientTypes.RecordingMode? = nil,
            resolution: IvsClientTypes.ThumbnailConfigurationResolution? = nil,
            storage: [IvsClientTypes.ThumbnailConfigurationStorage]? = nil,
            targetIntervalSeconds: Swift.Int? = nil
        )
        {
            self.recordingMode = recordingMode
            self.resolution = resolution
            self.storage = storage
            self.targetIntervalSeconds = targetIntervalSeconds
        }
    }
}

public struct CreateRecordingConfigurationInput: Swift.Sendable {
    /// A complex type that contains a destination configuration for where recorded video will be stored.
    /// This member is required.
    public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    /// Recording-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
    public var recordingReconnectWindowSeconds: Swift.Int
    /// Object that describes which renditions should be recorded for a stream.
    public var renditionConfiguration: IvsClientTypes.RenditionConfiguration?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?
    /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
    public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

    public init(
        destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        recordingReconnectWindowSeconds: Swift.Int = 0,
        renditionConfiguration: IvsClientTypes.RenditionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
        self.renditionConfiguration = renditionConfiguration
        self.tags = tags
        self.thumbnailConfiguration = thumbnailConfiguration
    }
}

extension IvsClientTypes {

    public enum RecordingConfigurationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createfailed
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationState] {
            return [
                .active,
                .createfailed,
                .creating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createfailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// An object representing a configuration to record a channel stream.
    public struct RecordingConfiguration: Swift.Sendable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
        public var recordingReconnectWindowSeconds: Swift.Int
        /// Object that describes which renditions should be recorded for a stream.
        public var renditionConfiguration: IvsClientTypes.RenditionConfiguration?
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
        public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

        public init(
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            recordingReconnectWindowSeconds: Swift.Int = 0,
            renditionConfiguration: IvsClientTypes.RenditionConfiguration? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
            self.renditionConfiguration = renditionConfiguration
            self.state = state
            self.tags = tags
            self.thumbnailConfiguration = thumbnailConfiguration
        }
    }
}

public struct CreateRecordingConfigurationOutput: Swift.Sendable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init(
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

public struct CreateStreamKeyInput: Swift.Sendable {
    /// ARN of the channel for which to create the stream key.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        channelArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.channelArn = channelArn
        self.tags = tags
    }
}

public struct CreateStreamKeyOutput: Swift.Sendable {
    /// Stream key used to authenticate an RTMPS stream for ingestion.
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

public struct DeleteChannelInput: Swift.Sendable {
    /// ARN of the channel to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePlaybackKeyPairInput: Swift.Sendable {
    /// ARN of the key pair to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePlaybackKeyPairOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePlaybackRestrictionPolicyInput: Swift.Sendable {
    /// ARN of the playback restriction policy to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteRecordingConfigurationInput: Swift.Sendable {
    /// ARN of the recording configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteStreamKeyInput: Swift.Sendable {
    /// ARN of the stream key to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetChannelInput: Swift.Sendable {
    /// ARN of the channel for which the configuration is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetChannelOutput: Swift.Sendable {
    ///
    public var channel: IvsClientTypes.Channel?

    public init(
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

public struct GetPlaybackKeyPairInput: Swift.Sendable {
    /// ARN of the key pair to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension IvsClientTypes {

    /// A key pair used to sign and validate a playback authorization token.
    public struct PlaybackKeyPair: Swift.Sendable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Key-pair identifier.
        public var fingerprint: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.tags = tags
        }
    }
}

public struct GetPlaybackKeyPairOutput: Swift.Sendable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init(
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

public struct GetPlaybackRestrictionPolicyInput: Swift.Sendable {
    /// ARN of the playback restriction policy to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetPlaybackRestrictionPolicyOutput: Swift.Sendable {
    ///
    public var playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy?

    public init(
        playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy? = nil
    )
    {
        self.playbackRestrictionPolicy = playbackRestrictionPolicy
    }
}

public struct GetRecordingConfigurationInput: Swift.Sendable {
    /// ARN of the recording configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetRecordingConfigurationOutput: Swift.Sendable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init(
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

///
public struct ChannelNotBroadcasting: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The stream is offline for the given channel ARN.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelNotBroadcasting" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

public struct GetStreamInput: Swift.Sendable {
    /// Channel ARN for stream to be accessed.
    /// This member is required.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

extension IvsClientTypes {

    public enum StreamHealth: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case starving
        case streamhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamHealth] {
            return [
                .starving,
                .streamhealthy,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .starving: return "STARVING"
            case .streamhealthy: return "HEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    public enum StreamState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case streamlive
        case streamoffline
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamState] {
            return [
                .streamlive,
                .streamoffline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .streamlive: return "LIVE"
            case .streamoffline: return "OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IvsClientTypes {

    /// Specifies a live video stream that has been ingested and distributed.
    public struct Stream: Swift.Sendable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streams health.
        public var health: IvsClientTypes.StreamHealth?
        /// URL of the master playlist, required by the video player to play the HLS stream.
        public var playbackUrl: Swift.String?
        /// Time of the streams start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// The streams state. Do not rely on the OFFLINE state, as the API may not return it; instead, a "NotBroadcasting" error will indicate that the stream is not live.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            playbackUrl: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.playbackUrl = playbackUrl
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }
}

public struct GetStreamOutput: Swift.Sendable {
    ///
    public var stream: IvsClientTypes.Stream?

    public init(
        stream: IvsClientTypes.Stream? = nil
    )
    {
        self.stream = stream
    }
}

public struct GetStreamKeyInput: Swift.Sendable {
    /// ARN for the stream key to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetStreamKeyOutput: Swift.Sendable {
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

public struct GetStreamSessionInput: Swift.Sendable {
    /// ARN of the channel resource
    /// This member is required.
    public var channelArn: Swift.String?
    /// Unique identifier for a live or previously live stream in the specified channel. If no streamId is provided, this returns the most recent stream session for the channel, if it exists.
    public var streamId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.streamId = streamId
    }
}

extension IvsClientTypes {

    /// Object specifying a streams audio configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct AudioConfiguration: Swift.Sendable {
        /// Number of audio channels.
        public var channels: Swift.Int
        /// Codec used for the audio encoding.
        public var codec: Swift.String?
        /// Number of audio samples recorded per second.
        public var sampleRate: Swift.Int
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int

        public init(
            channels: Swift.Int = 0,
            codec: Swift.String? = nil,
            sampleRate: Swift.Int = 0,
            targetBitrate: Swift.Int = 0
        )
        {
            self.channels = channels
            self.codec = codec
            self.sampleRate = sampleRate
            self.targetBitrate = targetBitrate
        }
    }
}

extension IvsClientTypes {

    /// Object specifying a streams video configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct VideoConfiguration: Swift.Sendable {
        /// Indicates the degree of required decoder performance for a profile. Normally this is set automatically by the encoder. For details, see the H.264 specification.
        public var avcLevel: Swift.String?
        /// Indicates to the decoder the requirements for decoding the stream. For definitions of the valid values, see the H.264 specification.
        public var avcProfile: Swift.String?
        /// Codec used for the video encoding.
        public var codec: Swift.String?
        /// Software or hardware used to encode the video.
        public var encoder: Swift.String?
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int
        /// The expected ingest framerate. This is configured in the encoder.
        public var targetFramerate: Swift.Int
        /// Video-resolution height in pixels.
        public var videoHeight: Swift.Int
        /// Video-resolution width in pixels.
        public var videoWidth: Swift.Int

        public init(
            avcLevel: Swift.String? = nil,
            avcProfile: Swift.String? = nil,
            codec: Swift.String? = nil,
            encoder: Swift.String? = nil,
            targetBitrate: Swift.Int = 0,
            targetFramerate: Swift.Int = 0,
            videoHeight: Swift.Int = 0,
            videoWidth: Swift.Int = 0
        )
        {
            self.avcLevel = avcLevel
            self.avcProfile = avcProfile
            self.codec = codec
            self.encoder = encoder
            self.targetBitrate = targetBitrate
            self.targetFramerate = targetFramerate
            self.videoHeight = videoHeight
            self.videoWidth = videoWidth
        }
    }
}

extension IvsClientTypes {

    /// Object specifying the ingest configuration set up by the broadcaster, usually in an encoder.
    public struct IngestConfiguration: Swift.Sendable {
        /// Encoder settings for audio.
        public var audio: IvsClientTypes.AudioConfiguration?
        /// Encoder settings for video.
        public var video: IvsClientTypes.VideoConfiguration?

        public init(
            audio: IvsClientTypes.AudioConfiguration? = nil,
            video: IvsClientTypes.VideoConfiguration? = nil
        )
        {
            self.audio = audio
            self.video = video
        }
    }
}

extension IvsClientTypes {

    /// Object specifying a streams events. For a list of events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
    public struct StreamEvent: Swift.Sendable {
        /// Provides additional details about the stream event. There are several values; note that the long descriptions are provided in the IVS console but not delivered through the IVS API or EventBridge:
        ///
        /// * StreamTakeoverMediaMismatch  The broadcast client attempted to take over with different media properties (e.g., codec, resolution, or video track type) from the original stream.
        ///
        /// * StreamTakeoverInvalidPriority  The broadcast client attempted a takeover with either a priority integer value equal to or lower than the original stream's value or a value outside the allowed range of 1 to 2,147,483,647.
        ///
        /// * StreamTakeoverLimitBreached  The broadcast client reached the maximum allowed takeover attempts for this stream.
        public var code: Swift.String?
        /// Time when the event occurred. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var eventTime: Foundation.Date?
        /// Name that identifies the stream event within a type.
        public var name: Swift.String?
        /// Logical group for certain events.
        public var type: Swift.String?

        public init(
            code: Swift.String? = nil,
            eventTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.code = code
            self.eventTime = eventTime
            self.name = name
            self.type = type
        }
    }
}

extension IvsClientTypes {

    /// Object that captures the Amazon IVS configuration that the customer provisioned, the ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events it encountered.
    public struct StreamSession: Swift.Sendable {
        /// The properties of the channel at the time of going live.
        public var channel: IvsClientTypes.Channel?
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: Foundation.Date?
        /// The properties of the incoming RTMP stream for the stream.
        public var ingestConfiguration: IvsClientTypes.IngestConfiguration?
        /// The properties of recording the live stream.
        public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// List of Amazon IVS events that the stream encountered. The list is sorted by most recent events and contains up to 500 events. For Amazon IVS events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
        public var truncatedEvents: [IvsClientTypes.StreamEvent]?

        public init(
            channel: IvsClientTypes.Channel? = nil,
            endTime: Foundation.Date? = nil,
            ingestConfiguration: IvsClientTypes.IngestConfiguration? = nil,
            recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil,
            startTime: Foundation.Date? = nil,
            streamId: Swift.String? = nil,
            truncatedEvents: [IvsClientTypes.StreamEvent]? = nil
        )
        {
            self.channel = channel
            self.endTime = endTime
            self.ingestConfiguration = ingestConfiguration
            self.recordingConfiguration = recordingConfiguration
            self.startTime = startTime
            self.streamId = streamId
            self.truncatedEvents = truncatedEvents
        }
    }
}

public struct GetStreamSessionOutput: Swift.Sendable {
    /// List of stream details.
    public var streamSession: IvsClientTypes.StreamSession?

    public init(
        streamSession: IvsClientTypes.StreamSession? = nil
    )
    {
        self.streamSession = streamSession
    }
}

public struct ImportPlaybackKeyPairInput: Swift.Sendable {
    /// Playback-key-pair name. The value does not need to be unique.
    public var name: Swift.String?
    /// The public portion of a customer-generated key pair.
    /// This member is required.
    public var publicKeyMaterial: Swift.String?
    /// Any tags provided with the request are added to the playback key pair tags. See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        publicKeyMaterial: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

public struct ImportPlaybackKeyPairOutput: Swift.Sendable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init(
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

public struct ListChannelsInput: Swift.Sendable {
    /// Filters the channel list to match the specified name.
    public var filterByName: Swift.String?
    /// Filters the channel list to match the specified policy.
    public var filterByPlaybackRestrictionPolicyArn: Swift.String?
    /// Filters the channel list to match the specified recording-configuration ARN.
    public var filterByRecordingConfigurationArn: Swift.String?
    /// Maximum number of channels to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first channel to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByName: Swift.String? = nil,
        filterByPlaybackRestrictionPolicyArn: Swift.String? = nil,
        filterByRecordingConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByName = filterByName
        self.filterByPlaybackRestrictionPolicyArn = filterByPlaybackRestrictionPolicyArn
        self.filterByRecordingConfigurationArn = filterByRecordingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a channel.
    public struct ChannelSummary: Swift.Sendable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Whether the channel allows insecure RTMP ingest. Default: false.
        public var insecureIngest: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW.
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Playback-restriction-policy ARN. A valid ARN value here both specifies the ARN and enables playback restriction. Default: "" (empty string, no playback restriction policy is applied).
        public var playbackRestrictionPolicyArn: Swift.String?
        /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
        public var preset: IvsClientTypes.TranscodePreset?
        /// Recording-configuration ARN. A valid ARN value here both specifies the ARN and enables recording. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
        public var type: IvsClientTypes.ChannelType?

        public init(
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            insecureIngest: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            playbackRestrictionPolicyArn: Swift.String? = nil,
            preset: IvsClientTypes.TranscodePreset? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.insecureIngest = insecureIngest
            self.latencyMode = latencyMode
            self.name = name
            self.playbackRestrictionPolicyArn = playbackRestrictionPolicyArn
            self.preset = preset
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
            self.type = type
        }
    }
}

public struct ListChannelsOutput: Swift.Sendable {
    /// List of the matching channels.
    /// This member is required.
    public var channels: [IvsClientTypes.ChannelSummary]?
    /// If there are more channels than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        channels: [IvsClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

public struct ListPlaybackKeyPairsInput: Swift.Sendable {
    /// Maximum number of key pairs to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int?
    /// The first key pair to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a playback key pair.
    public struct PlaybackKeyPairSummary: Swift.Sendable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListPlaybackKeyPairsOutput: Swift.Sendable {
    /// List of key pairs.
    /// This member is required.
    public var keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    /// If there are more key pairs than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyPairs = keyPairs
        self.nextToken = nextToken
    }
}

public struct ListPlaybackRestrictionPoliciesInput: Swift.Sendable {
    /// Maximum number of policies to return. Default: 1.
    public var maxResults: Swift.Int?
    /// The first policy to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a PlaybackRestrictionPolicy.
    public struct PlaybackRestrictionPolicySummary: Swift.Sendable {
        /// A list of country codes that control geoblocking restriction. Allowed values are the officially assigned [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes. Default: All countries (an empty array).
        /// This member is required.
        public var allowedCountries: [Swift.String]?
        /// A list of origin sites that control CORS restriction. Allowed values are the same as valid values of the Origin header defined at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). Default: All origins (an empty array).
        /// This member is required.
        public var allowedOrigins: [Swift.String]?
        /// Playback-restriction-policy ARN
        /// This member is required.
        public var arn: Swift.String?
        /// Whether channel playback is constrained by origin site. Default: false.
        public var enableStrictOriginEnforcement: Swift.Bool?
        /// Playback-restriction-policy name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            allowedCountries: [Swift.String]? = nil,
            allowedOrigins: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            enableStrictOriginEnforcement: Swift.Bool? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.allowedCountries = allowedCountries
            self.allowedOrigins = allowedOrigins
            self.arn = arn
            self.enableStrictOriginEnforcement = enableStrictOriginEnforcement
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListPlaybackRestrictionPoliciesOutput: Swift.Sendable {
    /// If there are more channels than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching policies.
    /// This member is required.
    public var playbackRestrictionPolicies: [IvsClientTypes.PlaybackRestrictionPolicySummary]?

    public init(
        nextToken: Swift.String? = nil,
        playbackRestrictionPolicies: [IvsClientTypes.PlaybackRestrictionPolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.playbackRestrictionPolicies = playbackRestrictionPolicies
    }
}

public struct ListRecordingConfigurationsInput: Swift.Sendable {
    /// Maximum number of recording configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int?
    /// The first recording configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a RecordingConfiguration.
    public struct RecordingConfigurationSummary: Swift.Sendable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.state = state
            self.tags = tags
        }
    }
}

public struct ListRecordingConfigurationsOutput: Swift.Sendable {
    /// If there are more recording configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching recording configurations.
    /// This member is required.
    public var recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recordingConfigurations = recordingConfigurations
    }
}

public struct ListStreamKeysInput: Swift.Sendable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streamKeys to return. Default: 1.
    public var maxResults: Swift.Int?
    /// The first stream key to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a stream key.
    public struct StreamKeySummary: Swift.Sendable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
        }
    }
}

public struct ListStreamKeysOutput: Swift.Sendable {
    /// If there are more stream keys than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream keys.
    /// This member is required.
    public var streamKeys: [IvsClientTypes.StreamKeySummary]?

    public init(
        nextToken: Swift.String? = nil,
        streamKeys: [IvsClientTypes.StreamKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamKeys = streamKeys
    }
}

extension IvsClientTypes {

    /// Object specifying the stream attribute on which to filter.
    public struct StreamFilters: Swift.Sendable {
        /// The streams health.
        public var health: IvsClientTypes.StreamHealth?

        public init(
            health: IvsClientTypes.StreamHealth? = nil
        )
        {
            self.health = health
        }
    }
}

public struct ListStreamsInput: Swift.Sendable {
    /// Filters the stream list to match the specified criterion.
    public var filterBy: IvsClientTypes.StreamFilters?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterBy: IvsClientTypes.StreamFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterBy = filterBy
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a stream.
    public struct StreamSummary: Swift.Sendable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streams health.
        public var health: IvsClientTypes.StreamHealth?
        /// Time of the streams start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// The streams state. Do not rely on the OFFLINE state, as the API may not return it; instead, a "NotBroadcasting" error will indicate that the stream is not live.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            startTime: Foundation.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }
}

public struct ListStreamsOutput: Swift.Sendable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of streams.
    /// This member is required.
    public var streams: [IvsClientTypes.StreamSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [IvsClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

public struct ListStreamSessionsInput: Swift.Sendable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IvsClientTypes {

    /// Summary information about a stream session.
    public struct StreamSessionSummary: Swift.Sendable {
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: Foundation.Date?
        /// If true, this stream encountered a quota breach or failure.
        public var hasErrorEvent: Swift.Bool
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            hasErrorEvent: Swift.Bool = false,
            startTime: Foundation.Date? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.hasErrorEvent = hasErrorEvent
            self.startTime = startTime
            self.streamId = streamId
        }
    }
}

public struct ListStreamSessionsOutput: Swift.Sendable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream sessions.
    /// This member is required.
    public var streamSessions: [IvsClientTypes.StreamSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streamSessions: [IvsClientTypes.StreamSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamSessions = streamSessions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutMetadataInput: Swift.Sendable {
    /// ARN of the channel into which metadata is inserted. This channel must have an active stream.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Metadata to insert into the stream. Maximum: 1 KB per request.
    /// This member is required.
    public var metadata: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.metadata = metadata
    }
}

extension PutMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMetadataInput(channelArn: \(Swift.String(describing: channelArn)), metadata: \"CONTENT_REDACTED\")"}
}

public struct StartViewerSessionRevocationInput: Swift.Sendable {
    /// The ARN of the channel associated with the viewer session to revoke.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ID of the viewer associated with the viewer session to revoke. Do not use this field for personally identifying, confidential, or sensitive information.
    /// This member is required.
    public var viewerId: Swift.String?
    /// An optional filter on which versions of the viewer session to revoke. All versions less than or equal to the specified version will be revoked. Default: 0.
    public var viewerSessionVersionsLessThanOrEqualTo: Swift.Int

    public init(
        channelArn: Swift.String? = nil,
        viewerId: Swift.String? = nil,
        viewerSessionVersionsLessThanOrEqualTo: Swift.Int = 0
    )
    {
        self.channelArn = channelArn
        self.viewerId = viewerId
        self.viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualTo
    }
}

public struct StartViewerSessionRevocationOutput: Swift.Sendable {

    public init() { }
}

///
public struct StreamUnavailable: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The stream is temporarily unavailable.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamUnavailable" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

public struct StopStreamInput: Swift.Sendable {
    /// ARN of the channel for which the stream is to be stopped.
    /// This member is required.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct StopStreamOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// ARN of the resource for which tags are to be added or updated. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// ARN of the resource for which tags are to be removed. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging Amazon Web Services Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateChannelInput: Swift.Sendable {
    /// ARN of the channel to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Whether the channel is private (enabled for playback authorization).
    public var authorized: Swift.Bool
    /// Whether the channel allows insecure RTMP and SRT ingest. Default: false.
    public var insecureIngest: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers.
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Playback-restriction-policy ARN. A valid ARN value here both specifies the ARN and enables playback restriction. If this is set to an empty string, playback restriction policy is disabled.
    public var playbackRestrictionPolicyArn: Swift.String?
    /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
    public var preset: IvsClientTypes.TranscodePreset?
    /// Recording-configuration ARN. A valid ARN value here both specifies the ARN and enables recording. If this is set to an empty string, recording is disabled.
    public var recordingConfigurationArn: Swift.String?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
    public var type: IvsClientTypes.ChannelType?

    public init(
        arn: Swift.String? = nil,
        authorized: Swift.Bool = false,
        insecureIngest: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        playbackRestrictionPolicyArn: Swift.String? = nil,
        preset: IvsClientTypes.TranscodePreset? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.insecureIngest = insecureIngest
        self.latencyMode = latencyMode
        self.name = name
        self.playbackRestrictionPolicyArn = playbackRestrictionPolicyArn
        self.preset = preset
        self.recordingConfigurationArn = recordingConfigurationArn
        self.type = type
    }
}

public struct UpdateChannelOutput: Swift.Sendable {
    /// Object specifying the updated channel.
    public var channel: IvsClientTypes.Channel?

    public init(
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

public struct UpdatePlaybackRestrictionPolicyInput: Swift.Sendable {
    /// A list of country codes that control geoblocking restriction. Allowed values are the officially assigned [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes. Default: All countries (an empty array).
    public var allowedCountries: [Swift.String]?
    /// A list of origin sites that control CORS restriction. Allowed values are the same as valid values of the Origin header defined at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin). Default: All origins (an empty array).
    public var allowedOrigins: [Swift.String]?
    /// ARN of the playback-restriction-policy to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Whether channel playback is constrained by origin site. Default: false.
    public var enableStrictOriginEnforcement: Swift.Bool?
    /// Playback-restriction-policy name. The value does not need to be unique.
    public var name: Swift.String?

    public init(
        allowedCountries: [Swift.String]? = nil,
        allowedOrigins: [Swift.String]? = nil,
        arn: Swift.String? = nil,
        enableStrictOriginEnforcement: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.allowedCountries = allowedCountries
        self.allowedOrigins = allowedOrigins
        self.arn = arn
        self.enableStrictOriginEnforcement = enableStrictOriginEnforcement
        self.name = name
    }
}

public struct UpdatePlaybackRestrictionPolicyOutput: Swift.Sendable {
    /// Object specifying the updated policy.
    public var playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy?

    public init(
        playbackRestrictionPolicy: IvsClientTypes.PlaybackRestrictionPolicy? = nil
    )
    {
        self.playbackRestrictionPolicy = playbackRestrictionPolicy
    }
}

extension BatchGetChannelInput {

    static func urlPathProvider(_ value: BatchGetChannelInput) -> Swift.String? {
        return "/BatchGetChannel"
    }
}

extension BatchGetStreamKeyInput {

    static func urlPathProvider(_ value: BatchGetStreamKeyInput) -> Swift.String? {
        return "/BatchGetStreamKey"
    }
}

extension BatchStartViewerSessionRevocationInput {

    static func urlPathProvider(_ value: BatchStartViewerSessionRevocationInput) -> Swift.String? {
        return "/BatchStartViewerSessionRevocation"
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        return "/CreateChannel"
    }
}

extension CreatePlaybackRestrictionPolicyInput {

    static func urlPathProvider(_ value: CreatePlaybackRestrictionPolicyInput) -> Swift.String? {
        return "/CreatePlaybackRestrictionPolicy"
    }
}

extension CreateRecordingConfigurationInput {

    static func urlPathProvider(_ value: CreateRecordingConfigurationInput) -> Swift.String? {
        return "/CreateRecordingConfiguration"
    }
}

extension CreateStreamKeyInput {

    static func urlPathProvider(_ value: CreateStreamKeyInput) -> Swift.String? {
        return "/CreateStreamKey"
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        return "/DeleteChannel"
    }
}

extension DeletePlaybackKeyPairInput {

    static func urlPathProvider(_ value: DeletePlaybackKeyPairInput) -> Swift.String? {
        return "/DeletePlaybackKeyPair"
    }
}

extension DeletePlaybackRestrictionPolicyInput {

    static func urlPathProvider(_ value: DeletePlaybackRestrictionPolicyInput) -> Swift.String? {
        return "/DeletePlaybackRestrictionPolicy"
    }
}

extension DeleteRecordingConfigurationInput {

    static func urlPathProvider(_ value: DeleteRecordingConfigurationInput) -> Swift.String? {
        return "/DeleteRecordingConfiguration"
    }
}

extension DeleteStreamKeyInput {

    static func urlPathProvider(_ value: DeleteStreamKeyInput) -> Swift.String? {
        return "/DeleteStreamKey"
    }
}

extension GetChannelInput {

    static func urlPathProvider(_ value: GetChannelInput) -> Swift.String? {
        return "/GetChannel"
    }
}

extension GetPlaybackKeyPairInput {

    static func urlPathProvider(_ value: GetPlaybackKeyPairInput) -> Swift.String? {
        return "/GetPlaybackKeyPair"
    }
}

extension GetPlaybackRestrictionPolicyInput {

    static func urlPathProvider(_ value: GetPlaybackRestrictionPolicyInput) -> Swift.String? {
        return "/GetPlaybackRestrictionPolicy"
    }
}

extension GetRecordingConfigurationInput {

    static func urlPathProvider(_ value: GetRecordingConfigurationInput) -> Swift.String? {
        return "/GetRecordingConfiguration"
    }
}

extension GetStreamInput {

    static func urlPathProvider(_ value: GetStreamInput) -> Swift.String? {
        return "/GetStream"
    }
}

extension GetStreamKeyInput {

    static func urlPathProvider(_ value: GetStreamKeyInput) -> Swift.String? {
        return "/GetStreamKey"
    }
}

extension GetStreamSessionInput {

    static func urlPathProvider(_ value: GetStreamSessionInput) -> Swift.String? {
        return "/GetStreamSession"
    }
}

extension ImportPlaybackKeyPairInput {

    static func urlPathProvider(_ value: ImportPlaybackKeyPairInput) -> Swift.String? {
        return "/ImportPlaybackKeyPair"
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/ListChannels"
    }
}

extension ListPlaybackKeyPairsInput {

    static func urlPathProvider(_ value: ListPlaybackKeyPairsInput) -> Swift.String? {
        return "/ListPlaybackKeyPairs"
    }
}

extension ListPlaybackRestrictionPoliciesInput {

    static func urlPathProvider(_ value: ListPlaybackRestrictionPoliciesInput) -> Swift.String? {
        return "/ListPlaybackRestrictionPolicies"
    }
}

extension ListRecordingConfigurationsInput {

    static func urlPathProvider(_ value: ListRecordingConfigurationsInput) -> Swift.String? {
        return "/ListRecordingConfigurations"
    }
}

extension ListStreamKeysInput {

    static func urlPathProvider(_ value: ListStreamKeysInput) -> Swift.String? {
        return "/ListStreamKeys"
    }
}

extension ListStreamsInput {

    static func urlPathProvider(_ value: ListStreamsInput) -> Swift.String? {
        return "/ListStreams"
    }
}

extension ListStreamSessionsInput {

    static func urlPathProvider(_ value: ListStreamSessionsInput) -> Swift.String? {
        return "/ListStreamSessions"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutMetadataInput {

    static func urlPathProvider(_ value: PutMetadataInput) -> Swift.String? {
        return "/PutMetadata"
    }
}

extension StartViewerSessionRevocationInput {

    static func urlPathProvider(_ value: StartViewerSessionRevocationInput) -> Swift.String? {
        return "/StartViewerSessionRevocation"
    }
}

extension StopStreamInput {

    static func urlPathProvider(_ value: StopStreamInput) -> Swift.String? {
        return "/StopStream"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        return "/UpdateChannel"
    }
}

extension UpdatePlaybackRestrictionPolicyInput {

    static func urlPathProvider(_ value: UpdatePlaybackRestrictionPolicyInput) -> Swift.String? {
        return "/UpdatePlaybackRestrictionPolicy"
    }
}

extension BatchGetChannelInput {

    static func write(value: BatchGetChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetStreamKeyInput {

    static func write(value: BatchGetStreamKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arns"].writeList(value.arns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchStartViewerSessionRevocationInput {

    static func write(value: BatchStartViewerSessionRevocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["viewerSessions"].writeList(value.viewerSessions, memberWritingClosure: IvsClientTypes.BatchStartViewerSessionRevocationViewerSession.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authorized"].write(value.authorized)
        try writer["insecureIngest"].write(value.insecureIngest)
        try writer["latencyMode"].write(value.latencyMode)
        try writer["name"].write(value.name)
        try writer["playbackRestrictionPolicyArn"].write(value.playbackRestrictionPolicyArn)
        try writer["preset"].write(value.preset)
        try writer["recordingConfigurationArn"].write(value.recordingConfigurationArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreatePlaybackRestrictionPolicyInput {

    static func write(value: CreatePlaybackRestrictionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedCountries"].writeList(value.allowedCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedOrigins"].writeList(value.allowedOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enableStrictOriginEnforcement"].write(value.enableStrictOriginEnforcement)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRecordingConfigurationInput {

    static func write(value: CreateRecordingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: IvsClientTypes.DestinationConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["recordingReconnectWindowSeconds"].write(value.recordingReconnectWindowSeconds)
        try writer["renditionConfiguration"].write(value.renditionConfiguration, with: IvsClientTypes.RenditionConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["thumbnailConfiguration"].write(value.thumbnailConfiguration, with: IvsClientTypes.ThumbnailConfiguration.write(value:to:))
    }
}

extension CreateStreamKeyInput {

    static func write(value: CreateStreamKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteChannelInput {

    static func write(value: DeleteChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeletePlaybackKeyPairInput {

    static func write(value: DeletePlaybackKeyPairInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeletePlaybackRestrictionPolicyInput {

    static func write(value: DeletePlaybackRestrictionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteRecordingConfigurationInput {

    static func write(value: DeleteRecordingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteStreamKeyInput {

    static func write(value: DeleteStreamKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetChannelInput {

    static func write(value: GetChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetPlaybackKeyPairInput {

    static func write(value: GetPlaybackKeyPairInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetPlaybackRestrictionPolicyInput {

    static func write(value: GetPlaybackRestrictionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetRecordingConfigurationInput {

    static func write(value: GetRecordingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetStreamInput {

    static func write(value: GetStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
    }
}

extension GetStreamKeyInput {

    static func write(value: GetStreamKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetStreamSessionInput {

    static func write(value: GetStreamSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["streamId"].write(value.streamId)
    }
}

extension ImportPlaybackKeyPairInput {

    static func write(value: ImportPlaybackKeyPairInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["publicKeyMaterial"].write(value.publicKeyMaterial)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListChannelsInput {

    static func write(value: ListChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByName"].write(value.filterByName)
        try writer["filterByPlaybackRestrictionPolicyArn"].write(value.filterByPlaybackRestrictionPolicyArn)
        try writer["filterByRecordingConfigurationArn"].write(value.filterByRecordingConfigurationArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListPlaybackKeyPairsInput {

    static func write(value: ListPlaybackKeyPairsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListPlaybackRestrictionPoliciesInput {

    static func write(value: ListPlaybackRestrictionPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRecordingConfigurationsInput {

    static func write(value: ListRecordingConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStreamKeysInput {

    static func write(value: ListStreamKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStreamsInput {

    static func write(value: ListStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterBy"].write(value.filterBy, with: IvsClientTypes.StreamFilters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStreamSessionsInput {

    static func write(value: ListStreamSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension PutMetadataInput {

    static func write(value: PutMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["metadata"].write(value.metadata)
    }
}

extension StartViewerSessionRevocationInput {

    static func write(value: StartViewerSessionRevocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["viewerId"].write(value.viewerId)
        try writer["viewerSessionVersionsLessThanOrEqualTo"].write(value.viewerSessionVersionsLessThanOrEqualTo)
    }
}

extension StopStreamInput {

    static func write(value: StopStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["authorized"].write(value.authorized)
        try writer["insecureIngest"].write(value.insecureIngest)
        try writer["latencyMode"].write(value.latencyMode)
        try writer["name"].write(value.name)
        try writer["playbackRestrictionPolicyArn"].write(value.playbackRestrictionPolicyArn)
        try writer["preset"].write(value.preset)
        try writer["recordingConfigurationArn"].write(value.recordingConfigurationArn)
        try writer["type"].write(value.type)
    }
}

extension UpdatePlaybackRestrictionPolicyInput {

    static func write(value: UpdatePlaybackRestrictionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedCountries"].writeList(value.allowedCountries, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedOrigins"].writeList(value.allowedOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["arn"].write(value.arn)
        try writer["enableStrictOriginEnforcement"].write(value.enableStrictOriginEnforcement)
        try writer["name"].write(value.name)
    }
}

extension BatchGetChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetChannelOutput()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: IvsClientTypes.Channel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IvsClientTypes.BatchError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetStreamKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetStreamKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetStreamKeyOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IvsClientTypes.BatchError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.streamKeys = try reader["streamKeys"].readListIfPresent(memberReadingClosure: IvsClientTypes.StreamKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchStartViewerSessionRevocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchStartViewerSessionRevocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchStartViewerSessionRevocationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IvsClientTypes.BatchStartViewerSessionRevocationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.channel = try reader["channel"].readIfPresent(with: IvsClientTypes.Channel.read(from:))
        value.streamKey = try reader["streamKey"].readIfPresent(with: IvsClientTypes.StreamKey.read(from:))
        return value
    }
}

extension CreatePlaybackRestrictionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePlaybackRestrictionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePlaybackRestrictionPolicyOutput()
        value.playbackRestrictionPolicy = try reader["playbackRestrictionPolicy"].readIfPresent(with: IvsClientTypes.PlaybackRestrictionPolicy.read(from:))
        return value
    }
}

extension CreateRecordingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRecordingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRecordingConfigurationOutput()
        value.recordingConfiguration = try reader["recordingConfiguration"].readIfPresent(with: IvsClientTypes.RecordingConfiguration.read(from:))
        return value
    }
}

extension CreateStreamKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamKeyOutput()
        value.streamKey = try reader["streamKey"].readIfPresent(with: IvsClientTypes.StreamKey.read(from:))
        return value
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeletePlaybackKeyPairOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlaybackKeyPairOutput {
        return DeletePlaybackKeyPairOutput()
    }
}

extension DeletePlaybackRestrictionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlaybackRestrictionPolicyOutput {
        return DeletePlaybackRestrictionPolicyOutput()
    }
}

extension DeleteRecordingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRecordingConfigurationOutput {
        return DeleteRecordingConfigurationOutput()
    }
}

extension DeleteStreamKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamKeyOutput {
        return DeleteStreamKeyOutput()
    }
}

extension GetChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelOutput()
        value.channel = try reader["channel"].readIfPresent(with: IvsClientTypes.Channel.read(from:))
        return value
    }
}

extension GetPlaybackKeyPairOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlaybackKeyPairOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaybackKeyPairOutput()
        value.keyPair = try reader["keyPair"].readIfPresent(with: IvsClientTypes.PlaybackKeyPair.read(from:))
        return value
    }
}

extension GetPlaybackRestrictionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlaybackRestrictionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlaybackRestrictionPolicyOutput()
        value.playbackRestrictionPolicy = try reader["playbackRestrictionPolicy"].readIfPresent(with: IvsClientTypes.PlaybackRestrictionPolicy.read(from:))
        return value
    }
}

extension GetRecordingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecordingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecordingConfigurationOutput()
        value.recordingConfiguration = try reader["recordingConfiguration"].readIfPresent(with: IvsClientTypes.RecordingConfiguration.read(from:))
        return value
    }
}

extension GetStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamOutput()
        value.stream = try reader["stream"].readIfPresent(with: IvsClientTypes.Stream.read(from:))
        return value
    }
}

extension GetStreamKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamKeyOutput()
        value.streamKey = try reader["streamKey"].readIfPresent(with: IvsClientTypes.StreamKey.read(from:))
        return value
    }
}

extension GetStreamSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamSessionOutput()
        value.streamSession = try reader["streamSession"].readIfPresent(with: IvsClientTypes.StreamSession.read(from:))
        return value
    }
}

extension ImportPlaybackKeyPairOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportPlaybackKeyPairOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportPlaybackKeyPairOutput()
        value.keyPair = try reader["keyPair"].readIfPresent(with: IvsClientTypes.PlaybackKeyPair.read(from:))
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["channels"].readListIfPresent(memberReadingClosure: IvsClientTypes.ChannelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPlaybackKeyPairsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlaybackKeyPairsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlaybackKeyPairsOutput()
        value.keyPairs = try reader["keyPairs"].readListIfPresent(memberReadingClosure: IvsClientTypes.PlaybackKeyPairSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPlaybackRestrictionPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlaybackRestrictionPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlaybackRestrictionPoliciesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.playbackRestrictionPolicies = try reader["playbackRestrictionPolicies"].readListIfPresent(memberReadingClosure: IvsClientTypes.PlaybackRestrictionPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRecordingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecordingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecordingConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recordingConfigurations = try reader["recordingConfigurations"].readListIfPresent(memberReadingClosure: IvsClientTypes.RecordingConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStreamKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamKeysOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streamKeys = try reader["streamKeys"].readListIfPresent(memberReadingClosure: IvsClientTypes.StreamKeySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streams = try reader["streams"].readListIfPresent(memberReadingClosure: IvsClientTypes.StreamSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStreamSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streamSessions = try reader["streamSessions"].readListIfPresent(memberReadingClosure: IvsClientTypes.StreamSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PutMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMetadataOutput {
        return PutMetadataOutput()
    }
}

extension StartViewerSessionRevocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartViewerSessionRevocationOutput {
        return StartViewerSessionRevocationOutput()
    }
}

extension StopStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopStreamOutput {
        return StopStreamOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.channel = try reader["channel"].readIfPresent(with: IvsClientTypes.Channel.read(from:))
        return value
    }
}

extension UpdatePlaybackRestrictionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePlaybackRestrictionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePlaybackRestrictionPolicyOutput()
        value.playbackRestrictionPolicy = try reader["playbackRestrictionPolicy"].readIfPresent(with: IvsClientTypes.PlaybackRestrictionPolicy.read(from:))
        return value
    }
}

enum BatchGetChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetStreamKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchStartViewerSessionRevocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePlaybackRestrictionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRecordingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlaybackKeyPairOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlaybackRestrictionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRecordingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlaybackKeyPairOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlaybackRestrictionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecordingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ChannelNotBroadcasting": return try ChannelNotBroadcasting.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportPlaybackKeyPairOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlaybackKeyPairsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlaybackRestrictionPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecordingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ChannelNotBroadcasting": return try ChannelNotBroadcasting.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartViewerSessionRevocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ChannelNotBroadcasting": return try ChannelNotBroadcasting.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "StreamUnavailable": return try StreamUnavailable.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePlaybackRestrictionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PendingVerification {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PendingVerification {
        let reader = baseError.errorBodyReader
        var value = PendingVerification()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChannelNotBroadcasting {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ChannelNotBroadcasting {
        let reader = baseError.errorBodyReader
        var value = ChannelNotBroadcasting()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StreamUnavailable {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StreamUnavailable {
        let reader = baseError.errorBodyReader
        var value = StreamUnavailable()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IvsClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.Channel()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.latencyMode = try reader["latencyMode"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.recordingConfigurationArn = try reader["recordingConfigurationArn"].readIfPresent()
        value.ingestEndpoint = try reader["ingestEndpoint"].readIfPresent()
        value.playbackUrl = try reader["playbackUrl"].readIfPresent()
        value.authorized = try reader["authorized"].readIfPresent() ?? false
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.insecureIngest = try reader["insecureIngest"].readIfPresent() ?? false
        value.preset = try reader["preset"].readIfPresent()
        value.srt = try reader["srt"].readIfPresent(with: IvsClientTypes.Srt.read(from:))
        value.playbackRestrictionPolicyArn = try reader["playbackRestrictionPolicyArn"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.Srt {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.Srt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.Srt()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.passphrase = try reader["passphrase"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.BatchError {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.BatchError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.BatchError()
        value.arn = try reader["arn"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.StreamKey {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamKey()
        value.arn = try reader["arn"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.BatchStartViewerSessionRevocationError {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.BatchStartViewerSessionRevocationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.BatchStartViewerSessionRevocationError()
        value.channelArn = try reader["channelArn"].readIfPresent() ?? ""
        value.viewerId = try reader["viewerId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.PlaybackRestrictionPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.PlaybackRestrictionPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.PlaybackRestrictionPolicy()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.allowedCountries = try reader["allowedCountries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allowedOrigins = try reader["allowedOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.enableStrictOriginEnforcement = try reader["enableStrictOriginEnforcement"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.RecordingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.RecordingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.RecordingConfiguration()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvsClientTypes.DestinationConfiguration.read(from:))
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.thumbnailConfiguration = try reader["thumbnailConfiguration"].readIfPresent(with: IvsClientTypes.ThumbnailConfiguration.read(from:))
        value.recordingReconnectWindowSeconds = try reader["recordingReconnectWindowSeconds"].readIfPresent() ?? 0
        value.renditionConfiguration = try reader["renditionConfiguration"].readIfPresent(with: IvsClientTypes.RenditionConfiguration.read(from:))
        return value
    }
}

extension IvsClientTypes.RenditionConfiguration {

    static func write(value: IvsClientTypes.RenditionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["renditionSelection"].write(value.renditionSelection)
        try writer["renditions"].writeList(value.renditions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IvsClientTypes.RenditionConfigurationRendition>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.RenditionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.RenditionConfiguration()
        value.renditionSelection = try reader["renditionSelection"].readIfPresent()
        value.renditions = try reader["renditions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IvsClientTypes.RenditionConfigurationRendition>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.ThumbnailConfiguration {

    static func write(value: IvsClientTypes.ThumbnailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recordingMode"].write(value.recordingMode)
        try writer["resolution"].write(value.resolution)
        try writer["storage"].writeList(value.storage, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IvsClientTypes.ThumbnailConfigurationStorage>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetIntervalSeconds"].write(value.targetIntervalSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.ThumbnailConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.ThumbnailConfiguration()
        value.recordingMode = try reader["recordingMode"].readIfPresent()
        value.targetIntervalSeconds = try reader["targetIntervalSeconds"].readIfPresent()
        value.resolution = try reader["resolution"].readIfPresent()
        value.storage = try reader["storage"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IvsClientTypes.ThumbnailConfigurationStorage>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.DestinationConfiguration {

    static func write(value: IvsClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3"].write(value.s3, with: IvsClientTypes.S3DestinationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.DestinationConfiguration()
        value.s3 = try reader["s3"].readIfPresent(with: IvsClientTypes.S3DestinationConfiguration.read(from:))
        return value
    }
}

extension IvsClientTypes.S3DestinationConfiguration {

    static func write(value: IvsClientTypes.S3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.S3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.S3DestinationConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        return value
    }
}

extension IvsClientTypes.PlaybackKeyPair {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.PlaybackKeyPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.PlaybackKeyPair()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.fingerprint = try reader["fingerprint"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.Stream {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.Stream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.Stream()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.playbackUrl = try reader["playbackUrl"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.state = try reader["state"].readIfPresent()
        value.health = try reader["health"].readIfPresent()
        value.viewerCount = try reader["viewerCount"].readIfPresent() ?? 0
        return value
    }
}

extension IvsClientTypes.StreamSession {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamSession()
        value.streamId = try reader["streamId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.channel = try reader["channel"].readIfPresent(with: IvsClientTypes.Channel.read(from:))
        value.ingestConfiguration = try reader["ingestConfiguration"].readIfPresent(with: IvsClientTypes.IngestConfiguration.read(from:))
        value.recordingConfiguration = try reader["recordingConfiguration"].readIfPresent(with: IvsClientTypes.RecordingConfiguration.read(from:))
        value.truncatedEvents = try reader["truncatedEvents"].readListIfPresent(memberReadingClosure: IvsClientTypes.StreamEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.StreamEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamEvent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.IngestConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.IngestConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.IngestConfiguration()
        value.video = try reader["video"].readIfPresent(with: IvsClientTypes.VideoConfiguration.read(from:))
        value.audio = try reader["audio"].readIfPresent(with: IvsClientTypes.AudioConfiguration.read(from:))
        return value
    }
}

extension IvsClientTypes.AudioConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.AudioConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.AudioConfiguration()
        value.codec = try reader["codec"].readIfPresent()
        value.targetBitrate = try reader["targetBitrate"].readIfPresent() ?? 0
        value.sampleRate = try reader["sampleRate"].readIfPresent() ?? 0
        value.channels = try reader["channels"].readIfPresent() ?? 0
        return value
    }
}

extension IvsClientTypes.VideoConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.VideoConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.VideoConfiguration()
        value.avcProfile = try reader["avcProfile"].readIfPresent()
        value.avcLevel = try reader["avcLevel"].readIfPresent()
        value.codec = try reader["codec"].readIfPresent()
        value.encoder = try reader["encoder"].readIfPresent()
        value.targetBitrate = try reader["targetBitrate"].readIfPresent() ?? 0
        value.targetFramerate = try reader["targetFramerate"].readIfPresent() ?? 0
        value.videoHeight = try reader["videoHeight"].readIfPresent() ?? 0
        value.videoWidth = try reader["videoWidth"].readIfPresent() ?? 0
        return value
    }
}

extension IvsClientTypes.ChannelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.ChannelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.ChannelSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.latencyMode = try reader["latencyMode"].readIfPresent()
        value.authorized = try reader["authorized"].readIfPresent() ?? false
        value.recordingConfigurationArn = try reader["recordingConfigurationArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.insecureIngest = try reader["insecureIngest"].readIfPresent() ?? false
        value.type = try reader["type"].readIfPresent()
        value.preset = try reader["preset"].readIfPresent()
        value.playbackRestrictionPolicyArn = try reader["playbackRestrictionPolicyArn"].readIfPresent()
        return value
    }
}

extension IvsClientTypes.PlaybackKeyPairSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.PlaybackKeyPairSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.PlaybackKeyPairSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.PlaybackRestrictionPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.PlaybackRestrictionPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.PlaybackRestrictionPolicySummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.allowedCountries = try reader["allowedCountries"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allowedOrigins = try reader["allowedOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.enableStrictOriginEnforcement = try reader["enableStrictOriginEnforcement"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.RecordingConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.RecordingConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.RecordingConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: IvsClientTypes.DestinationConfiguration.read(from:))
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.StreamKeySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamKeySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamKeySummary()
        value.arn = try reader["arn"].readIfPresent()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IvsClientTypes.StreamSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamSummary()
        value.channelArn = try reader["channelArn"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.health = try reader["health"].readIfPresent()
        value.viewerCount = try reader["viewerCount"].readIfPresent() ?? 0
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IvsClientTypes.StreamSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IvsClientTypes.StreamSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IvsClientTypes.StreamSessionSummary()
        value.streamId = try reader["streamId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.hasErrorEvent = try reader["hasErrorEvent"].readIfPresent() ?? false
        return value
    }
}

extension IvsClientTypes.BatchStartViewerSessionRevocationViewerSession {

    static func write(value: IvsClientTypes.BatchStartViewerSessionRevocationViewerSession?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["viewerId"].write(value.viewerId)
        try writer["viewerSessionVersionsLessThanOrEqualTo"].write(value.viewerSessionVersionsLessThanOrEqualTo)
    }
}

extension IvsClientTypes.StreamFilters {

    static func write(value: IvsClientTypes.StreamFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["health"].write(value.health)
    }
}

public enum IvsClientTypes {}
