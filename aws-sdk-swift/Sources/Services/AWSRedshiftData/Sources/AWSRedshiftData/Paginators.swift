//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension RedshiftDataClient {
    /// Paginate over `[DescribeTableOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTableInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTableOutput`
    public func describeTablePaginated(input: DescribeTableInput) -> ClientRuntime.PaginatorSequence<DescribeTableInput, DescribeTableOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTableInput, DescribeTableOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeTable(input:))
    }
}

extension DescribeTableInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTableInput {
        return DescribeTableInput(
            clusterIdentifier: self.clusterIdentifier,
            connectedDatabase: self.connectedDatabase,
            database: self.database,
            dbUser: self.dbUser,
            maxResults: self.maxResults,
            nextToken: token,
            schema: self.schema,
            secretArn: self.secretArn,
            table: self.table,
            workgroupName: self.workgroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTableInput, OperationStackOutput == DescribeTableOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTablePaginated`
    /// to access the nested member `[RedshiftDataClientTypes.ColumnMetadata]`
    /// - Returns: `[RedshiftDataClientTypes.ColumnMetadata]`
    public func columnList() async throws -> [RedshiftDataClientTypes.ColumnMetadata] {
        return try await self.asyncCompactMap { item in item.columnList }
    }
}
extension RedshiftDataClient {
    /// Paginate over `[GetStatementResultOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetStatementResultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetStatementResultOutput`
    public func getStatementResultPaginated(input: GetStatementResultInput) -> ClientRuntime.PaginatorSequence<GetStatementResultInput, GetStatementResultOutput> {
        return ClientRuntime.PaginatorSequence<GetStatementResultInput, GetStatementResultOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getStatementResult(input:))
    }
}

extension GetStatementResultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetStatementResultInput {
        return GetStatementResultInput(
            id: self.id,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetStatementResultInput, OperationStackOutput == GetStatementResultOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getStatementResultPaginated`
    /// to access the nested member `[[RedshiftDataClientTypes.Field]]`
    /// - Returns: `[[RedshiftDataClientTypes.Field]]`
    public func records() async throws -> [[RedshiftDataClientTypes.Field]] {
        return try await self.asyncCompactMap { item in item.records }
    }
}
extension RedshiftDataClient {
    /// Paginate over `[ListDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatabasesOutput`
    public func listDatabasesPaginated(input: ListDatabasesInput) -> ClientRuntime.PaginatorSequence<ListDatabasesInput, ListDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<ListDatabasesInput, ListDatabasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatabases(input:))
    }
}

extension ListDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatabasesInput {
        return ListDatabasesInput(
            clusterIdentifier: self.clusterIdentifier,
            database: self.database,
            dbUser: self.dbUser,
            maxResults: self.maxResults,
            nextToken: token,
            secretArn: self.secretArn,
            workgroupName: self.workgroupName
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatabasesInput, OperationStackOutput == ListDatabasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatabasesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func databases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.databases }
    }
}
extension RedshiftDataClient {
    /// Paginate over `[ListSchemasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutput`
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            clusterIdentifier: self.clusterIdentifier,
            connectedDatabase: self.connectedDatabase,
            database: self.database,
            dbUser: self.dbUser,
            maxResults: self.maxResults,
            nextToken: token,
            schemaPattern: self.schemaPattern,
            secretArn: self.secretArn,
            workgroupName: self.workgroupName
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemasInput, OperationStackOutput == ListSchemasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func schemas() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension RedshiftDataClient {
    /// Paginate over `[ListStatementsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStatementsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStatementsOutput`
    public func listStatementsPaginated(input: ListStatementsInput) -> ClientRuntime.PaginatorSequence<ListStatementsInput, ListStatementsOutput> {
        return ClientRuntime.PaginatorSequence<ListStatementsInput, ListStatementsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStatements(input:))
    }
}

extension ListStatementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStatementsInput {
        return ListStatementsInput(
            maxResults: self.maxResults,
            nextToken: token,
            roleLevel: self.roleLevel,
            statementName: self.statementName,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListStatementsInput, OperationStackOutput == ListStatementsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStatementsPaginated`
    /// to access the nested member `[RedshiftDataClientTypes.StatementData]`
    /// - Returns: `[RedshiftDataClientTypes.StatementData]`
    public func statements() async throws -> [RedshiftDataClientTypes.StatementData] {
        return try await self.asyncCompactMap { item in item.statements }
    }
}
extension RedshiftDataClient {
    /// Paginate over `[ListTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTablesOutput`
    public func listTablesPaginated(input: ListTablesInput) -> ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutput> {
        return ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTables(input:))
    }
}

extension ListTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTablesInput {
        return ListTablesInput(
            clusterIdentifier: self.clusterIdentifier,
            connectedDatabase: self.connectedDatabase,
            database: self.database,
            dbUser: self.dbUser,
            maxResults: self.maxResults,
            nextToken: token,
            schemaPattern: self.schemaPattern,
            secretArn: self.secretArn,
            tablePattern: self.tablePattern,
            workgroupName: self.workgroupName
        )}
}

extension PaginatorSequence where OperationStackInput == ListTablesInput, OperationStackOutput == ListTablesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTablesPaginated`
    /// to access the nested member `[RedshiftDataClientTypes.TableMember]`
    /// - Returns: `[RedshiftDataClientTypes.TableMember]`
    public func tables() async throws -> [RedshiftDataClientTypes.TableMember] {
        return try await self.asyncCompactMap { item in item.tables }
    }
}
