//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension BackupClient {
    /// Paginate over `[ListBackupJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupJobsOutput`
    public func listBackupJobsPaginated(input: ListBackupJobsInput) -> ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupJobsInput, ListBackupJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupJobs(input:))
    }
}

extension ListBackupJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupJobsInput {
        return ListBackupJobsInput(
            byAccountId: self.byAccountId,
            byBackupVaultName: self.byBackupVaultName,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byMessageCategory: self.byMessageCategory,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupJobsInput, OperationStackOutput == ListBackupJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupJobsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupJob]`
    /// - Returns: `[BackupClientTypes.BackupJob]`
    public func backupJobs() async throws -> [BackupClientTypes.BackupJob] {
        return try await self.asyncCompactMap { item in item.backupJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupJobSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupJobSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupJobSummariesOutput`
    public func listBackupJobSummariesPaginated(input: ListBackupJobSummariesInput) -> ClientRuntime.PaginatorSequence<ListBackupJobSummariesInput, ListBackupJobSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupJobSummariesInput, ListBackupJobSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupJobSummaries(input:))
    }
}

extension ListBackupJobSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupJobSummariesInput {
        return ListBackupJobSummariesInput(
            accountId: self.accountId,
            aggregationPeriod: self.aggregationPeriod,
            maxResults: self.maxResults,
            messageCategory: self.messageCategory,
            nextToken: token,
            resourceType: self.resourceType,
            state: self.state
        )}
}
extension BackupClient {
    /// Paginate over `[ListBackupPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlansOutput`
    public func listBackupPlansPaginated(input: ListBackupPlansInput) -> ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlansInput, ListBackupPlansOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupPlans(input:))
    }
}

extension ListBackupPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlansInput {
        return ListBackupPlansInput(
            includeDeleted: self.includeDeleted,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupPlansInput, OperationStackOutput == ListBackupPlansOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlansPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlansList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlansList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanTemplatesOutput`
    public func listBackupPlanTemplatesPaginated(input: ListBackupPlanTemplatesInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanTemplatesInput, ListBackupPlanTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupPlanTemplates(input:))
    }
}

extension ListBackupPlanTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanTemplatesInput {
        return ListBackupPlanTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupPlanTemplatesInput, OperationStackOutput == ListBackupPlanTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanTemplatesPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlanTemplatesListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlanTemplatesListMember]`
    public func backupPlanTemplatesList() async throws -> [BackupClientTypes.BackupPlanTemplatesListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanTemplatesList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupPlanVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupPlanVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupPlanVersionsOutput`
    public func listBackupPlanVersionsPaginated(input: ListBackupPlanVersionsInput) -> ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupPlanVersionsInput, ListBackupPlanVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupPlanVersions(input:))
    }
}

extension ListBackupPlanVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupPlanVersionsInput {
        return ListBackupPlanVersionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupPlanVersionsInput, OperationStackOutput == ListBackupPlanVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupPlanVersionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupPlansListMember]`
    /// - Returns: `[BackupClientTypes.BackupPlansListMember]`
    public func backupPlanVersionsList() async throws -> [BackupClientTypes.BackupPlansListMember] {
        return try await self.asyncCompactMap { item in item.backupPlanVersionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupSelectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupSelectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupSelectionsOutput`
    public func listBackupSelectionsPaginated(input: ListBackupSelectionsInput) -> ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupSelectionsInput, ListBackupSelectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupSelections(input:))
    }
}

extension ListBackupSelectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupSelectionsInput {
        return ListBackupSelectionsInput(
            backupPlanId: self.backupPlanId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupSelectionsInput, OperationStackOutput == ListBackupSelectionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupSelectionsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupSelectionsListMember]`
    /// - Returns: `[BackupClientTypes.BackupSelectionsListMember]`
    public func backupSelectionsList() async throws -> [BackupClientTypes.BackupSelectionsListMember] {
        return try await self.asyncCompactMap { item in item.backupSelectionsList }
    }
}
extension BackupClient {
    /// Paginate over `[ListBackupVaultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBackupVaultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBackupVaultsOutput`
    public func listBackupVaultsPaginated(input: ListBackupVaultsInput) -> ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutput> {
        return ClientRuntime.PaginatorSequence<ListBackupVaultsInput, ListBackupVaultsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBackupVaults(input:))
    }
}

extension ListBackupVaultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBackupVaultsInput {
        return ListBackupVaultsInput(
            byShared: self.byShared,
            byVaultType: self.byVaultType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBackupVaultsInput, OperationStackOutput == ListBackupVaultsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBackupVaultsPaginated`
    /// to access the nested member `[BackupClientTypes.BackupVaultListMember]`
    /// - Returns: `[BackupClientTypes.BackupVaultListMember]`
    public func backupVaultList() async throws -> [BackupClientTypes.BackupVaultListMember] {
        return try await self.asyncCompactMap { item in item.backupVaultList }
    }
}
extension BackupClient {
    /// Paginate over `[ListCopyJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCopyJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCopyJobsOutput`
    public func listCopyJobsPaginated(input: ListCopyJobsInput) -> ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListCopyJobsInput, ListCopyJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCopyJobs(input:))
    }
}

extension ListCopyJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCopyJobsInput {
        return ListCopyJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byDestinationVaultArn: self.byDestinationVaultArn,
            byMessageCategory: self.byMessageCategory,
            byParentJobId: self.byParentJobId,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            byState: self.byState,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCopyJobsInput, OperationStackOutput == ListCopyJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCopyJobsPaginated`
    /// to access the nested member `[BackupClientTypes.CopyJob]`
    /// - Returns: `[BackupClientTypes.CopyJob]`
    public func copyJobs() async throws -> [BackupClientTypes.CopyJob] {
        return try await self.asyncCompactMap { item in item.copyJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListCopyJobSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCopyJobSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCopyJobSummariesOutput`
    public func listCopyJobSummariesPaginated(input: ListCopyJobSummariesInput) -> ClientRuntime.PaginatorSequence<ListCopyJobSummariesInput, ListCopyJobSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListCopyJobSummariesInput, ListCopyJobSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCopyJobSummaries(input:))
    }
}

extension ListCopyJobSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCopyJobSummariesInput {
        return ListCopyJobSummariesInput(
            accountId: self.accountId,
            aggregationPeriod: self.aggregationPeriod,
            maxResults: self.maxResults,
            messageCategory: self.messageCategory,
            nextToken: token,
            resourceType: self.resourceType,
            state: self.state
        )}
}
extension BackupClient {
    /// Paginate over `[ListFrameworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFrameworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFrameworksOutput`
    public func listFrameworksPaginated(input: ListFrameworksInput) -> ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutput> {
        return ClientRuntime.PaginatorSequence<ListFrameworksInput, ListFrameworksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFrameworks(input:))
    }
}

extension ListFrameworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFrameworksInput {
        return ListFrameworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListLegalHoldsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLegalHoldsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLegalHoldsOutput`
    public func listLegalHoldsPaginated(input: ListLegalHoldsInput) -> ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutput> {
        return ClientRuntime.PaginatorSequence<ListLegalHoldsInput, ListLegalHoldsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLegalHolds(input:))
    }
}

extension ListLegalHoldsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLegalHoldsInput {
        return ListLegalHoldsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListLegalHoldsInput, OperationStackOutput == ListLegalHoldsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLegalHoldsPaginated`
    /// to access the nested member `[BackupClientTypes.LegalHold]`
    /// - Returns: `[BackupClientTypes.LegalHold]`
    public func legalHolds() async throws -> [BackupClientTypes.LegalHold] {
        return try await self.asyncCompactMap { item in item.legalHolds }
    }
}
extension BackupClient {
    /// Paginate over `[ListProtectedResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtectedResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtectedResourcesOutput`
    public func listProtectedResourcesPaginated(input: ListProtectedResourcesInput) -> ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListProtectedResourcesInput, ListProtectedResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProtectedResources(input:))
    }
}

extension ListProtectedResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectedResourcesInput {
        return ListProtectedResourcesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListProtectedResourcesInput, OperationStackOutput == ListProtectedResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProtectedResourcesPaginated`
    /// to access the nested member `[BackupClientTypes.ProtectedResource]`
    /// - Returns: `[BackupClientTypes.ProtectedResource]`
    public func results() async throws -> [BackupClientTypes.ProtectedResource] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
extension BackupClient {
    /// Paginate over `[ListProtectedResourcesByBackupVaultOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtectedResourcesByBackupVaultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtectedResourcesByBackupVaultOutput`
    public func listProtectedResourcesByBackupVaultPaginated(input: ListProtectedResourcesByBackupVaultInput) -> ClientRuntime.PaginatorSequence<ListProtectedResourcesByBackupVaultInput, ListProtectedResourcesByBackupVaultOutput> {
        return ClientRuntime.PaginatorSequence<ListProtectedResourcesByBackupVaultInput, ListProtectedResourcesByBackupVaultOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProtectedResourcesByBackupVault(input:))
    }
}

extension ListProtectedResourcesByBackupVaultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectedResourcesByBackupVaultInput {
        return ListProtectedResourcesByBackupVaultInput(
            backupVaultAccountId: self.backupVaultAccountId,
            backupVaultName: self.backupVaultName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListProtectedResourcesByBackupVaultInput, OperationStackOutput == ListProtectedResourcesByBackupVaultOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProtectedResourcesByBackupVaultPaginated`
    /// to access the nested member `[BackupClientTypes.ProtectedResource]`
    /// - Returns: `[BackupClientTypes.ProtectedResource]`
    public func results() async throws -> [BackupClientTypes.ProtectedResource] {
        return try await self.asyncCompactMap { item in item.results }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByBackupVaultOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByBackupVaultInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByBackupVaultOutput`
    public func listRecoveryPointsByBackupVaultPaginated(input: ListRecoveryPointsByBackupVaultInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByBackupVaultInput, ListRecoveryPointsByBackupVaultOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecoveryPointsByBackupVault(input:))
    }
}

extension ListRecoveryPointsByBackupVaultInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByBackupVaultInput {
        return ListRecoveryPointsByBackupVaultInput(
            backupVaultAccountId: self.backupVaultAccountId,
            backupVaultName: self.backupVaultName,
            byBackupPlanId: self.byBackupPlanId,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byParentRecoveryPointArn: self.byParentRecoveryPointArn,
            byResourceArn: self.byResourceArn,
            byResourceType: self.byResourceType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecoveryPointsByBackupVaultInput, OperationStackOutput == ListRecoveryPointsByBackupVaultOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByBackupVaultPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByBackupVault]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByBackupVault]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByBackupVault] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByLegalHoldOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByLegalHoldInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByLegalHoldOutput`
    public func listRecoveryPointsByLegalHoldPaginated(input: ListRecoveryPointsByLegalHoldInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByLegalHoldInput, ListRecoveryPointsByLegalHoldOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecoveryPointsByLegalHold(input:))
    }
}

extension ListRecoveryPointsByLegalHoldInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByLegalHoldInput {
        return ListRecoveryPointsByLegalHoldInput(
            legalHoldId: self.legalHoldId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecoveryPointsByLegalHoldInput, OperationStackOutput == ListRecoveryPointsByLegalHoldOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByLegalHoldPaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointMember]`
    /// - Returns: `[BackupClientTypes.RecoveryPointMember]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointMember] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListRecoveryPointsByResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryPointsByResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryPointsByResourceOutput`
    public func listRecoveryPointsByResourcePaginated(input: ListRecoveryPointsByResourceInput) -> ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryPointsByResourceInput, ListRecoveryPointsByResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecoveryPointsByResource(input:))
    }
}

extension ListRecoveryPointsByResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryPointsByResourceInput {
        return ListRecoveryPointsByResourceInput(
            managedByAWSBackupOnly: self.managedByAWSBackupOnly,
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecoveryPointsByResourceInput, OperationStackOutput == ListRecoveryPointsByResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryPointsByResourcePaginated`
    /// to access the nested member `[BackupClientTypes.RecoveryPointByResource]`
    /// - Returns: `[BackupClientTypes.RecoveryPointByResource]`
    public func recoveryPoints() async throws -> [BackupClientTypes.RecoveryPointByResource] {
        return try await self.asyncCompactMap { item in item.recoveryPoints }
    }
}
extension BackupClient {
    /// Paginate over `[ListReportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportJobsOutput`
    public func listReportJobsPaginated(input: ListReportJobsInput) -> ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListReportJobsInput, ListReportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReportJobs(input:))
    }
}

extension ListReportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportJobsInput {
        return ListReportJobsInput(
            byCreationAfter: self.byCreationAfter,
            byCreationBefore: self.byCreationBefore,
            byReportPlanName: self.byReportPlanName,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListReportPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReportPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReportPlansOutput`
    public func listReportPlansPaginated(input: ListReportPlansInput) -> ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListReportPlansInput, ListReportPlansOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReportPlans(input:))
    }
}

extension ListReportPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReportPlansInput {
        return ListReportPlansInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension BackupClient {
    /// Paginate over `[ListRestoreJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreJobsOutput`
    public func listRestoreJobsPaginated(input: ListRestoreJobsInput) -> ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreJobsInput, ListRestoreJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRestoreJobs(input:))
    }
}

extension ListRestoreJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreJobsInput {
        return ListRestoreJobsInput(
            byAccountId: self.byAccountId,
            byCompleteAfter: self.byCompleteAfter,
            byCompleteBefore: self.byCompleteBefore,
            byCreatedAfter: self.byCreatedAfter,
            byCreatedBefore: self.byCreatedBefore,
            byResourceType: self.byResourceType,
            byRestoreTestingPlanArn: self.byRestoreTestingPlanArn,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRestoreJobsInput, OperationStackOutput == ListRestoreJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreJobsPaginated`
    /// to access the nested member `[BackupClientTypes.RestoreJobsListMember]`
    /// - Returns: `[BackupClientTypes.RestoreJobsListMember]`
    public func restoreJobs() async throws -> [BackupClientTypes.RestoreJobsListMember] {
        return try await self.asyncCompactMap { item in item.restoreJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListRestoreJobsByProtectedResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreJobsByProtectedResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreJobsByProtectedResourceOutput`
    public func listRestoreJobsByProtectedResourcePaginated(input: ListRestoreJobsByProtectedResourceInput) -> ClientRuntime.PaginatorSequence<ListRestoreJobsByProtectedResourceInput, ListRestoreJobsByProtectedResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreJobsByProtectedResourceInput, ListRestoreJobsByProtectedResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRestoreJobsByProtectedResource(input:))
    }
}

extension ListRestoreJobsByProtectedResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreJobsByProtectedResourceInput {
        return ListRestoreJobsByProtectedResourceInput(
            byRecoveryPointCreationDateAfter: self.byRecoveryPointCreationDateAfter,
            byRecoveryPointCreationDateBefore: self.byRecoveryPointCreationDateBefore,
            byStatus: self.byStatus,
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListRestoreJobsByProtectedResourceInput, OperationStackOutput == ListRestoreJobsByProtectedResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreJobsByProtectedResourcePaginated`
    /// to access the nested member `[BackupClientTypes.RestoreJobsListMember]`
    /// - Returns: `[BackupClientTypes.RestoreJobsListMember]`
    public func restoreJobs() async throws -> [BackupClientTypes.RestoreJobsListMember] {
        return try await self.asyncCompactMap { item in item.restoreJobs }
    }
}
extension BackupClient {
    /// Paginate over `[ListRestoreJobSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreJobSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreJobSummariesOutput`
    public func listRestoreJobSummariesPaginated(input: ListRestoreJobSummariesInput) -> ClientRuntime.PaginatorSequence<ListRestoreJobSummariesInput, ListRestoreJobSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreJobSummariesInput, ListRestoreJobSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRestoreJobSummaries(input:))
    }
}

extension ListRestoreJobSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreJobSummariesInput {
        return ListRestoreJobSummariesInput(
            accountId: self.accountId,
            aggregationPeriod: self.aggregationPeriod,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType,
            state: self.state
        )}
}
extension BackupClient {
    /// Paginate over `[ListRestoreTestingPlansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreTestingPlansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreTestingPlansOutput`
    public func listRestoreTestingPlansPaginated(input: ListRestoreTestingPlansInput) -> ClientRuntime.PaginatorSequence<ListRestoreTestingPlansInput, ListRestoreTestingPlansOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreTestingPlansInput, ListRestoreTestingPlansOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRestoreTestingPlans(input:))
    }
}

extension ListRestoreTestingPlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreTestingPlansInput {
        return ListRestoreTestingPlansInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRestoreTestingPlansInput, OperationStackOutput == ListRestoreTestingPlansOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreTestingPlansPaginated`
    /// to access the nested member `[BackupClientTypes.RestoreTestingPlanForList]`
    /// - Returns: `[BackupClientTypes.RestoreTestingPlanForList]`
    public func restoreTestingPlans() async throws -> [BackupClientTypes.RestoreTestingPlanForList] {
        return try await self.asyncCompactMap { item in item.restoreTestingPlans }
    }
}
extension BackupClient {
    /// Paginate over `[ListRestoreTestingSelectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRestoreTestingSelectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRestoreTestingSelectionsOutput`
    public func listRestoreTestingSelectionsPaginated(input: ListRestoreTestingSelectionsInput) -> ClientRuntime.PaginatorSequence<ListRestoreTestingSelectionsInput, ListRestoreTestingSelectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListRestoreTestingSelectionsInput, ListRestoreTestingSelectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRestoreTestingSelections(input:))
    }
}

extension ListRestoreTestingSelectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRestoreTestingSelectionsInput {
        return ListRestoreTestingSelectionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            restoreTestingPlanName: self.restoreTestingPlanName
        )}
}

extension PaginatorSequence where OperationStackInput == ListRestoreTestingSelectionsInput, OperationStackOutput == ListRestoreTestingSelectionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRestoreTestingSelectionsPaginated`
    /// to access the nested member `[BackupClientTypes.RestoreTestingSelectionForList]`
    /// - Returns: `[BackupClientTypes.RestoreTestingSelectionForList]`
    public func restoreTestingSelections() async throws -> [BackupClientTypes.RestoreTestingSelectionForList] {
        return try await self.asyncCompactMap { item in item.restoreTestingSelections }
    }
}
extension BackupClient {
    /// Paginate over `[ListTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsOutput`
    public func listTagsPaginated(input: ListTagsInput) -> ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsInput, ListTagsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTags(input:))
    }
}

extension ListTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsInput {
        return ListTagsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}
