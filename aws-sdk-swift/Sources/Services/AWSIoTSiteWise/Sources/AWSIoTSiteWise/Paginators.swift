//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension IoTSiteWiseClient {
    /// Paginate over `[BatchGetAssetPropertyAggregatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[BatchGetAssetPropertyAggregatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `BatchGetAssetPropertyAggregatesOutput`
    public func batchGetAssetPropertyAggregatesPaginated(input: BatchGetAssetPropertyAggregatesInput) -> ClientRuntime.PaginatorSequence<BatchGetAssetPropertyAggregatesInput, BatchGetAssetPropertyAggregatesOutput> {
        return ClientRuntime.PaginatorSequence<BatchGetAssetPropertyAggregatesInput, BatchGetAssetPropertyAggregatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.batchGetAssetPropertyAggregates(input:))
    }
}

extension BatchGetAssetPropertyAggregatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> BatchGetAssetPropertyAggregatesInput {
        return BatchGetAssetPropertyAggregatesInput(
            entries: self.entries,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension IoTSiteWiseClient {
    /// Paginate over `[BatchGetAssetPropertyValueOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[BatchGetAssetPropertyValueInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `BatchGetAssetPropertyValueOutput`
    public func batchGetAssetPropertyValuePaginated(input: BatchGetAssetPropertyValueInput) -> ClientRuntime.PaginatorSequence<BatchGetAssetPropertyValueInput, BatchGetAssetPropertyValueOutput> {
        return ClientRuntime.PaginatorSequence<BatchGetAssetPropertyValueInput, BatchGetAssetPropertyValueOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.batchGetAssetPropertyValue(input:))
    }
}

extension BatchGetAssetPropertyValueInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> BatchGetAssetPropertyValueInput {
        return BatchGetAssetPropertyValueInput(
            entries: self.entries,
            nextToken: token
        )}
}
extension IoTSiteWiseClient {
    /// Paginate over `[BatchGetAssetPropertyValueHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[BatchGetAssetPropertyValueHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `BatchGetAssetPropertyValueHistoryOutput`
    public func batchGetAssetPropertyValueHistoryPaginated(input: BatchGetAssetPropertyValueHistoryInput) -> ClientRuntime.PaginatorSequence<BatchGetAssetPropertyValueHistoryInput, BatchGetAssetPropertyValueHistoryOutput> {
        return ClientRuntime.PaginatorSequence<BatchGetAssetPropertyValueHistoryInput, BatchGetAssetPropertyValueHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.batchGetAssetPropertyValueHistory(input:))
    }
}

extension BatchGetAssetPropertyValueHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> BatchGetAssetPropertyValueHistoryInput {
        return BatchGetAssetPropertyValueHistoryInput(
            entries: self.entries,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension IoTSiteWiseClient {
    /// Paginate over `[ExecuteQueryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ExecuteQueryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ExecuteQueryOutput`
    public func executeQueryPaginated(input: ExecuteQueryInput) -> ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput> {
        return ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.executeQuery(input:))
    }
}

extension ExecuteQueryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ExecuteQueryInput {
        return ExecuteQueryInput(
            maxResults: self.maxResults,
            nextToken: token,
            queryStatement: self.queryStatement
        )}
}

extension PaginatorSequence where OperationStackInput == ExecuteQueryInput, OperationStackOutput == ExecuteQueryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `executeQueryPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.Row]`
    /// - Returns: `[IoTSiteWiseClientTypes.Row]`
    public func rows() async throws -> [IoTSiteWiseClientTypes.Row] {
        return try await self.asyncCompactMap { item in item.rows }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[GetAssetPropertyAggregatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetAssetPropertyAggregatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetAssetPropertyAggregatesOutput`
    public func getAssetPropertyAggregatesPaginated(input: GetAssetPropertyAggregatesInput) -> ClientRuntime.PaginatorSequence<GetAssetPropertyAggregatesInput, GetAssetPropertyAggregatesOutput> {
        return ClientRuntime.PaginatorSequence<GetAssetPropertyAggregatesInput, GetAssetPropertyAggregatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getAssetPropertyAggregates(input:))
    }
}

extension GetAssetPropertyAggregatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAssetPropertyAggregatesInput {
        return GetAssetPropertyAggregatesInput(
            aggregateTypes: self.aggregateTypes,
            assetId: self.assetId,
            endDate: self.endDate,
            maxResults: self.maxResults,
            nextToken: token,
            propertyAlias: self.propertyAlias,
            propertyId: self.propertyId,
            qualities: self.qualities,
            resolution: self.resolution,
            startDate: self.startDate,
            timeOrdering: self.timeOrdering
        )}
}

extension PaginatorSequence where OperationStackInput == GetAssetPropertyAggregatesInput, OperationStackOutput == GetAssetPropertyAggregatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getAssetPropertyAggregatesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AggregatedValue]`
    /// - Returns: `[IoTSiteWiseClientTypes.AggregatedValue]`
    public func aggregatedValues() async throws -> [IoTSiteWiseClientTypes.AggregatedValue] {
        return try await self.asyncCompactMap { item in item.aggregatedValues }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[GetAssetPropertyValueHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetAssetPropertyValueHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetAssetPropertyValueHistoryOutput`
    public func getAssetPropertyValueHistoryPaginated(input: GetAssetPropertyValueHistoryInput) -> ClientRuntime.PaginatorSequence<GetAssetPropertyValueHistoryInput, GetAssetPropertyValueHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetAssetPropertyValueHistoryInput, GetAssetPropertyValueHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getAssetPropertyValueHistory(input:))
    }
}

extension GetAssetPropertyValueHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetAssetPropertyValueHistoryInput {
        return GetAssetPropertyValueHistoryInput(
            assetId: self.assetId,
            endDate: self.endDate,
            maxResults: self.maxResults,
            nextToken: token,
            propertyAlias: self.propertyAlias,
            propertyId: self.propertyId,
            qualities: self.qualities,
            startDate: self.startDate,
            timeOrdering: self.timeOrdering
        )}
}

extension PaginatorSequence where OperationStackInput == GetAssetPropertyValueHistoryInput, OperationStackOutput == GetAssetPropertyValueHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getAssetPropertyValueHistoryPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetPropertyValue]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetPropertyValue]`
    public func assetPropertyValueHistory() async throws -> [IoTSiteWiseClientTypes.AssetPropertyValue] {
        return try await self.asyncCompactMap { item in item.assetPropertyValueHistory }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[GetInterpolatedAssetPropertyValuesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetInterpolatedAssetPropertyValuesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetInterpolatedAssetPropertyValuesOutput`
    public func getInterpolatedAssetPropertyValuesPaginated(input: GetInterpolatedAssetPropertyValuesInput) -> ClientRuntime.PaginatorSequence<GetInterpolatedAssetPropertyValuesInput, GetInterpolatedAssetPropertyValuesOutput> {
        return ClientRuntime.PaginatorSequence<GetInterpolatedAssetPropertyValuesInput, GetInterpolatedAssetPropertyValuesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getInterpolatedAssetPropertyValues(input:))
    }
}

extension GetInterpolatedAssetPropertyValuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInterpolatedAssetPropertyValuesInput {
        return GetInterpolatedAssetPropertyValuesInput(
            assetId: self.assetId,
            endTimeInSeconds: self.endTimeInSeconds,
            endTimeOffsetInNanos: self.endTimeOffsetInNanos,
            intervalInSeconds: self.intervalInSeconds,
            intervalWindowInSeconds: self.intervalWindowInSeconds,
            maxResults: self.maxResults,
            nextToken: token,
            propertyAlias: self.propertyAlias,
            propertyId: self.propertyId,
            quality: self.quality,
            startTimeInSeconds: self.startTimeInSeconds,
            startTimeOffsetInNanos: self.startTimeOffsetInNanos,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == GetInterpolatedAssetPropertyValuesInput, OperationStackOutput == GetInterpolatedAssetPropertyValuesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getInterpolatedAssetPropertyValuesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]`
    /// - Returns: `[IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]`
    public func interpolatedAssetPropertyValues() async throws -> [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue] {
        return try await self.asyncCompactMap { item in item.interpolatedAssetPropertyValues }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAccessPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccessPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccessPoliciesOutput`
    public func listAccessPoliciesPaginated(input: ListAccessPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAccessPoliciesInput, ListAccessPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListAccessPoliciesInput, ListAccessPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAccessPolicies(input:))
    }
}

extension ListAccessPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessPoliciesInput {
        return ListAccessPoliciesInput(
            iamArn: self.iamArn,
            identityId: self.identityId,
            identityType: self.identityType,
            maxResults: self.maxResults,
            nextToken: token,
            resourceId: self.resourceId,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccessPoliciesInput, OperationStackOutput == ListAccessPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccessPoliciesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AccessPolicySummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AccessPolicySummary]`
    public func accessPolicySummaries() async throws -> [IoTSiteWiseClientTypes.AccessPolicySummary] {
        return try await self.asyncCompactMap { item in item.accessPolicySummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetModelCompositeModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetModelCompositeModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetModelCompositeModelsOutput`
    public func listAssetModelCompositeModelsPaginated(input: ListAssetModelCompositeModelsInput) -> ClientRuntime.PaginatorSequence<ListAssetModelCompositeModelsInput, ListAssetModelCompositeModelsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetModelCompositeModelsInput, ListAssetModelCompositeModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetModelCompositeModels(input:))
    }
}

extension ListAssetModelCompositeModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetModelCompositeModelsInput {
        return ListAssetModelCompositeModelsInput(
            assetModelId: self.assetModelId,
            assetModelVersion: self.assetModelVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetModelCompositeModelsInput, OperationStackOutput == ListAssetModelCompositeModelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetModelCompositeModelsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]`
    public func assetModelCompositeModelSummaries() async throws -> [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary] {
        return try await self.asyncCompactMap { item in item.assetModelCompositeModelSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetModelPropertiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetModelPropertiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetModelPropertiesOutput`
    public func listAssetModelPropertiesPaginated(input: ListAssetModelPropertiesInput) -> ClientRuntime.PaginatorSequence<ListAssetModelPropertiesInput, ListAssetModelPropertiesOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetModelPropertiesInput, ListAssetModelPropertiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetModelProperties(input:))
    }
}

extension ListAssetModelPropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetModelPropertiesInput {
        return ListAssetModelPropertiesInput(
            assetModelId: self.assetModelId,
            assetModelVersion: self.assetModelVersion,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetModelPropertiesInput, OperationStackOutput == ListAssetModelPropertiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetModelPropertiesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetModelPropertySummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetModelPropertySummary]`
    public func assetModelPropertySummaries() async throws -> [IoTSiteWiseClientTypes.AssetModelPropertySummary] {
        return try await self.asyncCompactMap { item in item.assetModelPropertySummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetModelsOutput`
    public func listAssetModelsPaginated(input: ListAssetModelsInput) -> ClientRuntime.PaginatorSequence<ListAssetModelsInput, ListAssetModelsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetModelsInput, ListAssetModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetModels(input:))
    }
}

extension ListAssetModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetModelsInput {
        return ListAssetModelsInput(
            assetModelTypes: self.assetModelTypes,
            assetModelVersion: self.assetModelVersion,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetModelsInput, OperationStackOutput == ListAssetModelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetModelsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetModelSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetModelSummary]`
    public func assetModelSummaries() async throws -> [IoTSiteWiseClientTypes.AssetModelSummary] {
        return try await self.asyncCompactMap { item in item.assetModelSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetPropertiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetPropertiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetPropertiesOutput`
    public func listAssetPropertiesPaginated(input: ListAssetPropertiesInput) -> ClientRuntime.PaginatorSequence<ListAssetPropertiesInput, ListAssetPropertiesOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetPropertiesInput, ListAssetPropertiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetProperties(input:))
    }
}

extension ListAssetPropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetPropertiesInput {
        return ListAssetPropertiesInput(
            assetId: self.assetId,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetPropertiesInput, OperationStackOutput == ListAssetPropertiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetPropertiesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetPropertySummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetPropertySummary]`
    public func assetPropertySummaries() async throws -> [IoTSiteWiseClientTypes.AssetPropertySummary] {
        return try await self.asyncCompactMap { item in item.assetPropertySummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetRelationshipsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetRelationshipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetRelationshipsOutput`
    public func listAssetRelationshipsPaginated(input: ListAssetRelationshipsInput) -> ClientRuntime.PaginatorSequence<ListAssetRelationshipsInput, ListAssetRelationshipsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetRelationshipsInput, ListAssetRelationshipsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetRelationships(input:))
    }
}

extension ListAssetRelationshipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetRelationshipsInput {
        return ListAssetRelationshipsInput(
            assetId: self.assetId,
            maxResults: self.maxResults,
            nextToken: token,
            traversalType: self.traversalType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetRelationshipsInput, OperationStackOutput == ListAssetRelationshipsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetRelationshipsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetRelationshipSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetRelationshipSummary]`
    public func assetRelationshipSummaries() async throws -> [IoTSiteWiseClientTypes.AssetRelationshipSummary] {
        return try await self.asyncCompactMap { item in item.assetRelationshipSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetsOutput`
    public func listAssetsPaginated(input: ListAssetsInput) -> ClientRuntime.PaginatorSequence<ListAssetsInput, ListAssetsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetsInput, ListAssetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssets(input:))
    }
}

extension ListAssetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetsInput {
        return ListAssetsInput(
            assetModelId: self.assetModelId,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetsInput, OperationStackOutput == ListAssetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssetSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssetSummary]`
    public func assetSummaries() async throws -> [IoTSiteWiseClientTypes.AssetSummary] {
        return try await self.asyncCompactMap { item in item.assetSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListAssociatedAssetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssociatedAssetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssociatedAssetsOutput`
    public func listAssociatedAssetsPaginated(input: ListAssociatedAssetsInput) -> ClientRuntime.PaginatorSequence<ListAssociatedAssetsInput, ListAssociatedAssetsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssociatedAssetsInput, ListAssociatedAssetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssociatedAssets(input:))
    }
}

extension ListAssociatedAssetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssociatedAssetsInput {
        return ListAssociatedAssetsInput(
            assetId: self.assetId,
            hierarchyId: self.hierarchyId,
            maxResults: self.maxResults,
            nextToken: token,
            traversalDirection: self.traversalDirection
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssociatedAssetsInput, OperationStackOutput == ListAssociatedAssetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssociatedAssetsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.AssociatedAssetsSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.AssociatedAssetsSummary]`
    public func assetSummaries() async throws -> [IoTSiteWiseClientTypes.AssociatedAssetsSummary] {
        return try await self.asyncCompactMap { item in item.assetSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListBulkImportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBulkImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBulkImportJobsOutput`
    public func listBulkImportJobsPaginated(input: ListBulkImportJobsInput) -> ClientRuntime.PaginatorSequence<ListBulkImportJobsInput, ListBulkImportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListBulkImportJobsInput, ListBulkImportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBulkImportJobs(input:))
    }
}

extension ListBulkImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBulkImportJobsInput {
        return ListBulkImportJobsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBulkImportJobsInput, OperationStackOutput == ListBulkImportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBulkImportJobsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.JobSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.JobSummary]`
    public func jobSummaries() async throws -> [IoTSiteWiseClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListCompositionRelationshipsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCompositionRelationshipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCompositionRelationshipsOutput`
    public func listCompositionRelationshipsPaginated(input: ListCompositionRelationshipsInput) -> ClientRuntime.PaginatorSequence<ListCompositionRelationshipsInput, ListCompositionRelationshipsOutput> {
        return ClientRuntime.PaginatorSequence<ListCompositionRelationshipsInput, ListCompositionRelationshipsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCompositionRelationships(input:))
    }
}

extension ListCompositionRelationshipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCompositionRelationshipsInput {
        return ListCompositionRelationshipsInput(
            assetModelId: self.assetModelId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCompositionRelationshipsInput, OperationStackOutput == ListCompositionRelationshipsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCompositionRelationshipsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.CompositionRelationshipSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.CompositionRelationshipSummary]`
    public func compositionRelationshipSummaries() async throws -> [IoTSiteWiseClientTypes.CompositionRelationshipSummary] {
        return try await self.asyncCompactMap { item in item.compositionRelationshipSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListDashboardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardsOutput`
    public func listDashboardsPaginated(input: ListDashboardsInput) -> ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutput> {
        return ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDashboards(input:))
    }
}

extension ListDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardsInput {
        return ListDashboardsInput(
            maxResults: self.maxResults,
            nextToken: token,
            projectId: self.projectId
        )}
}

extension PaginatorSequence where OperationStackInput == ListDashboardsInput, OperationStackOutput == ListDashboardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.DashboardSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.DashboardSummary]`
    public func dashboardSummaries() async throws -> [IoTSiteWiseClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListGatewaysOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGatewaysInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGatewaysOutput`
    public func listGatewaysPaginated(input: ListGatewaysInput) -> ClientRuntime.PaginatorSequence<ListGatewaysInput, ListGatewaysOutput> {
        return ClientRuntime.PaginatorSequence<ListGatewaysInput, ListGatewaysOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGateways(input:))
    }
}

extension ListGatewaysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGatewaysInput {
        return ListGatewaysInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListGatewaysInput, OperationStackOutput == ListGatewaysOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGatewaysPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.GatewaySummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.GatewaySummary]`
    public func gatewaySummaries() async throws -> [IoTSiteWiseClientTypes.GatewaySummary] {
        return try await self.asyncCompactMap { item in item.gatewaySummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListPortalsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPortalsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPortalsOutput`
    public func listPortalsPaginated(input: ListPortalsInput) -> ClientRuntime.PaginatorSequence<ListPortalsInput, ListPortalsOutput> {
        return ClientRuntime.PaginatorSequence<ListPortalsInput, ListPortalsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPortals(input:))
    }
}

extension ListPortalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPortalsInput {
        return ListPortalsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPortalsInput, OperationStackOutput == ListPortalsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPortalsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.PortalSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.PortalSummary]`
    public func portalSummaries() async throws -> [IoTSiteWiseClientTypes.PortalSummary] {
        return try await self.asyncCompactMap { item in item.portalSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListProjectAssetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectAssetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectAssetsOutput`
    public func listProjectAssetsPaginated(input: ListProjectAssetsInput) -> ClientRuntime.PaginatorSequence<ListProjectAssetsInput, ListProjectAssetsOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectAssetsInput, ListProjectAssetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProjectAssets(input:))
    }
}

extension ListProjectAssetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectAssetsInput {
        return ListProjectAssetsInput(
            maxResults: self.maxResults,
            nextToken: token,
            projectId: self.projectId
        )}
}

extension PaginatorSequence where OperationStackInput == ListProjectAssetsInput, OperationStackOutput == ListProjectAssetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProjectAssetsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func assetIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.assetIds }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectsOutput`
    public func listProjectsPaginated(input: ListProjectsInput) -> ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProjects(input:))
    }
}

extension ListProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectsInput {
        return ListProjectsInput(
            maxResults: self.maxResults,
            nextToken: token,
            portalId: self.portalId
        )}
}

extension PaginatorSequence where OperationStackInput == ListProjectsInput, OperationStackOutput == ListProjectsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProjectsPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.ProjectSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.ProjectSummary]`
    public func projectSummaries() async throws -> [IoTSiteWiseClientTypes.ProjectSummary] {
        return try await self.asyncCompactMap { item in item.projectSummaries }
    }
}
extension IoTSiteWiseClient {
    /// Paginate over `[ListTimeSeriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTimeSeriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTimeSeriesOutput`
    public func listTimeSeriesPaginated(input: ListTimeSeriesInput) -> ClientRuntime.PaginatorSequence<ListTimeSeriesInput, ListTimeSeriesOutput> {
        return ClientRuntime.PaginatorSequence<ListTimeSeriesInput, ListTimeSeriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTimeSeries(input:))
    }
}

extension ListTimeSeriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTimeSeriesInput {
        return ListTimeSeriesInput(
            aliasPrefix: self.aliasPrefix,
            assetId: self.assetId,
            maxResults: self.maxResults,
            nextToken: token,
            timeSeriesType: self.timeSeriesType
        )}
}

extension PaginatorSequence where OperationStackInput == ListTimeSeriesInput, OperationStackOutput == ListTimeSeriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTimeSeriesPaginated`
    /// to access the nested member `[IoTSiteWiseClientTypes.TimeSeriesSummary]`
    /// - Returns: `[IoTSiteWiseClientTypes.TimeSeriesSummary]`
    public func timeSeriesSummaries() async throws -> [IoTSiteWiseClientTypes.TimeSeriesSummary] {
        return try await self.asyncCompactMap { item in item.timeSeriesSummaries }
    }
}
