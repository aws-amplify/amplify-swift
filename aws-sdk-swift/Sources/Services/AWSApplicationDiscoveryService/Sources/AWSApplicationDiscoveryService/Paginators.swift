//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeAgentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAgentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAgentsOutput`
    public func describeAgentsPaginated(input: DescribeAgentsInput) -> ClientRuntime.PaginatorSequence<DescribeAgentsInput, DescribeAgentsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAgentsInput, DescribeAgentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAgents(input:))
    }
}

extension DescribeAgentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAgentsInput {
        return DescribeAgentsInput(
            agentIds: self.agentIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAgentsInput, OperationStackOutput == DescribeAgentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAgentsPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.AgentInfo]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.AgentInfo]`
    public func agentsInfo() async throws -> [ApplicationDiscoveryClientTypes.AgentInfo] {
        return try await self.asyncCompactMap { item in item.agentsInfo }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeContinuousExportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeContinuousExportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeContinuousExportsOutput`
    public func describeContinuousExportsPaginated(input: DescribeContinuousExportsInput) -> ClientRuntime.PaginatorSequence<DescribeContinuousExportsInput, DescribeContinuousExportsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeContinuousExportsInput, DescribeContinuousExportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeContinuousExports(input:))
    }
}

extension DescribeContinuousExportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeContinuousExportsInput {
        return DescribeContinuousExportsInput(
            exportIds: self.exportIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeContinuousExportsInput, OperationStackOutput == DescribeContinuousExportsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeContinuousExportsPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.ContinuousExportDescription]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.ContinuousExportDescription]`
    public func descriptions() async throws -> [ApplicationDiscoveryClientTypes.ContinuousExportDescription] {
        return try await self.asyncCompactMap { item in item.descriptions }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeExportConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeExportConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeExportConfigurationsOutput`
    public func describeExportConfigurationsPaginated(input: DescribeExportConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeExportConfigurationsInput, DescribeExportConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeExportConfigurationsInput, DescribeExportConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeExportConfigurations(input:))
    }
}

extension DescribeExportConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExportConfigurationsInput {
        return DescribeExportConfigurationsInput(
            exportIds: self.exportIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeExportConfigurationsInput, OperationStackOutput == DescribeExportConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeExportConfigurationsPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.ExportInfo]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.ExportInfo]`
    public func exportsInfo() async throws -> [ApplicationDiscoveryClientTypes.ExportInfo] {
        return try await self.asyncCompactMap { item in item.exportsInfo }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeExportTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeExportTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeExportTasksOutput`
    public func describeExportTasksPaginated(input: DescribeExportTasksInput) -> ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeExportTasks(input:))
    }
}

extension DescribeExportTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExportTasksInput {
        return DescribeExportTasksInput(
            exportIds: self.exportIds,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeExportTasksInput, OperationStackOutput == DescribeExportTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeExportTasksPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.ExportInfo]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.ExportInfo]`
    public func exportsInfo() async throws -> [ApplicationDiscoveryClientTypes.ExportInfo] {
        return try await self.asyncCompactMap { item in item.exportsInfo }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeImportTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeImportTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeImportTasksOutput`
    public func describeImportTasksPaginated(input: DescribeImportTasksInput) -> ClientRuntime.PaginatorSequence<DescribeImportTasksInput, DescribeImportTasksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeImportTasksInput, DescribeImportTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeImportTasks(input:))
    }
}

extension DescribeImportTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeImportTasksInput {
        return DescribeImportTasksInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeImportTasksInput, OperationStackOutput == DescribeImportTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeImportTasksPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.ImportTask]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.ImportTask]`
    public func tasks() async throws -> [ApplicationDiscoveryClientTypes.ImportTask] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[DescribeTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTagsOutput`
    public func describeTagsPaginated(input: DescribeTagsInput) -> ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeTags(input:))
    }
}

extension DescribeTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTagsInput {
        return DescribeTagsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTagsInput, OperationStackOutput == DescribeTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTagsPaginated`
    /// to access the nested member `[ApplicationDiscoveryClientTypes.ConfigurationTag]`
    /// - Returns: `[ApplicationDiscoveryClientTypes.ConfigurationTag]`
    public func tags() async throws -> [ApplicationDiscoveryClientTypes.ConfigurationTag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension ApplicationDiscoveryClient {
    /// Paginate over `[ListConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConfigurationsOutput`
    public func listConfigurationsPaginated(input: ListConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListConfigurationsInput, ListConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListConfigurationsInput, ListConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConfigurations(input:))
    }
}

extension ListConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConfigurationsInput {
        return ListConfigurationsInput(
            configurationType: self.configurationType,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            orderBy: self.orderBy
        )}
}

extension PaginatorSequence where OperationStackInput == ListConfigurationsInput, OperationStackOutput == ListConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listConfigurationsPaginated`
    /// to access the nested member `[[Swift.String: Swift.String]]`
    /// - Returns: `[[Swift.String: Swift.String]]`
    public func configurations() async throws -> [[Swift.String: Swift.String]] {
        return try await self.asyncCompactMap { item in item.configurations }
    }
}
