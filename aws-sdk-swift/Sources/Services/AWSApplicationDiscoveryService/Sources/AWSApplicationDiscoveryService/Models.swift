//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct ExportConfigurationsInput: Swift.Sendable {

    public init() { }
}

extension ApplicationDiscoveryClientTypes {

    /// Information about agents that were instructed to start collecting data. Information includes the agent ID, a description of the operation, and whether the agent configuration was updated.
    public struct AgentConfigurationStatus: Swift.Sendable {
        /// The agent ID.
        public var agentId: Swift.String?
        /// A description of the operation performed.
        public var description: Swift.String?
        /// Information about the status of the StartDataCollection and StopDataCollection operations. The system has recorded the data collection operation. The agent receives this command the next time it polls for a new command.
        public var operationSucceeded: Swift.Bool

        public init(
            agentId: Swift.String? = nil,
            description: Swift.String? = nil,
            operationSucceeded: Swift.Bool = false
        )
        {
            self.agentId = agentId
            self.description = description
            self.operationSucceeded = operationSucceeded
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Network details about the host where the agent/collector resides.
    public struct AgentNetworkInfo: Swift.Sendable {
        /// The IP address for the host where the agent/collector resides.
        public var ipAddress: Swift.String?
        /// The MAC address for the host where the agent/collector resides.
        public var macAddress: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.macAddress = macAddress
        }
    }
}

extension ApplicationDiscoveryClientTypes.AgentNetworkInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum AgentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blacklisted
        case healthy
        case running
        case shutdown
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .blacklisted,
                .healthy,
                .running,
                .shutdown,
                .unhealthy,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blacklisted: return "BLACKLISTED"
            case .healthy: return "HEALTHY"
            case .running: return "RUNNING"
            case .shutdown: return "SHUTDOWN"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Information about agents associated with the user’s Amazon Web Services account. Information includes agent IDs, IP addresses, media access control (MAC) addresses, agent or collector status, hostname where the agent resides, and agent version for each agent.
    public struct AgentInfo: Swift.Sendable {
        /// The agent or collector ID.
        public var agentId: Swift.String?
        /// Network details about the host where the agent or collector resides.
        public var agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]?
        /// Type of agent.
        public var agentType: Swift.String?
        /// Status of the collection process for an agent.
        public var collectionStatus: Swift.String?
        /// The ID of the connector.
        public var connectorId: Swift.String?
        /// The health of the agent.
        public var health: ApplicationDiscoveryClientTypes.AgentStatus?
        /// The name of the host where the agent or collector resides. The host can be a server or virtual machine.
        public var hostName: Swift.String?
        /// Time since agent health was reported.
        public var lastHealthPingTime: Swift.String?
        /// Agent's first registration timestamp in UTC.
        public var registeredTime: Swift.String?
        /// The agent or collector version.
        public var version: Swift.String?

        public init(
            agentId: Swift.String? = nil,
            agentNetworkInfoList: [ApplicationDiscoveryClientTypes.AgentNetworkInfo]? = nil,
            agentType: Swift.String? = nil,
            collectionStatus: Swift.String? = nil,
            connectorId: Swift.String? = nil,
            health: ApplicationDiscoveryClientTypes.AgentStatus? = nil,
            hostName: Swift.String? = nil,
            lastHealthPingTime: Swift.String? = nil,
            registeredTime: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.agentNetworkInfoList = agentNetworkInfoList
            self.agentType = agentType
            self.collectionStatus = collectionStatus
            self.connectorId = connectorId
            self.health = health
            self.hostName = hostName
            self.lastHealthPingTime = lastHealthPingTime
            self.registeredTime = registeredTime
            self.version = version
        }
    }
}

extension ApplicationDiscoveryClientTypes.AgentInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentInfo(agentId: \(Swift.String(describing: agentId)), agentType: \(Swift.String(describing: agentType)), collectionStatus: \(Swift.String(describing: collectionStatus)), connectorId: \(Swift.String(describing: connectorId)), health: \(Swift.String(describing: health)), hostName: \(Swift.String(describing: hostName)), lastHealthPingTime: \(Swift.String(describing: lastHealthPingTime)), registeredTime: \(Swift.String(describing: registeredTime)), version: \(Swift.String(describing: version)), agentNetworkInfoList: \"CONTENT_REDACTED\")"}
}

/// The user does not have permission to perform the action. Check the IAM policy associated with this user.
public struct AuthorizationErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The home Region is not set. Set the home Region to continue.
public struct HomeRegionNotSetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HomeRegionNotSetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more parameters are not valid. Verify the parameters and try again.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The value of one or more parameters are either invalid or out of range. Verify the parameter values and try again.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The server experienced an internal error. Try again.
public struct ServerInternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerInternalErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateConfigurationItemsToApplicationInput: Swift.Sendable {
    /// The configuration ID of an application with which items are to be associated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// The ID of each configuration item to be associated with an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

public struct AssociateConfigurationItemsToApplicationOutput: Swift.Sendable {

    public init() { }
}

extension ApplicationDiscoveryClientTypes {

    /// An object representing the agent or data collector to be deleted along with the optional configurations for error handling.
    public struct DeleteAgent: Swift.Sendable {
        /// The ID of the agent or data collector to delete.
        /// This member is required.
        public var agentId: Swift.String?
        /// Optional flag used to force delete an agent or data collector. It is needed to delete any agent in HEALTHY/UNHEALTHY/RUNNING status. Note that deleting an agent that is actively reporting health causes it to be re-registered with a different agent ID after data collector re-connects with Amazon Web Services.
        public var force: Swift.Bool

        public init(
            agentId: Swift.String? = nil,
            force: Swift.Bool = false
        )
        {
            self.agentId = agentId
            self.force = force
        }
    }
}

public struct BatchDeleteAgentsInput: Swift.Sendable {
    /// The list of agents to delete.
    /// This member is required.
    public var deleteAgents: [ApplicationDiscoveryClientTypes.DeleteAgent]?

    public init(
        deleteAgents: [ApplicationDiscoveryClientTypes.DeleteAgent]? = nil
    )
    {
        self.deleteAgents = deleteAgents
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum DeleteAgentErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agentInUse
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [DeleteAgentErrorCode] {
            return [
                .agentInUse,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agentInUse: return "AGENT_IN_USE"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// An object representing the agent or data collector that failed to delete, each containing agentId, errorMessage, and errorCode.
    public struct BatchDeleteAgentError: Swift.Sendable {
        /// The ID of the agent or data collector to delete.
        /// This member is required.
        public var agentId: Swift.String?
        /// The type of error that occurred for the delete failed agent. Valid status are: AGENT_IN_USE | NOT_FOUND | INTERNAL_SERVER_ERROR.
        /// This member is required.
        public var errorCode: ApplicationDiscoveryClientTypes.DeleteAgentErrorCode?
        /// The description of the error that occurred for the delete failed agent.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            agentId: Swift.String? = nil,
            errorCode: ApplicationDiscoveryClientTypes.DeleteAgentErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.agentId = agentId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct BatchDeleteAgentsOutput: Swift.Sendable {
    /// A list of agent IDs that failed to delete during the deletion task, each paired with an error message.
    public var errors: [ApplicationDiscoveryClientTypes.BatchDeleteAgentError]?

    public init(
        errors: [ApplicationDiscoveryClientTypes.BatchDeleteAgentError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDeleteImportDataInput: Swift.Sendable {
    /// Set to true to remove the deleted import task from [DescribeImportTasks].
    public var deleteHistory: Swift.Bool?
    /// The IDs for the import tasks that you want to delete.
    /// This member is required.
    public var importTaskIds: [Swift.String]?

    public init(
        deleteHistory: Swift.Bool? = false,
        importTaskIds: [Swift.String]? = nil
    )
    {
        self.deleteHistory = deleteHistory
        self.importTaskIds = importTaskIds
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum BatchDeleteImportDataErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalServerError
        case notFound
        case overLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteImportDataErrorCode] {
            return [
                .internalServerError,
                .notFound,
                .overLimit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case .overLimit: return "OVER_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Error messages returned for each import task that you deleted as a response for this command.
    public struct BatchDeleteImportDataError: Swift.Sendable {
        /// The type of error that occurred for a specific import task.
        public var errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode?
        /// The description of the error that occurred for a specific import task.
        public var errorDescription: Swift.String?
        /// The unique import ID associated with the error that occurred.
        public var importTaskId: Swift.String?

        public init(
            errorCode: ApplicationDiscoveryClientTypes.BatchDeleteImportDataErrorCode? = nil,
            errorDescription: Swift.String? = nil,
            importTaskId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorDescription = errorDescription
            self.importTaskId = importTaskId
        }
    }
}

public struct BatchDeleteImportDataOutput: Swift.Sendable {
    /// Error messages returned for each import task that you deleted as a response for this command.
    public var errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]?

    public init(
        errors: [ApplicationDiscoveryClientTypes.BatchDeleteImportDataError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct CreateApplicationInput: Swift.Sendable {
    /// Description of the application to be created.
    public var description: Swift.String?
    /// Name of the application to be created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

public struct CreateApplicationOutput: Swift.Sendable {
    /// Configuration ID of an application to be created.
    public var configurationId: Swift.String?

    public init(
        configurationId: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

/// The specified configuration ID was not located. Verify the configuration ID and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Metadata that help you categorize IT assets. Do not store sensitive information (like personal data) in tags.
    public struct Tag: Swift.Sendable {
        /// The type of tag on which to filter.
        /// This member is required.
        public var key: Swift.String?
        /// A value for a tag key on which to filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateTagsInput: Swift.Sendable {
    /// A list of configuration items that you want to tag.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to associate with one or more configuration items. Specify the tags that you want to create in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    /// This member is required.
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init(
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

public struct CreateTagsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApplicationsInput: Swift.Sendable {
    /// Configuration ID of an application to be deleted.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

public struct DeleteApplicationsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTagsInput: Swift.Sendable {
    /// A list of configuration items with tags that you want to delete.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// Tags that you want to delete from one or more configuration items. Specify the tags that you want to delete in a key-value format. For example: {"key": "serverType", "value": "webServer"}
    public var tags: [ApplicationDiscoveryClientTypes.Tag]?

    public init(
        configurationIds: [Swift.String]? = nil,
        tags: [ApplicationDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.configurationIds = configurationIds
        self.tags = tags
    }
}

public struct DeleteTagsOutput: Swift.Sendable {

    public init() { }
}

extension ApplicationDiscoveryClientTypes {

    /// A filter that can use conditional operators. For more information about filters, see [Querying Discovered Configuration Items](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html) in the Amazon Web Services Application Discovery Service User Guide.
    public struct Filter: Swift.Sendable {
        /// A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS, CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as though concatenated by AND. If you specify multiple values for a particular filter, the system differentiates the values using OR. Calling either DescribeConfigurations or ListConfigurations returns attributes of matching configuration items.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var name: Swift.String?
        /// A string value on which to filter. For example, if you choose the destinationServer.osVersion filter name, you could specify Ubuntu for the value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeAgentsInput: Swift.Sendable {
    /// The agent or the collector IDs for which you want information. If you specify no IDs, the system returns information about all agents/collectors associated with your user.
    public var agentIds: [Swift.String]?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "collectionStatus", "value": "STARTED"}
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of agents/collectors to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?

    public init(
        agentIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.agentIds = agentIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAgentsOutput: Swift.Sendable {
    /// Lists agents or the collector by ID or lists all agents/collectors associated with your user, if you did not specify an agent/collector ID. The output includes agent/collector IDs, IP addresses, media access control (MAC) addresses, agent/collector health, host name where the agent/collector resides, and the version number of each agent/collector.
    public var agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        agentsInfo: [ApplicationDiscoveryClientTypes.AgentInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentsInfo = agentsInfo
        self.nextToken = nextToken
    }
}

public struct DescribeBatchDeleteConfigurationTaskInput: Swift.Sendable {
    /// The ID of the task to delete.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum DeletionConfigurationItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionConfigurationItemType] {
            return [
                .server
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A configuration ID paired with a warning message.
    public struct DeletionWarning: Swift.Sendable {
        /// The unique identifier of the configuration that produced a warning.
        public var configurationId: Swift.String?
        /// The integer warning code associated with the warning message.
        public var warningCode: Swift.Int
        /// A descriptive message of the warning the associated configuration ID produced.
        public var warningText: Swift.String?

        public init(
            configurationId: Swift.String? = nil,
            warningCode: Swift.Int = 0,
            warningText: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.warningCode = warningCode
            self.warningText = warningText
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A configuration ID paired with an error message.
    public struct FailedConfiguration: Swift.Sendable {
        /// The unique identifier of the configuration the failed to delete.
        public var configurationId: Swift.String?
        /// A descriptive message indicating why the associated configuration failed to delete.
        public var errorMessage: Swift.String?
        /// The integer error code associated with the error message.
        public var errorStatusCode: Swift.Int

        public init(
            configurationId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorStatusCode: Swift.Int = 0
        )
        {
            self.configurationId = configurationId
            self.errorMessage = errorMessage
            self.errorStatusCode = errorStatusCode
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum BatchDeleteConfigurationTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case deleting
        case failed
        case initializing
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteConfigurationTaskStatus] {
            return [
                .completed,
                .deleting,
                .failed,
                .initializing,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .initializing: return "INITIALIZING"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A metadata object that represents the deletion task being executed.
    public struct BatchDeleteConfigurationTask: Swift.Sendable {
        /// The type of configuration item to delete. Supported types are: SERVER.
        public var configurationType: ApplicationDiscoveryClientTypes.DeletionConfigurationItemType?
        /// The list of configuration IDs that were successfully deleted by the deletion task.
        public var deletedConfigurations: [Swift.String]?
        /// A list of configuration IDs that produced warnings regarding their deletion, paired with a warning message.
        public var deletionWarnings: [ApplicationDiscoveryClientTypes.DeletionWarning]?
        /// An epoch seconds timestamp (UTC) of when the deletion task was completed or failed.
        public var endTime: Foundation.Date?
        /// A list of configuration IDs that failed to delete during the deletion task, each paired with an error message.
        public var failedConfigurations: [ApplicationDiscoveryClientTypes.FailedConfiguration]?
        /// The list of configuration IDs that were originally requested to be deleted by the deletion task.
        public var requestedConfigurations: [Swift.String]?
        /// An epoch seconds timestamp (UTC) of when the deletion task was started.
        public var startTime: Foundation.Date?
        /// The current execution status of the deletion task. Valid status are: INITIALIZING | VALIDATING | DELETING | COMPLETED | FAILED.
        public var status: ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTaskStatus?
        /// The deletion task's unique identifier.
        public var taskId: Swift.String?

        public init(
            configurationType: ApplicationDiscoveryClientTypes.DeletionConfigurationItemType? = nil,
            deletedConfigurations: [Swift.String]? = nil,
            deletionWarnings: [ApplicationDiscoveryClientTypes.DeletionWarning]? = nil,
            endTime: Foundation.Date? = nil,
            failedConfigurations: [ApplicationDiscoveryClientTypes.FailedConfiguration]? = nil,
            requestedConfigurations: [Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            status: ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTaskStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.configurationType = configurationType
            self.deletedConfigurations = deletedConfigurations
            self.deletionWarnings = deletionWarnings
            self.endTime = endTime
            self.failedConfigurations = failedConfigurations
            self.requestedConfigurations = requestedConfigurations
            self.startTime = startTime
            self.status = status
            self.taskId = taskId
        }
    }
}

public struct DescribeBatchDeleteConfigurationTaskOutput: Swift.Sendable {
    /// The BatchDeleteConfigurationTask that represents the deletion task being executed.
    public var task: ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask?

    public init(
        task: ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask? = nil
    )
    {
        self.task = task
    }
}

public struct DescribeConfigurationsInput: Swift.Sendable {
    /// One or more configuration IDs.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        configurationIds: [Swift.String]? = nil
    )
    {
        self.configurationIds = configurationIds
    }
}

public struct DescribeConfigurationsOutput: Swift.Sendable {
    /// A key in the response map. The value is an array of data.
    public var configurations: [[Swift.String: Swift.String]]?

    public init(
        configurations: [[Swift.String: Swift.String]]? = nil
    )
    {
        self.configurations = configurations
    }
}

/// This operation is not permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermittedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeContinuousExportsInput: Swift.Sendable {
    /// The unique IDs assigned to the exports.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum DataSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .agent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ContinuousExportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case error
        case inactive
        case startFailed
        case startInProgress
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ContinuousExportStatus] {
            return [
                .active,
                .error,
                .inactive,
                .startFailed,
                .startInProgress,
                .stopFailed,
                .stopInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A list of continuous export descriptions.
    public struct ContinuousExportDescription: Swift.Sendable {
        /// The type of data collector used to gather this data (currently only offered for AGENT).
        public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
        /// The unique ID assigned to this export.
        public var exportId: Swift.String?
        /// The name of the s3 bucket where the export data parquet files are stored.
        public var s3Bucket: Swift.String?
        /// An object which describes how the data is stored.
        ///
        /// * databaseName - the name of the Glue database used to store the schema.
        public var schemaStorageConfig: [Swift.String: Swift.String]?
        /// The timestamp representing when the continuous export was started.
        public var startTime: Foundation.Date?
        /// Describes the status of the export. Can be one of the following values:
        ///
        /// * START_IN_PROGRESS - setting up resources to start continuous export.
        ///
        /// * START_FAILED - an error occurred setting up continuous export. To recover, call start-continuous-export again.
        ///
        /// * ACTIVE - data is being exported to the customer bucket.
        ///
        /// * ERROR - an error occurred during export. To fix the issue, call stop-continuous-export and start-continuous-export.
        ///
        /// * STOP_IN_PROGRESS - stopping the export.
        ///
        /// * STOP_FAILED - an error occurred stopping the export. To recover, call stop-continuous-export again.
        ///
        /// * INACTIVE - the continuous export has been stopped. Data is no longer being exported to the customer bucket.
        public var status: ApplicationDiscoveryClientTypes.ContinuousExportStatus?
        /// Contains information about any errors that have occurred. This data type can have the following values:
        ///
        /// * ACCESS_DENIED - You don’t have permission to start Data Exploration in Amazon Athena. Contact your Amazon Web Services administrator for help. For more information, see [Setting Up Amazon Web Services Application Discovery Service](http://docs.aws.amazon.com/application-discovery/latest/userguide/setting-up.html) in the Application Discovery Service User Guide.
        ///
        /// * DELIVERY_STREAM_LIMIT_FAILURE - You reached the limit for Amazon Kinesis Data Firehose delivery streams. Reduce the number of streams or request a limit increase and try again. For more information, see [Kinesis Data Streams Limits](http://docs.aws.amazon.com/streams/latest/dev/service-sizes-and-limits.html) in the Amazon Kinesis Data Streams Developer Guide.
        ///
        /// * FIREHOSE_ROLE_MISSING - The Data Exploration feature is in an error state because your user is missing the Amazon Web ServicesApplicationDiscoveryServiceFirehose role. Turn on Data Exploration in Amazon Athena and try again. For more information, see [Creating the Amazon Web ServicesApplicationDiscoveryServiceFirehose Role](https://docs.aws.amazon.com/application-discovery/latest/userguide/security-iam-awsmanpol.html#security-iam-awsmanpol-create-firehose-role) in the Application Discovery Service User Guide.
        ///
        /// * FIREHOSE_STREAM_DOES_NOT_EXIST - The Data Exploration feature is in an error state because your user is missing one or more of the Kinesis data delivery streams.
        ///
        /// * INTERNAL_FAILURE - The Data Exploration feature is in an error state because of an internal failure. Try again later. If this problem persists, contact Amazon Web Services Support.
        ///
        /// * LAKE_FORMATION_ACCESS_DENIED - You don't have sufficient lake formation permissions to start continuous export. For more information, see [ Upgrading Amazon Web Services Glue Data Permissions to the Amazon Web Services Lake Formation Model ](http://docs.aws.amazon.com/lake-formation/latest/dg/upgrade-glue-lake-formation.html) in the Amazon Web Services Lake Formation Developer Guide. You can use one of the following two ways to resolve this issue.
        ///
        /// * If you don’t want to use the Lake Formation permission model, you can change the default Data Catalog settings to use only Amazon Web Services Identity and Access Management (IAM) access control for new databases. For more information, see [Change Data Catalog Settings](https://docs.aws.amazon.com/lake-formation/latest/dg/getting-started-setup.html#setup-change-cat-settings) in the Lake Formation Developer Guide.
        ///
        /// * You can give the service-linked IAM roles AWSServiceRoleForApplicationDiscoveryServiceContinuousExport and AWSApplicationDiscoveryServiceFirehose the required Lake Formation permissions. For more information, see [ Granting Database Permissions](https://docs.aws.amazon.com/lake-formation/latest/dg/granting-database-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSServiceRoleForApplicationDiscoveryServiceContinuousExport - Grant database creator permissions, which gives the role database creation ability and implicit permissions for any created tables. For more information, see [ Implicit Lake Formation Permissions ](https://docs.aws.amazon.com/lake-formation/latest/dg/implicit-permissions.html) in the Lake Formation Developer Guide.
        ///
        /// * AWSApplicationDiscoveryServiceFirehose - Grant describe permissions for all tables in the database.
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * S3_BUCKET_LIMIT_FAILURE - You reached the limit for Amazon S3 buckets. Reduce the number of S3 buckets or request a limit increase and try again. For more information, see [Bucket Restrictions and Limitations](http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) in the Amazon Simple Storage Service Developer Guide.
        ///
        /// * S3_NOT_SIGNED_UP - Your account is not signed up for the Amazon S3 service. You must sign up before you can use Amazon S3. You can sign up at the following URL: [https://aws.amazon.com/s3](https://aws.amazon.com/s3).
        public var statusDetail: Swift.String?
        /// The timestamp that represents when this continuous export was stopped.
        public var stopTime: Foundation.Date?

        public init(
            dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
            exportId: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            schemaStorageConfig: [Swift.String: Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            status: ApplicationDiscoveryClientTypes.ContinuousExportStatus? = nil,
            statusDetail: Swift.String? = nil,
            stopTime: Foundation.Date? = nil
        )
        {
            self.dataSource = dataSource
            self.exportId = exportId
            self.s3Bucket = s3Bucket
            self.schemaStorageConfig = schemaStorageConfig
            self.startTime = startTime
            self.status = status
            self.statusDetail = statusDetail
            self.stopTime = stopTime
        }
    }
}

public struct DescribeContinuousExportsOutput: Swift.Sendable {
    /// A list of continuous export descriptions.
    public var descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]?
    /// The token from the previous call to DescribeExportTasks.
    public var nextToken: Swift.String?

    public init(
        descriptions: [ApplicationDiscoveryClientTypes.ContinuousExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.descriptions = descriptions
        self.nextToken = nextToken
    }
}

public struct DescribeExportConfigurationsInput: Swift.Sendable {
    /// A list of continuous export IDs to search for.
    public var exportIds: [Swift.String]?
    /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
    public var maxResults: Swift.Int?
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ExportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Information regarding the export status of discovered data. The value is an array of objects.
    public struct ExportInfo: Swift.Sendable {
        /// A URL for an Amazon S3 bucket where you can review the exported data. The URL is displayed only if the export succeeded.
        public var configurationsDownloadUrl: Swift.String?
        /// A unique identifier used to query an export.
        /// This member is required.
        public var exportId: Swift.String?
        /// The time that the data export was initiated.
        /// This member is required.
        public var exportRequestTime: Foundation.Date?
        /// The status of the data export job.
        /// This member is required.
        public var exportStatus: ApplicationDiscoveryClientTypes.ExportStatus?
        /// If true, the export of agent information exceeded the size limit for a single export and the exported data is incomplete for the requested time range. To address this, select a smaller time range for the export by using startDate and endDate.
        public var isTruncated: Swift.Bool
        /// The endTime used in the StartExportTask request. If no endTime was requested, this result does not appear in ExportInfo.
        public var requestedEndTime: Foundation.Date?
        /// The value of startTime parameter in the StartExportTask request. If no startTime was requested, this result does not appear in ExportInfo.
        public var requestedStartTime: Foundation.Date?
        /// A status message provided for API callers.
        /// This member is required.
        public var statusMessage: Swift.String?

        public init(
            configurationsDownloadUrl: Swift.String? = nil,
            exportId: Swift.String? = nil,
            exportRequestTime: Foundation.Date? = nil,
            exportStatus: ApplicationDiscoveryClientTypes.ExportStatus? = nil,
            isTruncated: Swift.Bool = false,
            requestedEndTime: Foundation.Date? = nil,
            requestedStartTime: Foundation.Date? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.configurationsDownloadUrl = configurationsDownloadUrl
            self.exportId = exportId
            self.exportRequestTime = exportRequestTime
            self.exportStatus = exportStatus
            self.isTruncated = isTruncated
            self.requestedEndTime = requestedEndTime
            self.requestedStartTime = requestedStartTime
            self.statusMessage = statusMessage
        }
    }
}

public struct DescribeExportConfigurationsOutput: Swift.Sendable {
    ///
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The token from the previous call to describe-export-tasks.
    public var nextToken: Swift.String?

    public init(
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Used to select which agent's data is to be exported. A single agent ID may be selected for export using the [StartExportTask](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html) action.
    public struct ExportFilter: Swift.Sendable {
        /// Supported condition: EQUALS
        /// This member is required.
        public var condition: Swift.String?
        /// A single ExportFilter name. Supported filters: agentIds.
        /// This member is required.
        public var name: Swift.String?
        /// A single agent ID for a Discovery Agent. An agent ID can be found using the [DescribeAgents](http://docs.aws.amazon.com/application-discovery/latest/APIReference/API_DescribeAgents.html) action. Typically an ADS agent ID is in the form o-0123456789abcdef0.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: Swift.String? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeExportTasksInput: Swift.Sendable {
    /// One or more unique identifiers used to query the status of an export request.
    public var exportIds: [Swift.String]?
    /// One or more filters.
    ///
    /// * AgentId - ID of the agent whose collected data will be exported
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// The maximum number of volume results returned by DescribeExportTasks in paginated output. When this parameter is used, DescribeExportTasks only returns maxResults results in a single page along with a nextToken response element.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeExportTasks request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        exportIds: [Swift.String]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.exportIds = exportIds
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeExportTasksOutput: Swift.Sendable {
    /// Contains one or more sets of export request details. When the status of a request is SUCCEEDED, the response includes a URL for an Amazon S3 bucket where you can view the data in a CSV file.
    public var exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]?
    /// The nextToken value to include in a future DescribeExportTasks request. When the results of a DescribeExportTasks request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        exportsInfo: [ApplicationDiscoveryClientTypes.ExportInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportsInfo = exportsInfo
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ImportTaskFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case importTaskId
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportTaskFilterName] {
            return [
                .importTaskId,
                .name,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .importTaskId: return "IMPORT_TASK_ID"
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A name-values pair of elements you can use to filter the results when querying your import tasks. Currently, wildcards are not supported for filters. When filtering by import status, all other filter values are ignored.
    public struct ImportTaskFilter: Swift.Sendable {
        /// The name, status, or import task ID for a specific import task.
        public var name: ApplicationDiscoveryClientTypes.ImportTaskFilterName?
        /// An array of strings that you can provide to match against a specific name, status, or import task ID to filter the results for your import task queries.
        public var values: [Swift.String]?

        public init(
            name: ApplicationDiscoveryClientTypes.ImportTaskFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeImportTasksInput: Swift.Sendable {
    /// An array of name-value pairs that you provide to filter the results for the DescribeImportTask request to a specific subset of results. Currently, wildcard values aren't supported for filters.
    public var filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]?
    /// The maximum number of results that you want this request to return, up to 100.
    public var maxResults: Swift.Int?
    /// The token to request a specific page of results.
    public var nextToken: Swift.String?

    public init(
        filters: [ApplicationDiscoveryClientTypes.ImportTaskFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ImportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteComplete
        case deleteFailed
        case deleteFailedLimitExceeded
        case deleteInProgress
        case importComplete
        case importCompleteWithErrors
        case importFailed
        case importFailedRecordLimitExceeded
        case importFailedServerLimitExceeded
        case importInProgress
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportStatus] {
            return [
                .deleteComplete,
                .deleteFailed,
                .deleteFailedLimitExceeded,
                .deleteInProgress,
                .importComplete,
                .importCompleteWithErrors,
                .importFailed,
                .importFailedRecordLimitExceeded,
                .importFailedServerLimitExceeded,
                .importInProgress,
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteComplete: return "DELETE_COMPLETE"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteFailedLimitExceeded: return "DELETE_FAILED_LIMIT_EXCEEDED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .importComplete: return "IMPORT_COMPLETE"
            case .importCompleteWithErrors: return "IMPORT_COMPLETE_WITH_ERRORS"
            case .importFailed: return "IMPORT_FAILED"
            case .importFailedRecordLimitExceeded: return "IMPORT_FAILED_RECORD_LIMIT_EXCEEDED"
            case .importFailedServerLimitExceeded: return "IMPORT_FAILED_SERVER_LIMIT_EXCEEDED"
            case .importInProgress: return "IMPORT_IN_PROGRESS"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// An array of information related to the import task request that includes status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public struct ImportTask: Swift.Sendable {
        /// The total number of application records in the import file that failed to be imported.
        public var applicationImportFailure: Swift.Int
        /// The total number of application records in the import file that were successfully imported.
        public var applicationImportSuccess: Swift.Int
        /// A unique token used to prevent the same import request from occurring more than once. If you didn't provide a token, a token was automatically generated when the import task request was sent.
        public var clientRequestToken: Swift.String?
        /// A link to a compressed archive folder (in the ZIP format) that contains an error log and a file of failed records. You can use these two files to quickly identify records that failed, why they failed, and correct those records. Afterward, you can upload the corrected file to your Amazon S3 bucket and create another import task request. This field also includes authorization information so you can confirm the authenticity of the compressed archive before you download it. If some records failed to be imported we recommend that you correct the records in the failed entries file and then imports that failed entries file. This prevents you from having to correct and update the larger original file and attempt importing it again.
        public var errorsAndFailedEntriesZip: Swift.String?
        /// The time that the import task request finished, presented in the Unix time stamp format.
        public var importCompletionTime: Foundation.Date?
        /// The time that the import task request was deleted, presented in the Unix time stamp format.
        public var importDeletedTime: Foundation.Date?
        /// The time that the import task request was made, presented in the Unix time stamp format.
        public var importRequestTime: Foundation.Date?
        /// The unique ID for a specific import task. These IDs aren't globally unique, but they are unique within an Amazon Web Services account.
        public var importTaskId: Swift.String?
        /// The URL for your import file that you've uploaded to Amazon S3.
        public var importUrl: Swift.String?
        /// A descriptive name for an import task. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
        public var name: Swift.String?
        /// The total number of server records in the import file that failed to be imported.
        public var serverImportFailure: Swift.Int
        /// The total number of server records in the import file that were successfully imported.
        public var serverImportSuccess: Swift.Int
        /// The status of the import task. An import can have the status of IMPORT_COMPLETE and still have some records fail to import from the overall request. More information can be found in the downloadable archive defined in the errorsAndFailedEntriesZip field, or in the Migration Hub management console.
        public var status: ApplicationDiscoveryClientTypes.ImportStatus?

        public init(
            applicationImportFailure: Swift.Int = 0,
            applicationImportSuccess: Swift.Int = 0,
            clientRequestToken: Swift.String? = nil,
            errorsAndFailedEntriesZip: Swift.String? = nil,
            importCompletionTime: Foundation.Date? = nil,
            importDeletedTime: Foundation.Date? = nil,
            importRequestTime: Foundation.Date? = nil,
            importTaskId: Swift.String? = nil,
            importUrl: Swift.String? = nil,
            name: Swift.String? = nil,
            serverImportFailure: Swift.Int = 0,
            serverImportSuccess: Swift.Int = 0,
            status: ApplicationDiscoveryClientTypes.ImportStatus? = nil
        )
        {
            self.applicationImportFailure = applicationImportFailure
            self.applicationImportSuccess = applicationImportSuccess
            self.clientRequestToken = clientRequestToken
            self.errorsAndFailedEntriesZip = errorsAndFailedEntriesZip
            self.importCompletionTime = importCompletionTime
            self.importDeletedTime = importDeletedTime
            self.importRequestTime = importRequestTime
            self.importTaskId = importTaskId
            self.importUrl = importUrl
            self.name = name
            self.serverImportFailure = serverImportFailure
            self.serverImportSuccess = serverImportSuccess
            self.status = status
        }
    }
}

public struct DescribeImportTasksOutput: Swift.Sendable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// A returned array of import tasks that match any applied filters, up to the specified number of maximum results.
    public var tasks: [ApplicationDiscoveryClientTypes.ImportTask]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [ApplicationDiscoveryClientTypes.ImportTask]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

extension ApplicationDiscoveryClientTypes {

    /// The tag filter. Valid names are: tagKey, tagValue, configurationId.
    public struct TagFilter: Swift.Sendable {
        /// A name of the tag filter.
        /// This member is required.
        public var name: Swift.String?
        /// Values for the tag filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeTagsInput: Swift.Sendable {
    /// You can filter the list using a key-value format. You can separate these items by using logical operators. Allowed filters include tagKey, tagValue, and configurationId.
    public var filters: [ApplicationDiscoveryClientTypes.TagFilter]?
    /// The total number of items to return in a single page of output. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        filters: [ApplicationDiscoveryClientTypes.TagFilter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ConfigurationItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case connections
        case process
        case server
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationItemType] {
            return [
                .application,
                .connections,
                .process,
                .server
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .connections: return "CONNECTION"
            case .process: return "PROCESS"
            case .server: return "SERVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Tags for a configuration item. Tags are metadata that help you categorize IT assets.
    public struct ConfigurationTag: Swift.Sendable {
        /// The configuration ID for the item to tag. You can specify a list of keys and values.
        public var configurationId: Swift.String?
        /// A type of IT asset to tag.
        public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
        /// A type of tag on which to filter. For example, serverType.
        public var key: Swift.String?
        /// The time the configuration tag was created in Coordinated Universal Time (UTC).
        public var timeOfCreation: Foundation.Date?
        /// A value on which to filter. For example key = serverType and value = web server.
        public var value: Swift.String?

        public init(
            configurationId: Swift.String? = nil,
            configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
            key: Swift.String? = nil,
            timeOfCreation: Foundation.Date? = nil,
            value: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.configurationType = configurationType
            self.key = key
            self.timeOfCreation = timeOfCreation
            self.value = value
        }
    }
}

public struct DescribeTagsOutput: Swift.Sendable {
    /// The call returns a token. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Depending on the input, this is a list of configuration items tagged with a specific tag, or a list of tags for a specific configuration item.
    public var tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [ApplicationDiscoveryClientTypes.ConfigurationTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct DisassociateConfigurationItemsFromApplicationInput: Swift.Sendable {
    /// Configuration ID of an application from which each item is disassociated.
    /// This member is required.
    public var applicationConfigurationId: Swift.String?
    /// Configuration ID of each item to be disassociated from an application.
    /// This member is required.
    public var configurationIds: [Swift.String]?

    public init(
        applicationConfigurationId: Swift.String? = nil,
        configurationIds: [Swift.String]? = nil
    )
    {
        self.applicationConfigurationId = applicationConfigurationId
        self.configurationIds = configurationIds
    }
}

public struct DisassociateConfigurationItemsFromApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct ExportConfigurationsOutput: Swift.Sendable {
    /// A unique identifier that you can use to query the export status.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

public struct GetDiscoverySummaryInput: Swift.Sendable {

    public init() { }
}

extension ApplicationDiscoveryClientTypes {

    /// The inventory data for installed Agentless Collector collectors.
    public struct CustomerAgentlessCollectorInfo: Swift.Sendable {
        /// The number of active Agentless Collector collectors.
        /// This member is required.
        public var activeAgentlessCollectors: Swift.Int
        /// The number of deny-listed Agentless Collector collectors.
        /// This member is required.
        public var denyListedAgentlessCollectors: Swift.Int
        /// The number of healthy Agentless Collector collectors.
        /// This member is required.
        public var healthyAgentlessCollectors: Swift.Int
        /// The number of Agentless Collector collectors with SHUTDOWN status.
        /// This member is required.
        public var shutdownAgentlessCollectors: Swift.Int
        /// The total number of Agentless Collector collectors.
        /// This member is required.
        public var totalAgentlessCollectors: Swift.Int
        /// The number of unhealthy Agentless Collector collectors.
        /// This member is required.
        public var unhealthyAgentlessCollectors: Swift.Int
        /// The number of unknown Agentless Collector collectors.
        /// This member is required.
        public var unknownAgentlessCollectors: Swift.Int

        public init(
            activeAgentlessCollectors: Swift.Int = 0,
            denyListedAgentlessCollectors: Swift.Int = 0,
            healthyAgentlessCollectors: Swift.Int = 0,
            shutdownAgentlessCollectors: Swift.Int = 0,
            totalAgentlessCollectors: Swift.Int = 0,
            unhealthyAgentlessCollectors: Swift.Int = 0,
            unknownAgentlessCollectors: Swift.Int = 0
        )
        {
            self.activeAgentlessCollectors = activeAgentlessCollectors
            self.denyListedAgentlessCollectors = denyListedAgentlessCollectors
            self.healthyAgentlessCollectors = healthyAgentlessCollectors
            self.shutdownAgentlessCollectors = shutdownAgentlessCollectors
            self.totalAgentlessCollectors = totalAgentlessCollectors
            self.unhealthyAgentlessCollectors = unhealthyAgentlessCollectors
            self.unknownAgentlessCollectors = unknownAgentlessCollectors
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Inventory data for installed discovery agents.
    public struct CustomerAgentInfo: Swift.Sendable {
        /// Number of active discovery agents.
        /// This member is required.
        public var activeAgents: Swift.Int
        /// Number of blacklisted discovery agents.
        /// This member is required.
        public var blackListedAgents: Swift.Int
        /// Number of healthy discovery agents
        /// This member is required.
        public var healthyAgents: Swift.Int
        /// Number of discovery agents with status SHUTDOWN.
        /// This member is required.
        public var shutdownAgents: Swift.Int
        /// Total number of discovery agents.
        /// This member is required.
        public var totalAgents: Swift.Int
        /// Number of unhealthy discovery agents.
        /// This member is required.
        public var unhealthyAgents: Swift.Int
        /// Number of unknown discovery agents.
        /// This member is required.
        public var unknownAgents: Swift.Int

        public init(
            activeAgents: Swift.Int = 0,
            blackListedAgents: Swift.Int = 0,
            healthyAgents: Swift.Int = 0,
            shutdownAgents: Swift.Int = 0,
            totalAgents: Swift.Int = 0,
            unhealthyAgents: Swift.Int = 0,
            unknownAgents: Swift.Int = 0
        )
        {
            self.activeAgents = activeAgents
            self.blackListedAgents = blackListedAgents
            self.healthyAgents = healthyAgents
            self.shutdownAgents = shutdownAgents
            self.totalAgents = totalAgents
            self.unhealthyAgents = unhealthyAgents
            self.unknownAgents = unknownAgents
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Inventory data for installed discovery connectors.
    public struct CustomerConnectorInfo: Swift.Sendable {
        /// Number of active discovery connectors.
        /// This member is required.
        public var activeConnectors: Swift.Int
        /// Number of blacklisted discovery connectors.
        /// This member is required.
        public var blackListedConnectors: Swift.Int
        /// Number of healthy discovery connectors.
        /// This member is required.
        public var healthyConnectors: Swift.Int
        /// Number of discovery connectors with status SHUTDOWN,
        /// This member is required.
        public var shutdownConnectors: Swift.Int
        /// Total number of discovery connectors.
        /// This member is required.
        public var totalConnectors: Swift.Int
        /// Number of unhealthy discovery connectors.
        /// This member is required.
        public var unhealthyConnectors: Swift.Int
        /// Number of unknown discovery connectors.
        /// This member is required.
        public var unknownConnectors: Swift.Int

        public init(
            activeConnectors: Swift.Int = 0,
            blackListedConnectors: Swift.Int = 0,
            healthyConnectors: Swift.Int = 0,
            shutdownConnectors: Swift.Int = 0,
            totalConnectors: Swift.Int = 0,
            unhealthyConnectors: Swift.Int = 0,
            unknownConnectors: Swift.Int = 0
        )
        {
            self.activeConnectors = activeConnectors
            self.blackListedConnectors = blackListedConnectors
            self.healthyConnectors = healthyConnectors
            self.shutdownConnectors = shutdownConnectors
            self.totalConnectors = totalConnectors
            self.unhealthyConnectors = unhealthyConnectors
            self.unknownConnectors = unknownConnectors
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// The inventory data for installed Migration Evaluator collectors.
    public struct CustomerMeCollectorInfo: Swift.Sendable {
        /// The number of active Migration Evaluator collectors.
        /// This member is required.
        public var activeMeCollectors: Swift.Int
        /// The number of deny-listed Migration Evaluator collectors.
        /// This member is required.
        public var denyListedMeCollectors: Swift.Int
        /// The number of healthy Migration Evaluator collectors.
        /// This member is required.
        public var healthyMeCollectors: Swift.Int
        /// The number of Migration Evaluator collectors with SHUTDOWN status.
        /// This member is required.
        public var shutdownMeCollectors: Swift.Int
        /// The total number of Migration Evaluator collectors.
        /// This member is required.
        public var totalMeCollectors: Swift.Int
        /// The number of unhealthy Migration Evaluator collectors.
        /// This member is required.
        public var unhealthyMeCollectors: Swift.Int
        /// The number of unknown Migration Evaluator collectors.
        /// This member is required.
        public var unknownMeCollectors: Swift.Int

        public init(
            activeMeCollectors: Swift.Int = 0,
            denyListedMeCollectors: Swift.Int = 0,
            healthyMeCollectors: Swift.Int = 0,
            shutdownMeCollectors: Swift.Int = 0,
            totalMeCollectors: Swift.Int = 0,
            unhealthyMeCollectors: Swift.Int = 0,
            unknownMeCollectors: Swift.Int = 0
        )
        {
            self.activeMeCollectors = activeMeCollectors
            self.denyListedMeCollectors = denyListedMeCollectors
            self.healthyMeCollectors = healthyMeCollectors
            self.shutdownMeCollectors = shutdownMeCollectors
            self.totalMeCollectors = totalMeCollectors
            self.unhealthyMeCollectors = unhealthyMeCollectors
            self.unknownMeCollectors = unknownMeCollectors
        }
    }
}

public struct GetDiscoverySummaryOutput: Swift.Sendable {
    /// Details about discovered agents, including agent status and health.
    public var agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo?
    /// Details about Agentless Collector collectors, including status.
    public var agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo?
    /// The number of applications discovered.
    public var applications: Swift.Int
    /// Details about discovered connectors, including connector status and health.
    public var connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo?
    /// Details about Migration Evaluator collectors, including collector status and health.
    public var meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo?
    /// The number of servers discovered.
    public var servers: Swift.Int
    /// The number of servers mapped to applications.
    public var serversMappedToApplications: Swift.Int
    /// The number of servers mapped to tags.
    public var serversMappedtoTags: Swift.Int

    public init(
        agentSummary: ApplicationDiscoveryClientTypes.CustomerAgentInfo? = nil,
        agentlessCollectorSummary: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo? = nil,
        applications: Swift.Int = 0,
        connectorSummary: ApplicationDiscoveryClientTypes.CustomerConnectorInfo? = nil,
        meCollectorSummary: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo? = nil,
        servers: Swift.Int = 0,
        serversMappedToApplications: Swift.Int = 0,
        serversMappedtoTags: Swift.Int = 0
    )
    {
        self.agentSummary = agentSummary
        self.agentlessCollectorSummary = agentlessCollectorSummary
        self.applications = applications
        self.connectorSummary = connectorSummary
        self.meCollectorSummary = meCollectorSummary
        self.servers = servers
        self.serversMappedToApplications = serversMappedToApplications
        self.serversMappedtoTags = serversMappedtoTags
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum OrderString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderString] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// A field and direction for ordered output.
    public struct OrderByElement: Swift.Sendable {
        /// The field on which to order.
        /// This member is required.
        public var fieldName: Swift.String?
        /// Ordering direction.
        public var sortOrder: ApplicationDiscoveryClientTypes.OrderString?

        public init(
            fieldName: Swift.String? = nil,
            sortOrder: ApplicationDiscoveryClientTypes.OrderString? = nil
        )
        {
            self.fieldName = fieldName
            self.sortOrder = sortOrder
        }
    }
}

public struct ListConfigurationsInput: Swift.Sendable {
    /// A valid configuration identified by Application Discovery Service.
    /// This member is required.
    public var configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType?
    /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"} For a complete list of filter options and guidance about using them with this action, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var filters: [ApplicationDiscoveryClientTypes.Filter]?
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// Token to retrieve the next set of results. For example, if a previous call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Certain filter criteria return output that can be sorted in ascending or descending order. For a list of output characteristics for each filter, see [Using the ListConfigurations Action](https://docs.aws.amazon.com/application-discovery/latest/userguide/discovery-api-queries.html#ListConfigurations) in the Amazon Web Services Application Discovery Service User Guide.
    public var orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]?

    public init(
        configurationType: ApplicationDiscoveryClientTypes.ConfigurationItemType? = nil,
        filters: [ApplicationDiscoveryClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        orderBy: [ApplicationDiscoveryClientTypes.OrderByElement]? = nil
    )
    {
        self.configurationType = configurationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
    }
}

public struct ListConfigurationsOutput: Swift.Sendable {
    /// Returns configuration details, including the configuration ID, attribute names, and attribute values.
    public var configurations: [[Swift.String: Swift.String]]?
    /// Token to retrieve the next set of results. For example, if your call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        configurations: [[Swift.String: Swift.String]]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurations = configurations
        self.nextToken = nextToken
    }
}

public struct ListServerNeighborsInput: Swift.Sendable {
    /// Configuration ID of the server for which neighbors are being listed.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Maximum number of results to return in a single page of output.
    public var maxResults: Swift.Int?
    /// List of configuration IDs to test for one-hop-away.
    public var neighborConfigurationIds: [Swift.String]?
    /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
    public var nextToken: Swift.String?
    /// Flag to indicate if port and protocol information is needed as part of the response.
    public var portInformationNeeded: Swift.Bool?

    public init(
        configurationId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        neighborConfigurationIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        portInformationNeeded: Swift.Bool? = false
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.neighborConfigurationIds = neighborConfigurationIds
        self.nextToken = nextToken
        self.portInformationNeeded = portInformationNeeded
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Details about neighboring servers.
    public struct NeighborConnectionDetail: Swift.Sendable {
        /// The number of open network connections with the neighboring server.
        /// This member is required.
        public var connectionsCount: Swift.Int
        /// The destination network port for the connection.
        public var destinationPort: Swift.Int?
        /// The ID of the server that accepted the network connection.
        /// This member is required.
        public var destinationServerId: Swift.String?
        /// The ID of the server that opened the network connection.
        /// This member is required.
        public var sourceServerId: Swift.String?
        /// The network protocol used for the connection.
        public var transportProtocol: Swift.String?

        public init(
            connectionsCount: Swift.Int = 0,
            destinationPort: Swift.Int? = nil,
            destinationServerId: Swift.String? = nil,
            sourceServerId: Swift.String? = nil,
            transportProtocol: Swift.String? = nil
        )
        {
            self.connectionsCount = connectionsCount
            self.destinationPort = destinationPort
            self.destinationServerId = destinationServerId
            self.sourceServerId = sourceServerId
            self.transportProtocol = transportProtocol
        }
    }
}

public struct ListServerNeighborsOutput: Swift.Sendable {
    /// Count of distinct servers that are one hop away from the given server.
    public var knownDependencyCount: Swift.Int
    /// List of distinct servers that are one hop away from the given server.
    /// This member is required.
    public var neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]?
    /// Token to retrieve the next set of results. For example, if you specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        knownDependencyCount: Swift.Int = 0,
        neighbors: [ApplicationDiscoveryClientTypes.NeighborConnectionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knownDependencyCount = knownDependencyCount
        self.neighbors = neighbors
        self.nextToken = nextToken
    }
}

/// The limit of 200 configuration IDs per request has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartBatchDeleteConfigurationTaskInput: Swift.Sendable {
    /// The list of configuration IDs that will be deleted by the task.
    /// This member is required.
    public var configurationIds: [Swift.String]?
    /// The type of configuration item to delete. Supported types are: SERVER.
    /// This member is required.
    public var configurationType: ApplicationDiscoveryClientTypes.DeletionConfigurationItemType?

    public init(
        configurationIds: [Swift.String]? = nil,
        configurationType: ApplicationDiscoveryClientTypes.DeletionConfigurationItemType? = nil
    )
    {
        self.configurationIds = configurationIds
        self.configurationType = configurationType
    }
}

public struct StartBatchDeleteConfigurationTaskOutput: Swift.Sendable {
    /// The unique identifier associated with the newly started deletion task.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

/// Conflict error.
public struct ConflictErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This issue occurs when the same clientRequestToken is used with the StartImportTask action, but with different parameters. For example, you use the same request token but have two different import URLs, you can encounter this issue. If the import tasks are meant to be different, use a different clientRequestToken, and try again.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartContinuousExportInput: Swift.Sendable {

    public init() { }
}

public struct StartContinuousExportOutput: Swift.Sendable {
    /// The type of data collector used to gather this data (currently only offered for AGENT).
    public var dataSource: ApplicationDiscoveryClientTypes.DataSource?
    /// The unique ID assigned to this export.
    public var exportId: Swift.String?
    /// The name of the s3 bucket where the export data parquet files are stored.
    public var s3Bucket: Swift.String?
    /// A dictionary which describes how the data is stored.
    ///
    /// * databaseName - the name of the Glue database used to store the schema.
    public var schemaStorageConfig: [Swift.String: Swift.String]?
    /// The timestamp representing when the continuous export was started.
    public var startTime: Foundation.Date?

    public init(
        dataSource: ApplicationDiscoveryClientTypes.DataSource? = nil,
        exportId: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        schemaStorageConfig: [Swift.String: Swift.String]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.dataSource = dataSource
        self.exportId = exportId
        self.s3Bucket = s3Bucket
        self.schemaStorageConfig = schemaStorageConfig
        self.startTime = startTime
    }
}

public struct StartDataCollectionByAgentIdsInput: Swift.Sendable {
    /// The IDs of the agents from which to start collecting data. If you send a request to an agent ID that you do not have permission to contact, according to your Amazon Web Services account, the service does not throw an exception. Instead, it returns the error in the Description field. If you send a request to multiple agents and you do not have permission to contact some of those agents, the system does not throw an exception. Instead, the system shows Failed in the Description field.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init(
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

public struct StartDataCollectionByAgentIdsOutput: Swift.Sendable {
    /// Information about agents that were instructed to start collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init(
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum ExportDataFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportDataFormat] {
            return [
                .csv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Specifies the performance metrics to use for the server that is used for recommendations.
    public struct UsageMetricBasis: Swift.Sendable {
        /// A utilization metric that is used by the recommendations.
        public var name: Swift.String?
        /// Specifies the percentage of the specified utilization metric that is used by the recommendations.
        public var percentageAdjust: Swift.Double?

        public init(
            name: Swift.String? = nil,
            percentageAdjust: Swift.Double? = nil
        )
        {
            self.name = name
            self.percentageAdjust = percentageAdjust
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum OfferingClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertible
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingClass] {
            return [
                .convertible,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertible: return "CONVERTIBLE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum PurchasingOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PurchasingOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum TermLength: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [TermLength] {
            return [
                .oneYear,
                .threeYear
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYear: return "THREE_YEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Used to provide Reserved Instance preferences for the recommendation.
    public struct ReservedInstanceOptions: Swift.Sendable {
        /// The flexibility to change the instance types needed for your Reserved Instance.
        /// This member is required.
        public var offeringClass: ApplicationDiscoveryClientTypes.OfferingClass?
        /// The payment plan to use for your Reserved Instance.
        /// This member is required.
        public var purchasingOption: ApplicationDiscoveryClientTypes.PurchasingOption?
        /// The preferred duration of the Reserved Instance term.
        /// This member is required.
        public var termLength: ApplicationDiscoveryClientTypes.TermLength?

        public init(
            offeringClass: ApplicationDiscoveryClientTypes.OfferingClass? = nil,
            purchasingOption: ApplicationDiscoveryClientTypes.PurchasingOption? = nil,
            termLength: ApplicationDiscoveryClientTypes.TermLength? = nil
        )
        {
            self.offeringClass = offeringClass
            self.purchasingOption = purchasingOption
            self.termLength = termLength
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    public enum Tenancy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Tenancy] {
            return [
                .dedicated,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Indicates that the exported data must include EC2 instance type matches for on-premises servers that are discovered through Amazon Web Services Application Discovery Service.
    public struct Ec2RecommendationsExportPreferences: Swift.Sendable {
        /// The recommended EC2 instance type that matches the CPU usage metric of server performance data.
        public var cpuPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis?
        /// If set to true, the export [preferences](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html#API_StartExportTask_RequestSyntax) is set to Ec2RecommendationsExportPreferences.
        public var enabled: Swift.Bool
        /// An array of instance types to exclude from recommendations.
        public var excludedInstanceTypes: [Swift.String]?
        /// The target Amazon Web Services Region for the recommendations. You can use any of the Region codes available for the chosen service, as listed in [Amazon Web Services service endpoints](https://docs.aws.amazon.com/general/latest/gr/rande.html) in the Amazon Web Services General Reference.
        public var preferredRegion: Swift.String?
        /// The recommended EC2 instance type that matches the Memory usage metric of server performance data.
        public var ramPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis?
        /// The contract type for a reserved instance. If blank, we assume an On-Demand instance is preferred.
        public var reservedInstanceOptions: ApplicationDiscoveryClientTypes.ReservedInstanceOptions?
        /// The target tenancy to use for your recommended EC2 instances.
        public var tenancy: ApplicationDiscoveryClientTypes.Tenancy?

        public init(
            cpuPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis? = nil,
            enabled: Swift.Bool = false,
            excludedInstanceTypes: [Swift.String]? = nil,
            preferredRegion: Swift.String? = nil,
            ramPerformanceMetricBasis: ApplicationDiscoveryClientTypes.UsageMetricBasis? = nil,
            reservedInstanceOptions: ApplicationDiscoveryClientTypes.ReservedInstanceOptions? = nil,
            tenancy: ApplicationDiscoveryClientTypes.Tenancy? = nil
        )
        {
            self.cpuPerformanceMetricBasis = cpuPerformanceMetricBasis
            self.enabled = enabled
            self.excludedInstanceTypes = excludedInstanceTypes
            self.preferredRegion = preferredRegion
            self.ramPerformanceMetricBasis = ramPerformanceMetricBasis
            self.reservedInstanceOptions = reservedInstanceOptions
            self.tenancy = tenancy
        }
    }
}

extension ApplicationDiscoveryClientTypes {

    /// Indicates the type of data that is being exported. Only one ExportPreferences can be enabled for a [StartExportTask](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_StartExportTask.html) action.
    public enum ExportPreferences: Swift.Sendable {
        /// If enabled, exported data includes EC2 instance type matches for on-premises servers discovered through Amazon Web Services Application Discovery Service.
        case ec2recommendationspreferences(ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences)
        case sdkUnknown(Swift.String)
    }
}

public struct StartExportTaskInput: Swift.Sendable {
    /// The end timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, exported data includes the most recent data collected by the agent.
    public var endTime: Foundation.Date?
    /// The file format for the returned export data. Default value is CSV. Note: The GRAPHML option has been deprecated.
    public var exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]?
    /// If a filter is present, it selects the single agentId of the Application Discovery Agent for which data is exported. The agentId can be found in the results of the DescribeAgents API or CLI. If no filter is present, startTime and endTime are ignored and exported data includes both Amazon Web Services Application Discovery Service Agentless Collector collectors data and summary data from Application Discovery Agent agents.
    public var filters: [ApplicationDiscoveryClientTypes.ExportFilter]?
    /// Indicates the type of data that needs to be exported. Only one [ExportPreferences](https://docs.aws.amazon.com/application-discovery/latest/APIReference/API_ExportPreferences.html) can be enabled at any time.
    public var preferences: ApplicationDiscoveryClientTypes.ExportPreferences?
    /// The start timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, data is exported starting from the first data collected by the agent.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        exportDataFormat: [ApplicationDiscoveryClientTypes.ExportDataFormat]? = nil,
        filters: [ApplicationDiscoveryClientTypes.ExportFilter]? = nil,
        preferences: ApplicationDiscoveryClientTypes.ExportPreferences? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.exportDataFormat = exportDataFormat
        self.filters = filters
        self.preferences = preferences
        self.startTime = startTime
    }
}

public struct StartExportTaskOutput: Swift.Sendable {
    /// A unique identifier used to query the status of an export request.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

public struct StartImportTaskInput: Swift.Sendable {
    /// Optional. A unique token that you can provide to prevent the same import request from occurring more than once. If you don't provide a token, a token is automatically generated. Sending more than one StartImportTask request with the same client request token will return information about the original import task with that client request token.
    public var clientRequestToken: Swift.String?
    /// The URL for your import file that you've uploaded to Amazon S3. If you're using the Amazon Web Services CLI, this URL is structured as follows: s3://BucketName/ImportFileName.CSV
    /// This member is required.
    public var importUrl: Swift.String?
    /// A descriptive name for this request. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        importUrl: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.importUrl = importUrl
        self.name = name
    }
}

public struct StartImportTaskOutput: Swift.Sendable {
    /// An array of information related to the import task request including status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
    public var task: ApplicationDiscoveryClientTypes.ImportTask?

    public init(
        task: ApplicationDiscoveryClientTypes.ImportTask? = nil
    )
    {
        self.task = task
    }
}

public struct StopContinuousExportInput: Swift.Sendable {
    /// The unique ID assigned to this export.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

public struct StopContinuousExportOutput: Swift.Sendable {
    /// Timestamp that represents when this continuous export started collecting data.
    public var startTime: Foundation.Date?
    /// Timestamp that represents when this continuous export was stopped.
    public var stopTime: Foundation.Date?

    public init(
        startTime: Foundation.Date? = nil,
        stopTime: Foundation.Date? = nil
    )
    {
        self.startTime = startTime
        self.stopTime = stopTime
    }
}

public struct StopDataCollectionByAgentIdsInput: Swift.Sendable {
    /// The IDs of the agents from which to stop collecting data.
    /// This member is required.
    public var agentIds: [Swift.String]?

    public init(
        agentIds: [Swift.String]? = nil
    )
    {
        self.agentIds = agentIds
    }
}

public struct StopDataCollectionByAgentIdsOutput: Swift.Sendable {
    /// Information about the agents that were instructed to stop collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
    public var agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]?

    public init(
        agentsConfigurationStatus: [ApplicationDiscoveryClientTypes.AgentConfigurationStatus]? = nil
    )
    {
        self.agentsConfigurationStatus = agentsConfigurationStatus
    }
}

public struct UpdateApplicationInput: Swift.Sendable {
    /// Configuration ID of the application to be updated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// New description of the application to be updated.
    public var description: Swift.String?
    /// New name of the application to be updated.
    public var name: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.description = description
        self.name = name
    }
}

public struct UpdateApplicationOutput: Swift.Sendable {

    public init() { }
}

extension AssociateConfigurationItemsToApplicationInput {

    static func urlPathProvider(_ value: AssociateConfigurationItemsToApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteAgentsInput {

    static func urlPathProvider(_ value: BatchDeleteAgentsInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteImportDataInput {

    static func urlPathProvider(_ value: BatchDeleteImportDataInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTagsInput {

    static func urlPathProvider(_ value: CreateTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationsInput {

    static func urlPathProvider(_ value: DeleteApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTagsInput {

    static func urlPathProvider(_ value: DeleteTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAgentsInput {

    static func urlPathProvider(_ value: DescribeAgentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBatchDeleteConfigurationTaskInput {

    static func urlPathProvider(_ value: DescribeBatchDeleteConfigurationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationsInput {

    static func urlPathProvider(_ value: DescribeConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeContinuousExportsInput {

    static func urlPathProvider(_ value: DescribeContinuousExportsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExportConfigurationsInput {

    static func urlPathProvider(_ value: DescribeExportConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExportTasksInput {

    static func urlPathProvider(_ value: DescribeExportTasksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeImportTasksInput {

    static func urlPathProvider(_ value: DescribeImportTasksInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTagsInput {

    static func urlPathProvider(_ value: DescribeTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateConfigurationItemsFromApplicationInput {

    static func urlPathProvider(_ value: DisassociateConfigurationItemsFromApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension ExportConfigurationsInput {

    static func urlPathProvider(_ value: ExportConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension GetDiscoverySummaryInput {

    static func urlPathProvider(_ value: GetDiscoverySummaryInput) -> Swift.String? {
        return "/"
    }
}

extension ListConfigurationsInput {

    static func urlPathProvider(_ value: ListConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServerNeighborsInput {

    static func urlPathProvider(_ value: ListServerNeighborsInput) -> Swift.String? {
        return "/"
    }
}

extension StartBatchDeleteConfigurationTaskInput {

    static func urlPathProvider(_ value: StartBatchDeleteConfigurationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartContinuousExportInput {

    static func urlPathProvider(_ value: StartContinuousExportInput) -> Swift.String? {
        return "/"
    }
}

extension StartDataCollectionByAgentIdsInput {

    static func urlPathProvider(_ value: StartDataCollectionByAgentIdsInput) -> Swift.String? {
        return "/"
    }
}

extension StartExportTaskInput {

    static func urlPathProvider(_ value: StartExportTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartImportTaskInput {

    static func urlPathProvider(_ value: StartImportTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StopContinuousExportInput {

    static func urlPathProvider(_ value: StopContinuousExportInput) -> Swift.String? {
        return "/"
    }
}

extension StopDataCollectionByAgentIdsInput {

    static func urlPathProvider(_ value: StopDataCollectionByAgentIdsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateConfigurationItemsToApplicationInput {

    static func write(value: AssociateConfigurationItemsToApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationConfigurationId"].write(value.applicationConfigurationId)
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteAgentsInput {

    static func write(value: BatchDeleteAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteAgents"].writeList(value.deleteAgents, memberWritingClosure: ApplicationDiscoveryClientTypes.DeleteAgent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteImportDataInput {

    static func write(value: BatchDeleteImportDataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteHistory"].write(value.deleteHistory)
        try writer["importTaskIds"].writeList(value.importTaskIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension CreateTagsInput {

    static func write(value: CreateTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: ApplicationDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteApplicationsInput {

    static func write(value: DeleteApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteTagsInput {

    static func write(value: DeleteTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: ApplicationDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeAgentsInput {

    static func write(value: DescribeAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeBatchDeleteConfigurationTaskInput {

    static func write(value: DescribeBatchDeleteConfigurationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taskId"].write(value.taskId)
    }
}

extension DescribeConfigurationsInput {

    static func write(value: DescribeConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeContinuousExportsInput {

    static func write(value: DescribeContinuousExportsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportIds"].writeList(value.exportIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeExportConfigurationsInput {

    static func write(value: DescribeExportConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportIds"].writeList(value.exportIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeExportTasksInput {

    static func write(value: DescribeExportTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportIds"].writeList(value.exportIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.ExportFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeImportTasksInput {

    static func write(value: DescribeImportTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.ImportTaskFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeTagsInput {

    static func write(value: DescribeTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.TagFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DisassociateConfigurationItemsFromApplicationInput {

    static func write(value: DisassociateConfigurationItemsFromApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationConfigurationId"].write(value.applicationConfigurationId)
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ExportConfigurationsInput {

    static func write(value: ExportConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetDiscoverySummaryInput {

    static func write(value: GetDiscoverySummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListConfigurationsInput {

    static func write(value: ListConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationType"].write(value.configurationType)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["orderBy"].writeList(value.orderBy, memberWritingClosure: ApplicationDiscoveryClientTypes.OrderByElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListServerNeighborsInput {

    static func write(value: ListServerNeighborsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationId"].write(value.configurationId)
        try writer["maxResults"].write(value.maxResults)
        try writer["neighborConfigurationIds"].writeList(value.neighborConfigurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nextToken"].write(value.nextToken)
        try writer["portInformationNeeded"].write(value.portInformationNeeded)
    }
}

extension StartBatchDeleteConfigurationTaskInput {

    static func write(value: StartBatchDeleteConfigurationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationIds"].writeList(value.configurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["configurationType"].write(value.configurationType)
    }
}

extension StartContinuousExportInput {

    static func write(value: StartContinuousExportInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StartDataCollectionByAgentIdsInput {

    static func write(value: StartDataCollectionByAgentIdsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartExportTaskInput {

    static func write(value: StartExportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["exportDataFormat"].writeList(value.exportDataFormat, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ApplicationDiscoveryClientTypes.ExportDataFormat>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["filters"].writeList(value.filters, memberWritingClosure: ApplicationDiscoveryClientTypes.ExportFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["preferences"].write(value.preferences, with: ApplicationDiscoveryClientTypes.ExportPreferences.write(value:to:))
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension StartImportTaskInput {

    static func write(value: StartImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["importUrl"].write(value.importUrl)
        try writer["name"].write(value.name)
    }
}

extension StopContinuousExportInput {

    static func write(value: StopContinuousExportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exportId"].write(value.exportId)
    }
}

extension StopDataCollectionByAgentIdsInput {

    static func write(value: StopDataCollectionByAgentIdsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentIds"].writeList(value.agentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configurationId"].write(value.configurationId)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension AssociateConfigurationItemsToApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateConfigurationItemsToApplicationOutput {
        return AssociateConfigurationItemsToApplicationOutput()
    }
}

extension BatchDeleteAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteAgentsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.BatchDeleteAgentError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteImportDataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteImportDataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteImportDataOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.BatchDeleteImportDataError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.configurationId = try reader["configurationId"].readIfPresent()
        return value
    }
}

extension CreateTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTagsOutput {
        return CreateTagsOutput()
    }
}

extension DeleteApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationsOutput {
        return DeleteApplicationsOutput()
    }
}

extension DeleteTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTagsOutput {
        return DeleteTagsOutput()
    }
}

extension DescribeAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAgentsOutput()
        value.agentsInfo = try reader["agentsInfo"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.AgentInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeBatchDeleteConfigurationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBatchDeleteConfigurationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBatchDeleteConfigurationTaskOutput()
        value.task = try reader["task"].readIfPresent(with: ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask.read(from:))
        return value
    }
}

extension DescribeConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationsOutput()
        value.configurations = try reader["configurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeContinuousExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeContinuousExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeContinuousExportsOutput()
        value.descriptions = try reader["descriptions"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.ContinuousExportDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeExportConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExportConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExportConfigurationsOutput()
        value.exportsInfo = try reader["exportsInfo"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.ExportInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeExportTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExportTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExportTasksOutput()
        value.exportsInfo = try reader["exportsInfo"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.ExportInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeImportTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImportTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImportTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.ImportTask.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTagsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.ConfigurationTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateConfigurationItemsFromApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateConfigurationItemsFromApplicationOutput {
        return DisassociateConfigurationItemsFromApplicationOutput()
    }
}

extension ExportConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportConfigurationsOutput()
        value.exportId = try reader["exportId"].readIfPresent()
        return value
    }
}

extension GetDiscoverySummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDiscoverySummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDiscoverySummaryOutput()
        value.agentSummary = try reader["agentSummary"].readIfPresent(with: ApplicationDiscoveryClientTypes.CustomerAgentInfo.read(from:))
        value.agentlessCollectorSummary = try reader["agentlessCollectorSummary"].readIfPresent(with: ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo.read(from:))
        value.applications = try reader["applications"].readIfPresent() ?? 0
        value.connectorSummary = try reader["connectorSummary"].readIfPresent(with: ApplicationDiscoveryClientTypes.CustomerConnectorInfo.read(from:))
        value.meCollectorSummary = try reader["meCollectorSummary"].readIfPresent(with: ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo.read(from:))
        value.servers = try reader["servers"].readIfPresent() ?? 0
        value.serversMappedToApplications = try reader["serversMappedToApplications"].readIfPresent() ?? 0
        value.serversMappedtoTags = try reader["serversMappedtoTags"].readIfPresent() ?? 0
        return value
    }
}

extension ListConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationsOutput()
        value.configurations = try reader["configurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServerNeighborsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServerNeighborsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServerNeighborsOutput()
        value.knownDependencyCount = try reader["knownDependencyCount"].readIfPresent() ?? 0
        value.neighbors = try reader["neighbors"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.NeighborConnectionDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension StartBatchDeleteConfigurationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBatchDeleteConfigurationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBatchDeleteConfigurationTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension StartContinuousExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartContinuousExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartContinuousExportOutput()
        value.dataSource = try reader["dataSource"].readIfPresent()
        value.exportId = try reader["exportId"].readIfPresent()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.schemaStorageConfig = try reader["schemaStorageConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StartDataCollectionByAgentIdsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDataCollectionByAgentIdsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDataCollectionByAgentIdsOutput()
        value.agentsConfigurationStatus = try reader["agentsConfigurationStatus"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.AgentConfigurationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartExportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExportTaskOutput()
        value.exportId = try reader["exportId"].readIfPresent()
        return value
    }
}

extension StartImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportTaskOutput()
        value.task = try reader["task"].readIfPresent(with: ApplicationDiscoveryClientTypes.ImportTask.read(from:))
        return value
    }
}

extension StopContinuousExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopContinuousExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopContinuousExportOutput()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension StopDataCollectionByAgentIdsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopDataCollectionByAgentIdsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopDataCollectionByAgentIdsOutput()
        value.agentsConfigurationStatus = try reader["agentsConfigurationStatus"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.AgentConfigurationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

enum AssociateConfigurationItemsToApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteImportDataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBatchDeleteConfigurationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeContinuousExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExportConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExportTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImportTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateConfigurationItemsFromApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDiscoverySummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServerNeighborsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBatchDeleteConfigurationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartContinuousExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConflictErrorException": return try ConflictErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDataCollectionByAgentIdsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopContinuousExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "OperationNotPermittedException": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopDataCollectionByAgentIdsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationErrorException": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "HomeRegionNotSetException": return try HomeRegionNotSetException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ServerInternalErrorException": return try ServerInternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuthorizationErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AuthorizationErrorException {
        let reader = baseError.errorBodyReader
        var value = AuthorizationErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServerInternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServerInternalErrorException {
        let reader = baseError.errorBodyReader
        var value = ServerInternalErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HomeRegionNotSetException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> HomeRegionNotSetException {
        let reader = baseError.errorBodyReader
        var value = HomeRegionNotSetException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotPermittedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictErrorException {
        let reader = baseError.errorBodyReader
        var value = ConflictErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApplicationDiscoveryClientTypes.BatchDeleteAgentError {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.BatchDeleteAgentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.BatchDeleteAgentError()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ApplicationDiscoveryClientTypes.BatchDeleteImportDataError {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.BatchDeleteImportDataError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.BatchDeleteImportDataError()
        value.importTaskId = try reader["importTaskId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorDescription = try reader["errorDescription"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.AgentInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.AgentInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.AgentInfo()
        value.agentId = try reader["agentId"].readIfPresent()
        value.hostName = try reader["hostName"].readIfPresent()
        value.agentNetworkInfoList = try reader["agentNetworkInfoList"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.AgentNetworkInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectorId = try reader["connectorId"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.health = try reader["health"].readIfPresent()
        value.lastHealthPingTime = try reader["lastHealthPingTime"].readIfPresent()
        value.collectionStatus = try reader["collectionStatus"].readIfPresent()
        value.agentType = try reader["agentType"].readIfPresent()
        value.registeredTime = try reader["registeredTime"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.AgentNetworkInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.AgentNetworkInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.AgentNetworkInfo()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.macAddress = try reader["macAddress"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.BatchDeleteConfigurationTask()
        value.taskId = try reader["taskId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configurationType = try reader["configurationType"].readIfPresent()
        value.requestedConfigurations = try reader["requestedConfigurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deletedConfigurations = try reader["deletedConfigurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedConfigurations = try reader["failedConfigurations"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.FailedConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deletionWarnings = try reader["deletionWarnings"].readListIfPresent(memberReadingClosure: ApplicationDiscoveryClientTypes.DeletionWarning.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApplicationDiscoveryClientTypes.DeletionWarning {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.DeletionWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.DeletionWarning()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.warningCode = try reader["warningCode"].readIfPresent() ?? 0
        value.warningText = try reader["warningText"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.FailedConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.FailedConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.FailedConfiguration()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.errorStatusCode = try reader["errorStatusCode"].readIfPresent() ?? 0
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.ContinuousExportDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.ContinuousExportDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.ContinuousExportDescription()
        value.exportId = try reader["exportId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusDetail = try reader["statusDetail"].readIfPresent()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopTime = try reader["stopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSource = try reader["dataSource"].readIfPresent()
        value.schemaStorageConfig = try reader["schemaStorageConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ApplicationDiscoveryClientTypes.ExportInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.ExportInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.ExportInfo()
        value.exportId = try reader["exportId"].readIfPresent() ?? ""
        value.exportStatus = try reader["exportStatus"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent() ?? ""
        value.configurationsDownloadUrl = try reader["configurationsDownloadUrl"].readIfPresent()
        value.exportRequestTime = try reader["exportRequestTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.isTruncated = try reader["isTruncated"].readIfPresent() ?? false
        value.requestedStartTime = try reader["requestedStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requestedEndTime = try reader["requestedEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ApplicationDiscoveryClientTypes.ImportTask {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.ImportTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.ImportTask()
        value.importTaskId = try reader["importTaskId"].readIfPresent()
        value.clientRequestToken = try reader["clientRequestToken"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.importUrl = try reader["importUrl"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.importRequestTime = try reader["importRequestTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importCompletionTime = try reader["importCompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importDeletedTime = try reader["importDeletedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverImportSuccess = try reader["serverImportSuccess"].readIfPresent() ?? 0
        value.serverImportFailure = try reader["serverImportFailure"].readIfPresent() ?? 0
        value.applicationImportSuccess = try reader["applicationImportSuccess"].readIfPresent() ?? 0
        value.applicationImportFailure = try reader["applicationImportFailure"].readIfPresent() ?? 0
        value.errorsAndFailedEntriesZip = try reader["errorsAndFailedEntriesZip"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.ConfigurationTag {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.ConfigurationTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.ConfigurationTag()
        value.configurationType = try reader["configurationType"].readIfPresent()
        value.configurationId = try reader["configurationId"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.timeOfCreation = try reader["timeOfCreation"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ApplicationDiscoveryClientTypes.CustomerAgentInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.CustomerAgentInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.CustomerAgentInfo()
        value.activeAgents = try reader["activeAgents"].readIfPresent() ?? 0
        value.healthyAgents = try reader["healthyAgents"].readIfPresent() ?? 0
        value.blackListedAgents = try reader["blackListedAgents"].readIfPresent() ?? 0
        value.shutdownAgents = try reader["shutdownAgents"].readIfPresent() ?? 0
        value.unhealthyAgents = try reader["unhealthyAgents"].readIfPresent() ?? 0
        value.totalAgents = try reader["totalAgents"].readIfPresent() ?? 0
        value.unknownAgents = try reader["unknownAgents"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationDiscoveryClientTypes.CustomerConnectorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.CustomerConnectorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.CustomerConnectorInfo()
        value.activeConnectors = try reader["activeConnectors"].readIfPresent() ?? 0
        value.healthyConnectors = try reader["healthyConnectors"].readIfPresent() ?? 0
        value.blackListedConnectors = try reader["blackListedConnectors"].readIfPresent() ?? 0
        value.shutdownConnectors = try reader["shutdownConnectors"].readIfPresent() ?? 0
        value.unhealthyConnectors = try reader["unhealthyConnectors"].readIfPresent() ?? 0
        value.totalConnectors = try reader["totalConnectors"].readIfPresent() ?? 0
        value.unknownConnectors = try reader["unknownConnectors"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.CustomerMeCollectorInfo()
        value.activeMeCollectors = try reader["activeMeCollectors"].readIfPresent() ?? 0
        value.healthyMeCollectors = try reader["healthyMeCollectors"].readIfPresent() ?? 0
        value.denyListedMeCollectors = try reader["denyListedMeCollectors"].readIfPresent() ?? 0
        value.shutdownMeCollectors = try reader["shutdownMeCollectors"].readIfPresent() ?? 0
        value.unhealthyMeCollectors = try reader["unhealthyMeCollectors"].readIfPresent() ?? 0
        value.totalMeCollectors = try reader["totalMeCollectors"].readIfPresent() ?? 0
        value.unknownMeCollectors = try reader["unknownMeCollectors"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.CustomerAgentlessCollectorInfo()
        value.activeAgentlessCollectors = try reader["activeAgentlessCollectors"].readIfPresent() ?? 0
        value.healthyAgentlessCollectors = try reader["healthyAgentlessCollectors"].readIfPresent() ?? 0
        value.denyListedAgentlessCollectors = try reader["denyListedAgentlessCollectors"].readIfPresent() ?? 0
        value.shutdownAgentlessCollectors = try reader["shutdownAgentlessCollectors"].readIfPresent() ?? 0
        value.unhealthyAgentlessCollectors = try reader["unhealthyAgentlessCollectors"].readIfPresent() ?? 0
        value.totalAgentlessCollectors = try reader["totalAgentlessCollectors"].readIfPresent() ?? 0
        value.unknownAgentlessCollectors = try reader["unknownAgentlessCollectors"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationDiscoveryClientTypes.NeighborConnectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.NeighborConnectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.NeighborConnectionDetail()
        value.sourceServerId = try reader["sourceServerId"].readIfPresent() ?? ""
        value.destinationServerId = try reader["destinationServerId"].readIfPresent() ?? ""
        value.destinationPort = try reader["destinationPort"].readIfPresent()
        value.transportProtocol = try reader["transportProtocol"].readIfPresent()
        value.connectionsCount = try reader["connectionsCount"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationDiscoveryClientTypes.AgentConfigurationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationDiscoveryClientTypes.AgentConfigurationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationDiscoveryClientTypes.AgentConfigurationStatus()
        value.agentId = try reader["agentId"].readIfPresent()
        value.operationSucceeded = try reader["operationSucceeded"].readIfPresent() ?? false
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension ApplicationDiscoveryClientTypes.DeleteAgent {

    static func write(value: ApplicationDiscoveryClientTypes.DeleteAgent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentId"].write(value.agentId)
        try writer["force"].write(value.force)
    }
}

extension ApplicationDiscoveryClientTypes.Tag {

    static func write(value: ApplicationDiscoveryClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

extension ApplicationDiscoveryClientTypes.Filter {

    static func write(value: ApplicationDiscoveryClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ApplicationDiscoveryClientTypes.ExportFilter {

    static func write(value: ApplicationDiscoveryClientTypes.ExportFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ApplicationDiscoveryClientTypes.ImportTaskFilter {

    static func write(value: ApplicationDiscoveryClientTypes.ImportTaskFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ApplicationDiscoveryClientTypes.TagFilter {

    static func write(value: ApplicationDiscoveryClientTypes.TagFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ApplicationDiscoveryClientTypes.OrderByElement {

    static func write(value: ApplicationDiscoveryClientTypes.OrderByElement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldName"].write(value.fieldName)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ApplicationDiscoveryClientTypes.ExportPreferences {

    static func write(value: ApplicationDiscoveryClientTypes.ExportPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ec2recommendationspreferences(ec2recommendationspreferences):
                try writer["ec2RecommendationsPreferences"].write(ec2recommendationspreferences, with: ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences {

    static func write(value: ApplicationDiscoveryClientTypes.Ec2RecommendationsExportPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpuPerformanceMetricBasis"].write(value.cpuPerformanceMetricBasis, with: ApplicationDiscoveryClientTypes.UsageMetricBasis.write(value:to:))
        try writer["enabled"].write(value.enabled)
        try writer["excludedInstanceTypes"].writeList(value.excludedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["preferredRegion"].write(value.preferredRegion)
        try writer["ramPerformanceMetricBasis"].write(value.ramPerformanceMetricBasis, with: ApplicationDiscoveryClientTypes.UsageMetricBasis.write(value:to:))
        try writer["reservedInstanceOptions"].write(value.reservedInstanceOptions, with: ApplicationDiscoveryClientTypes.ReservedInstanceOptions.write(value:to:))
        try writer["tenancy"].write(value.tenancy)
    }
}

extension ApplicationDiscoveryClientTypes.ReservedInstanceOptions {

    static func write(value: ApplicationDiscoveryClientTypes.ReservedInstanceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offeringClass"].write(value.offeringClass)
        try writer["purchasingOption"].write(value.purchasingOption)
        try writer["termLength"].write(value.termLength)
    }
}

extension ApplicationDiscoveryClientTypes.UsageMetricBasis {

    static func write(value: ApplicationDiscoveryClientTypes.UsageMetricBasis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["percentageAdjust"].write(value.percentageAdjust)
    }
}

public enum ApplicationDiscoveryClientTypes {}
