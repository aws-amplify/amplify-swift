//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension TrustedAdvisorClient {
    /// Paginate over `[ListChecksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListChecksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListChecksOutput`
    public func listChecksPaginated(input: ListChecksInput) -> ClientRuntime.PaginatorSequence<ListChecksInput, ListChecksOutput> {
        return ClientRuntime.PaginatorSequence<ListChecksInput, ListChecksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listChecks(input:))
    }
}

extension ListChecksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListChecksInput {
        return ListChecksInput(
            awsService: self.awsService,
            language: self.language,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source
        )}
}

extension PaginatorSequence where OperationStackInput == ListChecksInput, OperationStackOutput == ListChecksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listChecksPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.CheckSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.CheckSummary]`
    public func checkSummaries() async throws -> [TrustedAdvisorClientTypes.CheckSummary] {
        return try await self.asyncCompactMap { item in item.checkSummaries }
    }
}
extension TrustedAdvisorClient {
    /// Paginate over `[ListOrganizationRecommendationAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationRecommendationAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationRecommendationAccountsOutput`
    public func listOrganizationRecommendationAccountsPaginated(input: ListOrganizationRecommendationAccountsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationRecommendationAccountsInput, ListOrganizationRecommendationAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationRecommendationAccountsInput, ListOrganizationRecommendationAccountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizationRecommendationAccounts(input:))
    }
}

extension ListOrganizationRecommendationAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationRecommendationAccountsInput {
        return ListOrganizationRecommendationAccountsInput(
            affectedAccountId: self.affectedAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationRecommendationIdentifier: self.organizationRecommendationIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListOrganizationRecommendationAccountsInput, OperationStackOutput == ListOrganizationRecommendationAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationRecommendationAccountsPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]`
    public func accountRecommendationLifecycleSummaries() async throws -> [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary] {
        return try await self.asyncCompactMap { item in item.accountRecommendationLifecycleSummaries }
    }
}
extension TrustedAdvisorClient {
    /// Paginate over `[ListOrganizationRecommendationResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationRecommendationResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationRecommendationResourcesOutput`
    public func listOrganizationRecommendationResourcesPaginated(input: ListOrganizationRecommendationResourcesInput) -> ClientRuntime.PaginatorSequence<ListOrganizationRecommendationResourcesInput, ListOrganizationRecommendationResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationRecommendationResourcesInput, ListOrganizationRecommendationResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizationRecommendationResources(input:))
    }
}

extension ListOrganizationRecommendationResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationRecommendationResourcesInput {
        return ListOrganizationRecommendationResourcesInput(
            affectedAccountId: self.affectedAccountId,
            exclusionStatus: self.exclusionStatus,
            maxResults: self.maxResults,
            nextToken: token,
            organizationRecommendationIdentifier: self.organizationRecommendationIdentifier,
            regionCode: self.regionCode,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListOrganizationRecommendationResourcesInput, OperationStackOutput == ListOrganizationRecommendationResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationRecommendationResourcesPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]`
    public func organizationRecommendationResourceSummaries() async throws -> [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary] {
        return try await self.asyncCompactMap { item in item.organizationRecommendationResourceSummaries }
    }
}
extension TrustedAdvisorClient {
    /// Paginate over `[ListOrganizationRecommendationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationRecommendationsOutput`
    public func listOrganizationRecommendationsPaginated(input: ListOrganizationRecommendationsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationRecommendationsInput, ListOrganizationRecommendationsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationRecommendationsInput, ListOrganizationRecommendationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizationRecommendations(input:))
    }
}

extension ListOrganizationRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationRecommendationsInput {
        return ListOrganizationRecommendationsInput(
            afterLastUpdatedAt: self.afterLastUpdatedAt,
            awsService: self.awsService,
            beforeLastUpdatedAt: self.beforeLastUpdatedAt,
            checkIdentifier: self.checkIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source,
            status: self.status,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListOrganizationRecommendationsInput, OperationStackOutput == ListOrganizationRecommendationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationRecommendationsPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.OrganizationRecommendationSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.OrganizationRecommendationSummary]`
    public func organizationRecommendationSummaries() async throws -> [TrustedAdvisorClientTypes.OrganizationRecommendationSummary] {
        return try await self.asyncCompactMap { item in item.organizationRecommendationSummaries }
    }
}
extension TrustedAdvisorClient {
    /// Paginate over `[ListRecommendationResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendationResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendationResourcesOutput`
    public func listRecommendationResourcesPaginated(input: ListRecommendationResourcesInput) -> ClientRuntime.PaginatorSequence<ListRecommendationResourcesInput, ListRecommendationResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendationResourcesInput, ListRecommendationResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecommendationResources(input:))
    }
}

extension ListRecommendationResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendationResourcesInput {
        return ListRecommendationResourcesInput(
            exclusionStatus: self.exclusionStatus,
            maxResults: self.maxResults,
            nextToken: token,
            recommendationIdentifier: self.recommendationIdentifier,
            regionCode: self.regionCode,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecommendationResourcesInput, OperationStackOutput == ListRecommendationResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendationResourcesPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.RecommendationResourceSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.RecommendationResourceSummary]`
    public func recommendationResourceSummaries() async throws -> [TrustedAdvisorClientTypes.RecommendationResourceSummary] {
        return try await self.asyncCompactMap { item in item.recommendationResourceSummaries }
    }
}
extension TrustedAdvisorClient {
    /// Paginate over `[ListRecommendationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendationsOutput`
    public func listRecommendationsPaginated(input: ListRecommendationsInput) -> ClientRuntime.PaginatorSequence<ListRecommendationsInput, ListRecommendationsOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendationsInput, ListRecommendationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecommendations(input:))
    }
}

extension ListRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendationsInput {
        return ListRecommendationsInput(
            afterLastUpdatedAt: self.afterLastUpdatedAt,
            awsService: self.awsService,
            beforeLastUpdatedAt: self.beforeLastUpdatedAt,
            checkIdentifier: self.checkIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            pillar: self.pillar,
            source: self.source,
            status: self.status,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecommendationsInput, OperationStackOutput == ListRecommendationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendationsPaginated`
    /// to access the nested member `[TrustedAdvisorClientTypes.RecommendationSummary]`
    /// - Returns: `[TrustedAdvisorClientTypes.RecommendationSummary]`
    public func recommendationSummaries() async throws -> [TrustedAdvisorClientTypes.RecommendationSummary] {
        return try await self.asyncCompactMap { item in item.recommendationSummaries }
    }
}
