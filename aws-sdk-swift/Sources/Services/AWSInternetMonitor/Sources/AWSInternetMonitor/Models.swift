//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InternetMonitorClientTypes {

    /// Amazon CloudWatch Internet Monitor calculates measurements about the availability for your application's internet traffic between client locations and Amazon Web Services. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, we report that information to you in the form of health scores: a performance score and an availability score. Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see [How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
    public struct AvailabilityMeasurement: Swift.Sendable {
        /// Experience scores, or health scores are calculated for different geographic and network provider combinations (that is, different granularities) and also summed into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and availability scores, and when it creates and resolves health events. For more information, see [How Amazon Web Services calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var experienceScore: Swift.Double?
        /// The percentage of impact caused by a health event for client location traffic globally. For information about how Internet Monitor calculates impact, see [Inside Internet Monitor](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var percentOfClientLocationImpacted: Swift.Double?
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this client location to the Amazon Web Services location using this client network. For information about how Internet Monitor calculates impact, see [How Internet Monitor works](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html) in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User Guide.
        public var percentOfTotalTrafficImpacted: Swift.Double?

        public init(
            experienceScore: Swift.Double? = nil,
            percentOfClientLocationImpacted: Swift.Double? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil
        )
        {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        }
    }
}

/// A bad request was received.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InternetMonitorClientTypes {

    /// The impacted location, such as a city, that Amazon Web Services clients access application resources from.
    public struct ClientLocation: Swift.Sendable {
        /// The name of the internet service provider (ISP) or network (ASN).
        /// This member is required.
        public var asName: Swift.String?
        /// The Autonomous System Number (ASN) of the network at an impacted location.
        /// This member is required.
        public var asNumber: Swift.Int?
        /// The name of the city where the internet event is located.
        /// This member is required.
        public var city: Swift.String?
        /// The name of the country where the internet event is located.
        /// This member is required.
        public var country: Swift.String?
        /// The latitude where the internet event is located.
        /// This member is required.
        public var latitude: Swift.Double?
        /// The longitude where the internet event is located.
        /// This member is required.
        public var longitude: Swift.Double?
        /// The metro area where the health event is located. Metro indicates a metropolitan region in the United States, such as the region around New York City. In non-US countries, this is a second-level subdivision. For example, in the United Kingdom, it could be a county, a London borough, a unitary authority, council area, and so on.
        public var metro: Swift.String?
        /// The subdivision location where the health event is located. The subdivision usually maps to states in most countries (including the United States). For United Kingdom, it maps to a country (England, Scotland, Wales) or province (Northern Ireland).
        public var subdivision: Swift.String?

        public init(
            asName: Swift.String? = nil,
            asNumber: Swift.Int? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil,
            metro: Swift.String? = nil,
            subdivision: Swift.String? = nil
        )
        {
            self.asName = asName
            self.asNumber = asNumber
            self.city = city
            self.country = country
            self.latitude = latitude
            self.longitude = longitude
            self.metro = metro
            self.subdivision = subdivision
        }
    }
}

/// The requested resource is in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeded a service quota.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Invalid request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InternetMonitorClientTypes {

    public enum LocalHealthEventsConfigStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LocalHealthEventsConfigStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    /// A complex type with the configuration information that determines the threshold and other conditions for when Internet Monitor creates a health event for a local performance or availability issue, when scores cross a threshold for one or more city-networks. Defines the percentages, for performance scores or availability scores, that are the local thresholds for when Amazon CloudWatch Internet Monitor creates a health event. Also defines whether a local threshold is enabled or disabled, and the minimum percentage of overall traffic that must be impacted by an issue before Internet Monitor creates an event when a threshold is crossed for a local health score. If you don't set a local health event threshold, the default value is 60%. For more information, see [ Change health event thresholds](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-overview.html#IMUpdateThresholdFromOverview) in the Internet Monitor section of the CloudWatch User Guide.
    public struct LocalHealthEventsConfig: Swift.Sendable {
        /// The health event threshold percentage set for a local health score.
        public var healthScoreThreshold: Swift.Double
        /// The minimum percentage of overall traffic for an application that must be impacted by an issue before Internet Monitor creates an event when a threshold is crossed for a local health score. If you don't set a minimum traffic impact threshold, the default value is 0.1%.
        public var minTrafficImpact: Swift.Double
        /// The status of whether Internet Monitor creates a health event based on a threshold percentage set for a local health score. The status can be ENABLED or DISABLED.
        public var status: InternetMonitorClientTypes.LocalHealthEventsConfigStatus?

        public init(
            healthScoreThreshold: Swift.Double = 0.0,
            minTrafficImpact: Swift.Double = 0.0,
            status: InternetMonitorClientTypes.LocalHealthEventsConfigStatus? = nil
        )
        {
            self.healthScoreThreshold = healthScoreThreshold
            self.minTrafficImpact = minTrafficImpact
            self.status = status
        }
    }
}

extension InternetMonitorClientTypes {

    /// A complex type with the configuration information that determines the threshold and other conditions for when Internet Monitor creates a health event for an overall performance or availability issue, across an application's geographies. Defines the percentages, for overall performance scores and availability scores for an application, that are the thresholds for when Amazon CloudWatch Internet Monitor creates a health event. You can override the defaults to set a custom threshold for overall performance or availability scores, or both. You can also set thresholds for local health scores,, where Internet Monitor creates a health event when scores cross a threshold for one or more city-networks, in addition to creating an event when an overall score crosses a threshold. If you don't set a health event threshold, the default value is 95%. For local thresholds, you also set a minimum percentage of overall traffic that is impacted by an issue before Internet Monitor creates an event. In addition, you can disable local thresholds, for performance scores, availability scores, or both. For more information, see [ Change health event thresholds](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-overview.html#IMUpdateThresholdFromOverview) in the Internet Monitor section of the CloudWatch User Guide.
    public struct HealthEventsConfig: Swift.Sendable {
        /// The configuration that determines the threshold and other conditions for when Internet Monitor creates a health event for a local availability issue.
        public var availabilityLocalHealthEventsConfig: InternetMonitorClientTypes.LocalHealthEventsConfig?
        /// The health event threshold percentage set for availability scores.
        public var availabilityScoreThreshold: Swift.Double
        /// The configuration that determines the threshold and other conditions for when Internet Monitor creates a health event for a local performance issue.
        public var performanceLocalHealthEventsConfig: InternetMonitorClientTypes.LocalHealthEventsConfig?
        /// The health event threshold percentage set for performance scores.
        public var performanceScoreThreshold: Swift.Double

        public init(
            availabilityLocalHealthEventsConfig: InternetMonitorClientTypes.LocalHealthEventsConfig? = nil,
            availabilityScoreThreshold: Swift.Double = 0.0,
            performanceLocalHealthEventsConfig: InternetMonitorClientTypes.LocalHealthEventsConfig? = nil,
            performanceScoreThreshold: Swift.Double = 0.0
        )
        {
            self.availabilityLocalHealthEventsConfig = availabilityLocalHealthEventsConfig
            self.availabilityScoreThreshold = availabilityScoreThreshold
            self.performanceLocalHealthEventsConfig = performanceLocalHealthEventsConfig
            self.performanceScoreThreshold = performanceScoreThreshold
        }
    }
}

extension InternetMonitorClientTypes {

    public enum LogDeliveryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [LogDeliveryStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    /// The configuration for publishing Amazon CloudWatch Internet Monitor internet measurements to Amazon S3. The configuration includes the bucket name and (optionally) prefix for the S3 bucket to store the measurements, and the delivery status. The delivery status is ENABLED or DISABLED, depending on whether you choose to deliver internet measurements to S3 logs.
    public struct S3Config: Swift.Sendable {
        /// The Amazon S3 bucket name.
        public var bucketName: Swift.String?
        /// The Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?
        /// The status of publishing Internet Monitor internet measurements to an Amazon S3 bucket.
        public var logDeliveryStatus: InternetMonitorClientTypes.LogDeliveryStatus?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            logDeliveryStatus: InternetMonitorClientTypes.LogDeliveryStatus? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.logDeliveryStatus = logDeliveryStatus
        }
    }
}

extension InternetMonitorClientTypes {

    /// Publish internet measurements to an Amazon S3 bucket in addition to CloudWatch Logs.
    public struct InternetMeasurementsLogDelivery: Swift.Sendable {
        /// The configuration information for publishing Internet Monitor internet measurements to Amazon S3. The configuration includes the bucket name and (optionally) prefix for the S3 bucket to store the measurements, and the delivery status. The delivery status is ENABLED or DISABLED, depending on whether you choose to deliver internet measurements to S3 logs.
        public var s3Config: InternetMonitorClientTypes.S3Config?

        public init(
            s3Config: InternetMonitorClientTypes.S3Config? = nil
        )
        {
            self.s3Config = s3Config
        }
    }
}

public struct CreateMonitorInput: Swift.Sendable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// Defines the threshold percentages and other configuration information for when Amazon CloudWatch Internet Monitor creates a health event. Internet Monitor creates a health event when an internet issue that affects your application end users has a health score percentage that is at or below a specific threshold, and, sometimes, when other criteria are met. If you don't set a health event threshold, the default value is 95%. For more information, see [ Change health event thresholds](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-overview.html#IMUpdateThresholdFromOverview) in the Internet Monitor section of the CloudWatch User Guide.
    public var healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig?
    /// Publish internet measurements for Internet Monitor to an Amazon S3 bucket in addition to CloudWatch Logs.
    public var internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery?
    /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources through. Setting this limit can help control billing costs. To learn more, see [Choosing a city-network maximum value ](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/IMCityNetworksMaximum.html) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public var maxCityNetworksToMonitor: Swift.Int?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). Resources can be VPCs, NLBs, Amazon CloudFront distributions, or Amazon WorkSpaces directories. You can add a combination of VPCs and CloudFront distributions, or you can add WorkSpaces directories, or you can add NLBs. You can't add NLBs or WorkSpaces directories together with any other resources. If you add only Amazon VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet connectivity.
    public var resources: [Swift.String]?
    /// The tags for a monitor. You can add a maximum of 50 tags in Internet Monitor.
    public var tags: [Swift.String: Swift.String]?
    /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor. If you set a city-networks maximum, that limit overrides the traffic percentage that you set. To learn more, see [Choosing an application traffic percentage to monitor ](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/IMTrafficPercentage.html) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public var trafficPercentageToMonitor: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig? = nil,
        internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery? = nil,
        maxCityNetworksToMonitor: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        resources: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        trafficPercentageToMonitor: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.healthEventsConfig = healthEventsConfig
        self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.monitorName = monitorName
        self.resources = resources
        self.tags = tags
        self.trafficPercentageToMonitor = trafficPercentageToMonitor
    }
}

extension InternetMonitorClientTypes {

    public enum MonitorConfigState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case error
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorConfigState] {
            return [
                .active,
                .error,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMonitorOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var arn: Swift.String?
    /// The status of a monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?

    public init(
        arn: Swift.String? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil
    )
    {
        self.arn = arn
        self.status = status
    }
}

public struct DeleteMonitorInput: Swift.Sendable {
    /// The name of the monitor to delete.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        monitorName: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
    }
}

public struct DeleteMonitorOutput: Swift.Sendable {

    public init() { }
}

extension InternetMonitorClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .equals,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    /// A filter that you use with the results of a Amazon CloudWatch Internet Monitor query that you created and ran. The query sets up a repository of data that is a subset of your application's Internet Monitor data. FilterParameter is a string that defines how you want to filter the repository of data to return a set of results, based on your criteria. The filter parameters that you can specify depend on the query type that you used to create the repository, since each query type returns a different set of Internet Monitor data. For each filter, you specify a field (such as city), an operator (such as not_equals, and a value or array of values (such as ["Seattle", "Redmond"]). Separate values in the array with commas. For more information about specifying filter parameters, see [Using the Amazon CloudWatch Internet Monitor query interface](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-view-cw-tools-cwim-query.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public struct FilterParameter: Swift.Sendable {
        /// A data field that you want to filter, to further scope your application's Internet Monitor data in a repository that you created by running a query. A field might be city, for example. The field must be one of the fields that was returned by the specific query that you used to create the repository.
        public var field: Swift.String?
        /// The operator to use with the filter field and a value, such as not_equals.
        public var `operator`: InternetMonitorClientTypes.Operator?
        /// One or more values to be used, together with the specified operator, to filter data for a query. For example, you could specify an array of values such as ["Seattle", "Redmond"]. Values in the array are separated by commas.
        public var values: [Swift.String]?

        public init(
            field: Swift.String? = nil,
            `operator`: InternetMonitorClientTypes.Operator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.field = field
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct GetHealthEventInput: Swift.Sendable {
    /// The internally-generated identifier of a health event. Because EventID contains the forward slash (“/”) character, you must URL-encode the EventID field in the request URL.
    /// This member is required.
    public var eventId: Swift.String?
    /// The account ID for an account that you've set up cross-account sharing for in Amazon CloudWatch Internet Monitor. You configure cross-account sharing by using Amazon CloudWatch Observability Access Manager. For more information, see [Internet Monitor cross-account observability](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cwim-cross-account.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var linkedAccountId: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        linkedAccountId: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.linkedAccountId = linkedAccountId
        self.monitorName = monitorName
    }
}

extension InternetMonitorClientTypes {

    /// An internet service provider (ISP) or network (ASN) in Amazon CloudWatch Internet Monitor.
    public struct Network: Swift.Sendable {
        /// The name of the internet service provider (ISP) or network (ASN).
        /// This member is required.
        public var asName: Swift.String?
        /// The Autonomous System Number (ASN) of the internet provider or network.
        /// This member is required.
        public var asNumber: Swift.Int?

        public init(
            asName: Swift.String? = nil,
            asNumber: Swift.Int? = nil
        )
        {
            self.asName = asName
            self.asNumber = asNumber
        }
    }
}

extension InternetMonitorClientTypes {

    public enum TriangulationEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case internet
        case sdkUnknown(Swift.String)

        public static var allCases: [TriangulationEventType] {
            return [
                .aws,
                .internet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .internet: return "Internet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    /// Information about the network impairment for a specific network measured by Amazon CloudWatch Internet Monitor.
    public struct NetworkImpairment: Swift.Sendable {
        /// The combination of the Autonomous System Number (ASN) of the network and the name of the network.
        /// This member is required.
        public var asPath: [InternetMonitorClientTypes.Network]?
        /// The type of network impairment.
        /// This member is required.
        public var networkEventType: InternetMonitorClientTypes.TriangulationEventType?
        /// The networks that could be impacted by a network impairment event.
        /// This member is required.
        public var networks: [InternetMonitorClientTypes.Network]?

        public init(
            asPath: [InternetMonitorClientTypes.Network]? = nil,
            networkEventType: InternetMonitorClientTypes.TriangulationEventType? = nil,
            networks: [InternetMonitorClientTypes.Network]? = nil
        )
        {
            self.asPath = asPath
            self.networkEventType = networkEventType
            self.networks = networks
        }
    }
}

extension InternetMonitorClientTypes {

    /// Round-trip time (RTT) is how long it takes for a request from the user to return a response to the user. Amazon CloudWatch Internet Monitor calculates RTT at different percentiles: p50, p90, and p95.
    public struct RoundTripTime: Swift.Sendable {
        /// RTT at the 50th percentile (p50).
        public var p50: Swift.Double?
        /// RTT at the 90th percentile (p90).
        public var p90: Swift.Double?
        /// RTT at the 95th percentile (p95).
        public var p95: Swift.Double?

        public init(
            p50: Swift.Double? = nil,
            p90: Swift.Double? = nil,
            p95: Swift.Double? = nil
        )
        {
            self.p50 = p50
            self.p90 = p90
            self.p95 = p95
        }
    }
}

extension InternetMonitorClientTypes {

    /// Amazon CloudWatch Internet Monitor calculates measurements about the performance for your application's internet traffic between client locations and Amazon Web Services. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, we report that information to you in the form of health scores: a performance score and an availability score. Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see [How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public struct PerformanceMeasurement: Swift.Sendable {
        /// Experience scores, or health scores, are calculated for different geographic and network provider combinations (that is, different granularities) and also totaled into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and availability scores, and when it creates and resolves health events. For more information, see [How Amazon Web Services calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var experienceScore: Swift.Double?
        /// How much performance impact was caused by a health event at a client location. For performance, this is the percentage of how much latency increased during the event compared to typical performance for traffic, from this client location to an Amazon Web Services location, using a specific client network. For more information, see [When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var percentOfClientLocationImpacted: Swift.Double?
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this client location to the Amazon Web Services location using this client network. For more information, see [When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var percentOfTotalTrafficImpacted: Swift.Double?
        /// This is the percentage of how much round-trip time increased during the event compared to typical round-trip time for your application for traffic. For more information, see [When Amazon Web Services creates and resolves health events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMHealthEventStartStop) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var roundTripTime: InternetMonitorClientTypes.RoundTripTime?

        public init(
            experienceScore: Swift.Double? = nil,
            percentOfClientLocationImpacted: Swift.Double? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil,
            roundTripTime: InternetMonitorClientTypes.RoundTripTime? = nil
        )
        {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.roundTripTime = roundTripTime
        }
    }
}

extension InternetMonitorClientTypes {

    /// Internet health includes measurements calculated by Amazon CloudWatch Internet Monitor about the performance and availability for your application on the internet. Amazon Web Services has substantial historical data about internet performance and availability between Amazon Web Services services and different network providers and geographies. By applying statistical analysis to the data, Internet Monitor can detect when the performance and availability for your application has dropped, compared to an estimated baseline that's already calculated. To make it easier to see those drops, Internet Monitor reports the information to you in the form of health scores: a performance score and an availability score.
    public struct InternetHealth: Swift.Sendable {
        /// Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see [How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var availability: InternetMonitorClientTypes.AvailabilityMeasurement?
        /// Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see [How Internet Monitor calculates performance and availability scores](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-inside-internet-monitor.html#IMExperienceScores) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public var performance: InternetMonitorClientTypes.PerformanceMeasurement?

        public init(
            availability: InternetMonitorClientTypes.AvailabilityMeasurement? = nil,
            performance: InternetMonitorClientTypes.PerformanceMeasurement? = nil
        )
        {
            self.availability = availability
            self.performance = performance
        }
    }
}

extension InternetMonitorClientTypes {

    public enum HealthEventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthEventStatus] {
            return [
                .active,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    /// Information about a location impacted by a health event in Amazon CloudWatch Internet Monitor. Geographic regions are hierarchically categorized into country, subdivision, metro and city geographic granularities. The geographic region is identified based on the IP address used at the client locations.
    public struct ImpactedLocation: Swift.Sendable {
        /// The name of the internet service provider (ISP) or network (ASN).
        /// This member is required.
        public var asName: Swift.String?
        /// The Autonomous System Number (ASN) of the network at an impacted location.
        /// This member is required.
        public var asNumber: Swift.Int?
        /// The cause of the impairment. There are two types of network impairments: Amazon Web Services network issues or internet issues. Internet issues are typically a problem with a network provider, like an internet service provider (ISP).
        public var causedBy: InternetMonitorClientTypes.NetworkImpairment?
        /// The name of the city where the health event is located.
        public var city: Swift.String?
        /// The name of the country where the health event is located.
        /// This member is required.
        public var country: Swift.String?
        /// The country code where the health event is located. The ISO 3166-2 codes for the country is provided, when available.
        public var countryCode: Swift.String?
        /// The calculated health at a specific location.
        public var internetHealth: InternetMonitorClientTypes.InternetHealth?
        /// The IPv4 prefixes at the client location that was impacted by the health event.
        public var ipv4Prefixes: [Swift.String]?
        /// The latitude where the health event is located.
        public var latitude: Swift.Double?
        /// The longitude where the health event is located.
        public var longitude: Swift.Double?
        /// The metro area where the health event is located. Metro indicates a metropolitan region in the United States, such as the region around New York City. In non-US countries, this is a second-level subdivision. For example, in the United Kingdom, it could be a county, a London borough, a unitary authority, council area, and so on.
        public var metro: Swift.String?
        /// The service location where the health event is located.
        public var serviceLocation: Swift.String?
        /// The status of the health event at an impacted location.
        /// This member is required.
        public var status: InternetMonitorClientTypes.HealthEventStatus?
        /// The subdivision location where the health event is located. The subdivision usually maps to states in most countries (including the United States). For United Kingdom, it maps to a country (England, Scotland, Wales) or province (Northern Ireland).
        public var subdivision: Swift.String?
        /// The subdivision code where the health event is located. The ISO 3166-2 codes for country subdivisions is provided, when available.
        public var subdivisionCode: Swift.String?

        public init(
            asName: Swift.String? = nil,
            asNumber: Swift.Int? = nil,
            causedBy: InternetMonitorClientTypes.NetworkImpairment? = nil,
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            internetHealth: InternetMonitorClientTypes.InternetHealth? = nil,
            ipv4Prefixes: [Swift.String]? = nil,
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil,
            metro: Swift.String? = nil,
            serviceLocation: Swift.String? = nil,
            status: InternetMonitorClientTypes.HealthEventStatus? = nil,
            subdivision: Swift.String? = nil,
            subdivisionCode: Swift.String? = nil
        )
        {
            self.asName = asName
            self.asNumber = asNumber
            self.causedBy = causedBy
            self.city = city
            self.country = country
            self.countryCode = countryCode
            self.internetHealth = internetHealth
            self.ipv4Prefixes = ipv4Prefixes
            self.latitude = latitude
            self.longitude = longitude
            self.metro = metro
            self.serviceLocation = serviceLocation
            self.status = status
            self.subdivision = subdivision
            self.subdivisionCode = subdivisionCode
        }
    }
}

extension InternetMonitorClientTypes {

    public enum HealthEventImpactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case availability
        case localAvailability
        case localPerformance
        case performance
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthEventImpactType] {
            return [
                .availability,
                .localAvailability,
                .localPerformance,
                .performance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .availability: return "AVAILABILITY"
            case .localAvailability: return "LOCAL_AVAILABILITY"
            case .localPerformance: return "LOCAL_PERFORMANCE"
            case .performance: return "PERFORMANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetHealthEventOutput: Swift.Sendable {
    /// The time when a health event was created.
    public var createdAt: Foundation.Date?
    /// The time when a health event was resolved. If the health event is still active, the end time is not set.
    public var endedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the event.
    /// This member is required.
    public var eventArn: Swift.String?
    /// The internally-generated identifier of a health event.
    /// This member is required.
    public var eventId: Swift.String?
    /// The threshold percentage for a health score that determines, along with other configuration information, when Internet Monitor creates a health event when there's an internet issue that affects your application end users.
    public var healthScoreThreshold: Swift.Double
    /// The type of impairment of a specific health event.
    /// This member is required.
    public var impactType: InternetMonitorClientTypes.HealthEventImpactType?
    /// The locations affected by a health event.
    /// This member is required.
    public var impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]?
    /// The time when a health event was last updated or recalculated.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this client location to the Amazon Web Services location using this client network.
    public var percentOfTotalTrafficImpacted: Swift.Double?
    /// The time when a health event started.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The status of a health event.
    /// This member is required.
    public var status: InternetMonitorClientTypes.HealthEventStatus?

    public init(
        createdAt: Foundation.Date? = nil,
        endedAt: Foundation.Date? = nil,
        eventArn: Swift.String? = nil,
        eventId: Swift.String? = nil,
        healthScoreThreshold: Swift.Double = 0.0,
        impactType: InternetMonitorClientTypes.HealthEventImpactType? = nil,
        impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        percentOfTotalTrafficImpacted: Swift.Double? = nil,
        startedAt: Foundation.Date? = nil,
        status: InternetMonitorClientTypes.HealthEventStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.endedAt = endedAt
        self.eventArn = eventArn
        self.eventId = eventId
        self.healthScoreThreshold = healthScoreThreshold
        self.impactType = impactType
        self.impactedLocations = impactedLocations
        self.lastUpdatedAt = lastUpdatedAt
        self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        self.startedAt = startedAt
        self.status = status
    }
}

public struct GetInternetEventInput: Swift.Sendable {
    /// The EventId of the internet event to return information for.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    )
    {
        self.eventId = eventId
    }
}

extension InternetMonitorClientTypes {

    public enum InternetEventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [InternetEventStatus] {
            return [
                .active,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternetMonitorClientTypes {

    public enum InternetEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case availability
        case performance
        case sdkUnknown(Swift.String)

        public static var allCases: [InternetEventType] {
            return [
                .availability,
                .performance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .availability: return "AVAILABILITY"
            case .performance: return "PERFORMANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetInternetEventOutput: Swift.Sendable {
    /// The impacted location, such as a city, where clients access Amazon Web Services application resources.
    /// This member is required.
    public var clientLocation: InternetMonitorClientTypes.ClientLocation?
    /// The time when the internet event ended. If the event hasn't ended yet, this value is empty.
    public var endedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the internet event.
    /// This member is required.
    public var eventArn: Swift.String?
    /// The internally-generated identifier of an internet event.
    /// This member is required.
    public var eventId: Swift.String?
    /// The status of the internet event.
    /// This member is required.
    public var eventStatus: InternetMonitorClientTypes.InternetEventStatus?
    /// The type of network impairment.
    /// This member is required.
    public var eventType: InternetMonitorClientTypes.InternetEventType?
    /// The time when the internet event started.
    /// This member is required.
    public var startedAt: Foundation.Date?

    public init(
        clientLocation: InternetMonitorClientTypes.ClientLocation? = nil,
        endedAt: Foundation.Date? = nil,
        eventArn: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventStatus: InternetMonitorClientTypes.InternetEventStatus? = nil,
        eventType: InternetMonitorClientTypes.InternetEventType? = nil,
        startedAt: Foundation.Date? = nil
    )
    {
        self.clientLocation = clientLocation
        self.endedAt = endedAt
        self.eventArn = eventArn
        self.eventId = eventId
        self.eventStatus = eventStatus
        self.eventType = eventType
        self.startedAt = startedAt
    }
}

public struct GetMonitorInput: Swift.Sendable {
    /// The account ID for an account that you've set up cross-account sharing for in Amazon CloudWatch Internet Monitor. You configure cross-account sharing by using Amazon CloudWatch Observability Access Manager. For more information, see [Internet Monitor cross-account observability](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cwim-cross-account.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var linkedAccountId: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?

    public init(
        linkedAccountId: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.linkedAccountId = linkedAccountId
        self.monitorName = monitorName
    }
}

extension InternetMonitorClientTypes {

    public enum MonitorProcessingStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collectingData
        case faultAccessCloudwatch
        case faultService
        case inactive
        case insufficientData
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorProcessingStatusCode] {
            return [
                .collectingData,
                .faultAccessCloudwatch,
                .faultService,
                .inactive,
                .insufficientData,
                .ok
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collectingData: return "COLLECTING_DATA"
            case .faultAccessCloudwatch: return "FAULT_ACCESS_CLOUDWATCH"
            case .faultService: return "FAULT_SERVICE"
            case .inactive: return "INACTIVE"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMonitorOutput: Swift.Sendable {
    /// The time when the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The list of health event threshold configurations. The threshold percentage for a health score determines, along with other configuration information, when Internet Monitor creates a health event when there's an internet issue that affects your application end users. For more information, see [ Change health event thresholds](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-overview.html#IMUpdateThresholdFromOverview) in the Internet Monitor section of the CloudWatch User Guide.
    public var healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig?
    /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
    public var internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery?
    /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources through. This limit can help control billing costs. To learn more, see [Choosing a city-network maximum value ](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/IMCityNetworksMaximum.html) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public var maxCityNetworksToMonitor: Swift.Int?
    /// The last time that the monitor was modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The health of the data processing for the monitor.
    public var processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode?
    /// Additional information about the health of the data processing for the monitor.
    public var processingStatusInfo: Swift.String?
    /// The resources monitored by the monitor. Resources are listed by their Amazon Resource Names (ARNs).
    /// This member is required.
    public var resources: [Swift.String]?
    /// The status of the monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?
    /// The tags that have been added to monitor.
    public var tags: [Swift.String: Swift.String]?
    /// The percentage of the internet-facing traffic for your application to monitor with this monitor. If you set a city-networks maximum, that limit overrides the traffic percentage that you set. To learn more, see [Choosing an application traffic percentage to monitor ](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/IMTrafficPercentage.html) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public var trafficPercentageToMonitor: Swift.Int?

    public init(
        createdAt: Foundation.Date? = nil,
        healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig? = nil,
        internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery? = nil,
        maxCityNetworksToMonitor: Swift.Int? = nil,
        modifiedAt: Foundation.Date? = nil,
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode? = nil,
        processingStatusInfo: Swift.String? = nil,
        resources: [Swift.String]? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        trafficPercentageToMonitor: Swift.Int? = nil
    )
    {
        self.createdAt = createdAt
        self.healthEventsConfig = healthEventsConfig
        self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.modifiedAt = modifiedAt
        self.monitorArn = monitorArn
        self.monitorName = monitorName
        self.processingStatus = processingStatus
        self.processingStatusInfo = processingStatusInfo
        self.resources = resources
        self.status = status
        self.tags = tags
        self.trafficPercentageToMonitor = trafficPercentageToMonitor
    }
}

public struct GetQueryResultsInput: Swift.Sendable {
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The name of the monitor to return data for.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The ID of the query that you want to return data results for. A QueryId is an internally-generated identifier for a specific query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorName = monitorName
        self.nextToken = nextToken
        self.queryId = queryId
    }
}

extension InternetMonitorClientTypes {

    /// Defines a field to query for your application's Amazon CloudWatch Internet Monitor data. You create a data repository by running a query of a specific type. Each QueryType includes a specific set of fields and datatypes to retrieve data for.
    public struct QueryField: Swift.Sendable {
        /// The name of a field to query your application's Amazon CloudWatch Internet Monitor data for, such as availability_score.
        public var name: Swift.String?
        /// The data type for a query field, which must correspond to the field you're defining for QueryField. For example, if the query field name is availability_score, the data type is float.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

public struct GetQueryResultsOutput: Swift.Sendable {
    /// The data results that the query returns. Data is returned in arrays, aligned with the Fields for the query, which creates a repository of Amazon CloudWatch Internet Monitor information for your application. Then, you can filter the information in the repository by using FilterParameters that you define.
    /// This member is required.
    public var data: [[Swift.String]]?
    /// The fields that the query returns data for. Fields are name-data type pairs, such as availability_score-float.
    /// This member is required.
    public var fields: [InternetMonitorClientTypes.QueryField]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        data: [[Swift.String]]? = nil,
        fields: [InternetMonitorClientTypes.QueryField]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.data = data
        self.fields = fields
        self.nextToken = nextToken
    }
}

public struct GetQueryStatusInput: Swift.Sendable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the query that you want to return the status for. A QueryId is an internally-generated dentifier for a specific query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.queryId = queryId
    }
}

extension InternetMonitorClientTypes {

    public enum QueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case queued
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStatus] {
            return [
                .canceled,
                .failed,
                .queued,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueryStatusOutput: Swift.Sendable {
    /// The current status for a query.
    /// This member is required.
    public var status: InternetMonitorClientTypes.QueryStatus?

    public init(
        status: InternetMonitorClientTypes.QueryStatus? = nil
    )
    {
        self.status = status
    }
}

extension InternetMonitorClientTypes {

    /// Information about a health event created in a monitor in Amazon CloudWatch Internet Monitor.
    public struct HealthEvent: Swift.Sendable {
        /// When the health event was created.
        public var createdAt: Foundation.Date?
        /// The time when a health event ended. If the health event is still active, then the end time is not set.
        public var endedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the event.
        /// This member is required.
        public var eventArn: Swift.String?
        /// The internally-generated identifier of a specific network traffic impairment health event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The value of the threshold percentage for performance or availability that was configured when Amazon CloudWatch Internet Monitor created the health event.
        public var healthScoreThreshold: Swift.Double
        /// The type of impairment for a health event.
        /// This member is required.
        public var impactType: InternetMonitorClientTypes.HealthEventImpactType?
        /// The locations impacted by the health event.
        /// This member is required.
        public var impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]?
        /// When the health event was last updated.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this client location to the Amazon Web Services location using this client network.
        public var percentOfTotalTrafficImpacted: Swift.Double?
        /// When a health event started.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// The status of a health event.
        /// This member is required.
        public var status: InternetMonitorClientTypes.HealthEventStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            endedAt: Foundation.Date? = nil,
            eventArn: Swift.String? = nil,
            eventId: Swift.String? = nil,
            healthScoreThreshold: Swift.Double = 0.0,
            impactType: InternetMonitorClientTypes.HealthEventImpactType? = nil,
            impactedLocations: [InternetMonitorClientTypes.ImpactedLocation]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            percentOfTotalTrafficImpacted: Swift.Double? = nil,
            startedAt: Foundation.Date? = nil,
            status: InternetMonitorClientTypes.HealthEventStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.healthScoreThreshold = healthScoreThreshold
            self.impactType = impactType
            self.impactedLocations = impactedLocations
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }
    }
}

public struct ListHealthEventsInput: Swift.Sendable {
    /// The time when a health event ended. If the health event is still ongoing, then the end time is not set.
    public var endTime: Foundation.Date?
    /// The status of a health event.
    public var eventStatus: InternetMonitorClientTypes.HealthEventStatus?
    /// The account ID for an account that you've set up cross-account sharing for in Amazon CloudWatch Internet Monitor. You configure cross-account sharing by using Amazon CloudWatch Observability Access Manager. For more information, see [Internet Monitor cross-account observability](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cwim-cross-account.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var linkedAccountId: Swift.String?
    /// The number of health event objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The time when a health event started.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        eventStatus: InternetMonitorClientTypes.HealthEventStatus? = nil,
        linkedAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.linkedAccountId = linkedAccountId
        self.maxResults = maxResults
        self.monitorName = monitorName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

public struct ListHealthEventsOutput: Swift.Sendable {
    /// A list of health events.
    /// This member is required.
    public var healthEvents: [InternetMonitorClientTypes.HealthEvent]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        healthEvents: [InternetMonitorClientTypes.HealthEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.healthEvents = healthEvents
        self.nextToken = nextToken
    }
}

/// There was an internal server error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListInternetEventsInput: Swift.Sendable {
    /// The end time of the time window that you want to get a list of internet events for.
    public var endTime: Foundation.Date?
    /// The status of an internet event.
    public var eventStatus: Swift.String?
    /// The type of network impairment.
    public var eventType: Swift.String?
    /// The number of query results that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?
    /// The start time of the time window that you want to get a list of internet events for.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        eventStatus: Swift.String? = nil,
        eventType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension InternetMonitorClientTypes {

    /// A summary of information about an internet event in Amazon CloudWatch Internet Monitor. Internet events are issues that cause performance degradation or availability problems for impacted Amazon Web Services client locations. Internet Monitor displays information about recent global health events, called internet events, on a global outages map that is available to all Amazon Web Services customers.
    public struct InternetEventSummary: Swift.Sendable {
        /// The impacted location, such as a city, that Amazon Web Services clients access application resources from.
        /// This member is required.
        public var clientLocation: InternetMonitorClientTypes.ClientLocation?
        /// The time when an internet event ended. If the event hasn't ended yet, this value is empty.
        public var endedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the internet event.
        /// This member is required.
        public var eventArn: Swift.String?
        /// The internally-generated identifier of an internet event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The status of an internet event.
        /// This member is required.
        public var eventStatus: InternetMonitorClientTypes.InternetEventStatus?
        /// The type of network impairment.
        /// This member is required.
        public var eventType: InternetMonitorClientTypes.InternetEventType?
        /// The time when an internet event started.
        /// This member is required.
        public var startedAt: Foundation.Date?

        public init(
            clientLocation: InternetMonitorClientTypes.ClientLocation? = nil,
            endedAt: Foundation.Date? = nil,
            eventArn: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventStatus: InternetMonitorClientTypes.InternetEventStatus? = nil,
            eventType: InternetMonitorClientTypes.InternetEventType? = nil,
            startedAt: Foundation.Date? = nil
        )
        {
            self.clientLocation = clientLocation
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.eventStatus = eventStatus
            self.eventType = eventType
            self.startedAt = startedAt
        }
    }
}

public struct ListInternetEventsOutput: Swift.Sendable {
    /// A set of internet events returned for the list operation.
    /// This member is required.
    public var internetEvents: [InternetMonitorClientTypes.InternetEventSummary]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        internetEvents: [InternetMonitorClientTypes.InternetEventSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.internetEvents = internetEvents
        self.nextToken = nextToken
    }
}

/// The request specifies something that doesn't exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There were too many requests.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for a resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Tags for a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListMonitorsInput: Swift.Sendable {
    /// A boolean option that you can set to TRUE to include monitors for linked accounts in a list of monitors, when you've set up cross-account sharing in Amazon CloudWatch Internet Monitor. You configure cross-account sharing by using Amazon CloudWatch Observability Access Manager. For more information, see [Internet Monitor cross-account observability](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cwim-cross-account.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var includeLinkedAccounts: Swift.Bool?
    /// The number of monitor objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The status of a monitor. This includes the status of the data processing for the monitor and the status of the monitor itself. For information about the statuses for a monitor, see [ Monitor](https://docs.aws.amazon.com/internet-monitor/latest/api/API_Monitor.html).
    public var monitorStatus: Swift.String?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        includeLinkedAccounts: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        monitorStatus: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeLinkedAccounts = includeLinkedAccounts
        self.maxResults = maxResults
        self.monitorStatus = monitorStatus
        self.nextToken = nextToken
    }
}

extension InternetMonitorClientTypes {

    /// The description of and information about a monitor in Amazon CloudWatch Internet Monitor.
    public struct Monitor: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the monitor.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// The health of data processing for the monitor.
        public var processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode?
        /// The status of a monitor.
        /// This member is required.
        public var status: InternetMonitorClientTypes.MonitorConfigState?

        public init(
            monitorArn: Swift.String? = nil,
            monitorName: Swift.String? = nil,
            processingStatus: InternetMonitorClientTypes.MonitorProcessingStatusCode? = nil,
            status: InternetMonitorClientTypes.MonitorConfigState? = nil
        )
        {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.status = status
        }
    }
}

public struct ListMonitorsOutput: Swift.Sendable {
    /// A list of monitors.
    /// This member is required.
    public var monitors: [InternetMonitorClientTypes.Monitor]?
    /// The token for the next set of results. You receive this token from a previous call.
    public var nextToken: Swift.String?

    public init(
        monitors: [InternetMonitorClientTypes.Monitor]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

extension InternetMonitorClientTypes {

    public enum QueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case measurements
        case overallTrafficSuggestions
        case overallTrafficSuggestionsDetails
        case topLocations
        case topLocationDetails
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryType] {
            return [
                .measurements,
                .overallTrafficSuggestions,
                .overallTrafficSuggestionsDetails,
                .topLocations,
                .topLocationDetails
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .measurements: return "MEASUREMENTS"
            case .overallTrafficSuggestions: return "OVERALL_TRAFFIC_SUGGESTIONS"
            case .overallTrafficSuggestionsDetails: return "OVERALL_TRAFFIC_SUGGESTIONS_DETAILS"
            case .topLocations: return "TOP_LOCATIONS"
            case .topLocationDetails: return "TOP_LOCATION_DETAILS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartQueryInput: Swift.Sendable {
    /// The timestamp that is the end of the period that you want to retrieve data for with your query.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The FilterParameters field that you use with Amazon CloudWatch Internet Monitor queries is a string the defines how you want a query to be filtered. The filter parameters that you can specify depend on the query type, since each query type returns a different set of Internet Monitor data. For more information about specifying filter parameters, see [Using the Amazon CloudWatch Internet Monitor query interface](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-view-cw-tools-cwim-query.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var filterParameters: [InternetMonitorClientTypes.FilterParameter]?
    /// The account ID for an account that you've set up cross-account sharing for in Amazon CloudWatch Internet Monitor. You configure cross-account sharing by using Amazon CloudWatch Observability Access Manager. For more information, see [Internet Monitor cross-account observability](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cwim-cross-account.html) in the Amazon CloudWatch Internet Monitor User Guide.
    public var linkedAccountId: Swift.String?
    /// The name of the monitor to query.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The type of query to run. The following are the three types of queries that you can run using the Internet Monitor query interface:
    ///
    /// * MEASUREMENTS: Provides availability score, performance score, total traffic, and round-trip times, at 5 minute intervals.
    ///
    /// * TOP_LOCATIONS: Provides availability score, performance score, total traffic, and time to first byte (TTFB) information, for the top location and ASN combinations that you're monitoring, by traffic volume.
    ///
    /// * TOP_LOCATION_DETAILS: Provides TTFB for Amazon CloudFront, your current configuration, and the best performing EC2 configuration, at 1 hour intervals.
    ///
    /// * OVERALL_TRAFFIC_SUGGESTIONS: Provides TTFB, using a 30-day weighted average, for all traffic in each Amazon Web Services location that is monitored.
    ///
    /// * OVERALL_TRAFFIC_SUGGESTIONS_DETAILS: Provides TTFB, using a 30-day weighted average, for each top location, for a proposed Amazon Web Services location. Must provide a Amazon Web Services location to search.
    ///
    ///
    /// For lists of the fields returned with each query type and more information about how each type of query is performed, see [ Using the Amazon CloudWatch Internet Monitor query interface](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-view-cw-tools-cwim-query.html) in the Amazon CloudWatch Internet Monitor User Guide.
    /// This member is required.
    public var queryType: InternetMonitorClientTypes.QueryType?
    /// The timestamp that is the beginning of the period that you want to retrieve data for with your query.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        filterParameters: [InternetMonitorClientTypes.FilterParameter]? = nil,
        linkedAccountId: Swift.String? = nil,
        monitorName: Swift.String? = nil,
        queryType: InternetMonitorClientTypes.QueryType? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.filterParameters = filterParameters
        self.linkedAccountId = linkedAccountId
        self.monitorName = monitorName
        self.queryType = queryType
        self.startTime = startTime
    }
}

public struct StartQueryOutput: Swift.Sendable {
    /// The internally-generated identifier of a specific query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

public struct StopQueryInput: Swift.Sendable {
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The ID of the query that you want to stop. A QueryId is an internally-generated identifier for a specific query.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        monitorName: Swift.String? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.monitorName = monitorName
        self.queryId = queryId
    }
}

public struct StopQueryOutput: Swift.Sendable {

    public init() { }
}

/// The request specifies a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateMonitorInput: Swift.Sendable {
    /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. You should not reuse the same client token for other API requests.
    public var clientToken: Swift.String?
    /// The list of health score thresholds. A threshold percentage for health scores, along with other configuration information, determines when Internet Monitor creates a health event when there's an internet issue that affects your application end users. For more information, see [ Change health event thresholds](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-IM-overview.html#IMUpdateThresholdFromOverview) in the Internet Monitor section of the CloudWatch User Guide.
    public var healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig?
    /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
    public var internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery?
    /// The maximum number of city-networks to monitor for your application. A city-network is the location (city) where clients access your application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources through. Setting this limit can help control billing costs.
    public var maxCityNetworksToMonitor: Swift.Int?
    /// The name of the monitor.
    /// This member is required.
    public var monitorName: Swift.String?
    /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). Resources can be VPCs, NLBs, Amazon CloudFront distributions, or Amazon WorkSpaces directories. You can add a combination of VPCs and CloudFront distributions, or you can add WorkSpaces directories, or you can add NLBs. You can't add NLBs or WorkSpaces directories together with any other resources. If you add only Amazon Virtual Private Clouds resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet connectivity.
    public var resourcesToAdd: [Swift.String]?
    /// The resources to remove from a monitor, which you provide as a set of Amazon Resource Names (ARNs).
    public var resourcesToRemove: [Swift.String]?
    /// The status for a monitor. The accepted values for Status with the UpdateMonitor API call are the following: ACTIVE and INACTIVE. The following values are not accepted: PENDING, and ERROR.
    public var status: InternetMonitorClientTypes.MonitorConfigState?
    /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor. If you set a city-networks maximum, that limit overrides the traffic percentage that you set. To learn more, see [Choosing an application traffic percentage to monitor ](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/IMTrafficPercentage.html) in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
    public var trafficPercentageToMonitor: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        healthEventsConfig: InternetMonitorClientTypes.HealthEventsConfig? = nil,
        internetMeasurementsLogDelivery: InternetMonitorClientTypes.InternetMeasurementsLogDelivery? = nil,
        maxCityNetworksToMonitor: Swift.Int? = nil,
        monitorName: Swift.String? = nil,
        resourcesToAdd: [Swift.String]? = nil,
        resourcesToRemove: [Swift.String]? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil,
        trafficPercentageToMonitor: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.healthEventsConfig = healthEventsConfig
        self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
        self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
        self.monitorName = monitorName
        self.resourcesToAdd = resourcesToAdd
        self.resourcesToRemove = resourcesToRemove
        self.status = status
        self.trafficPercentageToMonitor = trafficPercentageToMonitor
    }
}

public struct UpdateMonitorOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the monitor.
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The status of a monitor.
    /// This member is required.
    public var status: InternetMonitorClientTypes.MonitorConfigState?

    public init(
        monitorArn: Swift.String? = nil,
        status: InternetMonitorClientTypes.MonitorConfigState? = nil
    )
    {
        self.monitorArn = monitorArn
        self.status = status
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for a tag that you add to a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags that you add to a resource. You can add a maximum of 50 tags in Internet Monitor.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys that you remove from a resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/v20210603/Monitors"
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension GetHealthEventInput {

    static func urlPathProvider(_ value: GetHealthEventInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/HealthEvents/\(eventId.urlPercentEncoding())"
    }
}

extension GetHealthEventInput {

    static func queryItemProvider(_ value: GetHealthEventInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let linkedAccountId = value.linkedAccountId {
            let linkedAccountIdQueryItem = Smithy.URIQueryItem(name: "LinkedAccountId".urlPercentEncoding(), value: Swift.String(linkedAccountId).urlPercentEncoding())
            items.append(linkedAccountIdQueryItem)
        }
        return items
    }
}

extension GetInternetEventInput {

    static func urlPathProvider(_ value: GetInternetEventInput) -> Swift.String? {
        guard let eventId = value.eventId else {
            return nil
        }
        return "/v20210603/InternetEvents/\(eventId.urlPercentEncoding())"
    }
}

extension GetMonitorInput {

    static func urlPathProvider(_ value: GetMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension GetMonitorInput {

    static func queryItemProvider(_ value: GetMonitorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let linkedAccountId = value.linkedAccountId {
            let linkedAccountIdQueryItem = Smithy.URIQueryItem(name: "LinkedAccountId".urlPercentEncoding(), value: Swift.String(linkedAccountId).urlPercentEncoding())
            items.append(linkedAccountIdQueryItem)
        }
        return items
    }
}

extension GetQueryResultsInput {

    static func urlPathProvider(_ value: GetQueryResultsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/Queries/\(queryId.urlPercentEncoding())/Results"
    }
}

extension GetQueryResultsInput {

    static func queryItemProvider(_ value: GetQueryResultsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetQueryStatusInput {

    static func urlPathProvider(_ value: GetQueryStatusInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/Queries/\(queryId.urlPercentEncoding())/Status"
    }
}

extension ListHealthEventsInput {

    static func urlPathProvider(_ value: ListHealthEventsInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/HealthEvents"
    }
}

extension ListHealthEventsInput {

    static func queryItemProvider(_ value: ListHealthEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let linkedAccountId = value.linkedAccountId {
            let linkedAccountIdQueryItem = Smithy.URIQueryItem(name: "LinkedAccountId".urlPercentEncoding(), value: Swift.String(linkedAccountId).urlPercentEncoding())
            items.append(linkedAccountIdQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let eventStatus = value.eventStatus {
            let eventStatusQueryItem = Smithy.URIQueryItem(name: "EventStatus".urlPercentEncoding(), value: Swift.String(eventStatus.rawValue).urlPercentEncoding())
            items.append(eventStatusQueryItem)
        }
        return items
    }
}

extension ListInternetEventsInput {

    static func urlPathProvider(_ value: ListInternetEventsInput) -> Swift.String? {
        return "/v20210603/InternetEvents"
    }
}

extension ListInternetEventsInput {

    static func queryItemProvider(_ value: ListInternetEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let eventType = value.eventType {
            let eventTypeQueryItem = Smithy.URIQueryItem(name: "EventType".urlPercentEncoding(), value: Swift.String(eventType).urlPercentEncoding())
            items.append(eventTypeQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "InternetEventMaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let eventStatus = value.eventStatus {
            let eventStatusQueryItem = Smithy.URIQueryItem(name: "EventStatus".urlPercentEncoding(), value: Swift.String(eventStatus).urlPercentEncoding())
            items.append(eventStatusQueryItem)
        }
        return items
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/v20210603/Monitors"
    }
}

extension ListMonitorsInput {

    static func queryItemProvider(_ value: ListMonitorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let includeLinkedAccounts = value.includeLinkedAccounts {
            let includeLinkedAccountsQueryItem = Smithy.URIQueryItem(name: "IncludeLinkedAccounts".urlPercentEncoding(), value: Swift.String(includeLinkedAccounts).urlPercentEncoding())
            items.append(includeLinkedAccountsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let monitorStatus = value.monitorStatus {
            let monitorStatusQueryItem = Smithy.URIQueryItem(name: "MonitorStatus".urlPercentEncoding(), value: Swift.String(monitorStatus).urlPercentEncoding())
            items.append(monitorStatusQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartQueryInput {

    static func urlPathProvider(_ value: StartQueryInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/Queries"
    }
}

extension StopQueryInput {

    static func urlPathProvider(_ value: StopQueryInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        guard let queryId = value.queryId else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())/Queries/\(queryId.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateMonitorInput {

    static func urlPathProvider(_ value: UpdateMonitorInput) -> Swift.String? {
        guard let monitorName = value.monitorName else {
            return nil
        }
        return "/v20210603/Monitors/\(monitorName.urlPercentEncoding())"
    }
}

extension CreateMonitorInput {

    static func write(value: CreateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["HealthEventsConfig"].write(value.healthEventsConfig, with: InternetMonitorClientTypes.HealthEventsConfig.write(value:to:))
        try writer["InternetMeasurementsLogDelivery"].write(value.internetMeasurementsLogDelivery, with: InternetMonitorClientTypes.InternetMeasurementsLogDelivery.write(value:to:))
        try writer["MaxCityNetworksToMonitor"].write(value.maxCityNetworksToMonitor)
        try writer["MonitorName"].write(value.monitorName)
        try writer["Resources"].writeList(value.resources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TrafficPercentageToMonitor"].write(value.trafficPercentageToMonitor)
    }
}

extension StartQueryInput {

    static func write(value: StartQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["FilterParameters"].writeList(value.filterParameters, memberWritingClosure: InternetMonitorClientTypes.FilterParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinkedAccountId"].write(value.linkedAccountId)
        try writer["QueryType"].write(value.queryType)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateMonitorInput {

    static func write(value: UpdateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["HealthEventsConfig"].write(value.healthEventsConfig, with: InternetMonitorClientTypes.HealthEventsConfig.write(value:to:))
        try writer["InternetMeasurementsLogDelivery"].write(value.internetMeasurementsLogDelivery, with: InternetMonitorClientTypes.InternetMeasurementsLogDelivery.write(value:to:))
        try writer["MaxCityNetworksToMonitor"].write(value.maxCityNetworksToMonitor)
        try writer["ResourcesToAdd"].writeList(value.resourcesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourcesToRemove"].writeList(value.resourcesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["TrafficPercentageToMonitor"].write(value.trafficPercentageToMonitor)
    }
}

extension CreateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitorOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitorOutput {
        return DeleteMonitorOutput()
    }
}

extension GetHealthEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHealthEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHealthEventOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.eventArn = try reader["EventArn"].readIfPresent() ?? ""
        value.eventId = try reader["EventId"].readIfPresent() ?? ""
        value.healthScoreThreshold = try reader["HealthScoreThreshold"].readIfPresent() ?? 0
        value.impactType = try reader["ImpactType"].readIfPresent() ?? .sdkUnknown("")
        value.impactedLocations = try reader["ImpactedLocations"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.ImpactedLocation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.percentOfTotalTrafficImpacted = try reader["PercentOfTotalTrafficImpacted"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetInternetEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInternetEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInternetEventOutput()
        value.clientLocation = try reader["ClientLocation"].readIfPresent(with: InternetMonitorClientTypes.ClientLocation.read(from:))
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.eventArn = try reader["EventArn"].readIfPresent() ?? ""
        value.eventId = try reader["EventId"].readIfPresent() ?? ""
        value.eventStatus = try reader["EventStatus"].readIfPresent() ?? .sdkUnknown("")
        value.eventType = try reader["EventType"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMonitorOutput()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.healthEventsConfig = try reader["HealthEventsConfig"].readIfPresent(with: InternetMonitorClientTypes.HealthEventsConfig.read(from:))
        value.internetMeasurementsLogDelivery = try reader["InternetMeasurementsLogDelivery"].readIfPresent(with: InternetMonitorClientTypes.InternetMeasurementsLogDelivery.read(from:))
        value.maxCityNetworksToMonitor = try reader["MaxCityNetworksToMonitor"].readIfPresent()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        value.monitorName = try reader["MonitorName"].readIfPresent() ?? ""
        value.processingStatus = try reader["ProcessingStatus"].readIfPresent()
        value.processingStatusInfo = try reader["ProcessingStatusInfo"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.trafficPercentageToMonitor = try reader["TrafficPercentageToMonitor"].readIfPresent()
        return value
    }
}

extension GetQueryResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryResultsOutput()
        value.data = try reader["Data"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.QueryField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetQueryStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStatusOutput()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListHealthEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHealthEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHealthEventsOutput()
        value.healthEvents = try reader["HealthEvents"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.HealthEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInternetEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInternetEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInternetEventsOutput()
        value.internetEvents = try reader["InternetEvents"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.InternetEventSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorsOutput()
        value.monitors = try reader["Monitors"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.Monitor.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryOutput()
        value.queryId = try reader["QueryId"].readIfPresent() ?? ""
        return value
    }
}

extension StopQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopQueryOutput {
        return StopQueryOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMonitorOutput()
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

enum CreateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHealthEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInternetEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHealthEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInternetEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternetMonitorClientTypes.ImpactedLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.ImpactedLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.ImpactedLocation()
        value.asName = try reader["ASName"].readIfPresent() ?? ""
        value.asNumber = try reader["ASNumber"].readIfPresent() ?? 0
        value.country = try reader["Country"].readIfPresent() ?? ""
        value.subdivision = try reader["Subdivision"].readIfPresent()
        value.metro = try reader["Metro"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.latitude = try reader["Latitude"].readIfPresent()
        value.longitude = try reader["Longitude"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.subdivisionCode = try reader["SubdivisionCode"].readIfPresent()
        value.serviceLocation = try reader["ServiceLocation"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.causedBy = try reader["CausedBy"].readIfPresent(with: InternetMonitorClientTypes.NetworkImpairment.read(from:))
        value.internetHealth = try reader["InternetHealth"].readIfPresent(with: InternetMonitorClientTypes.InternetHealth.read(from:))
        value.ipv4Prefixes = try reader["Ipv4Prefixes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InternetMonitorClientTypes.InternetHealth {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.InternetHealth {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.InternetHealth()
        value.availability = try reader["Availability"].readIfPresent(with: InternetMonitorClientTypes.AvailabilityMeasurement.read(from:))
        value.performance = try reader["Performance"].readIfPresent(with: InternetMonitorClientTypes.PerformanceMeasurement.read(from:))
        return value
    }
}

extension InternetMonitorClientTypes.PerformanceMeasurement {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.PerformanceMeasurement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.PerformanceMeasurement()
        value.experienceScore = try reader["ExperienceScore"].readIfPresent()
        value.percentOfTotalTrafficImpacted = try reader["PercentOfTotalTrafficImpacted"].readIfPresent()
        value.percentOfClientLocationImpacted = try reader["PercentOfClientLocationImpacted"].readIfPresent()
        value.roundTripTime = try reader["RoundTripTime"].readIfPresent(with: InternetMonitorClientTypes.RoundTripTime.read(from:))
        return value
    }
}

extension InternetMonitorClientTypes.RoundTripTime {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.RoundTripTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.RoundTripTime()
        value.p50 = try reader["P50"].readIfPresent()
        value.p90 = try reader["P90"].readIfPresent()
        value.p95 = try reader["P95"].readIfPresent()
        return value
    }
}

extension InternetMonitorClientTypes.AvailabilityMeasurement {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.AvailabilityMeasurement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.AvailabilityMeasurement()
        value.experienceScore = try reader["ExperienceScore"].readIfPresent()
        value.percentOfTotalTrafficImpacted = try reader["PercentOfTotalTrafficImpacted"].readIfPresent()
        value.percentOfClientLocationImpacted = try reader["PercentOfClientLocationImpacted"].readIfPresent()
        return value
    }
}

extension InternetMonitorClientTypes.NetworkImpairment {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.NetworkImpairment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.NetworkImpairment()
        value.networks = try reader["Networks"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.Network.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.asPath = try reader["AsPath"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.Network.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.networkEventType = try reader["NetworkEventType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension InternetMonitorClientTypes.Network {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.Network {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.Network()
        value.asName = try reader["ASName"].readIfPresent() ?? ""
        value.asNumber = try reader["ASNumber"].readIfPresent() ?? 0
        return value
    }
}

extension InternetMonitorClientTypes.ClientLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.ClientLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.ClientLocation()
        value.asName = try reader["ASName"].readIfPresent() ?? ""
        value.asNumber = try reader["ASNumber"].readIfPresent() ?? 0
        value.country = try reader["Country"].readIfPresent() ?? ""
        value.subdivision = try reader["Subdivision"].readIfPresent()
        value.metro = try reader["Metro"].readIfPresent()
        value.city = try reader["City"].readIfPresent() ?? ""
        value.latitude = try reader["Latitude"].readIfPresent() ?? 0.0
        value.longitude = try reader["Longitude"].readIfPresent() ?? 0.0
        return value
    }
}

extension InternetMonitorClientTypes.InternetMeasurementsLogDelivery {

    static func write(value: InternetMonitorClientTypes.InternetMeasurementsLogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Config"].write(value.s3Config, with: InternetMonitorClientTypes.S3Config.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.InternetMeasurementsLogDelivery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.InternetMeasurementsLogDelivery()
        value.s3Config = try reader["S3Config"].readIfPresent(with: InternetMonitorClientTypes.S3Config.read(from:))
        return value
    }
}

extension InternetMonitorClientTypes.S3Config {

    static func write(value: InternetMonitorClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["BucketPrefix"].write(value.bucketPrefix)
        try writer["LogDeliveryStatus"].write(value.logDeliveryStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.S3Config()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.bucketPrefix = try reader["BucketPrefix"].readIfPresent()
        value.logDeliveryStatus = try reader["LogDeliveryStatus"].readIfPresent()
        return value
    }
}

extension InternetMonitorClientTypes.HealthEventsConfig {

    static func write(value: InternetMonitorClientTypes.HealthEventsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityLocalHealthEventsConfig"].write(value.availabilityLocalHealthEventsConfig, with: InternetMonitorClientTypes.LocalHealthEventsConfig.write(value:to:))
        try writer["AvailabilityScoreThreshold"].write(value.availabilityScoreThreshold)
        try writer["PerformanceLocalHealthEventsConfig"].write(value.performanceLocalHealthEventsConfig, with: InternetMonitorClientTypes.LocalHealthEventsConfig.write(value:to:))
        try writer["PerformanceScoreThreshold"].write(value.performanceScoreThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.HealthEventsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.HealthEventsConfig()
        value.availabilityScoreThreshold = try reader["AvailabilityScoreThreshold"].readIfPresent() ?? 0
        value.performanceScoreThreshold = try reader["PerformanceScoreThreshold"].readIfPresent() ?? 0
        value.availabilityLocalHealthEventsConfig = try reader["AvailabilityLocalHealthEventsConfig"].readIfPresent(with: InternetMonitorClientTypes.LocalHealthEventsConfig.read(from:))
        value.performanceLocalHealthEventsConfig = try reader["PerformanceLocalHealthEventsConfig"].readIfPresent(with: InternetMonitorClientTypes.LocalHealthEventsConfig.read(from:))
        return value
    }
}

extension InternetMonitorClientTypes.LocalHealthEventsConfig {

    static func write(value: InternetMonitorClientTypes.LocalHealthEventsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthScoreThreshold"].write(value.healthScoreThreshold)
        try writer["MinTrafficImpact"].write(value.minTrafficImpact)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.LocalHealthEventsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.LocalHealthEventsConfig()
        value.status = try reader["Status"].readIfPresent()
        value.healthScoreThreshold = try reader["HealthScoreThreshold"].readIfPresent() ?? 0
        value.minTrafficImpact = try reader["MinTrafficImpact"].readIfPresent() ?? 0
        return value
    }
}

extension InternetMonitorClientTypes.QueryField {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.QueryField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.QueryField()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension InternetMonitorClientTypes.HealthEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.HealthEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.HealthEvent()
        value.eventArn = try reader["EventArn"].readIfPresent() ?? ""
        value.eventId = try reader["EventId"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.impactedLocations = try reader["ImpactedLocations"].readListIfPresent(memberReadingClosure: InternetMonitorClientTypes.ImpactedLocation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.percentOfTotalTrafficImpacted = try reader["PercentOfTotalTrafficImpacted"].readIfPresent()
        value.impactType = try reader["ImpactType"].readIfPresent() ?? .sdkUnknown("")
        value.healthScoreThreshold = try reader["HealthScoreThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension InternetMonitorClientTypes.InternetEventSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.InternetEventSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.InternetEventSummary()
        value.eventId = try reader["EventId"].readIfPresent() ?? ""
        value.eventArn = try reader["EventArn"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.clientLocation = try reader["ClientLocation"].readIfPresent(with: InternetMonitorClientTypes.ClientLocation.read(from:))
        value.eventType = try reader["EventType"].readIfPresent() ?? .sdkUnknown("")
        value.eventStatus = try reader["EventStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension InternetMonitorClientTypes.Monitor {

    static func read(from reader: SmithyJSON.Reader) throws -> InternetMonitorClientTypes.Monitor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternetMonitorClientTypes.Monitor()
        value.monitorName = try reader["MonitorName"].readIfPresent() ?? ""
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.processingStatus = try reader["ProcessingStatus"].readIfPresent()
        return value
    }
}

extension InternetMonitorClientTypes.FilterParameter {

    static func write(value: InternetMonitorClientTypes.FilterParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Field"].write(value.field)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum InternetMonitorClientTypes {}
