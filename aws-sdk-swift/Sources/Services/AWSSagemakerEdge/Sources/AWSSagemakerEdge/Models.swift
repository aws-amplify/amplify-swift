//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError


public struct SendHeartbeatOutput: Swift.Sendable {

    public init() { }
}

/// An internal failure occurred. Try your request again. If the problem persists, contact Amazon Web Services customer support.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetDeploymentsInput: Swift.Sendable {
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device you want to get the configuration of active deployments from.
    /// This member is required.
    public var deviceName: Swift.String?

    public init(
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
    }
}

extension SagemakerEdgeClientTypes {

    public enum ChecksumType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sha1
        case sdkUnknown(Swift.String)

        public static var allCases: [ChecksumType] {
            return [
                .sha1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "SHA1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SagemakerEdgeClientTypes {

    /// Information about the checksum of a model deployed on a device.
    public struct Checksum: Swift.Sendable {
        /// The checksum of the model.
        public var sum: Swift.String?
        /// The type of the checksum.
        public var type: SagemakerEdgeClientTypes.ChecksumType?

        public init(
            sum: Swift.String? = nil,
            type: SagemakerEdgeClientTypes.ChecksumType? = nil
        )
        {
            self.sum = sum
            self.type = type
        }
    }
}

extension SagemakerEdgeClientTypes {

    public enum ModelState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploy
        case undeploy
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelState] {
            return [
                .deploy,
                .undeploy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploy: return "DEPLOY"
            case .undeploy: return "UNDEPLOY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SagemakerEdgeClientTypes {

    ///
    public struct Definition: Swift.Sendable {
        /// The checksum information of the model.
        public var checksum: SagemakerEdgeClientTypes.Checksum?
        /// The unique model handle.
        public var modelHandle: Swift.String?
        /// The absolute S3 location of the model.
        public var s3Url: Swift.String?
        /// The desired state of the model.
        public var state: SagemakerEdgeClientTypes.ModelState?

        public init(
            checksum: SagemakerEdgeClientTypes.Checksum? = nil,
            modelHandle: Swift.String? = nil,
            s3Url: Swift.String? = nil,
            state: SagemakerEdgeClientTypes.ModelState? = nil
        )
        {
            self.checksum = checksum
            self.modelHandle = modelHandle
            self.s3Url = s3Url
            self.state = state
        }
    }
}

extension SagemakerEdgeClientTypes {

    public enum FailureHandlingPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case donothing
        case rollbackonfailure
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureHandlingPolicy] {
            return [
                .donothing,
                .rollbackonfailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .donothing: return "DO_NOTHING"
            case .rollbackonfailure: return "ROLLBACK_ON_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SagemakerEdgeClientTypes {

    public enum DeploymentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case model
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .model
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .model: return "Model"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SagemakerEdgeClientTypes {

    /// Information about a deployment on an edge device that is registered with SageMaker Edge Manager.
    public struct EdgeDeployment: Swift.Sendable {
        /// Returns a list of Definition objects.
        public var definitions: [SagemakerEdgeClientTypes.Definition]?
        /// The name and unique ID of the deployment.
        public var deploymentName: Swift.String?
        /// Determines whether to rollback to previous configuration if deployment fails.
        public var failureHandlingPolicy: SagemakerEdgeClientTypes.FailureHandlingPolicy?
        /// The type of the deployment.
        public var type: SagemakerEdgeClientTypes.DeploymentType?

        public init(
            definitions: [SagemakerEdgeClientTypes.Definition]? = nil,
            deploymentName: Swift.String? = nil,
            failureHandlingPolicy: SagemakerEdgeClientTypes.FailureHandlingPolicy? = nil,
            type: SagemakerEdgeClientTypes.DeploymentType? = nil
        )
        {
            self.definitions = definitions
            self.deploymentName = deploymentName
            self.failureHandlingPolicy = failureHandlingPolicy
            self.type = type
        }
    }
}

public struct GetDeploymentsOutput: Swift.Sendable {
    /// Returns a list of the configurations of the active deployments on the device.
    public var deployments: [SagemakerEdgeClientTypes.EdgeDeployment]?

    public init(
        deployments: [SagemakerEdgeClientTypes.EdgeDeployment]? = nil
    )
    {
        self.deployments = deployments
    }
}

public struct GetDeviceRegistrationInput: Swift.Sendable {
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device you want to get the registration status from.
    /// This member is required.
    public var deviceName: Swift.String?

    public init(
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
    }
}

public struct GetDeviceRegistrationOutput: Swift.Sendable {
    /// The amount of time, in seconds, that the registration status is stored on the deviceâ€™s cache before it is refreshed.
    public var cacheTTL: Swift.String?
    /// Describes if the device is currently registered with SageMaker Edge Manager.
    public var deviceRegistration: Swift.String?

    public init(
        cacheTTL: Swift.String? = nil,
        deviceRegistration: Swift.String? = nil
    )
    {
        self.cacheTTL = cacheTTL
        self.deviceRegistration = deviceRegistration
    }
}

extension SagemakerEdgeClientTypes {

    /// Information required for edge device metrics.
    public struct EdgeMetric: Swift.Sendable {
        /// The dimension of metrics published.
        public var dimension: Swift.String?
        /// Returns the name of the metric.
        public var metricName: Swift.String?
        /// Timestamp of when the metric was requested.
        public var timestamp: Foundation.Date?
        /// Returns the value of the metric.
        public var value: Swift.Double?

        public init(
            dimension: Swift.String? = nil,
            metricName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            value: Swift.Double? = nil
        )
        {
            self.dimension = dimension
            self.metricName = metricName
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension SagemakerEdgeClientTypes {

    public enum DeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .fail,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SagemakerEdgeClientTypes {

    ///
    public struct DeploymentModel: Swift.Sendable {
        /// The desired state of the model.
        public var desiredState: SagemakerEdgeClientTypes.ModelState?
        /// The unique handle of the model.
        public var modelHandle: Swift.String?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?
        /// Returns the error message if there is a rollback.
        public var rollbackFailureReason: Swift.String?
        /// Returns the current state of the model.
        public var state: SagemakerEdgeClientTypes.ModelState?
        /// Returns the deployment status of the model.
        public var status: SagemakerEdgeClientTypes.DeploymentStatus?
        /// Returns the error message for the deployment status result.
        public var statusReason: Swift.String?

        public init(
            desiredState: SagemakerEdgeClientTypes.ModelState? = nil,
            modelHandle: Swift.String? = nil,
            modelName: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            rollbackFailureReason: Swift.String? = nil,
            state: SagemakerEdgeClientTypes.ModelState? = nil,
            status: SagemakerEdgeClientTypes.DeploymentStatus? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.desiredState = desiredState
            self.modelHandle = modelHandle
            self.modelName = modelName
            self.modelVersion = modelVersion
            self.rollbackFailureReason = rollbackFailureReason
            self.state = state
            self.status = status
            self.statusReason = statusReason
        }
    }
}

extension SagemakerEdgeClientTypes {

    /// Information about the result of a deployment on an edge device that is registered with SageMaker Edge Manager.
    public struct DeploymentResult: Swift.Sendable {
        /// The timestamp of when the deployment was ended, and the agent got the deployment results.
        public var deploymentEndTime: Foundation.Date?
        /// Returns a list of models deployed on the agent.
        public var deploymentModels: [SagemakerEdgeClientTypes.DeploymentModel]?
        /// The name and unique ID of the deployment.
        public var deploymentName: Swift.String?
        /// The timestamp of when the deployment was started on the agent.
        public var deploymentStartTime: Foundation.Date?
        /// Returns the bucket error code.
        public var deploymentStatus: Swift.String?
        /// Returns the detailed error message.
        public var deploymentStatusMessage: Swift.String?

        public init(
            deploymentEndTime: Foundation.Date? = nil,
            deploymentModels: [SagemakerEdgeClientTypes.DeploymentModel]? = nil,
            deploymentName: Swift.String? = nil,
            deploymentStartTime: Foundation.Date? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentStatusMessage: Swift.String? = nil
        )
        {
            self.deploymentEndTime = deploymentEndTime
            self.deploymentModels = deploymentModels
            self.deploymentName = deploymentName
            self.deploymentStartTime = deploymentStartTime
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
        }
    }
}

extension SagemakerEdgeClientTypes {

    /// Information about a model deployed on an edge device that is registered with SageMaker Edge Manager.
    public struct Model: Swift.Sendable {
        /// The timestamp of the last inference that was made.
        public var latestInference: Foundation.Date?
        /// The timestamp of the last data sample taken.
        public var latestSampleTime: Foundation.Date?
        /// Information required for model metrics.
        public var modelMetrics: [SagemakerEdgeClientTypes.EdgeMetric]?
        /// The name of the model.
        public var modelName: Swift.String?
        /// The version of the model.
        public var modelVersion: Swift.String?

        public init(
            latestInference: Foundation.Date? = nil,
            latestSampleTime: Foundation.Date? = nil,
            modelMetrics: [SagemakerEdgeClientTypes.EdgeMetric]? = nil,
            modelName: Swift.String? = nil,
            modelVersion: Swift.String? = nil
        )
        {
            self.latestInference = latestInference
            self.latestSampleTime = latestSampleTime
            self.modelMetrics = modelMetrics
            self.modelName = modelName
            self.modelVersion = modelVersion
        }
    }
}

public struct SendHeartbeatInput: Swift.Sendable {
    /// For internal use. Returns a list of SageMaker Edge Manager agent operating metrics.
    public var agentMetrics: [SagemakerEdgeClientTypes.EdgeMetric]?
    /// Returns the version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Returns the result of a deployment on the device.
    public var deploymentResult: SagemakerEdgeClientTypes.DeploymentResult?
    /// The name of the fleet that the device belongs to.
    /// This member is required.
    public var deviceFleetName: Swift.String?
    /// The unique name of the device.
    /// This member is required.
    public var deviceName: Swift.String?
    /// Returns a list of models deployed on the the device.
    public var models: [SagemakerEdgeClientTypes.Model]?

    public init(
        agentMetrics: [SagemakerEdgeClientTypes.EdgeMetric]? = nil,
        agentVersion: Swift.String? = nil,
        deploymentResult: SagemakerEdgeClientTypes.DeploymentResult? = nil,
        deviceFleetName: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        models: [SagemakerEdgeClientTypes.Model]? = nil
    )
    {
        self.agentMetrics = agentMetrics
        self.agentVersion = agentVersion
        self.deploymentResult = deploymentResult
        self.deviceFleetName = deviceFleetName
        self.deviceName = deviceName
        self.models = models
    }
}

extension GetDeploymentsInput {

    static func urlPathProvider(_ value: GetDeploymentsInput) -> Swift.String? {
        return "/GetDeployments"
    }
}

extension GetDeviceRegistrationInput {

    static func urlPathProvider(_ value: GetDeviceRegistrationInput) -> Swift.String? {
        return "/GetDeviceRegistration"
    }
}

extension SendHeartbeatInput {

    static func urlPathProvider(_ value: SendHeartbeatInput) -> Swift.String? {
        return "/SendHeartbeat"
    }
}

extension GetDeploymentsInput {

    static func write(value: GetDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceFleetName"].write(value.deviceFleetName)
        try writer["DeviceName"].write(value.deviceName)
    }
}

extension GetDeviceRegistrationInput {

    static func write(value: GetDeviceRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceFleetName"].write(value.deviceFleetName)
        try writer["DeviceName"].write(value.deviceName)
    }
}

extension SendHeartbeatInput {

    static func write(value: SendHeartbeatInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AgentMetrics"].writeList(value.agentMetrics, memberWritingClosure: SagemakerEdgeClientTypes.EdgeMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AgentVersion"].write(value.agentVersion)
        try writer["DeploymentResult"].write(value.deploymentResult, with: SagemakerEdgeClientTypes.DeploymentResult.write(value:to:))
        try writer["DeviceFleetName"].write(value.deviceFleetName)
        try writer["DeviceName"].write(value.deviceName)
        try writer["Models"].writeList(value.models, memberWritingClosure: SagemakerEdgeClientTypes.Model.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: SagemakerEdgeClientTypes.EdgeDeployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDeviceRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceRegistrationOutput()
        value.cacheTTL = try reader["CacheTTL"].readIfPresent()
        value.deviceRegistration = try reader["DeviceRegistration"].readIfPresent()
        return value
    }
}

extension SendHeartbeatOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendHeartbeatOutput {
        return SendHeartbeatOutput()
    }
}

enum GetDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendHeartbeatOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SagemakerEdgeClientTypes.EdgeDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> SagemakerEdgeClientTypes.EdgeDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SagemakerEdgeClientTypes.EdgeDeployment()
        value.deploymentName = try reader["DeploymentName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.failureHandlingPolicy = try reader["FailureHandlingPolicy"].readIfPresent()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: SagemakerEdgeClientTypes.Definition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SagemakerEdgeClientTypes.Definition {

    static func read(from reader: SmithyJSON.Reader) throws -> SagemakerEdgeClientTypes.Definition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SagemakerEdgeClientTypes.Definition()
        value.modelHandle = try reader["ModelHandle"].readIfPresent()
        value.s3Url = try reader["S3Url"].readIfPresent()
        value.checksum = try reader["Checksum"].readIfPresent(with: SagemakerEdgeClientTypes.Checksum.read(from:))
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SagemakerEdgeClientTypes.Checksum {

    static func read(from reader: SmithyJSON.Reader) throws -> SagemakerEdgeClientTypes.Checksum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SagemakerEdgeClientTypes.Checksum()
        value.type = try reader["Type"].readIfPresent()
        value.sum = try reader["Sum"].readIfPresent()
        return value
    }
}

extension SagemakerEdgeClientTypes.EdgeMetric {

    static func write(value: SagemakerEdgeClientTypes.EdgeMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimension"].write(value.dimension)
        try writer["MetricName"].write(value.metricName)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Value"].write(value.value)
    }
}

extension SagemakerEdgeClientTypes.Model {

    static func write(value: SagemakerEdgeClientTypes.Model?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LatestInference"].writeTimestamp(value.latestInference, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LatestSampleTime"].writeTimestamp(value.latestSampleTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ModelMetrics"].writeList(value.modelMetrics, memberWritingClosure: SagemakerEdgeClientTypes.EdgeMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ModelName"].write(value.modelName)
        try writer["ModelVersion"].write(value.modelVersion)
    }
}

extension SagemakerEdgeClientTypes.DeploymentResult {

    static func write(value: SagemakerEdgeClientTypes.DeploymentResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeploymentEndTime"].writeTimestamp(value.deploymentEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["DeploymentModels"].writeList(value.deploymentModels, memberWritingClosure: SagemakerEdgeClientTypes.DeploymentModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeploymentName"].write(value.deploymentName)
        try writer["DeploymentStartTime"].writeTimestamp(value.deploymentStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["DeploymentStatus"].write(value.deploymentStatus)
        try writer["DeploymentStatusMessage"].write(value.deploymentStatusMessage)
    }
}

extension SagemakerEdgeClientTypes.DeploymentModel {

    static func write(value: SagemakerEdgeClientTypes.DeploymentModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredState"].write(value.desiredState)
        try writer["ModelHandle"].write(value.modelHandle)
        try writer["ModelName"].write(value.modelName)
        try writer["ModelVersion"].write(value.modelVersion)
        try writer["RollbackFailureReason"].write(value.rollbackFailureReason)
        try writer["State"].write(value.state)
        try writer["Status"].write(value.status)
        try writer["StatusReason"].write(value.statusReason)
    }
}

public enum SagemakerEdgeClientTypes {}
