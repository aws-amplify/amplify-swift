//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension RedshiftServerlessClientTypes {
    /// An object that represents the custom domain name association.
    public struct Association {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public var customDomainCertificateArn: Swift.String?
        /// The expiration time for the certificate.
        public var customDomainCertificateExpiryTime: Foundation.Date?
        /// The custom domain name associated with the workgroup.
        public var customDomainName: Swift.String?
        /// The name of the workgroup associated with the database.
        public var workgroupName: Swift.String?

        public init(
            customDomainCertificateArn: Swift.String? = nil,
            customDomainCertificateExpiryTime: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }
    }

}

extension RedshiftServerlessClientTypes {
    /// An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.
    public struct ConfigParameter {
        /// The key of the parameter. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var parameterKey: Swift.String?
        /// The value of the parameter to set.
        public var parameterValue: Swift.String?

        public init(
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

/// The submitted action has conflicts.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that could not be found.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The service limit was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeded the number of tags allowed for a resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource that exceeded the number of tags allowed for a resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The input failed to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension RedshiftServerlessClientTypes {
    /// A map of key-value pairs.
    public struct Tag {
        /// The key to use in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct ConvertRecoveryPointToSnapshotInput {
    /// The unique identifier of the recovery point.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// How long to retain the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the created snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        recoveryPointId: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

extension RedshiftServerlessClientTypes {

    public enum SnapshotStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case cancelled
        case copying
        case creating
        case deleted
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotStatus] {
            return [
                .available,
                .cancelled,
                .copying,
                .creating,
                .deleted,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .cancelled: return "CANCELLED"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {
    /// A snapshot object that contains databases.
    public struct Snapshot {
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.
        public var accountsWithProvisionedRestoreAccess: [Swift.String]?
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a namespace.
        public var accountsWithRestoreAccess: [Swift.String]?
        /// The size of the incremental backup in megabytes.
        public var actualIncrementalBackupSizeInMegaBytes: Swift.Double?
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public var adminPasswordSecretArn: Swift.String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public var adminPasswordSecretKmsKeyId: Swift.String?
        /// The username of the database within a snapshot.
        public var adminUsername: Swift.String?
        /// The size in megabytes of the data that has been backed up to a snapshot.
        public var backupProgressInMegaBytes: Swift.Double?
        /// The rate at which data is backed up into a snapshot in megabytes per second.
        public var currentBackupRateInMegaBytesPerSecond: Swift.Double?
        /// The amount of time it took to back up data into a snapshot.
        public var elapsedTimeInSeconds: Swift.Int?
        /// The estimated amount of seconds until the snapshot completes backup.
        public var estimatedSecondsToCompletion: Swift.Int?
        /// The unique identifier of the KMS key used to encrypt the snapshot.
        public var kmsKeyId: Swift.String?
        /// The Amazon Resource Name (ARN) of the namespace the snapshot was created from.
        public var namespaceArn: Swift.String?
        /// The name of the namepsace.
        public var namespaceName: Swift.String?
        /// The owner Amazon Web Services; account of the snapshot.
        public var ownerAccount: Swift.String?
        /// The Amazon Resource Name (ARN) of the snapshot.
        public var snapshotArn: Swift.String?
        /// The timestamp of when the snapshot was created.
        public var snapshotCreateTime: Foundation.Date?
        /// The name of the snapshot.
        public var snapshotName: Swift.String?
        /// The amount of days until the snapshot is deleted.
        public var snapshotRemainingDays: Swift.Int?
        /// The period of time, in days, of how long the snapshot is retained.
        public var snapshotRetentionPeriod: Swift.Int?
        /// The timestamp of when data within the snapshot started getting retained.
        public var snapshotRetentionStartTime: Foundation.Date?
        /// The status of the snapshot.
        public var status: RedshiftServerlessClientTypes.SnapshotStatus?
        /// The total size, in megabytes, of how big the snapshot is.
        public var totalBackupSizeInMegaBytes: Swift.Double?

        public init(
            accountsWithProvisionedRestoreAccess: [Swift.String]? = nil,
            accountsWithRestoreAccess: [Swift.String]? = nil,
            actualIncrementalBackupSizeInMegaBytes: Swift.Double? = nil,
            adminPasswordSecretArn: Swift.String? = nil,
            adminPasswordSecretKmsKeyId: Swift.String? = nil,
            adminUsername: Swift.String? = nil,
            backupProgressInMegaBytes: Swift.Double? = nil,
            currentBackupRateInMegaBytesPerSecond: Swift.Double? = nil,
            elapsedTimeInSeconds: Swift.Int? = nil,
            estimatedSecondsToCompletion: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            snapshotCreateTime: Foundation.Date? = nil,
            snapshotName: Swift.String? = nil,
            snapshotRemainingDays: Swift.Int? = nil,
            snapshotRetentionPeriod: Swift.Int? = nil,
            snapshotRetentionStartTime: Foundation.Date? = nil,
            status: RedshiftServerlessClientTypes.SnapshotStatus? = nil,
            totalBackupSizeInMegaBytes: Swift.Double? = nil
        )
        {
            self.accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess
            self.accountsWithRestoreAccess = accountsWithRestoreAccess
            self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.backupProgressInMegaBytes = backupProgressInMegaBytes
            self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
            self.kmsKeyId = kmsKeyId
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotName = snapshotName
            self.snapshotRemainingDays = snapshotRemainingDays
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
            self.snapshotRetentionStartTime = snapshotRetentionStartTime
            self.status = status
            self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        }
    }

}

public struct ConvertRecoveryPointToSnapshotOutput {
    /// The snapshot converted from the recovery point.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct CreateCustomDomainAssociationInput {
    /// The custom domain name’s certificate Amazon resource name (ARN).
    /// This member is required.
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name to associate with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct CreateCustomDomainAssociationOutput {
    /// The custom domain name’s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: Foundation.Date?
    /// The custom domain name to associate with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct CreateEndpointAccessInput {
    /// The name of the VPC endpoint. An endpoint name must contain 1-30 characters. Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter. The name can't contain two consecutive hyphens or end with a hyphen.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?
    /// The unique identifers of subnets from which Amazon Redshift Serverless chooses one to deploy a VPC endpoint.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The unique identifiers of the security group that defines the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
    public var vpcSecurityGroupIds: [Swift.String]?
    /// The name of the workgroup to associate with the VPC endpoint.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        endpointName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
        self.ownerAccount = ownerAccount
        self.subnetIds = subnetIds
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
        self.workgroupName = workgroupName
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a network interface in an Amazon Redshift Serverless managed VPC endpoint.
    public struct NetworkInterface {
        /// The availability Zone.
        public var availabilityZone: Swift.String?
        /// The unique identifier of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The IPv4 address of the network interface within the subnet.
        public var privateIpAddress: Swift.String?
        /// The unique identifier of the subnet.
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
        }
    }

}

extension RedshiftServerlessClientTypes {
    /// The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.
    public struct VpcEndpoint {
        /// One or more network interfaces of the endpoint. Also known as an interface endpoint.
        public var networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]?
        /// The connection endpoint ID for connecting to Amazon Redshift Serverless.
        public var vpcEndpointId: Swift.String?
        /// The VPC identifier that the endpoint is associated with.
        public var vpcId: Swift.String?

        public init(
            networkInterfaces: [RedshiftServerlessClientTypes.NetworkInterface]? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.networkInterfaces = networkInterfaces
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension RedshiftServerlessClientTypes {
    /// Describes the members of a VPC security group.
    public struct VpcSecurityGroupMembership {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The unique identifier of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension RedshiftServerlessClientTypes {
    /// Information about an Amazon Redshift Serverless VPC endpoint.
    public struct EndpointAccess {
        /// The DNS address of the endpoint.
        public var address: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint.
        public var endpointArn: Swift.String?
        /// The time that the endpoint was created.
        public var endpointCreateTime: Foundation.Date?
        /// The name of the VPC endpoint.
        public var endpointName: Swift.String?
        /// The status of the VPC endpoint.
        public var endpointStatus: Swift.String?
        /// The port number on which Amazon Redshift Serverless accepts incoming connections.
        public var port: Swift.Int?
        /// The unique identifier of subnets where Amazon Redshift Serverless choose to deploy the VPC endpoint.
        public var subnetIds: [Swift.String]?
        /// The connection endpoint for connecting to Amazon Redshift Serverless.
        public var vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint?
        /// The security groups associated with the endpoint.
        public var vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]?
        /// The name of the workgroup associated with the endpoint.
        public var workgroupName: Swift.String?

        public init(
            address: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            endpointCreateTime: Foundation.Date? = nil,
            endpointName: Swift.String? = nil,
            endpointStatus: Swift.String? = nil,
            port: Swift.Int? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcEndpoint: RedshiftServerlessClientTypes.VpcEndpoint? = nil,
            vpcSecurityGroups: [RedshiftServerlessClientTypes.VpcSecurityGroupMembership]? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.address = address
            self.endpointArn = endpointArn
            self.endpointCreateTime = endpointCreateTime
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.port = port
            self.subnetIds = subnetIds
            self.vpcEndpoint = vpcEndpoint
            self.vpcSecurityGroups = vpcSecurityGroups
            self.workgroupName = workgroupName
        }
    }

}

public struct CreateEndpointAccessOutput {
    /// The created VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

extension RedshiftServerlessClientTypes {

    public enum LogExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectionLog
        case userActivityLog
        case userLog
        case sdkUnknown(Swift.String)

        public static var allCases: [LogExport] {
            return [
                .connectionLog,
                .userActivityLog,
                .userLog
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectionLog: return "connectionlog"
            case .userActivityLog: return "useractivitylog"
            case .userLog: return "userlog"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNamespaceInput {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret. You can only use this parameter if manageAdminPassword is true.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// The password of the administrator for the first database created in the namespace. You can't use adminUserPassword if manageAdminPassword is true.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace.
    public var adminUsername: Swift.String?
    /// The name of the first database created in the namespace.
    public var dbName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. Available export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials. You can't use adminUserPassword if manageAdminPassword is true. If manageAdminPassword is false or not set, Amazon Redshift uses adminUserPassword for the admin user account's password.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The ARN for the Redshift application that integrates with IAM Identity Center.
    public var redshiftIdcApplicationArn: Swift.String?
    /// A list of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        dbName: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        redshiftIdcApplicationArn: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.dbName = dbName
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
        self.redshiftIdcApplicationArn = redshiftIdcApplicationArn
        self.tags = tags
    }
}

extension CreateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNamespaceInput(adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), manageAdminPassword: \(Swift.String(describing: manageAdminPassword)), namespaceName: \(Swift.String(describing: namespaceName)), redshiftIdcApplicationArn: \(Swift.String(describing: redshiftIdcApplicationArn)), tags: \(Swift.String(describing: tags)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

extension RedshiftServerlessClientTypes {

    public enum NamespaceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .available,
                .deleting,
                .modifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {
    /// A collection of database objects and users.
    public struct Namespace {
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public var adminPasswordSecretArn: Swift.String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public var adminPasswordSecretKmsKeyId: Swift.String?
        /// The username of the administrator for the first database created in the namespace.
        public var adminUsername: Swift.String?
        /// The date of when the namespace was created.
        public var creationDate: Foundation.Date?
        /// The name of the first database created in the namespace.
        public var dbName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
        public var defaultIamRoleArn: Swift.String?
        /// A list of IAM roles to associate with the namespace.
        public var iamRoles: [Swift.String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.
        public var logExports: [RedshiftServerlessClientTypes.LogExport]?
        /// The Amazon Resource Name (ARN) associated with a namespace.
        public var namespaceArn: Swift.String?
        /// The unique identifier of a namespace.
        public var namespaceId: Swift.String?
        /// The name of the namespace. Must be between 3-64 alphanumeric characters in lowercase, and it cannot be a reserved word. A list of reserved words can be found in [Reserved Words](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide.
        public var namespaceName: Swift.String?
        /// The status of the namespace.
        public var status: RedshiftServerlessClientTypes.NamespaceStatus?

        public init(
            adminPasswordSecretArn: Swift.String? = nil,
            adminPasswordSecretKmsKeyId: Swift.String? = nil,
            adminUsername: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            dbName: Swift.String? = nil,
            defaultIamRoleArn: Swift.String? = nil,
            iamRoles: [Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
            namespaceArn: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            status: RedshiftServerlessClientTypes.NamespaceStatus? = nil
        )
        {
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.creationDate = creationDate
            self.dbName = dbName
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.namespaceArn = namespaceArn
            self.namespaceId = namespaceId
            self.namespaceName = namespaceName
            self.status = status
        }
    }

}

extension RedshiftServerlessClientTypes.Namespace: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Namespace(adminPasswordSecretArn: \(Swift.String(describing: adminPasswordSecretArn)), adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), creationDate: \(Swift.String(describing: creationDate)), dbName: \(Swift.String(describing: dbName)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), namespaceArn: \(Swift.String(describing: namespaceArn)), namespaceId: \(Swift.String(describing: namespaceId)), namespaceName: \(Swift.String(describing: namespaceName)), status: \(Swift.String(describing: status)), adminUsername: \"CONTENT_REDACTED\")"}
}

public struct CreateNamespaceOutput {
    /// The created namespace object.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

extension RedshiftServerlessClientTypes {
    /// The schedule of when Amazon Redshift Serverless should run the scheduled action.
    public enum Schedule {
        /// The timestamp of when Amazon Redshift Serverless should run the scheduled action. Timestamp is in UTC. Format of at expression is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.
        case at(Foundation.Date)
        /// The cron expression to use to schedule a recurring scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC. Format of cron expressions is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
        case cron(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension RedshiftServerlessClientTypes {
    /// The parameters that you can use to configure a [scheduled action](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html) to create a snapshot. For more information about creating a scheduled action, see [CreateScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html).
    public struct CreateSnapshotScheduleActionParameters {
        /// The name of the namespace for which you want to configure a scheduled action to create a snapshot.
        /// This member is required.
        public var namespaceName: Swift.String?
        /// The retention period of the snapshot created by the scheduled action.
        public var retentionPeriod: Swift.Int?
        /// A string prefix that is attached to the name of the snapshot created by the scheduled action. The final name of the snapshot is the string prefix appended by the date and time of when the snapshot was created.
        /// This member is required.
        public var snapshotNamePrefix: Swift.String?
        /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the snapshot.
        public var tags: [RedshiftServerlessClientTypes.Tag]?

        public init(
            namespaceName: Swift.String? = nil,
            retentionPeriod: Swift.Int? = nil,
            snapshotNamePrefix: Swift.String? = nil,
            tags: [RedshiftServerlessClientTypes.Tag]? = nil
        )
        {
            self.namespaceName = namespaceName
            self.retentionPeriod = retentionPeriod
            self.snapshotNamePrefix = snapshotNamePrefix
            self.tags = tags
        }
    }

}

extension RedshiftServerlessClientTypes {
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    public enum TargetAction {
        /// The parameters that you can use to configure a [scheduled action](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html) to create a snapshot. For more information about creating a scheduled action, see [CreateScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_CreateScheduledAction.html).
        case createsnapshot(RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateScheduledActionInput {
    /// Indicates whether the schedule is enabled. If false, the scheduled action does not trigger. For more information about state of the scheduled action, see [ScheduledAction](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_ScheduledAction.html).
    public var enabled: Swift.Bool?
    /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
    public var endTime: Foundation.Date?
    /// The name of the namespace for which to create a scheduled action.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
    /// This member is required.
    public var roleArn: Swift.String?
    /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.
    ///
    /// * Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.
    ///
    /// * Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
    /// This member is required.
    public var schedule: RedshiftServerlessClientTypes.Schedule?
    /// The description of the scheduled action.
    public var scheduledActionDescription: Swift.String?
    /// The name of the scheduled action.
    /// This member is required.
    public var scheduledActionName: Swift.String?
    /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
    public var startTime: Foundation.Date?
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    /// This member is required.
    public var targetAction: RedshiftServerlessClientTypes.TargetAction?

    public init(
        enabled: Swift.Bool? = nil,
        endTime: Foundation.Date? = nil,
        namespaceName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        schedule: RedshiftServerlessClientTypes.Schedule? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
    )
    {
        self.enabled = enabled
        self.endTime = endTime
        self.namespaceName = namespaceName
        self.roleArn = roleArn
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

extension RedshiftServerlessClientTypes {

    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {
    /// The returned scheduled action object.
    public struct ScheduledActionResponse {
        /// The end time of
        public var endTime: Foundation.Date?
        /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
        public var namespaceName: Swift.String?
        /// An array of timestamps of when the next scheduled actions will trigger.
        public var nextInvocations: [Foundation.Date]?
        /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
        public var roleArn: Swift.String?
        /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.
        ///
        /// * Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.
        ///
        /// * Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
        public var schedule: RedshiftServerlessClientTypes.Schedule?
        /// The description of the scheduled action.
        public var scheduledActionDescription: Swift.String?
        /// The name of the scheduled action.
        public var scheduledActionName: Swift.String?
        /// The uuid of the scheduled action.
        public var scheduledActionUuid: Swift.String?
        /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
        public var startTime: Foundation.Date?
        /// The state of the scheduled action.
        public var state: RedshiftServerlessClientTypes.State?
        /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
        public var targetAction: RedshiftServerlessClientTypes.TargetAction?

        public init(
            endTime: Foundation.Date? = nil,
            namespaceName: Swift.String? = nil,
            nextInvocations: [Foundation.Date]? = nil,
            roleArn: Swift.String? = nil,
            schedule: RedshiftServerlessClientTypes.Schedule? = nil,
            scheduledActionDescription: Swift.String? = nil,
            scheduledActionName: Swift.String? = nil,
            scheduledActionUuid: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: RedshiftServerlessClientTypes.State? = nil,
            targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
        )
        {
            self.endTime = endTime
            self.namespaceName = namespaceName
            self.nextInvocations = nextInvocations
            self.roleArn = roleArn
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.scheduledActionUuid = scheduledActionUuid
            self.startTime = startTime
            self.state = state
            self.targetAction = targetAction
        }
    }

}

public struct CreateScheduledActionOutput {
    /// The returned ScheduledAction object that describes the properties of a scheduled action.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

public struct CreateSnapshotInput {
    /// The namespace to create a snapshot for.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// How long to retain the created snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// An array of [Tag objects](https://docs.aws.amazon.com/redshift-serverless/latest/APIReference/API_Tag.html) to associate with the snapshot.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        namespaceName: Swift.String? = nil,
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.namespaceName = namespaceName
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
        self.tags = tags
    }
}

public struct CreateSnapshotOutput {
    /// The created snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

public struct CreateSnapshotCopyConfigurationInput {
    /// The KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
    public var destinationKmsKeyId: Swift.String?
    /// The destination Amazon Web Services Region that you want to copy snapshots to.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the namespace to copy snapshots from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The retention period of the snapshots that you copy to the destination Amazon Web Services Region.
    public var snapshotRetentionPeriod: Swift.Int?

    public init(
        destinationKmsKeyId: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        snapshotRetentionPeriod: Swift.Int? = nil
    )
    {
        self.destinationKmsKeyId = destinationKmsKeyId
        self.destinationRegion = destinationRegion
        self.namespaceName = namespaceName
        self.snapshotRetentionPeriod = snapshotRetentionPeriod
    }
}

extension RedshiftServerlessClientTypes {
    /// The object that you configure to copy snapshots from one namespace to a namespace in another Amazon Web Services Region.
    public struct SnapshotCopyConfiguration {
        /// The ID of the KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
        public var destinationKmsKeyId: Swift.String?
        /// The destination Amazon Web Services Region to copy snapshots to.
        public var destinationRegion: Swift.String?
        /// The name of the namespace to copy snapshots from in the source Amazon Web Services Region.
        public var namespaceName: Swift.String?
        /// The ARN of the snapshot copy configuration object.
        public var snapshotCopyConfigurationArn: Swift.String?
        /// The ID of the snapshot copy configuration object.
        public var snapshotCopyConfigurationId: Swift.String?
        /// The retention period of snapshots that are copied to the destination Amazon Web Services Region.
        public var snapshotRetentionPeriod: Swift.Int?

        public init(
            destinationKmsKeyId: Swift.String? = nil,
            destinationRegion: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            snapshotCopyConfigurationArn: Swift.String? = nil,
            snapshotCopyConfigurationId: Swift.String? = nil,
            snapshotRetentionPeriod: Swift.Int? = nil
        )
        {
            self.destinationKmsKeyId = destinationKmsKeyId
            self.destinationRegion = destinationRegion
            self.namespaceName = namespaceName
            self.snapshotCopyConfigurationArn = snapshotCopyConfigurationArn
            self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
        }
    }

}

public struct CreateSnapshotCopyConfigurationOutput {
    /// The snapshot copy configuration object that is returned.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

extension RedshiftServerlessClientTypes {

    public enum UsageLimitBreachAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deactivate
        case emitMetric
        case log
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitBreachAction] {
            return [
                .deactivate,
                .emitMetric,
                .log
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deactivate: return "deactivate"
            case .emitMetric: return "emit-metric"
            case .log: return "log"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {

    public enum UsageLimitPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitPeriod] {
            return [
                .daily,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "daily"
            case .monthly: return "monthly"
            case .weekly: return "weekly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {

    public enum UsageLimitUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crossRegionDatasharing
        case serverlessCompute
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageLimitUsageType] {
            return [
                .crossRegionDatasharing,
                .serverlessCompute
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crossRegionDatasharing: return "cross-region-datasharing"
            case .serverlessCompute: return "serverless-compute"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUsageLimitInput {
    /// The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    /// This member is required.
    public var amount: Swift.Int?
    /// The action that Amazon Redshift Serverless takes when the limit is reached. The default is log.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
    public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
    /// The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of Amazon Redshift Serverless usage to create a usage limit for.
    /// This member is required.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.period = period
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

extension RedshiftServerlessClientTypes {
    /// The usage limit object.
    public struct UsageLimit {
        /// The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.
        public var amount: Swift.Int?
        /// The action that Amazon Redshift Serverless takes when the limit is reached.
        public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
        /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
        public var period: RedshiftServerlessClientTypes.UsageLimitPeriod?
        /// The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.
        public var resourceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource associated with the usage limit.
        public var usageLimitArn: Swift.String?
        /// The identifier of the usage limit.
        public var usageLimitId: Swift.String?
        /// The Amazon Redshift Serverless feature to limit.
        public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

        public init(
            amount: Swift.Int? = nil,
            breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
            period: RedshiftServerlessClientTypes.UsageLimitPeriod? = nil,
            resourceArn: Swift.String? = nil,
            usageLimitArn: Swift.String? = nil,
            usageLimitId: Swift.String? = nil,
            usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
        )
        {
            self.amount = amount
            self.breachAction = breachAction
            self.period = period
            self.resourceArn = resourceArn
            self.usageLimitArn = usageLimitArn
            self.usageLimitId = usageLimitId
            self.usageType = usageType
        }
    }

}

public struct CreateUsageLimitOutput {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

/// There is an insufficient capacity to perform the action.
public struct InsufficientCapacityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientCapacityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateWorkgroupInput {
    /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
    public var enhancedVpcRouting: Swift.Bool?
    /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
    public var maxCapacity: Swift.Int?
    /// The name of the namespace to associate with the workgroup.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessed from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// A array of tag instances.
    public var tags: [RedshiftServerlessClientTypes.Tag]?
    /// The name of the created workgroup.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        maxCapacity: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maxCapacity = maxCapacity
        self.namespaceName = namespaceName
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.workgroupName = workgroupName
    }
}

extension RedshiftServerlessClientTypes {
    /// The VPC endpoint object.
    public struct Endpoint {
        /// The DNS address of the VPC endpoint.
        public var address: Swift.String?
        /// The port that Amazon Redshift Serverless listens on.
        public var port: Swift.Int?
        /// An array of VpcEndpoint objects.
        public var vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]?

        public init(
            address: Swift.String? = nil,
            port: Swift.Int? = nil,
            vpcEndpoints: [RedshiftServerlessClientTypes.VpcEndpoint]? = nil
        )
        {
            self.address = address
            self.port = port
            self.vpcEndpoints = vpcEndpoints
        }
    }

}

extension RedshiftServerlessClientTypes {

    public enum WorkgroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case modifying
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkgroupStatus] {
            return [
                .available,
                .creating,
                .deleting,
                .modifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .modifying: return "MODIFYING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension RedshiftServerlessClientTypes {
    /// The collection of computing resources from which an endpoint is created.
    public struct Workgroup {
        /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
        public var baseCapacity: Swift.Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
        public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
        /// The creation date of the workgroup.
        public var creationDate: Foundation.Date?
        /// A list of VPCs. Each entry is the unique identifier of a virtual private cloud with access to Amazon Redshift Serverless. If all of the VPCs for the grantee are allowed, it shows an asterisk.
        public var crossAccountVpcs: [Swift.String]?
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public var customDomainCertificateArn: Swift.String?
        /// The expiration time for the certificate.
        public var customDomainCertificateExpiryTime: Foundation.Date?
        /// The custom domain name associated with the workgroup.
        public var customDomainName: Swift.String?
        /// The endpoint that is created from the workgroup.
        public var endpoint: RedshiftServerlessClientTypes.Endpoint?
        /// The value that specifies whether to enable enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
        public var enhancedVpcRouting: Swift.Bool?
        /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
        public var maxCapacity: Swift.Int?
        /// The namespace the workgroup is associated with.
        public var namespaceName: Swift.String?
        /// The patch version of your Amazon Redshift Serverless workgroup. For more information about patch versions, see [Cluster versions for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/cluster-versions.html).
        public var patchVersion: Swift.String?
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public var port: Swift.Int?
        /// A value that specifies whether the workgroup can be accessible from a public network.
        public var publiclyAccessible: Swift.Bool?
        /// An array of security group IDs to associate with the workgroup.
        public var securityGroupIds: [Swift.String]?
        /// The status of the workgroup.
        public var status: RedshiftServerlessClientTypes.WorkgroupStatus?
        /// An array of subnet IDs the workgroup is associated with.
        public var subnetIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) that links to the workgroup.
        public var workgroupArn: Swift.String?
        /// The unique identifier of the workgroup.
        public var workgroupId: Swift.String?
        /// The name of the workgroup.
        public var workgroupName: Swift.String?
        /// The Amazon Redshift Serverless version of your workgroup. For more information about Amazon Redshift Serverless versions, see[Cluster versions for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/cluster-versions.html).
        public var workgroupVersion: Swift.String?

        public init(
            baseCapacity: Swift.Int? = nil,
            configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
            creationDate: Foundation.Date? = nil,
            crossAccountVpcs: [Swift.String]? = nil,
            customDomainCertificateArn: Swift.String? = nil,
            customDomainCertificateExpiryTime: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            endpoint: RedshiftServerlessClientTypes.Endpoint? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            maxCapacity: Swift.Int? = nil,
            namespaceName: Swift.String? = nil,
            patchVersion: Swift.String? = nil,
            port: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: RedshiftServerlessClientTypes.WorkgroupStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            workgroupArn: Swift.String? = nil,
            workgroupId: Swift.String? = nil,
            workgroupName: Swift.String? = nil,
            workgroupVersion: Swift.String? = nil
        )
        {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.creationDate = creationDate
            self.crossAccountVpcs = crossAccountVpcs
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maxCapacity = maxCapacity
            self.namespaceName = namespaceName
            self.patchVersion = patchVersion
            self.port = port
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.workgroupArn = workgroupArn
            self.workgroupId = workgroupId
            self.workgroupName = workgroupName
            self.workgroupVersion = workgroupVersion
        }
    }

}

public struct CreateWorkgroupOutput {
    /// The created workgroup object.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

public struct DeleteEndpointAccessInput {
    /// The name of the VPC endpoint to delete.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

public struct DeleteEndpointAccessOutput {
    /// The deleted VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct GetEndpointAccessInput {
    /// The name of the VPC endpoint to return information for.
    /// This member is required.
    public var endpointName: Swift.String?

    public init(
        endpointName: Swift.String? = nil
    )
    {
        self.endpointName = endpointName
    }
}

public struct GetEndpointAccessOutput {
    /// The returned VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct ListEndpointAccessInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListEndpointAccess operation returns a nextToken, you can include the returned nextToken in following ListEndpointAccess operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?
    /// The unique identifier of the virtual private cloud with access to Amazon Redshift Serverless.
    public var vpcId: Swift.String?
    /// The name of the workgroup associated with the VPC endpoint to return.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        vpcId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.vpcId = vpcId
        self.workgroupName = workgroupName
    }
}

public struct ListEndpointAccessOutput {
    /// The returned VPC endpoints.
    /// This member is required.
    public var endpoints: [RedshiftServerlessClientTypes.EndpointAccess]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        endpoints: [RedshiftServerlessClientTypes.EndpointAccess]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

public struct UpdateEndpointAccessInput {
    /// The name of the VPC endpoint to update.
    /// This member is required.
    public var endpointName: Swift.String?
    /// The list of VPC security groups associated with the endpoint after the endpoint is modified.
    public var vpcSecurityGroupIds: [Swift.String]?

    public init(
        endpointName: Swift.String? = nil,
        vpcSecurityGroupIds: [Swift.String]? = nil
    )
    {
        self.endpointName = endpointName
        self.vpcSecurityGroupIds = vpcSecurityGroupIds
    }
}

public struct UpdateEndpointAccessOutput {
    /// The updated VPC endpoint.
    public var endpoint: RedshiftServerlessClientTypes.EndpointAccess?

    public init(
        endpoint: RedshiftServerlessClientTypes.EndpointAccess? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct DeleteCustomDomainAssociationInput {
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct DeleteCustomDomainAssociationOutput {

    public init() { }
}

public struct DeleteNamespaceInput {
    /// The name of the snapshot to be created before the namespace is deleted.
    public var finalSnapshotName: Swift.String?
    /// How long to retain the final snapshot.
    public var finalSnapshotRetentionPeriod: Swift.Int?
    /// The name of the namespace to delete.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        finalSnapshotName: Swift.String? = nil,
        finalSnapshotRetentionPeriod: Swift.Int? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.finalSnapshotName = finalSnapshotName
        self.finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriod
        self.namespaceName = namespaceName
    }
}

public struct DeleteNamespaceOutput {
    /// The deleted namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

public struct DeleteResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the policy to delete.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

public struct DeleteScheduledActionInput {
    /// The name of the scheduled action to delete.
    /// This member is required.
    public var scheduledActionName: Swift.String?

    public init(
        scheduledActionName: Swift.String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

public struct DeleteScheduledActionOutput {
    /// The deleted scheduled action object.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

public struct DeleteSnapshotInput {
    /// The name of the snapshot to be deleted.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        snapshotName: Swift.String? = nil
    )
    {
        self.snapshotName = snapshotName
    }
}

public struct DeleteSnapshotOutput {
    /// The deleted snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

public struct DeleteSnapshotCopyConfigurationInput {
    /// The ID of the snapshot copy configuration to delete.
    /// This member is required.
    public var snapshotCopyConfigurationId: Swift.String?

    public init(
        snapshotCopyConfigurationId: Swift.String? = nil
    )
    {
        self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
    }
}

public struct DeleteSnapshotCopyConfigurationOutput {
    /// The deleted snapshot copy configuration object.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

public struct DeleteUsageLimitInput {
    /// The unique identifier of the usage limit to delete.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

public struct DeleteUsageLimitOutput {
    /// The deleted usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

public struct DeleteWorkgroupInput {
    /// The name of the workgroup to be deleted.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

public struct DeleteWorkgroupOutput {
    /// The deleted workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

public struct GetCredentialsInput {
    /// The custom domain name associated with the workgroup. The custom domain name or the workgroup name must be included in the request.
    public var customDomainName: Swift.String?
    /// The name of the database to get temporary authorization to log on to. Constraints:
    ///
    /// * Must be 1 to 64 alphanumeric characters or hyphens.
    ///
    /// * Must contain only uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.
    ///
    /// * The first character must be a letter.
    ///
    /// * Must not contain a colon ( : ) or slash ( / ).
    ///
    /// * Cannot be a reserved word. A list of reserved words can be found in [Reserved Words ](https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html) in the Amazon Redshift Database Developer Guide
    public var dbName: Swift.String?
    /// The number of seconds until the returned temporary password expires. The minimum is 900 seconds, and the maximum is 3600 seconds.
    public var durationSeconds: Swift.Int?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        dbName: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.dbName = dbName
        self.durationSeconds = durationSeconds
        self.workgroupName = workgroupName
    }
}

public struct GetCredentialsOutput {
    /// A temporary password that authorizes the user name returned by DbUser to log on to the database DbName.
    public var dbPassword: Swift.String?
    /// A database user name that is authorized to log on to the database DbName using the password DbPassword. If the specified DbUser exists in the database, the new user name has the same database privileges as the the user named in DbUser. By default, the user is added to PUBLIC.
    public var dbUser: Swift.String?
    /// The date and time the password in DbPassword expires.
    public var expiration: Foundation.Date?
    /// The date and time of when the DbUser and DbPassword authorization refreshes.
    public var nextRefreshTime: Foundation.Date?

    public init(
        dbPassword: Swift.String? = nil,
        dbUser: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        nextRefreshTime: Foundation.Date? = nil
    )
    {
        self.dbPassword = dbPassword
        self.dbUser = dbUser
        self.expiration = expiration
        self.nextRefreshTime = nextRefreshTime
    }
}

extension GetCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCredentialsOutput(expiration: \(Swift.String(describing: expiration)), nextRefreshTime: \(Swift.String(describing: nextRefreshTime)), dbPassword: \"CONTENT_REDACTED\", dbUser: \"CONTENT_REDACTED\")"}
}

public struct GetCustomDomainAssociationInput {
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct GetCustomDomainAssociationOutput {
    /// The custom domain name’s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: Foundation.Date?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct GetNamespaceInput {
    /// The name of the namespace to retrieve information for.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
    }
}

public struct GetNamespaceOutput {
    /// The returned namespace object.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

public struct GetRecoveryPointInput {
    /// The unique identifier of the recovery point to return information for.
    /// This member is required.
    public var recoveryPointId: Swift.String?

    public init(
        recoveryPointId: Swift.String? = nil
    )
    {
        self.recoveryPointId = recoveryPointId
    }
}

extension RedshiftServerlessClientTypes {
    /// The automatically created recovery point of a namespace. Recovery points are created every 30 minutes and kept for 24 hours.
    public struct RecoveryPoint {
        /// The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.
        public var namespaceArn: Swift.String?
        /// The name of the namespace the recovery point is associated with.
        public var namespaceName: Swift.String?
        /// The time the recovery point is created.
        public var recoveryPointCreateTime: Foundation.Date?
        /// The unique identifier of the recovery point.
        public var recoveryPointId: Swift.String?
        /// The total size of the data in the recovery point in megabytes.
        public var totalSizeInMegaBytes: Swift.Double?
        /// The name of the workgroup the recovery point is associated with.
        public var workgroupName: Swift.String?

        public init(
            namespaceArn: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            recoveryPointCreateTime: Foundation.Date? = nil,
            recoveryPointId: Swift.String? = nil,
            totalSizeInMegaBytes: Swift.Double? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.recoveryPointCreateTime = recoveryPointCreateTime
            self.recoveryPointId = recoveryPointId
            self.totalSizeInMegaBytes = totalSizeInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

public struct GetRecoveryPointOutput {
    /// The returned recovery point object.
    public var recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint?

    public init(
        recoveryPoint: RedshiftServerlessClientTypes.RecoveryPoint? = nil
    )
    {
        self.recoveryPoint = recoveryPoint
    }
}

public struct GetResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the resource to return.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension RedshiftServerlessClientTypes {
    /// The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.
    public struct ResourcePolicy {
        /// The resource policy.
        public var policy: Swift.String?
        /// The Amazon Resource Name (ARN) of the policy.
        public var resourceArn: Swift.String?

        public init(
            policy: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.policy = policy
            self.resourceArn = resourceArn
        }
    }

}

public struct GetResourcePolicyOutput {
    /// The returned resource policy.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

public struct GetScheduledActionInput {
    /// The name of the scheduled action.
    /// This member is required.
    public var scheduledActionName: Swift.String?

    public init(
        scheduledActionName: Swift.String? = nil
    )
    {
        self.scheduledActionName = scheduledActionName
    }
}

public struct GetScheduledActionOutput {
    /// The returned scheduled action object.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

public struct GetSnapshotInput {
    /// The owner Amazon Web Services account of a snapshot shared with another user.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to return.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to return.
    public var snapshotName: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
    }
}

public struct GetSnapshotOutput {
    /// The returned snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

public struct GetTableRestoreStatusInput {
    /// The ID of the RestoreTableFromSnapshot request to return status for.
    /// This member is required.
    public var tableRestoreRequestId: Swift.String?

    public init(
        tableRestoreRequestId: Swift.String? = nil
    )
    {
        self.tableRestoreRequestId = tableRestoreRequestId
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains information about a table restore request.
    public struct TableRestoreStatus {
        /// A message that explains the returned status. For example, if the status of the operation is FAILED, the message explains why the operation failed.
        public var message: Swift.String?
        /// The namespace of the table being restored from.
        public var namespaceName: Swift.String?
        /// The name of the table to create from the restore operation.
        public var newTableName: Swift.String?
        /// The amount of data restored to the new table so far, in megabytes (MB).
        public var progressInMegaBytes: Swift.Int?
        /// The ID of the recovery point being restored from.
        public var recoveryPointId: Swift.String?
        /// The time that the table restore request was made, in Universal Coordinated Time (UTC).
        public var requestTime: Foundation.Date?
        /// The name of the snapshot being restored from.
        public var snapshotName: Swift.String?
        /// The name of the source database being restored from.
        public var sourceDatabaseName: Swift.String?
        /// The name of the source schema being restored from.
        public var sourceSchemaName: Swift.String?
        /// The name of the source table being restored from.
        public var sourceTableName: Swift.String?
        /// A value that describes the current state of the table restore request. Possible values are SUCCEEDED, FAILED, CANCELED, PENDING, and IN_PROGRESS.
        public var status: Swift.String?
        /// The ID of the RestoreTableFromSnapshot request.
        public var tableRestoreRequestId: Swift.String?
        /// The name of the database to restore to.
        public var targetDatabaseName: Swift.String?
        /// The name of the schema to restore to.
        public var targetSchemaName: Swift.String?
        /// The total amount of data to restore to the new table, in megabytes (MB).
        public var totalDataInMegaBytes: Swift.Int?
        /// The name of the workgroup being restored from.
        public var workgroupName: Swift.String?

        public init(
            message: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            newTableName: Swift.String? = nil,
            progressInMegaBytes: Swift.Int? = nil,
            recoveryPointId: Swift.String? = nil,
            requestTime: Foundation.Date? = nil,
            snapshotName: Swift.String? = nil,
            sourceDatabaseName: Swift.String? = nil,
            sourceSchemaName: Swift.String? = nil,
            sourceTableName: Swift.String? = nil,
            status: Swift.String? = nil,
            tableRestoreRequestId: Swift.String? = nil,
            targetDatabaseName: Swift.String? = nil,
            targetSchemaName: Swift.String? = nil,
            totalDataInMegaBytes: Swift.Int? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.message = message
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.progressInMegaBytes = progressInMegaBytes
            self.recoveryPointId = recoveryPointId
            self.requestTime = requestTime
            self.snapshotName = snapshotName
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.status = status
            self.tableRestoreRequestId = tableRestoreRequestId
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.totalDataInMegaBytes = totalDataInMegaBytes
            self.workgroupName = workgroupName
        }
    }

}

public struct GetTableRestoreStatusOutput {
    /// The returned TableRestoreStatus object that contains information about the status of your RestoreTableFromSnapshot request.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

public struct GetUsageLimitInput {
    /// The unique identifier of the usage limit to return information for.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        usageLimitId: Swift.String? = nil
    )
    {
        self.usageLimitId = usageLimitId
    }
}

public struct GetUsageLimitOutput {
    /// The returned usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

public struct GetWorkgroupInput {
    /// The name of the workgroup to return information for.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        workgroupName: Swift.String? = nil
    )
    {
        self.workgroupName = workgroupName
    }
}

public struct GetWorkgroupOutput {
    /// The returned workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

/// The provided pagination token is invalid.
public struct InvalidPaginationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListCustomDomainAssociationsInput {
    /// The custom domain name’s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCustomDomainAssociationsOutput {
    /// A list of Association objects.
    public var associations: [RedshiftServerlessClientTypes.Association]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        associations: [RedshiftServerlessClientTypes.Association]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.associations = associations
        self.nextToken = nextToken
    }
}

public struct ListNamespacesInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListNamespaces operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListNamespacesOutput {
    /// The list of returned namespaces.
    /// This member is required.
    public var namespaces: [RedshiftServerlessClientTypes.Namespace]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        namespaces: [RedshiftServerlessClientTypes.Namespace]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

public struct ListRecoveryPointsInput {
    /// The time when creation of the recovery point finished.
    public var endTime: Foundation.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list recovery points.
    public var namespaceArn: Swift.String?
    /// The name of the namespace to list recovery points for.
    public var namespaceName: Swift.String?
    /// If your initial ListRecoveryPoints operation returns a nextToken, you can include the returned nextToken in following ListRecoveryPoints operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The time when the recovery point's creation was initiated.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

public struct ListRecoveryPointsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The returned recovery point objects.
    public var recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]?

    public init(
        nextToken: Swift.String? = nil,
        recoveryPoints: [RedshiftServerlessClientTypes.RecoveryPoint]? = nil
    )
    {
        self.nextToken = nextToken
        self.recoveryPoints = recoveryPoints
    }
}

public struct ListScheduledActionsInput {
    /// An optional parameter that specifies the maximum number of results to return. Use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The name of namespace associated with the scheduled action to retrieve.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
    }
}

extension RedshiftServerlessClientTypes {
    /// Contains names of objects associated with a scheduled action.
    public struct ScheduledActionAssociation {
        /// Name of associated Amazon Redshift Serverless namespace.
        public var namespaceName: Swift.String?
        /// Name of associated scheduled action.
        public var scheduledActionName: Swift.String?

        public init(
            namespaceName: Swift.String? = nil,
            scheduledActionName: Swift.String? = nil
        )
        {
            self.namespaceName = namespaceName
            self.scheduledActionName = scheduledActionName
        }
    }

}

public struct ListScheduledActionsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned scheduled action association objects.
    public var scheduledActions: [RedshiftServerlessClientTypes.ScheduledActionAssociation]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledActions: [RedshiftServerlessClientTypes.ScheduledActionAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledActions = scheduledActions
    }
}

public struct ListSnapshotCopyConfigurationsInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The namespace from which to list all snapshot copy configurations.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
    }
}

public struct ListSnapshotCopyConfigurationsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned snapshot copy configurations.
    /// This member is required.
    public var snapshotCopyConfigurations: [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        snapshotCopyConfigurations: [RedshiftServerlessClientTypes.SnapshotCopyConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshotCopyConfigurations = snapshotCopyConfigurations
    }
}

public struct ListSnapshotsInput {
    /// The timestamp showing when the snapshot creation finished.
    public var endTime: Foundation.Date?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of the namespace from which to list all snapshots.
    public var namespaceArn: Swift.String?
    /// The namespace from which to list all snapshots.
    public var namespaceName: Swift.String?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account of the snapshot.
    public var ownerAccount: Swift.String?
    /// The time when the creation of the snapshot was initiated.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        namespaceArn: Swift.String? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.namespaceArn = namespaceArn
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.startTime = startTime
    }
}

public struct ListSnapshotsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// All of the returned snapshot objects.
    public var snapshots: [RedshiftServerlessClientTypes.Snapshot]?

    public init(
        nextToken: Swift.String? = nil,
        snapshots: [RedshiftServerlessClientTypes.Snapshot]? = nil
    )
    {
        self.nextToken = nextToken
        self.snapshots = snapshots
    }
}

public struct ListTableRestoreStatusInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// The namespace from which to list all of the statuses of RestoreTableFromSnapshot operations .
    public var namespaceName: Swift.String?
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will return results on the next page.
    public var nextToken: Swift.String?
    /// The workgroup from which to list all of the statuses of RestoreTableFromSnapshot operations.
    public var workgroupName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.nextToken = nextToken
        self.workgroupName = workgroupName
    }
}

public struct ListTableRestoreStatusOutput {
    /// If your initial ListTableRestoreStatus operation returns a nextToken, you can include the returned nextToken in following ListTableRestoreStatus operations. This will returns results on the next page.
    public var nextToken: Swift.String?
    /// The array of returned TableRestoreStatus objects.
    public var tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]?

    public init(
        nextToken: Swift.String? = nil,
        tableRestoreStatuses: [RedshiftServerlessClientTypes.TableRestoreStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableRestoreStatuses = tableRestoreStatuses
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A map of the key-value pairs assigned to the resource.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListUsageLimitsInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 100.
    public var maxResults: Swift.Int?
    /// If your initial ListUsageLimits operation returns a nextToken, you can include the returned nextToken in following ListUsageLimits operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the resource whose usage limits you want to list.
    public var resourceArn: Swift.String?
    /// The Amazon Redshift Serverless feature whose limits you want to see.
    public var usageType: RedshiftServerlessClientTypes.UsageLimitUsageType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        usageType: RedshiftServerlessClientTypes.UsageLimitUsageType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
        self.usageType = usageType
    }
}

public struct ListUsageLimitsOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// An array of returned usage limit objects.
    public var usageLimits: [RedshiftServerlessClientTypes.UsageLimit]?

    public init(
        nextToken: Swift.String? = nil,
        usageLimits: [RedshiftServerlessClientTypes.UsageLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageLimits = usageLimits
    }
}

public struct ListWorkgroupsInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListWorkgroups operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
    public var ownerAccount: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
    }
}

public struct ListWorkgroupsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token.
    public var nextToken: Swift.String?
    /// The returned array of workgroups.
    /// This member is required.
    public var workgroups: [RedshiftServerlessClientTypes.Workgroup]?

    public init(
        nextToken: Swift.String? = nil,
        workgroups: [RedshiftServerlessClientTypes.Workgroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.workgroups = workgroups
    }
}

public struct UpdateNamespaceInput {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret. You can only use this parameter if manageAdminPassword is true.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// The password of the administrator for the first database created in the namespace. This parameter must be updated together with adminUsername. You can't use adminUserPassword if manageAdminPassword is true.
    public var adminUserPassword: Swift.String?
    /// The username of the administrator for the first database created in the namespace. This parameter must be updated together with adminUserPassword.
    public var adminUsername: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace. This parameter must be updated together with iamRoles.
    public var defaultIamRoleArn: Swift.String?
    /// A list of IAM roles to associate with the namespace. This parameter must be updated together with defaultIamRoleArn.
    public var iamRoles: [Swift.String]?
    /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
    public var kmsKeyId: Swift.String?
    /// The types of logs the namespace can export. The export types are userlog, connectionlog, and useractivitylog.
    public var logExports: [RedshiftServerlessClientTypes.LogExport]?
    /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials. You can't use adminUserPassword if manageAdminPassword is true. If manageAdminPassword is false or not set, Amazon Redshift uses adminUserPassword for the admin user account's password.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace to update. You can't update the name of a namespace once it is created.
    /// This member is required.
    public var namespaceName: Swift.String?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        adminUserPassword: Swift.String? = nil,
        adminUsername: Swift.String? = nil,
        defaultIamRoleArn: Swift.String? = nil,
        iamRoles: [Swift.String]? = nil,
        kmsKeyId: Swift.String? = nil,
        logExports: [RedshiftServerlessClientTypes.LogExport]? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.adminUserPassword = adminUserPassword
        self.adminUsername = adminUsername
        self.defaultIamRoleArn = defaultIamRoleArn
        self.iamRoles = iamRoles
        self.kmsKeyId = kmsKeyId
        self.logExports = logExports
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
    }
}

extension UpdateNamespaceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNamespaceInput(adminPasswordSecretKmsKeyId: \(Swift.String(describing: adminPasswordSecretKmsKeyId)), defaultIamRoleArn: \(Swift.String(describing: defaultIamRoleArn)), iamRoles: \(Swift.String(describing: iamRoles)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), logExports: \(Swift.String(describing: logExports)), manageAdminPassword: \(Swift.String(describing: manageAdminPassword)), namespaceName: \(Swift.String(describing: namespaceName)), adminUserPassword: \"CONTENT_REDACTED\", adminUsername: \"CONTENT_REDACTED\")"}
}

public struct UpdateNamespaceOutput {
    /// A list of tag instances.
    /// This member is required.
    public var namespace: RedshiftServerlessClientTypes.Namespace?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

public struct PutResourcePolicyInput {
    /// The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot. "{\"Version\": \"2012-10-17\", \"Statement\" : [{ \"Sid\": \"AllowUserRestoreFromSnapshot\", \"Principal\":{\"AWS\": [\"739247239426\"]}, \"Action\": [\"redshift-serverless:RestoreFromSnapshot\"] , \"Effect\": \"Allow\" }]}"
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the account to create or update a resource policy for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput {
    /// The policy that was created or updated.
    public var resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy?

    public init(
        resourcePolicy: RedshiftServerlessClientTypes.ResourcePolicy? = nil
    )
    {
        self.resourcePolicy = resourcePolicy
    }
}

public struct RestoreFromRecoveryPointInput {
    /// The name of the namespace to restore data into.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The unique identifier of the recovery point to restore from.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// The name of the workgroup used to restore data.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil,
        recoveryPointId: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
        self.recoveryPointId = recoveryPointId
        self.workgroupName = workgroupName
    }
}

public struct RestoreFromRecoveryPointOutput {
    /// The namespace that data was restored into.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The unique identifier of the recovery point used for the restore.
    public var recoveryPointId: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        recoveryPointId: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.recoveryPointId = recoveryPointId
    }
}

public struct RestoreTableFromRecoveryPointInput {
    /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
    public var activateCaseSensitiveIdentifier: Swift.Bool?
    /// Namespace of the recovery point to restore from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the table to create from the restore operation.
    /// This member is required.
    public var newTableName: Swift.String?
    /// The ID of the recovery point to restore the table from.
    /// This member is required.
    public var recoveryPointId: Swift.String?
    /// The name of the source database that contains the table being restored.
    /// This member is required.
    public var sourceDatabaseName: Swift.String?
    /// The name of the source schema that contains the table being restored.
    public var sourceSchemaName: Swift.String?
    /// The name of the source table being restored.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// The name of the database to restore the table to.
    public var targetDatabaseName: Swift.String?
    /// The name of the schema to restore the table to.
    public var targetSchemaName: Swift.String?
    /// The workgroup to restore the table to.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        activateCaseSensitiveIdentifier: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        newTableName: Swift.String? = nil,
        recoveryPointId: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
        self.namespaceName = namespaceName
        self.newTableName = newTableName
        self.recoveryPointId = recoveryPointId
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.workgroupName = workgroupName
    }
}

public struct RestoreTableFromRecoveryPointOutput {
    /// Contains information about a table restore request.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

public struct UpdateScheduledActionInput {
    /// Specifies whether to enable the scheduled action.
    public var enabled: Swift.Bool?
    /// The end time in UTC of the scheduled action to update.
    public var endTime: Foundation.Date?
    /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action. This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf. For more information about the IAM role to use with the Amazon Redshift scheduler, see [Using Identity-Based Policies for Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html) in the Amazon Redshift Cluster Management Guide
    public var roleArn: Swift.String?
    /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.
    ///
    /// * Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.
    ///
    /// * Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see [Cron Expressions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html#CronExpressions) in the Amazon CloudWatch Events User Guide.
    public var schedule: RedshiftServerlessClientTypes.Schedule?
    /// The descripion of the scheduled action to update to.
    public var scheduledActionDescription: Swift.String?
    /// The name of the scheduled action to update to.
    /// This member is required.
    public var scheduledActionName: Swift.String?
    /// The start time in UTC of the scheduled action to update to.
    public var startTime: Foundation.Date?
    /// A JSON format string of the Amazon Redshift Serverless API operation with input parameters. The following is an example of a target action. "{"CreateSnapshot": {"NamespaceName": "sampleNamespace","SnapshotName": "sampleSnapshot", "retentionPeriod": "1"}}"
    public var targetAction: RedshiftServerlessClientTypes.TargetAction?

    public init(
        enabled: Swift.Bool? = nil,
        endTime: Foundation.Date? = nil,
        roleArn: Swift.String? = nil,
        schedule: RedshiftServerlessClientTypes.Schedule? = nil,
        scheduledActionDescription: Swift.String? = nil,
        scheduledActionName: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        targetAction: RedshiftServerlessClientTypes.TargetAction? = nil
    )
    {
        self.enabled = enabled
        self.endTime = endTime
        self.roleArn = roleArn
        self.schedule = schedule
        self.scheduledActionDescription = scheduledActionDescription
        self.scheduledActionName = scheduledActionName
        self.startTime = startTime
        self.targetAction = targetAction
    }
}

public struct UpdateScheduledActionOutput {
    /// The ScheduledAction object that was updated.
    public var scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse?

    public init(
        scheduledAction: RedshiftServerlessClientTypes.ScheduledActionResponse? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

public struct RestoreFromSnapshotInput {
    /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
    public var adminPasswordSecretKmsKeyId: Swift.String?
    /// If true, Amazon Redshift uses Secrets Manager to manage the restored snapshot's admin credentials. If MmanageAdminPassword is false or not set, Amazon Redshift uses the admin credentials that the namespace or cluster had at the time the snapshot was taken.
    public var manageAdminPassword: Swift.Bool?
    /// The name of the namespace to restore the snapshot to.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The Amazon Web Services account that owns the snapshot.
    public var ownerAccount: Swift.String?
    /// The Amazon Resource Name (ARN) of the snapshot to restore from. Required if restoring from Amazon Redshift Serverless to a provisioned cluster. Must not be specified at the same time as snapshotName. The format of the ARN is arn:aws:redshift:<region>:<account_id>:snapshot:<cluster_identifier>/<snapshot_identifier>.
    public var snapshotArn: Swift.String?
    /// The name of the snapshot to restore from. Must not be specified at the same time as snapshotArn.
    public var snapshotName: Swift.String?
    /// The name of the workgroup used to restore the snapshot.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        adminPasswordSecretKmsKeyId: Swift.String? = nil,
        manageAdminPassword: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotArn: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
        self.manageAdminPassword = manageAdminPassword
        self.namespaceName = namespaceName
        self.ownerAccount = ownerAccount
        self.snapshotArn = snapshotArn
        self.snapshotName = snapshotName
        self.workgroupName = workgroupName
    }
}

public struct RestoreFromSnapshotOutput {
    /// A collection of database objects and users.
    public var namespace: RedshiftServerlessClientTypes.Namespace?
    /// The owner Amazon Web Services; account of the snapshot that was restored.
    public var ownerAccount: Swift.String?
    /// The name of the snapshot used to restore the namespace.
    public var snapshotName: Swift.String?

    public init(
        namespace: RedshiftServerlessClientTypes.Namespace? = nil,
        ownerAccount: Swift.String? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.namespace = namespace
        self.ownerAccount = ownerAccount
        self.snapshotName = snapshotName
    }
}

public struct RestoreTableFromSnapshotInput {
    /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
    public var activateCaseSensitiveIdentifier: Swift.Bool?
    /// The namespace of the snapshot to restore from.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the table to create from the restore operation.
    /// This member is required.
    public var newTableName: Swift.String?
    /// The name of the snapshot to restore the table from.
    /// This member is required.
    public var snapshotName: Swift.String?
    /// The name of the source database that contains the table being restored.
    /// This member is required.
    public var sourceDatabaseName: Swift.String?
    /// The name of the source schema that contains the table being restored.
    public var sourceSchemaName: Swift.String?
    /// The name of the source table being restored.
    /// This member is required.
    public var sourceTableName: Swift.String?
    /// The name of the database to restore the table to.
    public var targetDatabaseName: Swift.String?
    /// The name of the schema to restore the table to.
    public var targetSchemaName: Swift.String?
    /// The workgroup to restore the table to.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        activateCaseSensitiveIdentifier: Swift.Bool? = nil,
        namespaceName: Swift.String? = nil,
        newTableName: Swift.String? = nil,
        snapshotName: Swift.String? = nil,
        sourceDatabaseName: Swift.String? = nil,
        sourceSchemaName: Swift.String? = nil,
        sourceTableName: Swift.String? = nil,
        targetDatabaseName: Swift.String? = nil,
        targetSchemaName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
        self.namespaceName = namespaceName
        self.newTableName = newTableName
        self.snapshotName = snapshotName
        self.sourceDatabaseName = sourceDatabaseName
        self.sourceSchemaName = sourceSchemaName
        self.sourceTableName = sourceTableName
        self.targetDatabaseName = targetDatabaseName
        self.targetSchemaName = targetSchemaName
        self.workgroupName = workgroupName
    }
}

public struct RestoreTableFromSnapshotOutput {
    /// The TableRestoreStatus object that contains the status of the restore operation.
    public var tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus?

    public init(
        tableRestoreStatus: RedshiftServerlessClientTypes.TableRestoreStatus? = nil
    )
    {
        self.tableRestoreStatus = tableRestoreStatus
    }
}

public struct UpdateSnapshotInput {
    /// The new retention period of the snapshot.
    public var retentionPeriod: Swift.Int?
    /// The name of the snapshot.
    /// This member is required.
    public var snapshotName: Swift.String?

    public init(
        retentionPeriod: Swift.Int? = nil,
        snapshotName: Swift.String? = nil
    )
    {
        self.retentionPeriod = retentionPeriod
        self.snapshotName = snapshotName
    }
}

public struct UpdateSnapshotOutput {
    /// The updated snapshot object.
    public var snapshot: RedshiftServerlessClientTypes.Snapshot?

    public init(
        snapshot: RedshiftServerlessClientTypes.Snapshot? = nil
    )
    {
        self.snapshot = snapshot
    }
}

public struct UpdateSnapshotCopyConfigurationInput {
    /// The ID of the snapshot copy configuration to update.
    /// This member is required.
    public var snapshotCopyConfigurationId: Swift.String?
    /// The new retention period of how long to keep a snapshot in the destination Amazon Web Services Region.
    public var snapshotRetentionPeriod: Swift.Int?

    public init(
        snapshotCopyConfigurationId: Swift.String? = nil,
        snapshotRetentionPeriod: Swift.Int? = nil
    )
    {
        self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
        self.snapshotRetentionPeriod = snapshotRetentionPeriod
    }
}

public struct UpdateSnapshotCopyConfigurationOutput {
    /// The updated snapshot copy configuration object.
    /// This member is required.
    public var snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration?

    public init(
        snapshotCopyConfiguration: RedshiftServerlessClientTypes.SnapshotCopyConfiguration? = nil
    )
    {
        self.snapshotCopyConfiguration = snapshotCopyConfiguration
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The map of the key-value pairs used to tag the resource.
    /// This member is required.
    public var tags: [RedshiftServerlessClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [RedshiftServerlessClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag or set of tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateCustomDomainAssociationInput {
    /// The custom domain name’s certificate Amazon resource name (ARN). This is optional.
    /// This member is required.
    public var customDomainCertificateArn: Swift.String?
    /// The custom domain name associated with the workgroup.
    /// This member is required.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct UpdateCustomDomainAssociationOutput {
    /// The custom domain name’s certificate Amazon resource name (ARN).
    public var customDomainCertificateArn: Swift.String?
    /// The expiration time for the certificate.
    public var customDomainCertificateExpiryTime: Foundation.Date?
    /// The custom domain name associated with the workgroup.
    public var customDomainName: Swift.String?
    /// The name of the workgroup associated with the database.
    public var workgroupName: Swift.String?

    public init(
        customDomainCertificateArn: Swift.String? = nil,
        customDomainCertificateExpiryTime: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.customDomainCertificateArn = customDomainCertificateArn
        self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
        self.customDomainName = customDomainName
        self.workgroupName = workgroupName
    }
}

public struct UpdateUsageLimitInput {
    /// The new limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
    public var amount: Swift.Int?
    /// The new action that Amazon Redshift Serverless takes when the limit is reached.
    public var breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction?
    /// The identifier of the usage limit to update.
    /// This member is required.
    public var usageLimitId: Swift.String?

    public init(
        amount: Swift.Int? = nil,
        breachAction: RedshiftServerlessClientTypes.UsageLimitBreachAction? = nil,
        usageLimitId: Swift.String? = nil
    )
    {
        self.amount = amount
        self.breachAction = breachAction
        self.usageLimitId = usageLimitId
    }
}

public struct UpdateUsageLimitOutput {
    /// The updated usage limit object.
    public var usageLimit: RedshiftServerlessClientTypes.UsageLimit?

    public init(
        usageLimit: RedshiftServerlessClientTypes.UsageLimit? = nil
    )
    {
        self.usageLimit = usageLimit
    }
}

public struct UpdateWorkgroupInput {
    /// The new base data warehouse capacity in Redshift Processing Units (RPUs).
    public var baseCapacity: Swift.Int?
    /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see [ Query monitoring metrics for Amazon Redshift Serverless](https://docs.aws.amazon.com/redshift/latest/dg/cm-c-wlm-query-monitoring-rules.html#cm-c-wlm-query-monitoring-metrics-serverless).
    public var configParameters: [RedshiftServerlessClientTypes.ConfigParameter]?
    /// The value that specifies whether to turn on enhanced virtual private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
    public var enhancedVpcRouting: Swift.Bool?
    /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
    public var maxCapacity: Swift.Int?
    /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
    public var port: Swift.Int?
    /// A value that specifies whether the workgroup can be accessible from a public network.
    public var publiclyAccessible: Swift.Bool?
    /// An array of security group IDs to associate with the workgroup.
    public var securityGroupIds: [Swift.String]?
    /// An array of VPC subnet IDs to associate with the workgroup.
    public var subnetIds: [Swift.String]?
    /// The name of the workgroup to update. You can't update the name of a workgroup once it is created.
    /// This member is required.
    public var workgroupName: Swift.String?

    public init(
        baseCapacity: Swift.Int? = nil,
        configParameters: [RedshiftServerlessClientTypes.ConfigParameter]? = nil,
        enhancedVpcRouting: Swift.Bool? = nil,
        maxCapacity: Swift.Int? = nil,
        port: Swift.Int? = nil,
        publiclyAccessible: Swift.Bool? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        workgroupName: Swift.String? = nil
    )
    {
        self.baseCapacity = baseCapacity
        self.configParameters = configParameters
        self.enhancedVpcRouting = enhancedVpcRouting
        self.maxCapacity = maxCapacity
        self.port = port
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.workgroupName = workgroupName
    }
}

public struct UpdateWorkgroupOutput {
    /// The updated workgroup object.
    /// This member is required.
    public var workgroup: RedshiftServerlessClientTypes.Workgroup?

    public init(
        workgroup: RedshiftServerlessClientTypes.Workgroup? = nil
    )
    {
        self.workgroup = workgroup
    }
}

extension ConvertRecoveryPointToSnapshotInput {

    static func urlPathProvider(_ value: ConvertRecoveryPointToSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCustomDomainAssociationInput {

    static func urlPathProvider(_ value: CreateCustomDomainAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEndpointAccessInput {

    static func urlPathProvider(_ value: CreateEndpointAccessInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNamespaceInput {

    static func urlPathProvider(_ value: CreateNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateScheduledActionInput {

    static func urlPathProvider(_ value: CreateScheduledActionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSnapshotInput {

    static func urlPathProvider(_ value: CreateSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSnapshotCopyConfigurationInput {

    static func urlPathProvider(_ value: CreateSnapshotCopyConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUsageLimitInput {

    static func urlPathProvider(_ value: CreateUsageLimitInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkgroupInput {

    static func urlPathProvider(_ value: CreateWorkgroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCustomDomainAssociationInput {

    static func urlPathProvider(_ value: DeleteCustomDomainAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEndpointAccessInput {

    static func urlPathProvider(_ value: DeleteEndpointAccessInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteScheduledActionInput {

    static func urlPathProvider(_ value: DeleteScheduledActionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSnapshotInput {

    static func urlPathProvider(_ value: DeleteSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSnapshotCopyConfigurationInput {

    static func urlPathProvider(_ value: DeleteSnapshotCopyConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUsageLimitInput {

    static func urlPathProvider(_ value: DeleteUsageLimitInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkgroupInput {

    static func urlPathProvider(_ value: DeleteWorkgroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetCredentialsInput {

    static func urlPathProvider(_ value: GetCredentialsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCustomDomainAssociationInput {

    static func urlPathProvider(_ value: GetCustomDomainAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension GetEndpointAccessInput {

    static func urlPathProvider(_ value: GetEndpointAccessInput) -> Swift.String? {
        return "/"
    }
}

extension GetNamespaceInput {

    static func urlPathProvider(_ value: GetNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension GetRecoveryPointInput {

    static func urlPathProvider(_ value: GetRecoveryPointInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetScheduledActionInput {

    static func urlPathProvider(_ value: GetScheduledActionInput) -> Swift.String? {
        return "/"
    }
}

extension GetSnapshotInput {

    static func urlPathProvider(_ value: GetSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension GetTableRestoreStatusInput {

    static func urlPathProvider(_ value: GetTableRestoreStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetUsageLimitInput {

    static func urlPathProvider(_ value: GetUsageLimitInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkgroupInput {

    static func urlPathProvider(_ value: GetWorkgroupInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomDomainAssociationsInput {

    static func urlPathProvider(_ value: ListCustomDomainAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEndpointAccessInput {

    static func urlPathProvider(_ value: ListEndpointAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ListNamespacesInput {

    static func urlPathProvider(_ value: ListNamespacesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecoveryPointsInput {

    static func urlPathProvider(_ value: ListRecoveryPointsInput) -> Swift.String? {
        return "/"
    }
}

extension ListScheduledActionsInput {

    static func urlPathProvider(_ value: ListScheduledActionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSnapshotCopyConfigurationsInput {

    static func urlPathProvider(_ value: ListSnapshotCopyConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSnapshotsInput {

    static func urlPathProvider(_ value: ListSnapshotsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTableRestoreStatusInput {

    static func urlPathProvider(_ value: ListTableRestoreStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsageLimitsInput {

    static func urlPathProvider(_ value: ListUsageLimitsInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkgroupsInput {

    static func urlPathProvider(_ value: ListWorkgroupsInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreFromRecoveryPointInput {

    static func urlPathProvider(_ value: RestoreFromRecoveryPointInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreFromSnapshotInput {

    static func urlPathProvider(_ value: RestoreFromSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreTableFromRecoveryPointInput {

    static func urlPathProvider(_ value: RestoreTableFromRecoveryPointInput) -> Swift.String? {
        return "/"
    }
}

extension RestoreTableFromSnapshotInput {

    static func urlPathProvider(_ value: RestoreTableFromSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCustomDomainAssociationInput {

    static func urlPathProvider(_ value: UpdateCustomDomainAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEndpointAccessInput {

    static func urlPathProvider(_ value: UpdateEndpointAccessInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNamespaceInput {

    static func urlPathProvider(_ value: UpdateNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateScheduledActionInput {

    static func urlPathProvider(_ value: UpdateScheduledActionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSnapshotInput {

    static func urlPathProvider(_ value: UpdateSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSnapshotCopyConfigurationInput {

    static func urlPathProvider(_ value: UpdateSnapshotCopyConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUsageLimitInput {

    static func urlPathProvider(_ value: UpdateUsageLimitInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkgroupInput {

    static func urlPathProvider(_ value: UpdateWorkgroupInput) -> Swift.String? {
        return "/"
    }
}

extension ConvertRecoveryPointToSnapshotInput {

    static func write(value: ConvertRecoveryPointToSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recoveryPointId"].write(value.recoveryPointId)
        try writer["retentionPeriod"].write(value.retentionPeriod)
        try writer["snapshotName"].write(value.snapshotName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCustomDomainAssociationInput {

    static func write(value: CreateCustomDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainCertificateArn"].write(value.customDomainCertificateArn)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension CreateEndpointAccessInput {

    static func write(value: CreateEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpointName"].write(value.endpointName)
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension CreateNamespaceInput {

    static func write(value: CreateNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminPasswordSecretKmsKeyId"].write(value.adminPasswordSecretKmsKeyId)
        try writer["adminUserPassword"].write(value.adminUserPassword)
        try writer["adminUsername"].write(value.adminUsername)
        try writer["dbName"].write(value.dbName)
        try writer["defaultIamRoleArn"].write(value.defaultIamRoleArn)
        try writer["iamRoles"].writeList(value.iamRoles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["logExports"].writeList(value.logExports, memberWritingClosure: SmithyReadWrite.WritingClosureBox<RedshiftServerlessClientTypes.LogExport>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAdminPassword"].write(value.manageAdminPassword)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["redshiftIdcApplicationArn"].write(value.redshiftIdcApplicationArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateScheduledActionInput {

    static func write(value: CreateScheduledActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["roleArn"].write(value.roleArn)
        try writer["schedule"].write(value.schedule, with: RedshiftServerlessClientTypes.Schedule.write(value:to:))
        try writer["scheduledActionDescription"].write(value.scheduledActionDescription)
        try writer["scheduledActionName"].write(value.scheduledActionName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["targetAction"].write(value.targetAction, with: RedshiftServerlessClientTypes.TargetAction.write(value:to:))
    }
}

extension CreateSnapshotInput {

    static func write(value: CreateSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
        try writer["retentionPeriod"].write(value.retentionPeriod)
        try writer["snapshotName"].write(value.snapshotName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSnapshotCopyConfigurationInput {

    static func write(value: CreateSnapshotCopyConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationKmsKeyId"].write(value.destinationKmsKeyId)
        try writer["destinationRegion"].write(value.destinationRegion)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["snapshotRetentionPeriod"].write(value.snapshotRetentionPeriod)
    }
}

extension CreateUsageLimitInput {

    static func write(value: CreateUsageLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amount"].write(value.amount)
        try writer["breachAction"].write(value.breachAction)
        try writer["period"].write(value.period)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["usageType"].write(value.usageType)
    }
}

extension CreateWorkgroupInput {

    static func write(value: CreateWorkgroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseCapacity"].write(value.baseCapacity)
        try writer["configParameters"].writeList(value.configParameters, memberWritingClosure: RedshiftServerlessClientTypes.ConfigParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enhancedVpcRouting"].write(value.enhancedVpcRouting)
        try writer["maxCapacity"].write(value.maxCapacity)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["port"].write(value.port)
        try writer["publiclyAccessible"].write(value.publiclyAccessible)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension DeleteCustomDomainAssociationInput {

    static func write(value: DeleteCustomDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainName"].write(value.customDomainName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension DeleteEndpointAccessInput {

    static func write(value: DeleteEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpointName"].write(value.endpointName)
    }
}

extension DeleteNamespaceInput {

    static func write(value: DeleteNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["finalSnapshotName"].write(value.finalSnapshotName)
        try writer["finalSnapshotRetentionPeriod"].write(value.finalSnapshotRetentionPeriod)
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension DeleteScheduledActionInput {

    static func write(value: DeleteScheduledActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scheduledActionName"].write(value.scheduledActionName)
    }
}

extension DeleteSnapshotInput {

    static func write(value: DeleteSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["snapshotName"].write(value.snapshotName)
    }
}

extension DeleteSnapshotCopyConfigurationInput {

    static func write(value: DeleteSnapshotCopyConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["snapshotCopyConfigurationId"].write(value.snapshotCopyConfigurationId)
    }
}

extension DeleteUsageLimitInput {

    static func write(value: DeleteUsageLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["usageLimitId"].write(value.usageLimitId)
    }
}

extension DeleteWorkgroupInput {

    static func write(value: DeleteWorkgroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension GetCredentialsInput {

    static func write(value: GetCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainName"].write(value.customDomainName)
        try writer["dbName"].write(value.dbName)
        try writer["durationSeconds"].write(value.durationSeconds)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension GetCustomDomainAssociationInput {

    static func write(value: GetCustomDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainName"].write(value.customDomainName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension GetEndpointAccessInput {

    static func write(value: GetEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpointName"].write(value.endpointName)
    }
}

extension GetNamespaceInput {

    static func write(value: GetNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension GetRecoveryPointInput {

    static func write(value: GetRecoveryPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recoveryPointId"].write(value.recoveryPointId)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension GetScheduledActionInput {

    static func write(value: GetScheduledActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scheduledActionName"].write(value.scheduledActionName)
    }
}

extension GetSnapshotInput {

    static func write(value: GetSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["snapshotArn"].write(value.snapshotArn)
        try writer["snapshotName"].write(value.snapshotName)
    }
}

extension GetTableRestoreStatusInput {

    static func write(value: GetTableRestoreStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tableRestoreRequestId"].write(value.tableRestoreRequestId)
    }
}

extension GetUsageLimitInput {

    static func write(value: GetUsageLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["usageLimitId"].write(value.usageLimitId)
    }
}

extension GetWorkgroupInput {

    static func write(value: GetWorkgroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension ListCustomDomainAssociationsInput {

    static func write(value: ListCustomDomainAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainCertificateArn"].write(value.customDomainCertificateArn)
        try writer["customDomainName"].write(value.customDomainName)
    }
}

extension ListEndpointAccessInput {

    static func write(value: ListEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["vpcId"].write(value.vpcId)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension ListNamespacesInput {

    static func write(value: ListNamespacesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListRecoveryPointsInput {

    static func write(value: ListRecoveryPointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["namespaceArn"].write(value.namespaceArn)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListScheduledActionsInput {

    static func write(value: ListScheduledActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension ListSnapshotCopyConfigurationsInput {

    static func write(value: ListSnapshotCopyConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension ListSnapshotsInput {

    static func write(value: ListSnapshotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["namespaceArn"].write(value.namespaceArn)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListTableRestoreStatusInput {

    static func write(value: ListTableRestoreStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListUsageLimitsInput {

    static func write(value: ListUsageLimitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["usageType"].write(value.usageType)
    }
}

extension ListWorkgroupsInput {

    static func write(value: ListWorkgroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ownerAccount"].write(value.ownerAccount)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RestoreFromRecoveryPointInput {

    static func write(value: RestoreFromRecoveryPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
        try writer["recoveryPointId"].write(value.recoveryPointId)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension RestoreFromSnapshotInput {

    static func write(value: RestoreFromSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminPasswordSecretKmsKeyId"].write(value.adminPasswordSecretKmsKeyId)
        try writer["manageAdminPassword"].write(value.manageAdminPassword)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["snapshotArn"].write(value.snapshotArn)
        try writer["snapshotName"].write(value.snapshotName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension RestoreTableFromRecoveryPointInput {

    static func write(value: RestoreTableFromRecoveryPointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activateCaseSensitiveIdentifier"].write(value.activateCaseSensitiveIdentifier)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["newTableName"].write(value.newTableName)
        try writer["recoveryPointId"].write(value.recoveryPointId)
        try writer["sourceDatabaseName"].write(value.sourceDatabaseName)
        try writer["sourceSchemaName"].write(value.sourceSchemaName)
        try writer["sourceTableName"].write(value.sourceTableName)
        try writer["targetDatabaseName"].write(value.targetDatabaseName)
        try writer["targetSchemaName"].write(value.targetSchemaName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension RestoreTableFromSnapshotInput {

    static func write(value: RestoreTableFromSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activateCaseSensitiveIdentifier"].write(value.activateCaseSensitiveIdentifier)
        try writer["namespaceName"].write(value.namespaceName)
        try writer["newTableName"].write(value.newTableName)
        try writer["snapshotName"].write(value.snapshotName)
        try writer["sourceDatabaseName"].write(value.sourceDatabaseName)
        try writer["sourceSchemaName"].write(value.sourceSchemaName)
        try writer["sourceTableName"].write(value.sourceTableName)
        try writer["targetDatabaseName"].write(value.targetDatabaseName)
        try writer["targetSchemaName"].write(value.targetSchemaName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCustomDomainAssociationInput {

    static func write(value: UpdateCustomDomainAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customDomainCertificateArn"].write(value.customDomainCertificateArn)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension UpdateEndpointAccessInput {

    static func write(value: UpdateEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpointName"].write(value.endpointName)
        try writer["vpcSecurityGroupIds"].writeList(value.vpcSecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateNamespaceInput {

    static func write(value: UpdateNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminPasswordSecretKmsKeyId"].write(value.adminPasswordSecretKmsKeyId)
        try writer["adminUserPassword"].write(value.adminUserPassword)
        try writer["adminUsername"].write(value.adminUsername)
        try writer["defaultIamRoleArn"].write(value.defaultIamRoleArn)
        try writer["iamRoles"].writeList(value.iamRoles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["logExports"].writeList(value.logExports, memberWritingClosure: SmithyReadWrite.WritingClosureBox<RedshiftServerlessClientTypes.LogExport>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["manageAdminPassword"].write(value.manageAdminPassword)
        try writer["namespaceName"].write(value.namespaceName)
    }
}

extension UpdateScheduledActionInput {

    static func write(value: UpdateScheduledActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["roleArn"].write(value.roleArn)
        try writer["schedule"].write(value.schedule, with: RedshiftServerlessClientTypes.Schedule.write(value:to:))
        try writer["scheduledActionDescription"].write(value.scheduledActionDescription)
        try writer["scheduledActionName"].write(value.scheduledActionName)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["targetAction"].write(value.targetAction, with: RedshiftServerlessClientTypes.TargetAction.write(value:to:))
    }
}

extension UpdateSnapshotInput {

    static func write(value: UpdateSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["retentionPeriod"].write(value.retentionPeriod)
        try writer["snapshotName"].write(value.snapshotName)
    }
}

extension UpdateSnapshotCopyConfigurationInput {

    static func write(value: UpdateSnapshotCopyConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["snapshotCopyConfigurationId"].write(value.snapshotCopyConfigurationId)
        try writer["snapshotRetentionPeriod"].write(value.snapshotRetentionPeriod)
    }
}

extension UpdateUsageLimitInput {

    static func write(value: UpdateUsageLimitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amount"].write(value.amount)
        try writer["breachAction"].write(value.breachAction)
        try writer["usageLimitId"].write(value.usageLimitId)
    }
}

extension UpdateWorkgroupInput {

    static func write(value: UpdateWorkgroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["baseCapacity"].write(value.baseCapacity)
        try writer["configParameters"].writeList(value.configParameters, memberWritingClosure: RedshiftServerlessClientTypes.ConfigParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["enhancedVpcRouting"].write(value.enhancedVpcRouting)
        try writer["maxCapacity"].write(value.maxCapacity)
        try writer["port"].write(value.port)
        try writer["publiclyAccessible"].write(value.publiclyAccessible)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workgroupName"].write(value.workgroupName)
    }
}

extension ConvertRecoveryPointToSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConvertRecoveryPointToSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConvertRecoveryPointToSnapshotOutput()
        value.snapshot = try reader["snapshot"].readIfPresent(with: RedshiftServerlessClientTypes.Snapshot.read(from:))
        return value
    }
}

extension CreateCustomDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomDomainAssociationOutput()
        value.customDomainCertificateArn = try reader["customDomainCertificateArn"].readIfPresent()
        value.customDomainCertificateExpiryTime = try reader["customDomainCertificateExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        return value
    }
}

extension CreateEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEndpointAccessOutput()
        value.endpoint = try reader["endpoint"].readIfPresent(with: RedshiftServerlessClientTypes.EndpointAccess.read(from:))
        return value
    }
}

extension CreateNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        return value
    }
}

extension CreateScheduledActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScheduledActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScheduledActionOutput()
        value.scheduledAction = try reader["scheduledAction"].readIfPresent(with: RedshiftServerlessClientTypes.ScheduledActionResponse.read(from:))
        return value
    }
}

extension CreateSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSnapshotOutput()
        value.snapshot = try reader["snapshot"].readIfPresent(with: RedshiftServerlessClientTypes.Snapshot.read(from:))
        return value
    }
}

extension CreateSnapshotCopyConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSnapshotCopyConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSnapshotCopyConfigurationOutput()
        value.snapshotCopyConfiguration = try reader["snapshotCopyConfiguration"].readIfPresent(with: RedshiftServerlessClientTypes.SnapshotCopyConfiguration.read(from:))
        return value
    }
}

extension CreateUsageLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUsageLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUsageLimitOutput()
        value.usageLimit = try reader["usageLimit"].readIfPresent(with: RedshiftServerlessClientTypes.UsageLimit.read(from:))
        return value
    }
}

extension CreateWorkgroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkgroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkgroupOutput()
        value.workgroup = try reader["workgroup"].readIfPresent(with: RedshiftServerlessClientTypes.Workgroup.read(from:))
        return value
    }
}

extension DeleteCustomDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomDomainAssociationOutput {
        return DeleteCustomDomainAssociationOutput()
    }
}

extension DeleteEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEndpointAccessOutput()
        value.endpoint = try reader["endpoint"].readIfPresent(with: RedshiftServerlessClientTypes.EndpointAccess.read(from:))
        return value
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteScheduledActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteScheduledActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteScheduledActionOutput()
        value.scheduledAction = try reader["scheduledAction"].readIfPresent(with: RedshiftServerlessClientTypes.ScheduledActionResponse.read(from:))
        return value
    }
}

extension DeleteSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSnapshotOutput()
        value.snapshot = try reader["snapshot"].readIfPresent(with: RedshiftServerlessClientTypes.Snapshot.read(from:))
        return value
    }
}

extension DeleteSnapshotCopyConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSnapshotCopyConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSnapshotCopyConfigurationOutput()
        value.snapshotCopyConfiguration = try reader["snapshotCopyConfiguration"].readIfPresent(with: RedshiftServerlessClientTypes.SnapshotCopyConfiguration.read(from:))
        return value
    }
}

extension DeleteUsageLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUsageLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUsageLimitOutput()
        value.usageLimit = try reader["usageLimit"].readIfPresent(with: RedshiftServerlessClientTypes.UsageLimit.read(from:))
        return value
    }
}

extension DeleteWorkgroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkgroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkgroupOutput()
        value.workgroup = try reader["workgroup"].readIfPresent(with: RedshiftServerlessClientTypes.Workgroup.read(from:))
        return value
    }
}

extension GetCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCredentialsOutput()
        value.dbPassword = try reader["dbPassword"].readIfPresent()
        value.dbUser = try reader["dbUser"].readIfPresent()
        value.expiration = try reader["expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextRefreshTime = try reader["nextRefreshTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetCustomDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCustomDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCustomDomainAssociationOutput()
        value.customDomainCertificateArn = try reader["customDomainCertificateArn"].readIfPresent()
        value.customDomainCertificateExpiryTime = try reader["customDomainCertificateExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        return value
    }
}

extension GetEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEndpointAccessOutput()
        value.endpoint = try reader["endpoint"].readIfPresent(with: RedshiftServerlessClientTypes.EndpointAccess.read(from:))
        return value
    }
}

extension GetNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        return value
    }
}

extension GetRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecoveryPointOutput()
        value.recoveryPoint = try reader["recoveryPoint"].readIfPresent(with: RedshiftServerlessClientTypes.RecoveryPoint.read(from:))
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent(with: RedshiftServerlessClientTypes.ResourcePolicy.read(from:))
        return value
    }
}

extension GetScheduledActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetScheduledActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetScheduledActionOutput()
        value.scheduledAction = try reader["scheduledAction"].readIfPresent(with: RedshiftServerlessClientTypes.ScheduledActionResponse.read(from:))
        return value
    }
}

extension GetSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSnapshotOutput()
        value.snapshot = try reader["snapshot"].readIfPresent(with: RedshiftServerlessClientTypes.Snapshot.read(from:))
        return value
    }
}

extension GetTableRestoreStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableRestoreStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableRestoreStatusOutput()
        value.tableRestoreStatus = try reader["tableRestoreStatus"].readIfPresent(with: RedshiftServerlessClientTypes.TableRestoreStatus.read(from:))
        return value
    }
}

extension GetUsageLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsageLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsageLimitOutput()
        value.usageLimit = try reader["usageLimit"].readIfPresent(with: RedshiftServerlessClientTypes.UsageLimit.read(from:))
        return value
    }
}

extension GetWorkgroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkgroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkgroupOutput()
        value.workgroup = try reader["workgroup"].readIfPresent(with: RedshiftServerlessClientTypes.Workgroup.read(from:))
        return value
    }
}

extension ListCustomDomainAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomDomainAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomDomainAssociationsOutput()
        value.associations = try reader["associations"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Association.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEndpointAccessOutput()
        value.endpoints = try reader["endpoints"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.EndpointAccess.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamespacesOutput()
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Namespace.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRecoveryPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecoveryPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecoveryPointsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recoveryPoints = try reader["recoveryPoints"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.RecoveryPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListScheduledActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScheduledActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScheduledActionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.scheduledActions = try reader["scheduledActions"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.ScheduledActionAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSnapshotCopyConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSnapshotCopyConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSnapshotCopyConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.snapshotCopyConfigurations = try reader["snapshotCopyConfigurations"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.SnapshotCopyConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSnapshotsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.snapshots = try reader["snapshots"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Snapshot.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTableRestoreStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTableRestoreStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableRestoreStatusOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tableRestoreStatuses = try reader["tableRestoreStatuses"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.TableRestoreStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsageLimitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsageLimitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsageLimitsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.usageLimits = try reader["usageLimits"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.UsageLimit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkgroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkgroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkgroupsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workgroups = try reader["workgroups"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Workgroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent(with: RedshiftServerlessClientTypes.ResourcePolicy.read(from:))
        return value
    }
}

extension RestoreFromRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreFromRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreFromRecoveryPointOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        value.recoveryPointId = try reader["recoveryPointId"].readIfPresent()
        return value
    }
}

extension RestoreFromSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreFromSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreFromSnapshotOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.snapshotName = try reader["snapshotName"].readIfPresent()
        return value
    }
}

extension RestoreTableFromRecoveryPointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreTableFromRecoveryPointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreTableFromRecoveryPointOutput()
        value.tableRestoreStatus = try reader["tableRestoreStatus"].readIfPresent(with: RedshiftServerlessClientTypes.TableRestoreStatus.read(from:))
        return value
    }
}

extension RestoreTableFromSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreTableFromSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreTableFromSnapshotOutput()
        value.tableRestoreStatus = try reader["tableRestoreStatus"].readIfPresent(with: RedshiftServerlessClientTypes.TableRestoreStatus.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCustomDomainAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCustomDomainAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCustomDomainAssociationOutput()
        value.customDomainCertificateArn = try reader["customDomainCertificateArn"].readIfPresent()
        value.customDomainCertificateExpiryTime = try reader["customDomainCertificateExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        return value
    }
}

extension UpdateEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEndpointAccessOutput()
        value.endpoint = try reader["endpoint"].readIfPresent(with: RedshiftServerlessClientTypes.EndpointAccess.read(from:))
        return value
    }
}

extension UpdateNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: RedshiftServerlessClientTypes.Namespace.read(from:))
        return value
    }
}

extension UpdateScheduledActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScheduledActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateScheduledActionOutput()
        value.scheduledAction = try reader["scheduledAction"].readIfPresent(with: RedshiftServerlessClientTypes.ScheduledActionResponse.read(from:))
        return value
    }
}

extension UpdateSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSnapshotOutput()
        value.snapshot = try reader["snapshot"].readIfPresent(with: RedshiftServerlessClientTypes.Snapshot.read(from:))
        return value
    }
}

extension UpdateSnapshotCopyConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSnapshotCopyConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSnapshotCopyConfigurationOutput()
        value.snapshotCopyConfiguration = try reader["snapshotCopyConfiguration"].readIfPresent(with: RedshiftServerlessClientTypes.SnapshotCopyConfiguration.read(from:))
        return value
    }
}

extension UpdateUsageLimitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUsageLimitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUsageLimitOutput()
        value.usageLimit = try reader["usageLimit"].readIfPresent(with: RedshiftServerlessClientTypes.UsageLimit.read(from:))
        return value
    }
}

extension UpdateWorkgroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkgroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkgroupOutput()
        value.workgroup = try reader["workgroup"].readIfPresent(with: RedshiftServerlessClientTypes.Workgroup.read(from:))
        return value
    }
}

enum ConvertRecoveryPointToSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScheduledActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSnapshotCopyConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUsageLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkgroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientCapacityException": return try InsufficientCapacityException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteScheduledActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSnapshotCopyConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUsageLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkgroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCustomDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetScheduledActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableRestoreStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsageLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkgroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomDomainAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidPaginationException": return try InvalidPaginationException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecoveryPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScheduledActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidPaginationException": return try InvalidPaginationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSnapshotCopyConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidPaginationException": return try InvalidPaginationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTableRestoreStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationException": return try InvalidPaginationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsageLimitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidPaginationException": return try InvalidPaginationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkgroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreFromRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreFromSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreTableFromRecoveryPointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreTableFromSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCustomDomainAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScheduledActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSnapshotCopyConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUsageLimitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkgroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InsufficientCapacityException": return try InsufficientCapacityException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InsufficientCapacityException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InsufficientCapacityException {
        let reader = baseError.errorBodyReader
        var value = InsufficientCapacityException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPaginationException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RedshiftServerlessClientTypes.Snapshot {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Snapshot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Snapshot()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.snapshotName = try reader["snapshotName"].readIfPresent()
        value.snapshotCreateTime = try reader["snapshotCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.adminUsername = try reader["adminUsername"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.totalBackupSizeInMegaBytes = try reader["totalBackupSizeInMegaBytes"].readIfPresent()
        value.actualIncrementalBackupSizeInMegaBytes = try reader["actualIncrementalBackupSizeInMegaBytes"].readIfPresent()
        value.backupProgressInMegaBytes = try reader["backupProgressInMegaBytes"].readIfPresent()
        value.currentBackupRateInMegaBytesPerSecond = try reader["currentBackupRateInMegaBytesPerSecond"].readIfPresent()
        value.estimatedSecondsToCompletion = try reader["estimatedSecondsToCompletion"].readIfPresent()
        value.elapsedTimeInSeconds = try reader["elapsedTimeInSeconds"].readIfPresent()
        value.snapshotRetentionPeriod = try reader["snapshotRetentionPeriod"].readIfPresent()
        value.snapshotRemainingDays = try reader["snapshotRemainingDays"].readIfPresent()
        value.snapshotRetentionStartTime = try reader["snapshotRetentionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.snapshotArn = try reader["snapshotArn"].readIfPresent()
        value.accountsWithRestoreAccess = try reader["accountsWithRestoreAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.accountsWithProvisionedRestoreAccess = try reader["accountsWithProvisionedRestoreAccess"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.adminPasswordSecretArn = try reader["adminPasswordSecretArn"].readIfPresent()
        value.adminPasswordSecretKmsKeyId = try reader["adminPasswordSecretKmsKeyId"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.EndpointAccess {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.EndpointAccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.EndpointAccess()
        value.endpointName = try reader["endpointName"].readIfPresent()
        value.endpointStatus = try reader["endpointStatus"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        value.endpointCreateTime = try reader["endpointCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.port = try reader["port"].readIfPresent()
        value.address = try reader["address"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcSecurityGroups = try reader["vpcSecurityGroups"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.VpcSecurityGroupMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcEndpoint = try reader["vpcEndpoint"].readIfPresent(with: RedshiftServerlessClientTypes.VpcEndpoint.read(from:))
        value.endpointArn = try reader["endpointArn"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.VpcEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.VpcEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.VpcEndpoint()
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RedshiftServerlessClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.NetworkInterface()
        value.networkInterfaceId = try reader["networkInterfaceId"].readIfPresent()
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.VpcSecurityGroupMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.VpcSecurityGroupMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.VpcSecurityGroupMembership()
        value.vpcSecurityGroupId = try reader["vpcSecurityGroupId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.Namespace {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Namespace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Namespace()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.adminUsername = try reader["adminUsername"].readIfPresent()
        value.dbName = try reader["dbName"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.defaultIamRoleArn = try reader["defaultIamRoleArn"].readIfPresent()
        value.iamRoles = try reader["iamRoles"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.logExports = try reader["logExports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<RedshiftServerlessClientTypes.LogExport>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.adminPasswordSecretArn = try reader["adminPasswordSecretArn"].readIfPresent()
        value.adminPasswordSecretKmsKeyId = try reader["adminPasswordSecretKmsKeyId"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.ScheduledActionResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.ScheduledActionResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.ScheduledActionResponse()
        value.scheduledActionName = try reader["scheduledActionName"].readIfPresent()
        value.schedule = try reader["schedule"].readIfPresent(with: RedshiftServerlessClientTypes.Schedule.read(from:))
        value.scheduledActionDescription = try reader["scheduledActionDescription"].readIfPresent()
        value.nextInvocations = try reader["nextInvocations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.targetAction = try reader["targetAction"].readIfPresent(with: RedshiftServerlessClientTypes.TargetAction.read(from:))
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.scheduledActionUuid = try reader["scheduledActionUuid"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.TargetAction {

    static func write(value: RedshiftServerlessClientTypes.TargetAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .createsnapshot(createsnapshot):
                try writer["createSnapshot"].write(createsnapshot, with: RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.TargetAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "createSnapshot":
                return .createsnapshot(try reader["createSnapshot"].read(with: RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters {

    static func write(value: RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespaceName"].write(value.namespaceName)
        try writer["retentionPeriod"].write(value.retentionPeriod)
        try writer["snapshotNamePrefix"].write(value.snapshotNamePrefix)
        try writer["tags"].writeList(value.tags, memberWritingClosure: RedshiftServerlessClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.CreateSnapshotScheduleActionParameters()
        value.namespaceName = try reader["namespaceName"].readIfPresent() ?? ""
        value.snapshotNamePrefix = try reader["snapshotNamePrefix"].readIfPresent() ?? ""
        value.retentionPeriod = try reader["retentionPeriod"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RedshiftServerlessClientTypes.Tag {

    static func write(value: RedshiftServerlessClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension RedshiftServerlessClientTypes.Schedule {

    static func write(value: RedshiftServerlessClientTypes.Schedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .at(at):
                try writer["at"].writeTimestamp(at, format: SmithyTimestamps.TimestampFormat.epochSeconds)
            case let .cron(cron):
                try writer["cron"].write(cron)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Schedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "at":
                return .at(try reader["at"].readTimestamp(format: SmithyTimestamps.TimestampFormat.epochSeconds))
            case "cron":
                return .cron(try reader["cron"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension RedshiftServerlessClientTypes.SnapshotCopyConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.SnapshotCopyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.SnapshotCopyConfiguration()
        value.snapshotCopyConfigurationId = try reader["snapshotCopyConfigurationId"].readIfPresent()
        value.snapshotCopyConfigurationArn = try reader["snapshotCopyConfigurationArn"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.destinationRegion = try reader["destinationRegion"].readIfPresent()
        value.snapshotRetentionPeriod = try reader["snapshotRetentionPeriod"].readIfPresent()
        value.destinationKmsKeyId = try reader["destinationKmsKeyId"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.UsageLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.UsageLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.UsageLimit()
        value.usageLimitId = try reader["usageLimitId"].readIfPresent()
        value.usageLimitArn = try reader["usageLimitArn"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.usageType = try reader["usageType"].readIfPresent()
        value.amount = try reader["amount"].readIfPresent()
        value.period = try reader["period"].readIfPresent()
        value.breachAction = try reader["breachAction"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.Workgroup {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Workgroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Workgroup()
        value.workgroupId = try reader["workgroupId"].readIfPresent()
        value.workgroupArn = try reader["workgroupArn"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.baseCapacity = try reader["baseCapacity"].readIfPresent()
        value.enhancedVpcRouting = try reader["enhancedVpcRouting"].readIfPresent()
        value.configParameters = try reader["configParameters"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.ConfigParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent(with: RedshiftServerlessClientTypes.Endpoint.read(from:))
        value.publiclyAccessible = try reader["publiclyAccessible"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.port = try reader["port"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.customDomainCertificateArn = try reader["customDomainCertificateArn"].readIfPresent()
        value.customDomainCertificateExpiryTime = try reader["customDomainCertificateExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.workgroupVersion = try reader["workgroupVersion"].readIfPresent()
        value.patchVersion = try reader["patchVersion"].readIfPresent()
        value.maxCapacity = try reader["maxCapacity"].readIfPresent()
        value.crossAccountVpcs = try reader["crossAccountVpcs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RedshiftServerlessClientTypes.Endpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Endpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Endpoint()
        value.address = try reader["address"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.vpcEndpoints = try reader["vpcEndpoints"].readListIfPresent(memberReadingClosure: RedshiftServerlessClientTypes.VpcEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RedshiftServerlessClientTypes.ConfigParameter {

    static func write(value: RedshiftServerlessClientTypes.ConfigParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameterKey"].write(value.parameterKey)
        try writer["parameterValue"].write(value.parameterValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.ConfigParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.ConfigParameter()
        value.parameterKey = try reader["parameterKey"].readIfPresent()
        value.parameterValue = try reader["parameterValue"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.RecoveryPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.RecoveryPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.RecoveryPoint()
        value.recoveryPointId = try reader["recoveryPointId"].readIfPresent()
        value.recoveryPointCreateTime = try reader["recoveryPointCreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.totalSizeInMegaBytes = try reader["totalSizeInMegaBytes"].readIfPresent()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        value.namespaceArn = try reader["namespaceArn"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.ResourcePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.ResourcePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.ResourcePolicy()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.TableRestoreStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.TableRestoreStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.TableRestoreStatus()
        value.tableRestoreRequestId = try reader["tableRestoreRequestId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.requestTime = try reader["requestTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        value.snapshotName = try reader["snapshotName"].readIfPresent()
        value.progressInMegaBytes = try reader["progressInMegaBytes"].readIfPresent()
        value.totalDataInMegaBytes = try reader["totalDataInMegaBytes"].readIfPresent()
        value.sourceDatabaseName = try reader["sourceDatabaseName"].readIfPresent()
        value.sourceSchemaName = try reader["sourceSchemaName"].readIfPresent()
        value.sourceTableName = try reader["sourceTableName"].readIfPresent()
        value.targetDatabaseName = try reader["targetDatabaseName"].readIfPresent()
        value.targetSchemaName = try reader["targetSchemaName"].readIfPresent()
        value.newTableName = try reader["newTableName"].readIfPresent()
        value.recoveryPointId = try reader["recoveryPointId"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.Association {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.Association {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.Association()
        value.customDomainCertificateArn = try reader["customDomainCertificateArn"].readIfPresent()
        value.customDomainCertificateExpiryTime = try reader["customDomainCertificateExpiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.workgroupName = try reader["workgroupName"].readIfPresent()
        return value
    }
}

extension RedshiftServerlessClientTypes.ScheduledActionAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> RedshiftServerlessClientTypes.ScheduledActionAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = RedshiftServerlessClientTypes.ScheduledActionAssociation()
        value.namespaceName = try reader["namespaceName"].readIfPresent()
        value.scheduledActionName = try reader["scheduledActionName"].readIfPresent()
        return value
    }
}

public enum RedshiftServerlessClientTypes {}
