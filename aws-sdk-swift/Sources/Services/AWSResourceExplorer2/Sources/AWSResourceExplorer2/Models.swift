//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem


public struct DisassociateDefaultViewInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateDefaultViewOutput: Swift.Sendable {

    public init() { }
}

public struct GetAccountLevelServiceConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetDefaultViewInput: Swift.Sendable {

    public init() { }
}

public struct GetIndexInput: Swift.Sendable {

    public init() { }
}

/// The credentials that you used to call this operation don't have the minimum required permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because of internal service error. Try your request again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You specified a resource that doesn't exist. Check the ID or ARN that you used to identity the resource, and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because you exceeded a rate limit for this operation. For more information, see [Quotas for Resource Explorer](https://docs.aws.amazon.com/resource-explorer/latest/userguide/quotas.html).
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceExplorer2ClientTypes {

    /// A structure that describes a request field with a validation error.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The name of the request field that had a validation error.
        /// This member is required.
        public var name: Swift.String?
        /// The validation error caused by the request field.
        /// This member is required.
        public var validationIssue: Swift.String?

        public init(
            name: Swift.String? = nil,
            validationIssue: Swift.String? = nil
        )
        {
            self.name = name
            self.validationIssue = validationIssue
        }
    }
}

/// You provided an invalid value for one of the operation's parameters. Check the syntax for the operation, and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// An array of the request fields that had validation errors.
        public internal(set) var fieldList: [ResourceExplorer2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [ResourceExplorer2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

public struct AssociateDefaultViewInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view to set as the default for the Amazon Web Services Region and Amazon Web Services account in which you call this operation. The specified view must already exist in the called Region.
    /// This member is required.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

public struct AssociateDefaultViewOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that the operation set as the default for queries made in the Amazon Web Services Region and Amazon Web Services account in which you called this operation.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

extension ResourceExplorer2ClientTypes {

    public enum AWSServiceAccessStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AWSServiceAccessStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The principal making the request isn't permitted to perform the operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetViewInput: Swift.Sendable {
    /// A list of [Amazon resource names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) that identify the views you want details for.
    public var viewArns: [Swift.String]?

    public init(
        viewArns: [Swift.String]? = nil
    )
    {
        self.viewArns = viewArns
    }
}

extension ResourceExplorer2ClientTypes {

    /// A collection of error messages for any views that Amazon Web Services Resource Explorer couldn't retrieve details.
    public struct BatchGetViewError: Swift.Sendable {
        /// The description of the error for the specified view.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view for which Resource Explorer failed to retrieve details.
        /// This member is required.
        public var viewArn: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            viewArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.viewArn = viewArn
        }
    }
}

extension ResourceExplorer2ClientTypes {

    /// A search filter defines which resources can be part of a search query result set.
    public struct SearchFilter: Swift.Sendable {
        /// The string that contains the search keywords, prefixes, and operators to control the results that can be returned by a [Search] operation. For more details, see [Search query syntax](https://docs.aws.amazon.com/resource-explorer/latest/APIReference/about-query-syntax.html).
        /// This member is required.
        public var filterString: Swift.String?

        public init(
            filterString: Swift.String? = nil
        )
        {
            self.filterString = filterString
        }
    }
}

extension ResourceExplorer2ClientTypes.SearchFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension ResourceExplorer2ClientTypes {

    /// Information about an additional property that describes a resource, that you can optionally include in the view. This lets you view that property in search results, and filter your search results based on the value of the property.
    public struct IncludedProperty: Swift.Sendable {
        /// The name of the property that is included in this view. You can specify the following property names for this field:
        ///
        /// * Tags
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension ResourceExplorer2ClientTypes {

    /// A view is a structure that defines a set of filters that provide a view into the information in the Amazon Web Services Resource Explorer index. The filters specify which information from the index is visible to the users of the view. For example, you can specify filters that include only resources that are tagged with the key "ENV" and the value "DEVELOPMENT" in the results returned by this view. You could also create a second view that includes only resources that are tagged with "ENV" and "PRODUCTION".
    public struct View: Swift.Sendable {
        /// An array of [SearchFilter] objects that specify which resources can be included in the results of queries made using this view.
        public var filters: ResourceExplorer2ClientTypes.SearchFilter?
        /// A structure that contains additional information about the view.
        public var includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]?
        /// The date and time when this view was last modified.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Web Services account that owns this view.
        public var owner: Swift.String?
        /// An [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an Amazon Web Services account, an organization, or an organizational unit (OU) that specifies whether this view includes resources from only the specified Amazon Web Services account, all accounts in the specified organization, or all accounts in the specified OU. If not specified, the value defaults to the Amazon Web Services account used to call this operation.
        public var scope: Swift.String?
        /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view.
        public var viewArn: Swift.String?

        public init(
            filters: ResourceExplorer2ClientTypes.SearchFilter? = nil,
            includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            owner: Swift.String? = nil,
            scope: Swift.String? = nil,
            viewArn: Swift.String? = nil
        )
        {
            self.filters = filters
            self.includedProperties = includedProperties
            self.lastUpdatedAt = lastUpdatedAt
            self.owner = owner
            self.scope = scope
            self.viewArn = viewArn
        }
    }
}

extension ResourceExplorer2ClientTypes.View: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "View(includedProperties: \(Swift.String(describing: includedProperties)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), owner: \(Swift.String(describing: owner)), scope: \(Swift.String(describing: scope)), viewArn: \(Swift.String(describing: viewArn)), filters: \"CONTENT_REDACTED\")"}
}

public struct BatchGetViewOutput: Swift.Sendable {
    /// If any of the specified ARNs result in an error, then this structure describes the error.
    public var errors: [ResourceExplorer2ClientTypes.BatchGetViewError]?
    /// A structure with a list of objects with details for each of the specified views.
    public var views: [ResourceExplorer2ClientTypes.View]?

    public init(
        errors: [ResourceExplorer2ClientTypes.BatchGetViewError]? = nil,
        views: [ResourceExplorer2ClientTypes.View]? = nil
    )
    {
        self.errors = errors
        self.views = views
    }
}

/// If you attempted to create a view, then the request failed because either you specified parameters that didn’t match the original request, or you attempted to create a view with a name that already exists in this Amazon Web Services Region. If you attempted to create an index, then the request failed because either you specified parameters that didn't match the original request, or an index already exists in the current Amazon Web Services Region. If you attempted to update an index type to AGGREGATOR, then the request failed because you already have an AGGREGATOR index in a different Amazon Web Services Region.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateIndexInput: Swift.Sendable {
    /// This value helps ensure idempotency. Resource Explorer uses this value to prevent the accidental creation of duplicate versions. We recommend that you generate a [UUID-type value](https://wikipedia.org/wiki/Universally_unique_identifier) to ensure the uniqueness of your index.
    public var clientToken: Swift.String?
    /// The specified tags are attached only to the index created in this Amazon Web Services Region. The tags aren't attached to any of the resources listed in the index.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.tags = tags
    }
}

extension CreateIndexInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIndexInput(clientToken: \(Swift.String(describing: clientToken)), tags: \"CONTENT_REDACTED\")"}
}

extension ResourceExplorer2ClientTypes {

    public enum IndexState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Index is active.
        case active
        /// Resource Explorer is creating the index.
        case creating
        /// Resource Explorer successfully deleted the index.
        case deleted
        /// Resource Explorer is deleting the index.
        case deleting
        /// Resource Explorer is switching the index type between local and aggregator.
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIndexOutput: Swift.Sendable {
    /// The ARN of the new local index for the Region. You can reference this ARN in IAM permission policies to authorize the following operations: [DeleteIndex] | [GetIndex] | [UpdateIndexType] | [CreateView]
    public var arn: Swift.String?
    /// The date and timestamp when the index was created.
    public var createdAt: Foundation.Date?
    /// Indicates the current state of the index. You can check for changes to the state for asynchronous operations by calling the [GetIndex] operation. The state can remain in the CREATING or UPDATING state for several hours as Resource Explorer discovers the information about your resources and populates the index.
    public var state: ResourceExplorer2ClientTypes.IndexState?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        state: ResourceExplorer2ClientTypes.IndexState? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.state = state
    }
}

public struct DeleteIndexInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index that you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteIndexOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index that you successfully started the deletion process. This operation is asynchronous. To check its status, call the [GetIndex] operation.
    public var arn: Swift.String?
    /// The date and time when you last updated this index.
    public var lastUpdatedAt: Foundation.Date?
    /// Indicates the current state of the index.
    public var state: ResourceExplorer2ClientTypes.IndexState?

    public init(
        arn: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        state: ResourceExplorer2ClientTypes.IndexState? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.state = state
    }
}

extension ResourceExplorer2ClientTypes {

    public enum IndexType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// aggregator index
        case aggregator
        /// local index
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [IndexType] {
            return [
                .aggregator,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregator: return "AGGREGATOR"
            case .local: return "LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListIndexesInput: Swift.Sendable {
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// If specified, limits the response to only information about the index in the specified list of Amazon Web Services Regions.
    public var regions: [Swift.String]?
    /// If specified, limits the output to only indexes of the specified Type, either LOCAL or AGGREGATOR. Use this option to discover the aggregator index for your account.
    public var type: ResourceExplorer2ClientTypes.IndexType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        type: ResourceExplorer2ClientTypes.IndexType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regions = regions
        self.type = type
    }
}

extension ResourceExplorer2ClientTypes {

    /// An index is the data store used by Amazon Web Services Resource Explorer to hold information about your Amazon Web Services resources that the service discovers. Creating an index in an Amazon Web Services Region turns on Resource Explorer and lets it discover your resources. By default, an index is local, meaning that it contains information about resources in only the same Region as the index. However, you can promote the index of one Region in the account by calling [UpdateIndexType] to convert it into an aggregator index. The aggregator index receives a replicated copy of the index information from all other Regions where Resource Explorer is turned on. This allows search operations in that Region to return results from all Regions in the account.
    public struct Index: Swift.Sendable {
        /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index.
        public var arn: Swift.String?
        /// The Amazon Web Services Region in which the index exists.
        public var region: Swift.String?
        /// The type of index. It can be one of the following values:
        ///
        /// * LOCAL – The index contains information about resources from only the same Amazon Web Services Region.
        ///
        /// * AGGREGATOR – Resource Explorer replicates copies of the indexed information about resources in all other Amazon Web Services Regions to the aggregator index. This lets search results in the Region with the aggregator index to include resources from all Regions in the account where Resource Explorer is turned on.
        public var type: ResourceExplorer2ClientTypes.IndexType?

        public init(
            arn: Swift.String? = nil,
            region: Swift.String? = nil,
            type: ResourceExplorer2ClientTypes.IndexType? = nil
        )
        {
            self.arn = arn
            self.region = region
            self.type = type
        }
    }
}

public struct ListIndexesOutput: Swift.Sendable {
    /// A structure that contains the details and status of each index.
    public var indexes: [ResourceExplorer2ClientTypes.Index]?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        indexes: [ResourceExplorer2ClientTypes.Index]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexes = indexes
        self.nextToken = nextToken
    }
}

/// The request failed because it exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the service quota that was exceeded by the request.
        /// This member is required.
        public internal(set) var name: Swift.String? = nil
        /// The current value for the quota that the request tried to exceed.
        /// This member is required.
        public internal(set) var value: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        name: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.name = name
        self.properties.value = value
    }
}

public struct UpdateIndexTypeInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index that you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The type of the index. To understand the difference between LOCAL and AGGREGATOR, see [Turning on cross-Region search](https://docs.aws.amazon.com/resource-explorer/latest/userguide/manage-aggregator-region.html) in the Amazon Web Services Resource Explorer User Guide.
    /// This member is required.
    public var type: ResourceExplorer2ClientTypes.IndexType?

    public init(
        arn: Swift.String? = nil,
        type: ResourceExplorer2ClientTypes.IndexType? = nil
    )
    {
        self.arn = arn
        self.type = type
    }
}

public struct UpdateIndexTypeOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index that you updated.
    public var arn: Swift.String?
    /// The date and timestamp when the index was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// Indicates the state of the request to update the index. This operation is asynchronous. Call the [GetIndex] operation to check for changes.
    public var state: ResourceExplorer2ClientTypes.IndexState?
    /// Specifies the type of the specified index after the operation completes.
    public var type: ResourceExplorer2ClientTypes.IndexType?

    public init(
        arn: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        state: ResourceExplorer2ClientTypes.IndexState? = nil,
        type: ResourceExplorer2ClientTypes.IndexType? = nil
    )
    {
        self.arn = arn
        self.lastUpdatedAt = lastUpdatedAt
        self.state = state
        self.type = type
    }
}

public struct CreateViewInput: Swift.Sendable {
    /// This value helps ensure idempotency. Resource Explorer uses this value to prevent the accidental creation of duplicate versions. We recommend that you generate a [UUID-type value](https://wikipedia.org/wiki/Universally_unique_identifier) to ensure the uniqueness of your views.
    public var clientToken: Swift.String?
    /// An array of strings that specify which resources are included in the results of queries made using this view. When you use this view in a [Search] operation, the filter string is combined with the search's QueryString parameter using a logical AND operator. For information about the supported syntax, see [Search query reference for Resource Explorer](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html) in the Amazon Web Services Resource Explorer User Guide. This query string in the context of this operation supports only [filter prefixes](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html#query-syntax-filters) with optional [operators](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html#query-syntax-operators). It doesn't support free-form text. For example, the string region:us* service:ec2 -tag:stage=prod includes all Amazon EC2 resources in any Amazon Web Services Region that begins with the letters us and is not tagged with a key Stage that has the value prod.
    public var filters: ResourceExplorer2ClientTypes.SearchFilter?
    /// Specifies optional fields that you want included in search results from this view. It is a list of objects that each describe a field to include. The default is an empty list, with no optional fields included in the results.
    public var includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]?
    /// The root ARN of the account, an organizational unit (OU), or an organization ARN. If left empty, the default is account.
    public var scope: Swift.String?
    /// Tag key and value pairs that are attached to the view.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the new view. This name appears in the list of views in Resource Explorer. The name must be no more than 64 characters long, and can include letters, digits, and the dash (-) character. The name must be unique within its Amazon Web Services Region.
    /// This member is required.
    public var viewName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        filters: ResourceExplorer2ClientTypes.SearchFilter? = nil,
        includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]? = nil,
        scope: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        viewName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.filters = filters
        self.includedProperties = includedProperties
        self.scope = scope
        self.tags = tags
        self.viewName = viewName
    }
}

extension CreateViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateViewInput(clientToken: \(Swift.String(describing: clientToken)), includedProperties: \(Swift.String(describing: includedProperties)), scope: \(Swift.String(describing: scope)), viewName: \(Swift.String(describing: viewName)), filters: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateViewOutput: Swift.Sendable {
    /// A structure that contains the details about the new view.
    public var view: ResourceExplorer2ClientTypes.View?

    public init(
        view: ResourceExplorer2ClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

public struct DeleteViewInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that you want to delete.
    /// This member is required.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

public struct DeleteViewOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that you successfully deleted.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

public struct GetViewInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that you want information about.
    /// This member is required.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

public struct GetViewOutput: Swift.Sendable {
    /// Tag key and value pairs that are attached to the view.
    public var tags: [Swift.String: Swift.String]?
    /// A structure that contains the details for the requested view.
    public var view: ResourceExplorer2ClientTypes.View?

    public init(
        tags: [Swift.String: Swift.String]? = nil,
        view: ResourceExplorer2ClientTypes.View? = nil
    )
    {
        self.tags = tags
        self.view = view
    }
}

extension GetViewOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetViewOutput(view: \(Swift.String(describing: view)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListViewsInput: Swift.Sendable {
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListViewsOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The list of views available in the Amazon Web Services Region in which you called this operation.
    public var views: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        views: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.views = views
    }
}

public struct UpdateViewInput: Swift.Sendable {
    /// An array of strings that specify which resources are included in the results of queries made using this view. When you use this view in a [Search] operation, the filter string is combined with the search's QueryString parameter using a logical AND operator. For information about the supported syntax, see [Search query reference for Resource Explorer](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html) in the Amazon Web Services Resource Explorer User Guide. This query string in the context of this operation supports only [filter prefixes](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html#query-syntax-filters) with optional [operators](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html#query-syntax-operators). It doesn't support free-form text. For example, the string region:us* service:ec2 -tag:stage=prod includes all Amazon EC2 resources in any Amazon Web Services Region that begins with the letters us and is not tagged with a key Stage that has the value prod.
    public var filters: ResourceExplorer2ClientTypes.SearchFilter?
    /// Specifies optional fields that you want included in search results from this view. It is a list of objects that each describe a field to include. The default is an empty list, with no optional fields included in the results.
    public var includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]?
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that you want to modify.
    /// This member is required.
    public var viewArn: Swift.String?

    public init(
        filters: ResourceExplorer2ClientTypes.SearchFilter? = nil,
        includedProperties: [ResourceExplorer2ClientTypes.IncludedProperty]? = nil,
        viewArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.includedProperties = includedProperties
        self.viewArn = viewArn
    }
}

extension UpdateViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateViewInput(includedProperties: \(Swift.String(describing: includedProperties)), viewArn: \(Swift.String(describing: viewArn)), filters: \"CONTENT_REDACTED\")"}
}

public struct UpdateViewOutput: Swift.Sendable {
    /// Details about the view that you changed with this operation.
    public var view: ResourceExplorer2ClientTypes.View?

    public init(
        view: ResourceExplorer2ClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

extension ResourceExplorer2ClientTypes {

    /// This is a structure that contains the status of Amazon Web Services service access, and whether you have a valid service-linked role to enable multi-account search for your organization.
    public struct OrgConfiguration: Swift.Sendable {
        /// This value displays whether your Amazon Web Services service access is ENABLED or DISABLED.
        /// This member is required.
        public var awsServiceAccessStatus: ResourceExplorer2ClientTypes.AWSServiceAccessStatus?
        /// This value shows whether or not you have a valid a service-linked role required to start the multi-account search feature.
        public var serviceLinkedRole: Swift.String?

        public init(
            awsServiceAccessStatus: ResourceExplorer2ClientTypes.AWSServiceAccessStatus? = nil,
            serviceLinkedRole: Swift.String? = nil
        )
        {
            self.awsServiceAccessStatus = awsServiceAccessStatus
            self.serviceLinkedRole = serviceLinkedRole
        }
    }
}

public struct GetAccountLevelServiceConfigurationOutput: Swift.Sendable {
    /// Details about the organization, and whether configuration is ENABLED or DISABLED.
    public var orgConfiguration: ResourceExplorer2ClientTypes.OrgConfiguration?

    public init(
        orgConfiguration: ResourceExplorer2ClientTypes.OrgConfiguration? = nil
    )
    {
        self.orgConfiguration = orgConfiguration
    }
}

public struct GetDefaultViewOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that is the current default for the Amazon Web Services Region in which you called this operation.
    public var viewArn: Swift.String?

    public init(
        viewArn: Swift.String? = nil
    )
    {
        self.viewArn = viewArn
    }
}

public struct GetIndexOutput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index.
    public var arn: Swift.String?
    /// The date and time when the index was originally created.
    public var createdAt: Foundation.Date?
    /// The date and time when the index was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// This response value is present only if this index is Type=AGGREGATOR. A list of the Amazon Web Services Regions that replicate their content to the index in this Region.
    public var replicatingFrom: [Swift.String]?
    /// This response value is present only if this index is Type=LOCAL. The Amazon Web Services Region that contains the aggregator index, if one exists. If an aggregator index does exist then the Region in which you called this operation replicates its index information to the Region specified in this response value.
    public var replicatingTo: [Swift.String]?
    /// The current state of the index in this Amazon Web Services Region.
    public var state: ResourceExplorer2ClientTypes.IndexState?
    /// Tag key and value pairs that are attached to the index.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the index in this Region. For information about the aggregator index and how it differs from a local index, see [Turning on cross-Region search by creating an aggregator index](https://docs.aws.amazon.com/resource-explorer/latest/userguide/manage-aggregator-region.html).
    public var type: ResourceExplorer2ClientTypes.IndexType?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        replicatingFrom: [Swift.String]? = nil,
        replicatingTo: [Swift.String]? = nil,
        state: ResourceExplorer2ClientTypes.IndexState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: ResourceExplorer2ClientTypes.IndexType? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.replicatingFrom = replicatingFrom
        self.replicatingTo = replicatingTo
        self.state = state
        self.tags = tags
        self.type = type
    }
}

extension GetIndexOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIndexOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), replicatingFrom: \(Swift.String(describing: replicatingFrom)), replicatingTo: \(Swift.String(describing: replicatingTo)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)), tags: \"CONTENT_REDACTED\")"}
}

public struct ListIndexesForMembersInput: Swift.Sendable {
    /// The account IDs will limit the output to only indexes from these accounts.
    /// This member is required.
    public var accountIdList: [Swift.String]?
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        accountIdList: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIdList = accountIdList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ResourceExplorer2ClientTypes {

    /// An index is the data store used by Amazon Web Services Resource Explorer to hold information about your Amazon Web Services resources that the service discovers.
    public struct MemberIndex: Swift.Sendable {
        /// The account ID for the index.
        public var accountId: Swift.String?
        /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the index.
        public var arn: Swift.String?
        /// The Amazon Web Services Region in which the index exists.
        public var region: Swift.String?
        /// The type of index. It can be one of the following values:
        ///
        /// * LOCAL – The index contains information about resources from only the same Amazon Web Services Region.
        ///
        /// * AGGREGATOR – Resource Explorer replicates copies of the indexed information about resources in all other Amazon Web Services Regions to the aggregator index. This lets search results in the Region with the aggregator index to include resources from all Regions in the account where Resource Explorer is turned on.
        public var type: ResourceExplorer2ClientTypes.IndexType?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            region: Swift.String? = nil,
            type: ResourceExplorer2ClientTypes.IndexType? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.region = region
            self.type = type
        }
    }
}

public struct ListIndexesForMembersOutput: Swift.Sendable {
    /// A structure that contains the details and status of each index.
    public var indexes: [ResourceExplorer2ClientTypes.MemberIndex]?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        indexes: [ResourceExplorer2ClientTypes.MemberIndex]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.indexes = indexes
        self.nextToken = nextToken
    }
}

public struct ListResourcesInput: Swift.Sendable {
    /// A search filter defines which resources can be part of a search query result set.
    public var filters: ResourceExplorer2ClientTypes.SearchFilter?
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// Specifies the Amazon resource name (ARN) of the view to use for the query. If you don't specify a value for this parameter, then the operation automatically uses the default view for the Amazon Web Services Region in which you called this operation. If the Region either doesn't have a default view or if you don't have permission to use the default view, then the operation fails with a 401 Unauthorized exception.
    public var viewArn: Swift.String?

    public init(
        filters: ResourceExplorer2ClientTypes.SearchFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        viewArn: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.viewArn = viewArn
    }
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), viewArn: \(Swift.String(describing: viewArn)), filters: \"CONTENT_REDACTED\")"}
}

extension ResourceExplorer2ClientTypes {

    /// A structure that describes a property of a resource.
    public struct ResourceProperty: Swift.Sendable {
        /// Details about this property. The content of this field is a JSON object that varies based on the resource type.
        public var data: Smithy.Document?
        /// The date and time that the information about this resource property was last updated.
        public var lastReportedAt: Foundation.Date?
        /// The name of this property of the resource.
        public var name: Swift.String?

        public init(
            data: Smithy.Document? = nil,
            lastReportedAt: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.data = data
            self.lastReportedAt = lastReportedAt
            self.name = name
        }
    }
}

extension ResourceExplorer2ClientTypes {

    /// A resource in Amazon Web Services that Amazon Web Services Resource Explorer has discovered, and for which it has stored information in the index of the Amazon Web Services Region that contains the resource.
    public struct Resource: Swift.Sendable {
        /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
        public var arn: Swift.String?
        /// The date and time that Resource Explorer last queried this resource and updated the index with the latest information about the resource.
        public var lastReportedAt: Foundation.Date?
        /// The Amazon Web Services account that owns the resource.
        public var owningAccountId: Swift.String?
        /// A structure with additional type-specific details about the resource. These properties can be added by turning on integration between Resource Explorer and other Amazon Web Services services.
        public var properties: [ResourceExplorer2ClientTypes.ResourceProperty]?
        /// The Amazon Web Services Region in which the resource was created and exists.
        public var region: Swift.String?
        /// The type of the resource.
        public var resourceType: Swift.String?
        /// The Amazon Web Servicesservice that owns the resource and is responsible for creating and updating it.
        public var service: Swift.String?

        public init(
            arn: Swift.String? = nil,
            lastReportedAt: Foundation.Date? = nil,
            owningAccountId: Swift.String? = nil,
            properties: [ResourceExplorer2ClientTypes.ResourceProperty]? = nil,
            region: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.arn = arn
            self.lastReportedAt = lastReportedAt
            self.owningAccountId = owningAccountId
            self.properties = properties
            self.region = region
            self.resourceType = resourceType
            self.service = service
        }
    }
}

public struct ListResourcesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The list of structures that describe the resources that match the query.
    public var resources: [ResourceExplorer2ClientTypes.Resource]?
    /// The Amazon resource name (ARN) of the view that this operation used to perform the search.
    public var viewArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resources: [ResourceExplorer2ClientTypes.Resource]? = nil,
        viewArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
        self.viewArn = viewArn
    }
}

public struct ListSupportedResourceTypesInput: Swift.Sendable {
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ResourceExplorer2ClientTypes {

    /// A structure that describes a resource type supported by Amazon Web Services Resource Explorer.
    public struct SupportedResourceType: Swift.Sendable {
        /// The unique identifier of the resource type.
        public var resourceType: Swift.String?
        /// The Amazon Web Servicesservice that is associated with the resource type. This is the primary service that lets you create and interact with resources of this type.
        public var service: Swift.String?

        public init(
            resourceType: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.resourceType = resourceType
            self.service = service
        }
    }
}

public struct ListSupportedResourceTypesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The list of resource types supported by Resource Explorer.
    public var resourceTypes: [ResourceExplorer2ClientTypes.SupportedResourceType]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTypes: [ResourceExplorer2ClientTypes.SupportedResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view or index that you want to attach tags to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tag key and value pairs that you want to attach to the specified view or index.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ResourceExplorer2ClientTypes {

    /// Information about the number of results that match the query. At this time, Amazon Web Services Resource Explorer doesn't count more than 1,000 matches for any query. This structure provides information about whether the query exceeded this limit. This field is included in every page when you paginate the results.
    public struct ResourceCount: Swift.Sendable {
        /// Indicates whether the TotalResources value represents an exhaustive count of search results.
        ///
        /// * If True, it indicates that the search was exhaustive. Every resource that matches the query was counted.
        ///
        /// * If False, then the search reached the limit of 1,000 matching results, and stopped counting.
        public var complete: Swift.Bool?
        /// The number of resources that match the search query. This value can't exceed 1,000. If there are more than 1,000 resources that match the query, then only 1,000 are counted and the Complete field is set to false. We recommend that you refine your query to return a smaller number of results.
        public var totalResources: Swift.Int?

        public init(
            complete: Swift.Bool? = nil,
            totalResources: Swift.Int? = nil
        )
        {
            self.complete = complete
            self.totalResources = totalResources
        }
    }
}

public struct SearchInput: Swift.Sendable {
    /// The maximum number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value appropriate to the operation. If additional items exist beyond those included in the current response, the NextToken response element is present and has a value (is not null). Include that value as the NextToken request parameter in the next call to the operation to get the next part of the results. An API operation can return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// The parameter for receiving additional results if you receive a NextToken response in a previous request. A NextToken response indicates that more output is available. Set this parameter to the value of the previous call's NextToken response to indicate where the output should continue from. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// A string that includes keywords and filters that specify the resources that you want to include in the results. For the complete syntax supported by the QueryString parameter, see [Search query syntax reference for Resource Explorer](https://docs.aws.amazon.com/resource-explorer/latest/userguide/using-search-query-syntax.html). The search is completely case insensitive. You can specify an empty string to return all results up to the limit of 1,000 total results. The operation can return only the first 1,000 results. If the resource you want is not included, then use a different value for QueryString to refine the results.
    /// This member is required.
    public var queryString: Swift.String?
    /// Specifies the [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view to use for the query. If you don't specify a value for this parameter, then the operation automatically uses the default view for the Amazon Web Services Region in which you called this operation. If the Region either doesn't have a default view or if you don't have permission to use the default view, then the operation fails with a 401 Unauthorized exception.
    public var viewArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryString: Swift.String? = nil,
        viewArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryString = queryString
        self.viewArn = viewArn
    }
}

extension SearchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), viewArn: \(Swift.String(describing: viewArn)), queryString: \"CONTENT_REDACTED\")"}
}

public struct SearchOutput: Swift.Sendable {
    /// The number of resources that match the query.
    public var count: ResourceExplorer2ClientTypes.ResourceCount?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. The pagination tokens expire after 24 hours.
    public var nextToken: Swift.String?
    /// The list of structures that describe the resources that match the query.
    public var resources: [ResourceExplorer2ClientTypes.Resource]?
    /// The [Amazon resource name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the view that this operation used to perform the search.
    public var viewArn: Swift.String?

    public init(
        count: ResourceExplorer2ClientTypes.ResourceCount? = nil,
        nextToken: Swift.String? = nil,
        resources: [ResourceExplorer2ClientTypes.Resource]? = nil,
        viewArn: Swift.String? = nil
    )
    {
        self.count = count
        self.nextToken = nextToken
        self.resources = resources
        self.viewArn = viewArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the view or index that you want to attach tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key and value pairs that you want to attach to the specified view or index.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the view or index that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of the keys for the tags that you want to remove from the specified view or index.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateDefaultViewInput {

    static func urlPathProvider(_ value: AssociateDefaultViewInput) -> Swift.String? {
        return "/AssociateDefaultView"
    }
}

extension BatchGetViewInput {

    static func urlPathProvider(_ value: BatchGetViewInput) -> Swift.String? {
        return "/BatchGetView"
    }
}

extension CreateIndexInput {

    static func urlPathProvider(_ value: CreateIndexInput) -> Swift.String? {
        return "/CreateIndex"
    }
}

extension CreateViewInput {

    static func urlPathProvider(_ value: CreateViewInput) -> Swift.String? {
        return "/CreateView"
    }
}

extension DeleteIndexInput {

    static func urlPathProvider(_ value: DeleteIndexInput) -> Swift.String? {
        return "/DeleteIndex"
    }
}

extension DeleteViewInput {

    static func urlPathProvider(_ value: DeleteViewInput) -> Swift.String? {
        return "/DeleteView"
    }
}

extension DisassociateDefaultViewInput {

    static func urlPathProvider(_ value: DisassociateDefaultViewInput) -> Swift.String? {
        return "/DisassociateDefaultView"
    }
}

extension GetAccountLevelServiceConfigurationInput {

    static func urlPathProvider(_ value: GetAccountLevelServiceConfigurationInput) -> Swift.String? {
        return "/GetAccountLevelServiceConfiguration"
    }
}

extension GetDefaultViewInput {

    static func urlPathProvider(_ value: GetDefaultViewInput) -> Swift.String? {
        return "/GetDefaultView"
    }
}

extension GetIndexInput {

    static func urlPathProvider(_ value: GetIndexInput) -> Swift.String? {
        return "/GetIndex"
    }
}

extension GetViewInput {

    static func urlPathProvider(_ value: GetViewInput) -> Swift.String? {
        return "/GetView"
    }
}

extension ListIndexesInput {

    static func urlPathProvider(_ value: ListIndexesInput) -> Swift.String? {
        return "/ListIndexes"
    }
}

extension ListIndexesForMembersInput {

    static func urlPathProvider(_ value: ListIndexesForMembersInput) -> Swift.String? {
        return "/ListIndexesForMembers"
    }
}

extension ListResourcesInput {

    static func urlPathProvider(_ value: ListResourcesInput) -> Swift.String? {
        return "/ListResources"
    }
}

extension ListSupportedResourceTypesInput {

    static func urlPathProvider(_ value: ListSupportedResourceTypesInput) -> Swift.String? {
        return "/ListSupportedResourceTypes"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListViewsInput {

    static func urlPathProvider(_ value: ListViewsInput) -> Swift.String? {
        return "/ListViews"
    }
}

extension SearchInput {

    static func urlPathProvider(_ value: SearchInput) -> Swift.String? {
        return "/Search"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateIndexTypeInput {

    static func urlPathProvider(_ value: UpdateIndexTypeInput) -> Swift.String? {
        return "/UpdateIndexType"
    }
}

extension UpdateViewInput {

    static func urlPathProvider(_ value: UpdateViewInput) -> Swift.String? {
        return "/UpdateView"
    }
}

extension AssociateDefaultViewInput {

    static func write(value: AssociateDefaultViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension BatchGetViewInput {

    static func write(value: BatchGetViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewArns"].writeList(value.viewArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIndexInput {

    static func write(value: CreateIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateViewInput {

    static func write(value: CreateViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Filters"].write(value.filters, with: ResourceExplorer2ClientTypes.SearchFilter.write(value:to:))
        try writer["IncludedProperties"].writeList(value.includedProperties, memberWritingClosure: ResourceExplorer2ClientTypes.IncludedProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Scope"].write(value.scope)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ViewName"].write(value.viewName)
    }
}

extension DeleteIndexInput {

    static func write(value: DeleteIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension DeleteViewInput {

    static func write(value: DeleteViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension GetViewInput {

    static func write(value: GetViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension ListIndexesInput {

    static func write(value: ListIndexesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension ListIndexesForMembersInput {

    static func write(value: ListIndexesForMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIdList"].writeList(value.accountIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourcesInput {

    static func write(value: ListResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ResourceExplorer2ClientTypes.SearchFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension ListSupportedResourceTypesInput {

    static func write(value: ListSupportedResourceTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListViewsInput {

    static func write(value: ListViewsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchInput {

    static func write(value: SearchInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["QueryString"].write(value.queryString)
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateIndexTypeInput {

    static func write(value: UpdateIndexTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Type"].write(value.type)
    }
}

extension UpdateViewInput {

    static func write(value: UpdateViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ResourceExplorer2ClientTypes.SearchFilter.write(value:to:))
        try writer["IncludedProperties"].writeList(value.includedProperties, memberWritingClosure: ResourceExplorer2ClientTypes.IncludedProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ViewArn"].write(value.viewArn)
    }
}

extension AssociateDefaultViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDefaultViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateDefaultViewOutput()
        value.viewArn = try reader["ViewArn"].readIfPresent()
        return value
    }
}

extension BatchGetViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetViewOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.BatchGetViewError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.views = try reader["Views"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.View.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIndexOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension CreateViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateViewOutput()
        value.view = try reader["View"].readIfPresent(with: ResourceExplorer2ClientTypes.View.read(from:))
        return value
    }
}

extension DeleteIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIndexOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DeleteViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteViewOutput()
        value.viewArn = try reader["ViewArn"].readIfPresent()
        return value
    }
}

extension DisassociateDefaultViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDefaultViewOutput {
        return DisassociateDefaultViewOutput()
    }
}

extension GetAccountLevelServiceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountLevelServiceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountLevelServiceConfigurationOutput()
        value.orgConfiguration = try reader["OrgConfiguration"].readIfPresent(with: ResourceExplorer2ClientTypes.OrgConfiguration.read(from:))
        return value
    }
}

extension GetDefaultViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultViewOutput()
        value.viewArn = try reader["ViewArn"].readIfPresent()
        return value
    }
}

extension GetIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIndexOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.replicatingFrom = try reader["ReplicatingFrom"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.replicatingTo = try reader["ReplicatingTo"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetViewOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.view = try reader["View"].readIfPresent(with: ResourceExplorer2ClientTypes.View.read(from:))
        return value
    }
}

extension ListIndexesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndexesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndexesOutput()
        value.indexes = try reader["Indexes"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.Index.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIndexesForMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndexesForMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndexesForMembersOutput()
        value.indexes = try reader["Indexes"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.MemberIndex.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.viewArn = try reader["ViewArn"].readIfPresent()
        return value
    }
}

extension ListSupportedResourceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSupportedResourceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSupportedResourceTypesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceTypes = try reader["ResourceTypes"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.SupportedResourceType.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListViewsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.views = try reader["Views"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchOutput()
        value.count = try reader["Count"].readIfPresent(with: ResourceExplorer2ClientTypes.ResourceCount.read(from:))
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.viewArn = try reader["ViewArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateIndexTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIndexTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIndexTypeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.state = try reader["State"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension UpdateViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateViewOutput()
        value.view = try reader["View"].readIfPresent(with: ResourceExplorer2ClientTypes.View.read(from:))
        return value
    }
}

enum AssociateDefaultViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDefaultViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountLevelServiceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndexesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndexesForMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSupportedResourceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIndexTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["FieldList"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.name = try reader["Name"].readIfPresent() ?? ""
        value.properties.value = try reader["Value"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceExplorer2ClientTypes.View {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.View {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.View()
        value.viewArn = try reader["ViewArn"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.scope = try reader["Scope"].readIfPresent()
        value.includedProperties = try reader["IncludedProperties"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.IncludedProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filters = try reader["Filters"].readIfPresent(with: ResourceExplorer2ClientTypes.SearchFilter.read(from:))
        return value
    }
}

extension ResourceExplorer2ClientTypes.SearchFilter {

    static func write(value: ResourceExplorer2ClientTypes.SearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterString"].write(value.filterString)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.SearchFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.SearchFilter()
        value.filterString = try reader["FilterString"].readIfPresent() ?? ""
        return value
    }
}

extension ResourceExplorer2ClientTypes.IncludedProperty {

    static func write(value: ResourceExplorer2ClientTypes.IncludedProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.IncludedProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.IncludedProperty()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension ResourceExplorer2ClientTypes.BatchGetViewError {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.BatchGetViewError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.BatchGetViewError()
        value.viewArn = try reader["ViewArn"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension ResourceExplorer2ClientTypes.OrgConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.OrgConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.OrgConfiguration()
        value.awsServiceAccessStatus = try reader["AWSServiceAccessStatus"].readIfPresent() ?? .sdkUnknown("")
        value.serviceLinkedRole = try reader["ServiceLinkedRole"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.Index {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.Index {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.Index()
        value.region = try reader["Region"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.MemberIndex {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.MemberIndex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.MemberIndex()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.Resource()
        value.arn = try reader["Arn"].readIfPresent()
        value.owningAccountId = try reader["OwningAccountId"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.service = try reader["Service"].readIfPresent()
        value.lastReportedAt = try reader["LastReportedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: ResourceExplorer2ClientTypes.ResourceProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ResourceExplorer2ClientTypes.ResourceProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.ResourceProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.ResourceProperty()
        value.name = try reader["Name"].readIfPresent()
        value.lastReportedAt = try reader["LastReportedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.data = try reader["Data"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.SupportedResourceType {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.SupportedResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.SupportedResourceType()
        value.service = try reader["Service"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.ResourceCount {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.ResourceCount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.ResourceCount()
        value.totalResources = try reader["TotalResources"].readIfPresent()
        value.complete = try reader["Complete"].readIfPresent()
        return value
    }
}

extension ResourceExplorer2ClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> ResourceExplorer2ClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ResourceExplorer2ClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.validationIssue = try reader["ValidationIssue"].readIfPresent() ?? ""
        return value
    }
}

public enum ResourceExplorer2ClientTypes {}
