//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct DescribeHealthServiceStatusForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct DisableHealthServiceAccessForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct DisableHealthServiceAccessForOrganizationOutput: Swift.Sendable {

    public init() { }
}

public struct EnableHealthServiceAccessForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct EnableHealthServiceAccessForOrganizationOutput: Swift.Sendable {

    public init() { }
}

extension HealthClientTypes {

    public enum EntityStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case impaired
        case pending
        case resolved
        case unimpaired
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityStatusCode] {
            return [
                .impaired,
                .pending,
                .resolved,
                .unimpaired,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .impaired: return "IMPAIRED"
            case .pending: return "PENDING"
            case .resolved: return "RESOLVED"
            case .unimpaired: return "UNIMPAIRED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthClientTypes {

    /// The number of entities in an account that are impacted by a specific event aggregated by the entity status codes.
    public struct AccountEntityAggregate: Swift.Sendable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var accountId: Swift.String?
        /// The number of entities that match the filter criteria for the specified events.
        public var count: Swift.Int
        /// The number of affected entities aggregated by the entity status codes.
        public var statuses: [Swift.String: Swift.Int]?

        public init(
            accountId: Swift.String? = nil,
            count: Swift.Int = 0,
            statuses: [Swift.String: Swift.Int]? = nil
        )
        {
            self.accountId = accountId
            self.count = count
            self.statuses = statuses
        }
    }
}

extension HealthClientTypes {

    /// Information about an entity that is affected by a Health event.
    public struct AffectedEntity: Swift.Sendable {
        /// The 12-digit Amazon Web Services account number that contains the affected entity.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the entity. Format: arn:aws:health:entity-region:aws-account:entity/entity-id . Example: arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K
        public var entityArn: Swift.String?
        /// The URL of the affected entity.
        public var entityUrl: Swift.String?
        /// The ID of the affected entity.
        public var entityValue: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?
        /// The most recent time that the entity was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.
        public var statusCode: HealthClientTypes.EntityStatusCode?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [Swift.String: Swift.String]?

        public init(
            awsAccountId: Swift.String? = nil,
            entityArn: Swift.String? = nil,
            entityUrl: Swift.String? = nil,
            entityValue: Swift.String? = nil,
            eventArn: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            statusCode: HealthClientTypes.EntityStatusCode? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.entityArn = entityArn
            self.entityUrl = entityUrl
            self.entityValue = entityValue
            self.eventArn = eventArn
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.tags = tags
        }
    }
}

/// The specified pagination token (nextToken) is not valid.
public struct InvalidPaginationToken: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationToken" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAffectedAccountsForOrganizationInput: Swift.Sendable {
    /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
    /// This member is required.
    public var eventArn: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventArn = eventArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    public enum EventScopeCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountSpecific
        case `none`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [EventScopeCode] {
            return [
                .accountSpecific,
                .none,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountSpecific: return "ACCOUNT_SPECIFIC"
            case .none: return "NONE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeAffectedAccountsForOrganizationOutput: Swift.Sendable {
    /// A JSON set of elements of the affected accounts.
    public var affectedAccounts: [Swift.String]?
    /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
    ///
    /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
    ///
    /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
    ///
    /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
    public var eventScopeCode: HealthClientTypes.EventScopeCode?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        affectedAccounts: [Swift.String]? = nil,
        eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.affectedAccounts = affectedAccounts
        self.eventScopeCode = eventScopeCode
        self.nextToken = nextToken
    }
}

/// The specified locale is not supported.
public struct UnsupportedLocale: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedLocale" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension HealthClientTypes {

    /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
    public struct DateTimeRange: Swift.Sendable {
        /// The starting date and time of a time range.
        public var from: Foundation.Date?
        /// The ending date and time of a time range.
        public var to: Foundation.Date?

        public init(
            from: Foundation.Date? = nil,
            to: Foundation.Date? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }
}

extension HealthClientTypes {

    /// The values to use to filter results from the [DescribeAffectedEntities](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntities.html) operation.
    public struct EntityFilter: Swift.Sendable {
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of IDs for affected entities.
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        /// This member is required.
        public var eventArns: [Swift.String]?
        /// A list of the most recent dates and times that the entity was updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity status codes (IMPAIRED, UNIMPAIRED, or UNKNOWN).
        public var statusCodes: [HealthClientTypes.EntityStatusCode]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String: Swift.String]]?

        public init(
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            statusCodes: [HealthClientTypes.EntityStatusCode]? = nil,
            tags: [[Swift.String: Swift.String]]? = nil
        )
        {
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.lastUpdatedTimes = lastUpdatedTimes
            self.statusCodes = statusCodes
            self.tags = tags
        }
    }
}

public struct DescribeAffectedEntitiesInput: Swift.Sendable {
    /// Values to narrow the results returned. At least one event ARN is required.
    /// This member is required.
    public var filter: HealthClientTypes.EntityFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EntityFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAffectedEntitiesOutput: Swift.Sendable {
    /// The entities that match the filter criteria.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// A JSON set of elements including the awsAccountId, eventArn and a set of statusCodes.
    public struct EntityAccountFilter: Swift.Sendable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        /// This member is required.
        public var eventArn: Swift.String?
        /// A list of entity status codes.
        public var statusCodes: [HealthClientTypes.EntityStatusCode]?

        public init(
            awsAccountId: Swift.String? = nil,
            eventArn: Swift.String? = nil,
            statusCodes: [HealthClientTypes.EntityStatusCode]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
            self.statusCodes = statusCodes
        }
    }
}

extension HealthClientTypes {

    /// The values used to filter results from the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) and [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operations.
    public struct EventAccountFilter: Swift.Sendable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        /// This member is required.
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationInput: Swift.Sendable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// A JSON set of elements including the awsAccountId, eventArn and a set of statusCodes.
    public var organizationEntityAccountFilters: [HealthClientTypes.EntityAccountFilter]?
    /// A JSON set of elements including the awsAccountId and the eventArn.
    @available(*, deprecated, message: "This property is deprecated, use organizationEntityAccountFilters instead.")
    public var organizationEntityFilters: [HealthClientTypes.EventAccountFilter]?

    public init(
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationEntityAccountFilters: [HealthClientTypes.EntityAccountFilter]? = nil,
        organizationEntityFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationEntityAccountFilters = organizationEntityAccountFilters
        self.organizationEntityFilters = organizationEntityFilters
    }
}

extension HealthClientTypes {

    /// Error information returned when a [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operation can't find or process a specific entity.
    public struct OrganizationAffectedEntitiesErrorItem: Swift.Sendable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// A message that describes the error. Follow the error message and retry your request. For example, the InvalidAccountInputError error message appears if you call the DescribeAffectedEntitiesForOrganization operation and specify the AccountSpecific value for the EventScopeCode parameter, but don't specify an Amazon Web Services account.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationOutput: Swift.Sendable {
    /// A JSON set of elements including the awsAccountId and its entityArn, entityValue and its entityArn, lastUpdatedTime, and statusCode.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// A JSON set of elements of the failed response, including the awsAccountId, errorMessage, errorName, and eventArn.
    public var failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.failedSet = failedSet
        self.nextToken = nextToken
    }
}

public struct DescribeEntityAggregatesInput: Swift.Sendable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    public var eventArns: [Swift.String]?

    public init(
        eventArns: [Swift.String]? = nil
    )
    {
        self.eventArns = eventArns
    }
}

extension HealthClientTypes {

    /// The number of entities that are affected by one or more events. Returned by the [DescribeEntityAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEntityAggregates.html) operation.
    public struct EntityAggregate: Swift.Sendable {
        /// The number of entities that match the criteria for the specified events.
        public var count: Swift.Int
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?
        /// The number of affected entities aggregated by the entity status codes.
        public var statuses: [Swift.String: Swift.Int]?

        public init(
            count: Swift.Int = 0,
            eventArn: Swift.String? = nil,
            statuses: [Swift.String: Swift.Int]? = nil
        )
        {
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }
    }
}

public struct DescribeEntityAggregatesOutput: Swift.Sendable {
    /// The number of entities that are affected by each of the specified events.
    public var entityAggregates: [HealthClientTypes.EntityAggregate]?

    public init(
        entityAggregates: [HealthClientTypes.EntityAggregate]? = nil
    )
    {
        self.entityAggregates = entityAggregates
    }
}

public struct DescribeEntityAggregatesForOrganizationInput: Swift.Sendable {
    /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
    public var awsAccountIds: [Swift.String]?
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    /// This member is required.
    public var eventArns: [Swift.String]?

    public init(
        awsAccountIds: [Swift.String]? = nil,
        eventArns: [Swift.String]? = nil
    )
    {
        self.awsAccountIds = awsAccountIds
        self.eventArns = eventArns
    }
}

extension HealthClientTypes {

    /// The aggregate results of entities affected by the specified event in your organization. The results are aggregated by the entity status codes for the specified set of accountsIDs.
    public struct OrganizationEntityAggregate: Swift.Sendable {
        /// A list of entity aggregates for each of the specified accounts in your organization that are affected by a specific event. If there are no awsAccountIds provided in the request, this field will be empty in the response.
        public var accounts: [HealthClientTypes.AccountEntityAggregate]?
        /// The number of entities for the organization that match the filter criteria for the specified events.
        public var count: Swift.Int
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public var eventArn: Swift.String?
        /// The number of affected entities aggregated by the entitiy status codes.
        public var statuses: [Swift.String: Swift.Int]?

        public init(
            accounts: [HealthClientTypes.AccountEntityAggregate]? = nil,
            count: Swift.Int = 0,
            eventArn: Swift.String? = nil,
            statuses: [Swift.String: Swift.Int]? = nil
        )
        {
            self.accounts = accounts
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }
    }
}

public struct DescribeEntityAggregatesForOrganizationOutput: Swift.Sendable {
    /// The list of entity aggregates for each of the specified accounts that are affected by each of the specified events.
    public var organizationEntityAggregates: [HealthClientTypes.OrganizationEntityAggregate]?

    public init(
        organizationEntityAggregates: [HealthClientTypes.OrganizationEntityAggregate]? = nil
    )
    {
        self.organizationEntityAggregates = organizationEntityAggregates
    }
}

extension HealthClientTypes {

    public enum EventAggregateField: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventtypecategory
        case sdkUnknown(Swift.String)

        public static var allCases: [EventAggregateField] {
            return [
                .eventtypecategory
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventtypecategory: return "eventTypeCategory"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthClientTypes {

    public enum EventStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case `open`
        case upcoming
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatusCode] {
            return [
                .closed,
                .open,
                .upcoming
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "closed"
            case .open: return "open"
            case .upcoming: return "upcoming"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthClientTypes {

    public enum EventTypeCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountNotification
        case investigation
        case issue
        case scheduledChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTypeCategory] {
            return [
                .accountNotification,
                .investigation,
                .issue,
                .scheduledChange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountNotification: return "accountNotification"
            case .investigation: return "investigation"
            case .issue: return "issue"
            case .scheduledChange: return "scheduledChange"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension HealthClientTypes {

    /// The values to use to filter results from the [DescribeEvents](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEvents.html) and [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operations.
    public struct EventFilter: Swift.Sendable {
        /// A list of Amazon Web Services Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// A list of dates and times that the event ended.
        public var endTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public var eventArns: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A list of dates and times that the event was last updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A list of dates and times that the event began.
        public var startTimes: [HealthClientTypes.DateTimeRange]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String: Swift.String]]?

        public init(
            availabilityZones: [Swift.String]? = nil,
            endTimes: [HealthClientTypes.DateTimeRange]? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTimes: [HealthClientTypes.DateTimeRange]? = nil,
            tags: [[Swift.String: Swift.String]]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.endTimes = endTimes
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTimes = lastUpdatedTimes
            self.regions = regions
            self.services = services
            self.startTimes = startTimes
            self.tags = tags
        }
    }
}

public struct DescribeEventAggregatesInput: Swift.Sendable {
    /// The only currently supported value is eventTypeCategory.
    /// This member is required.
    public var aggregateField: HealthClientTypes.EventAggregateField?
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        aggregateField: HealthClientTypes.EventAggregateField? = nil,
        filter: HealthClientTypes.EventFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateField = aggregateField
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// The number of events of each issue type. Returned by the [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operation.
    public struct EventAggregate: Swift.Sendable {
        /// The issue type for the associated count.
        public var aggregateValue: Swift.String?
        /// The number of events of the associated issue type.
        public var count: Swift.Int

        public init(
            aggregateValue: Swift.String? = nil,
            count: Swift.Int = 0
        )
        {
            self.aggregateValue = aggregateValue
            self.count = count
        }
    }
}

public struct DescribeEventAggregatesOutput: Swift.Sendable {
    /// The number of events in each category that meet the optional filter criteria.
    public var eventAggregates: [HealthClientTypes.EventAggregate]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventAggregates: [HealthClientTypes.EventAggregate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventAggregates = eventAggregates
        self.nextToken = nextToken
    }
}

public struct DescribeEventDetailsInput: Swift.Sendable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    /// This member is required.
    public var eventArns: [Swift.String]?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?

    public init(
        eventArns: [Swift.String]? = nil,
        locale: Swift.String? = nil
    )
    {
        self.eventArns = eventArns
        self.locale = locale
    }
}

extension HealthClientTypes {

    /// Error information returned when a [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation can't find a specified event.
    public struct EventDetailsErrorItem: Swift.Sendable {
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }
}

extension HealthClientTypes {

    /// Summary information about an Health event. Health events can be public or account-specific:
    ///
    /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
    ///
    /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
    ///
    ///
    /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
    public struct Event: Swift.Sendable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The Amazon Web Services Availability Zone of the event. For example, us-east-1a.
        public var availabilityZone: Swift.String?
        /// The date and time that the event ended.
        public var endTime: Foundation.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: Foundation.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }
}

extension HealthClientTypes {

    /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDescription: Swift.Sendable {
        /// The most recent description of the event.
        public var latestDescription: Swift.String?

        public init(
            latestDescription: Swift.String? = nil
        )
        {
            self.latestDescription = latestDescription
        }
    }
}

extension HealthClientTypes {

    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDetails: Swift.Sendable {
        /// Summary information about the event.
        public var event: HealthClientTypes.Event?
        /// The most recent description of the event.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String: Swift.String]?

        public init(
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String: Swift.String]? = nil
        )
        {
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }
}

public struct DescribeEventDetailsOutput: Swift.Sendable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.EventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.EventDetails]?

    public init(
        failedSet: [HealthClientTypes.EventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.EventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

public struct DescribeEventDetailsForOrganizationInput: Swift.Sendable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// A set of JSON elements that includes the awsAccountId and the eventArn.
    /// This member is required.
    public var organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]?

    public init(
        locale: Swift.String? = nil,
        organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.organizationEventDetailFilters = organizationEventDetailFilters
    }
}

extension HealthClientTypes {

    /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
    public struct OrganizationEventDetailsErrorItem: Swift.Sendable {
        /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
        public var awsAccountId: Swift.String?
        /// A message that describes the error. If you call the DescribeEventDetailsForOrganization operation and receive one of the following errors, follow the recommendations in the message:
        ///
        /// * We couldn't find a public event that matches your request. To find an event that is account specific, you must enter an Amazon Web Services account ID in the request.
        ///
        /// * We couldn't find an account specific event for the specified Amazon Web Services account. To find an event that is public, you must enter a null value for the Amazon Web Services account ID in the request.
        ///
        /// * Your Amazon Web Services account doesn't include the Amazon Web Services Support plan required to use the Health API. You must have either a Business, Enterprise On-Ramp, or Enterprise Support plan.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }
}

extension HealthClientTypes {

    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation.
    public struct OrganizationEventDetails: Swift.Sendable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// Summary information about an Health event. Health events can be public or account-specific:
        ///
        /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
        ///
        /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
        ///
        ///
        /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
        public var event: HealthClientTypes.Event?
        /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String: Swift.String]?

        public init(
            awsAccountId: Swift.String? = nil,
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String: Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }
}

public struct DescribeEventDetailsForOrganizationOutput: Swift.Sendable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.OrganizationEventDetails]?

    public init(
        failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.OrganizationEventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

public struct DescribeEventsInput: Swift.Sendable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeEventsOutput: Swift.Sendable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.Event]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        events: [HealthClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// The values to filter results from the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEventFilter: Swift.Sendable {
        /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountIds: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var endTime: HealthClientTypes.DateTimeRange?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var lastUpdatedTime: HealthClientTypes.DateTimeRange?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var startTime: HealthClientTypes.DateTimeRange?

        public init(
            awsAccountIds: [Swift.String]? = nil,
            endTime: HealthClientTypes.DateTimeRange? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTime: HealthClientTypes.DateTimeRange? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTime: HealthClientTypes.DateTimeRange? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.endTime = endTime
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTime = lastUpdatedTime
            self.regions = regions
            self.services = services
            self.startTime = startTime
        }
    }
}

public struct DescribeEventsForOrganizationInput: Swift.Sendable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.OrganizationEventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.OrganizationEventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// Summary information about an event, returned by the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEvent: Swift.Sendable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The date and time that the event ended.
        public var endTime: Foundation.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION. For example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Service that is affected by the event, such as EC2 and RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: Foundation.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init(
            arn: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }
}

public struct DescribeEventsForOrganizationOutput: Swift.Sendable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.OrganizationEvent]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        events: [HealthClientTypes.OrganizationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// The values to use to filter results from the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) operation.
    public struct EventTypeFilter: Swift.Sendable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of event type codes.
        public var eventTypeCodes: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?

        public init(
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            services: [Swift.String]? = nil
        )
        {
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.services = services
        }
    }
}

public struct DescribeEventTypesInput: Swift.Sendable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventTypeFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive. If you don't specify the maxResults parameter, this operation returns a maximum of 30 items by default.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EventTypeFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension HealthClientTypes {

    /// Contains the metadata about a type of event that is reported by Health. The EventType shows the category, service, and the event type code of the event. For example, an issue might be the category, EC2 the service, and AWS_EC2_SYSTEM_MAINTENANCE_EVENT the event type code. You can use the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) API operation to return this information about an event. You can also use the Amazon CloudWatch Events console to create a rule so that you can get notified or take action when Health delivers a specific event to your Amazon Web Services account. For more information, see [Monitor for Health events with Amazon CloudWatch Events](https://docs.aws.amazon.com/health/latest/ug/cloudwatch-events-health.html) in the Health User Guide.
    public struct EventType: Swift.Sendable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var category: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var code: Swift.String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?

        public init(
            category: HealthClientTypes.EventTypeCategory? = nil,
            code: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.category = category
            self.code = code
            self.service = service
        }
    }
}

public struct DescribeEventTypesOutput: Swift.Sendable {
    /// A list of event types that match the filter criteria. Event types have a category (issue, accountNotification, or scheduledChange), a service (for example, EC2, RDS, DATAPIPELINE, BILLING), and a code (in the format AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT).
    public var eventTypes: [HealthClientTypes.EventType]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventTypes: [HealthClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

public struct DescribeHealthServiceStatusForOrganizationOutput: Swift.Sendable {
    /// Information about the status of enabling or disabling the Health organizational view feature in your organization. Valid values are ENABLED | DISABLED | PENDING.
    public var healthServiceAccessStatusForOrganization: Swift.String?

    public init(
        healthServiceAccessStatusForOrganization: Swift.String? = nil
    )
    {
        self.healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganization
    }
}

/// [EnableHealthServiceAccessForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_EnableHealthServiceAccessForOrganization.html) is already in progress. Wait for the action to complete before trying again. To get the current status, use the [DescribeHealthServiceStatusForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeHealthServiceStatusForOrganization.html) operation.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DescribeAffectedAccountsForOrganizationInput {

    static func urlPathProvider(_ value: DescribeAffectedAccountsForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAffectedEntitiesInput {

    static func urlPathProvider(_ value: DescribeAffectedEntitiesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAffectedEntitiesForOrganizationInput {

    static func urlPathProvider(_ value: DescribeAffectedEntitiesForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEntityAggregatesInput {

    static func urlPathProvider(_ value: DescribeEntityAggregatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEntityAggregatesForOrganizationInput {

    static func urlPathProvider(_ value: DescribeEntityAggregatesForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventAggregatesInput {

    static func urlPathProvider(_ value: DescribeEventAggregatesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventDetailsInput {

    static func urlPathProvider(_ value: DescribeEventDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventDetailsForOrganizationInput {

    static func urlPathProvider(_ value: DescribeEventDetailsForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventsInput {

    static func urlPathProvider(_ value: DescribeEventsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventsForOrganizationInput {

    static func urlPathProvider(_ value: DescribeEventsForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEventTypesInput {

    static func urlPathProvider(_ value: DescribeEventTypesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeHealthServiceStatusForOrganizationInput {

    static func urlPathProvider(_ value: DescribeHealthServiceStatusForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DisableHealthServiceAccessForOrganizationInput {

    static func urlPathProvider(_ value: DisableHealthServiceAccessForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension EnableHealthServiceAccessForOrganizationInput {

    static func urlPathProvider(_ value: EnableHealthServiceAccessForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAffectedAccountsForOrganizationInput {

    static func write(value: DescribeAffectedAccountsForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventArn"].write(value.eventArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeAffectedEntitiesInput {

    static func write(value: DescribeAffectedEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: HealthClientTypes.EntityFilter.write(value:to:))
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeAffectedEntitiesForOrganizationInput {

    static func write(value: DescribeAffectedEntitiesForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["organizationEntityAccountFilters"].writeList(value.organizationEntityAccountFilters, memberWritingClosure: HealthClientTypes.EntityAccountFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["organizationEntityFilters"].writeList(value.organizationEntityFilters, memberWritingClosure: HealthClientTypes.EventAccountFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeEntityAggregatesInput {

    static func write(value: DescribeEntityAggregatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventArns"].writeList(value.eventArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeEntityAggregatesForOrganizationInput {

    static func write(value: DescribeEntityAggregatesForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountIds"].writeList(value.awsAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventArns"].writeList(value.eventArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeEventAggregatesInput {

    static func write(value: DescribeEventAggregatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregateField"].write(value.aggregateField)
        try writer["filter"].write(value.filter, with: HealthClientTypes.EventFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeEventDetailsInput {

    static func write(value: DescribeEventDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventArns"].writeList(value.eventArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["locale"].write(value.locale)
    }
}

extension DescribeEventDetailsForOrganizationInput {

    static func write(value: DescribeEventDetailsForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["locale"].write(value.locale)
        try writer["organizationEventDetailFilters"].writeList(value.organizationEventDetailFilters, memberWritingClosure: HealthClientTypes.EventAccountFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeEventsInput {

    static func write(value: DescribeEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: HealthClientTypes.EventFilter.write(value:to:))
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeEventsForOrganizationInput {

    static func write(value: DescribeEventsForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: HealthClientTypes.OrganizationEventFilter.write(value:to:))
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeEventTypesInput {

    static func write(value: DescribeEventTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: HealthClientTypes.EventTypeFilter.write(value:to:))
        try writer["locale"].write(value.locale)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeHealthServiceStatusForOrganizationInput {

    static func write(value: DescribeHealthServiceStatusForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisableHealthServiceAccessForOrganizationInput {

    static func write(value: DisableHealthServiceAccessForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension EnableHealthServiceAccessForOrganizationInput {

    static func write(value: EnableHealthServiceAccessForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeAffectedAccountsForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAffectedAccountsForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAffectedAccountsForOrganizationOutput()
        value.affectedAccounts = try reader["affectedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventScopeCode = try reader["eventScopeCode"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeAffectedEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAffectedEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAffectedEntitiesOutput()
        value.entities = try reader["entities"].readListIfPresent(memberReadingClosure: HealthClientTypes.AffectedEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeAffectedEntitiesForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAffectedEntitiesForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAffectedEntitiesForOrganizationOutput()
        value.entities = try reader["entities"].readListIfPresent(memberReadingClosure: HealthClientTypes.AffectedEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failedSet = try reader["failedSet"].readListIfPresent(memberReadingClosure: HealthClientTypes.OrganizationAffectedEntitiesErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeEntityAggregatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEntityAggregatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEntityAggregatesOutput()
        value.entityAggregates = try reader["entityAggregates"].readListIfPresent(memberReadingClosure: HealthClientTypes.EntityAggregate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEntityAggregatesForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEntityAggregatesForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEntityAggregatesForOrganizationOutput()
        value.organizationEntityAggregates = try reader["organizationEntityAggregates"].readListIfPresent(memberReadingClosure: HealthClientTypes.OrganizationEntityAggregate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEventAggregatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventAggregatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventAggregatesOutput()
        value.eventAggregates = try reader["eventAggregates"].readListIfPresent(memberReadingClosure: HealthClientTypes.EventAggregate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeEventDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventDetailsOutput()
        value.failedSet = try reader["failedSet"].readListIfPresent(memberReadingClosure: HealthClientTypes.EventDetailsErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfulSet = try reader["successfulSet"].readListIfPresent(memberReadingClosure: HealthClientTypes.EventDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEventDetailsForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventDetailsForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventDetailsForOrganizationOutput()
        value.failedSet = try reader["failedSet"].readListIfPresent(memberReadingClosure: HealthClientTypes.OrganizationEventDetailsErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successfulSet = try reader["successfulSet"].readListIfPresent(memberReadingClosure: HealthClientTypes.OrganizationEventDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: HealthClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeEventsForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventsForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventsForOrganizationOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: HealthClientTypes.OrganizationEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeEventTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEventTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEventTypesOutput()
        value.eventTypes = try reader["eventTypes"].readListIfPresent(memberReadingClosure: HealthClientTypes.EventType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeHealthServiceStatusForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHealthServiceStatusForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHealthServiceStatusForOrganizationOutput()
        value.healthServiceAccessStatusForOrganization = try reader["healthServiceAccessStatusForOrganization"].readIfPresent()
        return value
    }
}

extension DisableHealthServiceAccessForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableHealthServiceAccessForOrganizationOutput {
        return DisableHealthServiceAccessForOrganizationOutput()
    }
}

extension EnableHealthServiceAccessForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableHealthServiceAccessForOrganizationOutput {
        return EnableHealthServiceAccessForOrganizationOutput()
    }
}

enum DescribeAffectedAccountsForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAffectedEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAffectedEntitiesForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEntityAggregatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEntityAggregatesForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventAggregatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventDetailsForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventsForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEventTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidPaginationToken": return try InvalidPaginationToken.makeError(baseError: baseError)
            case "UnsupportedLocale": return try UnsupportedLocale.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHealthServiceStatusForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableHealthServiceAccessForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableHealthServiceAccessForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidPaginationToken {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPaginationToken {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationToken()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedLocale {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedLocale {
        let reader = baseError.errorBodyReader
        var value = UnsupportedLocale()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension HealthClientTypes.AffectedEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.AffectedEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.AffectedEntity()
        value.entityArn = try reader["entityArn"].readIfPresent()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.entityValue = try reader["entityValue"].readIfPresent()
        value.entityUrl = try reader["entityUrl"].readIfPresent()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.OrganizationAffectedEntitiesErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.OrganizationAffectedEntitiesErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.OrganizationAffectedEntitiesErrorItem()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.errorName = try reader["errorName"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.EntityAggregate {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EntityAggregate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EntityAggregate()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.statuses = try reader["statuses"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.OrganizationEntityAggregate {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.OrganizationEntityAggregate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.OrganizationEntityAggregate()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.statuses = try reader["statuses"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.accounts = try reader["accounts"].readListIfPresent(memberReadingClosure: HealthClientTypes.AccountEntityAggregate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.AccountEntityAggregate {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.AccountEntityAggregate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.AccountEntityAggregate()
        value.accountId = try reader["accountId"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.statuses = try reader["statuses"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.EventAggregate {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EventAggregate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EventAggregate()
        value.aggregateValue = try reader["aggregateValue"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        return value
    }
}

extension HealthClientTypes.EventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EventDetails()
        value.event = try reader["event"].readIfPresent(with: HealthClientTypes.Event.read(from:))
        value.eventDescription = try reader["eventDescription"].readIfPresent(with: HealthClientTypes.EventDescription.read(from:))
        value.eventMetadata = try reader["eventMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.EventDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EventDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EventDescription()
        value.latestDescription = try reader["latestDescription"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.Event()
        value.arn = try reader["arn"].readIfPresent()
        value.service = try reader["service"].readIfPresent()
        value.eventTypeCode = try reader["eventTypeCode"].readIfPresent()
        value.eventTypeCategory = try reader["eventTypeCategory"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.eventScopeCode = try reader["eventScopeCode"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.EventDetailsErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EventDetailsErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EventDetailsErrorItem()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.errorName = try reader["errorName"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.OrganizationEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.OrganizationEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.OrganizationEventDetails()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.event = try reader["event"].readIfPresent(with: HealthClientTypes.Event.read(from:))
        value.eventDescription = try reader["eventDescription"].readIfPresent(with: HealthClientTypes.EventDescription.read(from:))
        value.eventMetadata = try reader["eventMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension HealthClientTypes.OrganizationEventDetailsErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.OrganizationEventDetailsErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.OrganizationEventDetailsErrorItem()
        value.awsAccountId = try reader["awsAccountId"].readIfPresent()
        value.eventArn = try reader["eventArn"].readIfPresent()
        value.errorName = try reader["errorName"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.OrganizationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.OrganizationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.OrganizationEvent()
        value.arn = try reader["arn"].readIfPresent()
        value.service = try reader["service"].readIfPresent()
        value.eventTypeCode = try reader["eventTypeCode"].readIfPresent()
        value.eventTypeCategory = try reader["eventTypeCategory"].readIfPresent()
        value.eventScopeCode = try reader["eventScopeCode"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.EventType {

    static func read(from reader: SmithyJSON.Reader) throws -> HealthClientTypes.EventType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = HealthClientTypes.EventType()
        value.service = try reader["service"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        return value
    }
}

extension HealthClientTypes.EntityFilter {

    static func write(value: HealthClientTypes.EntityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityArns"].writeList(value.entityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["entityValues"].writeList(value.entityValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventArns"].writeList(value.eventArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastUpdatedTimes"].writeList(value.lastUpdatedTimes, memberWritingClosure: HealthClientTypes.DateTimeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["statusCodes"].writeList(value.statusCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EntityStatusCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }
}

extension HealthClientTypes.DateTimeRange {

    static func write(value: HealthClientTypes.DateTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["from"].writeTimestamp(value.from, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["to"].writeTimestamp(value.to, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension HealthClientTypes.EventAccountFilter {

    static func write(value: HealthClientTypes.EventAccountFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["eventArn"].write(value.eventArn)
    }
}

extension HealthClientTypes.EntityAccountFilter {

    static func write(value: HealthClientTypes.EntityAccountFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountId"].write(value.awsAccountId)
        try writer["eventArn"].write(value.eventArn)
        try writer["statusCodes"].writeList(value.statusCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EntityStatusCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension HealthClientTypes.EventFilter {

    static func write(value: HealthClientTypes.EventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["availabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["endTimes"].writeList(value.endTimes, memberWritingClosure: HealthClientTypes.DateTimeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["entityArns"].writeList(value.entityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["entityValues"].writeList(value.entityValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventArns"].writeList(value.eventArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventStatusCodes"].writeList(value.eventStatusCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EventStatusCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTypeCategories"].writeList(value.eventTypeCategories, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EventTypeCategory>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTypeCodes"].writeList(value.eventTypeCodes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastUpdatedTimes"].writeList(value.lastUpdatedTimes, memberWritingClosure: HealthClientTypes.DateTimeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTimes"].writeList(value.startTimes, memberWritingClosure: HealthClientTypes.DateTimeRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
    }
}

extension HealthClientTypes.OrganizationEventFilter {

    static func write(value: HealthClientTypes.OrganizationEventFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awsAccountIds"].writeList(value.awsAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["endTime"].write(value.endTime, with: HealthClientTypes.DateTimeRange.write(value:to:))
        try writer["entityArns"].writeList(value.entityArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["entityValues"].writeList(value.entityValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventStatusCodes"].writeList(value.eventStatusCodes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EventStatusCode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTypeCategories"].writeList(value.eventTypeCategories, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EventTypeCategory>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTypeCodes"].writeList(value.eventTypeCodes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["lastUpdatedTime"].write(value.lastUpdatedTime, with: HealthClientTypes.DateTimeRange.write(value:to:))
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startTime"].write(value.startTime, with: HealthClientTypes.DateTimeRange.write(value:to:))
    }
}

extension HealthClientTypes.EventTypeFilter {

    static func write(value: HealthClientTypes.EventTypeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTypeCategories"].writeList(value.eventTypeCategories, memberWritingClosure: SmithyReadWrite.WritingClosureBox<HealthClientTypes.EventTypeCategory>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventTypeCodes"].writeList(value.eventTypeCodes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum HealthClientTypes {}
