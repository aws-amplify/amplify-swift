//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension HealthClient {
    /// Paginate over `[DescribeAffectedAccountsForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAffectedAccountsForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedAccountsForOrganizationOutput`
    public func describeAffectedAccountsForOrganizationPaginated(input: DescribeAffectedAccountsForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedAccountsForOrganizationInput, DescribeAffectedAccountsForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedAccountsForOrganizationInput, DescribeAffectedAccountsForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAffectedAccountsForOrganization(input:))
    }
}

extension DescribeAffectedAccountsForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedAccountsForOrganizationInput {
        return DescribeAffectedAccountsForOrganizationInput(
            eventArn: self.eventArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAffectedAccountsForOrganizationInput, OperationStackOutput == DescribeAffectedAccountsForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAffectedAccountsForOrganizationPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func affectedAccounts() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.affectedAccounts }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeAffectedEntitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAffectedEntitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedEntitiesOutput`
    public func describeAffectedEntitiesPaginated(input: DescribeAffectedEntitiesInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesInput, DescribeAffectedEntitiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesInput, DescribeAffectedEntitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAffectedEntities(input:))
    }
}

extension DescribeAffectedEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedEntitiesInput {
        return DescribeAffectedEntitiesInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAffectedEntitiesInput, OperationStackOutput == DescribeAffectedEntitiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAffectedEntitiesPaginated`
    /// to access the nested member `[HealthClientTypes.AffectedEntity]`
    /// - Returns: `[HealthClientTypes.AffectedEntity]`
    public func entities() async throws -> [HealthClientTypes.AffectedEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeAffectedEntitiesForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAffectedEntitiesForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAffectedEntitiesForOrganizationOutput`
    public func describeAffectedEntitiesForOrganizationPaginated(input: DescribeAffectedEntitiesForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesForOrganizationInput, DescribeAffectedEntitiesForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAffectedEntitiesForOrganizationInput, DescribeAffectedEntitiesForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAffectedEntitiesForOrganization(input:))
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAffectedEntitiesForOrganizationInput {
        return DescribeAffectedEntitiesForOrganizationInput(
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            organizationEntityAccountFilters: self.organizationEntityAccountFilters,
            organizationEntityFilters: self.organizationEntityFilters
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAffectedEntitiesForOrganizationInput, OperationStackOutput == DescribeAffectedEntitiesForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAffectedEntitiesForOrganizationPaginated`
    /// to access the nested member `[HealthClientTypes.AffectedEntity]`
    /// - Returns: `[HealthClientTypes.AffectedEntity]`
    public func entities() async throws -> [HealthClientTypes.AffectedEntity] {
        return try await self.asyncCompactMap { item in item.entities }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeEventAggregatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventAggregatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventAggregatesOutput`
    public func describeEventAggregatesPaginated(input: DescribeEventAggregatesInput) -> ClientRuntime.PaginatorSequence<DescribeEventAggregatesInput, DescribeEventAggregatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventAggregatesInput, DescribeEventAggregatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEventAggregates(input:))
    }
}

extension DescribeEventAggregatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventAggregatesInput {
        return DescribeEventAggregatesInput(
            aggregateField: self.aggregateField,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventAggregatesInput, OperationStackOutput == DescribeEventAggregatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventAggregatesPaginated`
    /// to access the nested member `[HealthClientTypes.EventAggregate]`
    /// - Returns: `[HealthClientTypes.EventAggregate]`
    public func eventAggregates() async throws -> [HealthClientTypes.EventAggregate] {
        return try await self.asyncCompactMap { item in item.eventAggregates }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutput`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventsInput, OperationStackOutput == DescribeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[HealthClientTypes.Event]`
    /// - Returns: `[HealthClientTypes.Event]`
    public func events() async throws -> [HealthClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeEventsForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsForOrganizationOutput`
    public func describeEventsForOrganizationPaginated(input: DescribeEventsForOrganizationInput) -> ClientRuntime.PaginatorSequence<DescribeEventsForOrganizationInput, DescribeEventsForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsForOrganizationInput, DescribeEventsForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEventsForOrganization(input:))
    }
}

extension DescribeEventsForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsForOrganizationInput {
        return DescribeEventsForOrganizationInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventsForOrganizationInput, OperationStackOutput == DescribeEventsForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsForOrganizationPaginated`
    /// to access the nested member `[HealthClientTypes.OrganizationEvent]`
    /// - Returns: `[HealthClientTypes.OrganizationEvent]`
    public func events() async throws -> [HealthClientTypes.OrganizationEvent] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension HealthClient {
    /// Paginate over `[DescribeEventTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventTypesOutput`
    public func describeEventTypesPaginated(input: DescribeEventTypesInput) -> ClientRuntime.PaginatorSequence<DescribeEventTypesInput, DescribeEventTypesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventTypesInput, DescribeEventTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEventTypes(input:))
    }
}

extension DescribeEventTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventTypesInput {
        return DescribeEventTypesInput(
            filter: self.filter,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventTypesInput, OperationStackOutput == DescribeEventTypesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventTypesPaginated`
    /// to access the nested member `[HealthClientTypes.EventType]`
    /// - Returns: `[HealthClientTypes.EventType]`
    public func eventTypes() async throws -> [HealthClientTypes.EventType] {
        return try await self.asyncCompactMap { item in item.eventTypes }
    }
}
