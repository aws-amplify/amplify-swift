//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension LookoutEquipmentClient {
    /// Paginate over `[ListDataIngestionJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataIngestionJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataIngestionJobsOutput`
    public func listDataIngestionJobsPaginated(input: ListDataIngestionJobsInput) -> ClientRuntime.PaginatorSequence<ListDataIngestionJobsInput, ListDataIngestionJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataIngestionJobsInput, ListDataIngestionJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataIngestionJobs(input:))
    }
}

extension ListDataIngestionJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataIngestionJobsInput {
        return ListDataIngestionJobsInput(
            datasetName: self.datasetName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListDatasetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetsOutput`
    public func listDatasetsPaginated(input: ListDatasetsInput) -> ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasets(input:))
    }
}

extension ListDatasetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetsInput {
        return ListDatasetsInput(
            datasetNameBeginsWith: self.datasetNameBeginsWith,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListInferenceEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceEventsOutput`
    public func listInferenceEventsPaginated(input: ListInferenceEventsInput) -> ClientRuntime.PaginatorSequence<ListInferenceEventsInput, ListInferenceEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceEventsInput, ListInferenceEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceEvents(input:))
    }
}

extension ListInferenceEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceEventsInput {
        return ListInferenceEventsInput(
            inferenceSchedulerName: self.inferenceSchedulerName,
            intervalEndTime: self.intervalEndTime,
            intervalStartTime: self.intervalStartTime,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListInferenceExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceExecutionsOutput`
    public func listInferenceExecutionsPaginated(input: ListInferenceExecutionsInput) -> ClientRuntime.PaginatorSequence<ListInferenceExecutionsInput, ListInferenceExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceExecutionsInput, ListInferenceExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceExecutions(input:))
    }
}

extension ListInferenceExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceExecutionsInput {
        return ListInferenceExecutionsInput(
            dataEndTimeBefore: self.dataEndTimeBefore,
            dataStartTimeAfter: self.dataStartTimeAfter,
            inferenceSchedulerName: self.inferenceSchedulerName,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListInferenceSchedulersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInferenceSchedulersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInferenceSchedulersOutput`
    public func listInferenceSchedulersPaginated(input: ListInferenceSchedulersInput) -> ClientRuntime.PaginatorSequence<ListInferenceSchedulersInput, ListInferenceSchedulersOutput> {
        return ClientRuntime.PaginatorSequence<ListInferenceSchedulersInput, ListInferenceSchedulersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInferenceSchedulers(input:))
    }
}

extension ListInferenceSchedulersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInferenceSchedulersInput {
        return ListInferenceSchedulersInput(
            inferenceSchedulerNameBeginsWith: self.inferenceSchedulerNameBeginsWith,
            maxResults: self.maxResults,
            modelName: self.modelName,
            nextToken: token,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListLabelGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLabelGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLabelGroupsOutput`
    public func listLabelGroupsPaginated(input: ListLabelGroupsInput) -> ClientRuntime.PaginatorSequence<ListLabelGroupsInput, ListLabelGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListLabelGroupsInput, ListLabelGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLabelGroups(input:))
    }
}

extension ListLabelGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelGroupsInput {
        return ListLabelGroupsInput(
            labelGroupNameBeginsWith: self.labelGroupNameBeginsWith,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListLabelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLabelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLabelsOutput`
    public func listLabelsPaginated(input: ListLabelsInput) -> ClientRuntime.PaginatorSequence<ListLabelsInput, ListLabelsOutput> {
        return ClientRuntime.PaginatorSequence<ListLabelsInput, ListLabelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLabels(input:))
    }
}

extension ListLabelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLabelsInput {
        return ListLabelsInput(
            equipment: self.equipment,
            faultCode: self.faultCode,
            intervalEndTime: self.intervalEndTime,
            intervalStartTime: self.intervalStartTime,
            labelGroupName: self.labelGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelsOutput`
    public func listModelsPaginated(input: ListModelsInput) -> ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelsInput, ListModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModels(input:))
    }
}

extension ListModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelsInput {
        return ListModelsInput(
            datasetNameBeginsWith: self.datasetNameBeginsWith,
            maxResults: self.maxResults,
            modelNameBeginsWith: self.modelNameBeginsWith,
            nextToken: token,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListModelVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListModelVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListModelVersionsOutput`
    public func listModelVersionsPaginated(input: ListModelVersionsInput) -> ClientRuntime.PaginatorSequence<ListModelVersionsInput, ListModelVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListModelVersionsInput, ListModelVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listModelVersions(input:))
    }
}

extension ListModelVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListModelVersionsInput {
        return ListModelVersionsInput(
            createdAtEndTime: self.createdAtEndTime,
            createdAtStartTime: self.createdAtStartTime,
            maxModelVersion: self.maxModelVersion,
            maxResults: self.maxResults,
            minModelVersion: self.minModelVersion,
            modelName: self.modelName,
            nextToken: token,
            sourceType: self.sourceType,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListRetrainingSchedulersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRetrainingSchedulersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRetrainingSchedulersOutput`
    public func listRetrainingSchedulersPaginated(input: ListRetrainingSchedulersInput) -> ClientRuntime.PaginatorSequence<ListRetrainingSchedulersInput, ListRetrainingSchedulersOutput> {
        return ClientRuntime.PaginatorSequence<ListRetrainingSchedulersInput, ListRetrainingSchedulersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRetrainingSchedulers(input:))
    }
}

extension ListRetrainingSchedulersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRetrainingSchedulersInput {
        return ListRetrainingSchedulersInput(
            maxResults: self.maxResults,
            modelNameBeginsWith: self.modelNameBeginsWith,
            nextToken: token,
            status: self.status
        )}
}
extension LookoutEquipmentClient {
    /// Paginate over `[ListSensorStatisticsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSensorStatisticsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSensorStatisticsOutput`
    public func listSensorStatisticsPaginated(input: ListSensorStatisticsInput) -> ClientRuntime.PaginatorSequence<ListSensorStatisticsInput, ListSensorStatisticsOutput> {
        return ClientRuntime.PaginatorSequence<ListSensorStatisticsInput, ListSensorStatisticsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSensorStatistics(input:))
    }
}

extension ListSensorStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSensorStatisticsInput {
        return ListSensorStatisticsInput(
            datasetName: self.datasetName,
            ingestionJobId: self.ingestionJobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
