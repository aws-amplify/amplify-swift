//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension RDSClient {
    /// Paginate over `[DescribeBlueGreenDeploymentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBlueGreenDeploymentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBlueGreenDeploymentsOutput`
    public func describeBlueGreenDeploymentsPaginated(input: DescribeBlueGreenDeploymentsInput) -> ClientRuntime.PaginatorSequence<DescribeBlueGreenDeploymentsInput, DescribeBlueGreenDeploymentsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBlueGreenDeploymentsInput, DescribeBlueGreenDeploymentsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeBlueGreenDeployments(input:))
    }
}

extension DescribeBlueGreenDeploymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBlueGreenDeploymentsInput {
        return DescribeBlueGreenDeploymentsInput(
            blueGreenDeploymentIdentifier: self.blueGreenDeploymentIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBlueGreenDeploymentsInput, OperationStackOutput == DescribeBlueGreenDeploymentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBlueGreenDeploymentsPaginated`
    /// to access the nested member `[RDSClientTypes.BlueGreenDeployment]`
    /// - Returns: `[RDSClientTypes.BlueGreenDeployment]`
    public func blueGreenDeployments() async throws -> [RDSClientTypes.BlueGreenDeployment] {
        return try await self.asyncCompactMap { item in item.blueGreenDeployments }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeCertificatesOutput`
    public func describeCertificatesPaginated(input: DescribeCertificatesInput) -> ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeCertificatesInput, DescribeCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeCertificates(input:))
    }
}

extension DescribeCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCertificatesInput {
        return DescribeCertificatesInput(
            certificateIdentifier: self.certificateIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeCertificatesInput, OperationStackOutput == DescribeCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeCertificatesPaginated`
    /// to access the nested member `[RDSClientTypes.Certificate]`
    /// - Returns: `[RDSClientTypes.Certificate]`
    public func certificates() async throws -> [RDSClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterAutomatedBackupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterAutomatedBackupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterAutomatedBackupsOutput`
    public func describeDBClusterAutomatedBackupsPaginated(input: DescribeDBClusterAutomatedBackupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterAutomatedBackupsInput, DescribeDBClusterAutomatedBackupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterAutomatedBackupsInput, DescribeDBClusterAutomatedBackupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterAutomatedBackups(input:))
    }
}

extension DescribeDBClusterAutomatedBackupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterAutomatedBackupsInput {
        return DescribeDBClusterAutomatedBackupsInput(
            dbClusterIdentifier: self.dbClusterIdentifier,
            dbClusterResourceId: self.dbClusterResourceId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterAutomatedBackupsInput, OperationStackOutput == DescribeDBClusterAutomatedBackupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterAutomatedBackupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBClusterAutomatedBackup]`
    /// - Returns: `[RDSClientTypes.DBClusterAutomatedBackup]`
    public func dbClusterAutomatedBackups() async throws -> [RDSClientTypes.DBClusterAutomatedBackup] {
        return try await self.asyncCompactMap { item in item.dbClusterAutomatedBackups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterBacktracksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterBacktracksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterBacktracksOutput`
    public func describeDBClusterBacktracksPaginated(input: DescribeDBClusterBacktracksInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterBacktracksInput, DescribeDBClusterBacktracksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterBacktracksInput, DescribeDBClusterBacktracksOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterBacktracks(input:))
    }
}

extension DescribeDBClusterBacktracksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterBacktracksInput {
        return DescribeDBClusterBacktracksInput(
            backtrackIdentifier: self.backtrackIdentifier,
            dbClusterIdentifier: self.dbClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterBacktracksInput, OperationStackOutput == DescribeDBClusterBacktracksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterBacktracksPaginated`
    /// to access the nested member `[RDSClientTypes.DBClusterBacktrack]`
    /// - Returns: `[RDSClientTypes.DBClusterBacktrack]`
    public func dbClusterBacktracks() async throws -> [RDSClientTypes.DBClusterBacktrack] {
        return try await self.asyncCompactMap { item in item.dbClusterBacktracks }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterEndpointsOutput`
    public func describeDBClusterEndpointsPaginated(input: DescribeDBClusterEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterEndpointsInput, DescribeDBClusterEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterEndpointsInput, DescribeDBClusterEndpointsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterEndpoints(input:))
    }
}

extension DescribeDBClusterEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterEndpointsInput {
        return DescribeDBClusterEndpointsInput(
            dbClusterEndpointIdentifier: self.dbClusterEndpointIdentifier,
            dbClusterIdentifier: self.dbClusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterEndpointsInput, OperationStackOutput == DescribeDBClusterEndpointsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterEndpointsPaginated`
    /// to access the nested member `[RDSClientTypes.DBClusterEndpoint]`
    /// - Returns: `[RDSClientTypes.DBClusterEndpoint]`
    public func dbClusterEndpoints() async throws -> [RDSClientTypes.DBClusterEndpoint] {
        return try await self.asyncCompactMap { item in item.dbClusterEndpoints }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterParameterGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterParameterGroupsOutput`
    public func describeDBClusterParameterGroupsPaginated(input: DescribeDBClusterParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterParameterGroupsInput, DescribeDBClusterParameterGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterParameterGroupsInput, DescribeDBClusterParameterGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterParameterGroups(input:))
    }
}

extension DescribeDBClusterParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterParameterGroupsInput {
        return DescribeDBClusterParameterGroupsInput(
            dbClusterParameterGroupName: self.dbClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterParameterGroupsInput, OperationStackOutput == DescribeDBClusterParameterGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterParameterGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBClusterParameterGroup]`
    /// - Returns: `[RDSClientTypes.DBClusterParameterGroup]`
    public func dbClusterParameterGroups() async throws -> [RDSClientTypes.DBClusterParameterGroup] {
        return try await self.asyncCompactMap { item in item.dbClusterParameterGroups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterParametersOutput`
    public func describeDBClusterParametersPaginated(input: DescribeDBClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterParametersInput, DescribeDBClusterParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterParametersInput, DescribeDBClusterParametersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterParameters(input:))
    }
}

extension DescribeDBClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterParametersInput {
        return DescribeDBClusterParametersInput(
            dbClusterParameterGroupName: self.dbClusterParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterParametersInput, OperationStackOutput == DescribeDBClusterParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterParametersPaginated`
    /// to access the nested member `[RDSClientTypes.Parameter]`
    /// - Returns: `[RDSClientTypes.Parameter]`
    public func parameters() async throws -> [RDSClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClustersOutput`
    public func describeDBClustersPaginated(input: DescribeDBClustersInput) -> ClientRuntime.PaginatorSequence<DescribeDBClustersInput, DescribeDBClustersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClustersInput, DescribeDBClustersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusters(input:))
    }
}

extension DescribeDBClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClustersInput {
        return DescribeDBClustersInput(
            dbClusterIdentifier: self.dbClusterIdentifier,
            filters: self.filters,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClustersInput, OperationStackOutput == DescribeDBClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClustersPaginated`
    /// to access the nested member `[RDSClientTypes.DBCluster]`
    /// - Returns: `[RDSClientTypes.DBCluster]`
    public func dbClusters() async throws -> [RDSClientTypes.DBCluster] {
        return try await self.asyncCompactMap { item in item.dbClusters }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBClusterSnapshotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBClusterSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBClusterSnapshotsOutput`
    public func describeDBClusterSnapshotsPaginated(input: DescribeDBClusterSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeDBClusterSnapshotsInput, DescribeDBClusterSnapshotsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBClusterSnapshotsInput, DescribeDBClusterSnapshotsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBClusterSnapshots(input:))
    }
}

extension DescribeDBClusterSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBClusterSnapshotsInput {
        return DescribeDBClusterSnapshotsInput(
            dbClusterIdentifier: self.dbClusterIdentifier,
            dbClusterResourceId: self.dbClusterResourceId,
            dbClusterSnapshotIdentifier: self.dbClusterSnapshotIdentifier,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBClusterSnapshotsInput, OperationStackOutput == DescribeDBClusterSnapshotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBClusterSnapshotsPaginated`
    /// to access the nested member `[RDSClientTypes.DBClusterSnapshot]`
    /// - Returns: `[RDSClientTypes.DBClusterSnapshot]`
    public func dbClusterSnapshots() async throws -> [RDSClientTypes.DBClusterSnapshot] {
        return try await self.asyncCompactMap { item in item.dbClusterSnapshots }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBEngineVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBEngineVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBEngineVersionsOutput`
    public func describeDBEngineVersionsPaginated(input: DescribeDBEngineVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeDBEngineVersionsInput, DescribeDBEngineVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBEngineVersionsInput, DescribeDBEngineVersionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBEngineVersions(input:))
    }
}

extension DescribeDBEngineVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBEngineVersionsInput {
        return DescribeDBEngineVersionsInput(
            dbParameterGroupFamily: self.dbParameterGroupFamily,
            defaultOnly: self.defaultOnly,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            includeAll: self.includeAll,
            listSupportedCharacterSets: self.listSupportedCharacterSets,
            listSupportedTimezones: self.listSupportedTimezones,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBEngineVersionsInput, OperationStackOutput == DescribeDBEngineVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBEngineVersionsPaginated`
    /// to access the nested member `[RDSClientTypes.DBEngineVersion]`
    /// - Returns: `[RDSClientTypes.DBEngineVersion]`
    public func dbEngineVersions() async throws -> [RDSClientTypes.DBEngineVersion] {
        return try await self.asyncCompactMap { item in item.dbEngineVersions }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBInstanceAutomatedBackupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBInstanceAutomatedBackupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBInstanceAutomatedBackupsOutput`
    public func describeDBInstanceAutomatedBackupsPaginated(input: DescribeDBInstanceAutomatedBackupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBInstanceAutomatedBackupsInput, DescribeDBInstanceAutomatedBackupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBInstanceAutomatedBackupsInput, DescribeDBInstanceAutomatedBackupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBInstanceAutomatedBackups(input:))
    }
}

extension DescribeDBInstanceAutomatedBackupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBInstanceAutomatedBackupsInput {
        return DescribeDBInstanceAutomatedBackupsInput(
            dbInstanceAutomatedBackupsArn: self.dbInstanceAutomatedBackupsArn,
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBInstanceAutomatedBackupsInput, OperationStackOutput == DescribeDBInstanceAutomatedBackupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBInstanceAutomatedBackupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBInstanceAutomatedBackup]`
    /// - Returns: `[RDSClientTypes.DBInstanceAutomatedBackup]`
    public func dbInstanceAutomatedBackups() async throws -> [RDSClientTypes.DBInstanceAutomatedBackup] {
        return try await self.asyncCompactMap { item in item.dbInstanceAutomatedBackups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBInstancesOutput`
    public func describeDBInstancesPaginated(input: DescribeDBInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeDBInstancesInput, DescribeDBInstancesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBInstancesInput, DescribeDBInstancesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBInstances(input:))
    }
}

extension DescribeDBInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBInstancesInput {
        return DescribeDBInstancesInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBInstancesInput, OperationStackOutput == DescribeDBInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBInstancesPaginated`
    /// to access the nested member `[RDSClientTypes.DBInstance]`
    /// - Returns: `[RDSClientTypes.DBInstance]`
    public func dbInstances() async throws -> [RDSClientTypes.DBInstance] {
        return try await self.asyncCompactMap { item in item.dbInstances }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBLogFilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBLogFilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBLogFilesOutput`
    public func describeDBLogFilesPaginated(input: DescribeDBLogFilesInput) -> ClientRuntime.PaginatorSequence<DescribeDBLogFilesInput, DescribeDBLogFilesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBLogFilesInput, DescribeDBLogFilesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBLogFiles(input:))
    }
}

extension DescribeDBLogFilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBLogFilesInput {
        return DescribeDBLogFilesInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            fileLastWritten: self.fileLastWritten,
            fileSize: self.fileSize,
            filenameContains: self.filenameContains,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBLogFilesInput, OperationStackOutput == DescribeDBLogFilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBLogFilesPaginated`
    /// to access the nested member `[RDSClientTypes.DescribeDBLogFilesDetails]`
    /// - Returns: `[RDSClientTypes.DescribeDBLogFilesDetails]`
    public func describeDBLogFiles() async throws -> [RDSClientTypes.DescribeDBLogFilesDetails] {
        return try await self.asyncCompactMap { item in item.describeDBLogFiles }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBParameterGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBParameterGroupsOutput`
    public func describeDBParameterGroupsPaginated(input: DescribeDBParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBParameterGroupsInput, DescribeDBParameterGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBParameterGroupsInput, DescribeDBParameterGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBParameterGroups(input:))
    }
}

extension DescribeDBParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBParameterGroupsInput {
        return DescribeDBParameterGroupsInput(
            dbParameterGroupName: self.dbParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBParameterGroupsInput, OperationStackOutput == DescribeDBParameterGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBParameterGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBParameterGroup]`
    /// - Returns: `[RDSClientTypes.DBParameterGroup]`
    public func dbParameterGroups() async throws -> [RDSClientTypes.DBParameterGroup] {
        return try await self.asyncCompactMap { item in item.dbParameterGroups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBParametersOutput`
    public func describeDBParametersPaginated(input: DescribeDBParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDBParametersInput, DescribeDBParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBParametersInput, DescribeDBParametersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBParameters(input:))
    }
}

extension DescribeDBParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBParametersInput {
        return DescribeDBParametersInput(
            dbParameterGroupName: self.dbParameterGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            source: self.source
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBParametersInput, OperationStackOutput == DescribeDBParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBParametersPaginated`
    /// to access the nested member `[RDSClientTypes.Parameter]`
    /// - Returns: `[RDSClientTypes.Parameter]`
    public func parameters() async throws -> [RDSClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBProxiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBProxiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxiesOutput`
    public func describeDBProxiesPaginated(input: DescribeDBProxiesInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxiesInput, DescribeDBProxiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxiesInput, DescribeDBProxiesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBProxies(input:))
    }
}

extension DescribeDBProxiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxiesInput {
        return DescribeDBProxiesInput(
            dbProxyName: self.dbProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBProxiesInput, OperationStackOutput == DescribeDBProxiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBProxiesPaginated`
    /// to access the nested member `[RDSClientTypes.DBProxy]`
    /// - Returns: `[RDSClientTypes.DBProxy]`
    public func dbProxies() async throws -> [RDSClientTypes.DBProxy] {
        return try await self.asyncCompactMap { item in item.dbProxies }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBProxyEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBProxyEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyEndpointsOutput`
    public func describeDBProxyEndpointsPaginated(input: DescribeDBProxyEndpointsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyEndpointsInput, DescribeDBProxyEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyEndpointsInput, DescribeDBProxyEndpointsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBProxyEndpoints(input:))
    }
}

extension DescribeDBProxyEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyEndpointsInput {
        return DescribeDBProxyEndpointsInput(
            dbProxyEndpointName: self.dbProxyEndpointName,
            dbProxyName: self.dbProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBProxyEndpointsInput, OperationStackOutput == DescribeDBProxyEndpointsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBProxyEndpointsPaginated`
    /// to access the nested member `[RDSClientTypes.DBProxyEndpoint]`
    /// - Returns: `[RDSClientTypes.DBProxyEndpoint]`
    public func dbProxyEndpoints() async throws -> [RDSClientTypes.DBProxyEndpoint] {
        return try await self.asyncCompactMap { item in item.dbProxyEndpoints }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBProxyTargetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBProxyTargetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyTargetGroupsOutput`
    public func describeDBProxyTargetGroupsPaginated(input: DescribeDBProxyTargetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyTargetGroupsInput, DescribeDBProxyTargetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyTargetGroupsInput, DescribeDBProxyTargetGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBProxyTargetGroups(input:))
    }
}

extension DescribeDBProxyTargetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyTargetGroupsInput {
        return DescribeDBProxyTargetGroupsInput(
            dbProxyName: self.dbProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBProxyTargetGroupsInput, OperationStackOutput == DescribeDBProxyTargetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBProxyTargetGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBProxyTargetGroup]`
    /// - Returns: `[RDSClientTypes.DBProxyTargetGroup]`
    public func targetGroups() async throws -> [RDSClientTypes.DBProxyTargetGroup] {
        return try await self.asyncCompactMap { item in item.targetGroups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBProxyTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBProxyTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBProxyTargetsOutput`
    public func describeDBProxyTargetsPaginated(input: DescribeDBProxyTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeDBProxyTargetsInput, DescribeDBProxyTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBProxyTargetsInput, DescribeDBProxyTargetsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBProxyTargets(input:))
    }
}

extension DescribeDBProxyTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBProxyTargetsInput {
        return DescribeDBProxyTargetsInput(
            dbProxyName: self.dbProxyName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            targetGroupName: self.targetGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBProxyTargetsInput, OperationStackOutput == DescribeDBProxyTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBProxyTargetsPaginated`
    /// to access the nested member `[RDSClientTypes.DBProxyTarget]`
    /// - Returns: `[RDSClientTypes.DBProxyTarget]`
    public func targets() async throws -> [RDSClientTypes.DBProxyTarget] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBRecommendationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBRecommendationsOutput`
    public func describeDBRecommendationsPaginated(input: DescribeDBRecommendationsInput) -> ClientRuntime.PaginatorSequence<DescribeDBRecommendationsInput, DescribeDBRecommendationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBRecommendationsInput, DescribeDBRecommendationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBRecommendations(input:))
    }
}

extension DescribeDBRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBRecommendationsInput {
        return DescribeDBRecommendationsInput(
            filters: self.filters,
            lastUpdatedAfter: self.lastUpdatedAfter,
            lastUpdatedBefore: self.lastUpdatedBefore,
            locale: self.locale,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBRecommendationsInput, OperationStackOutput == DescribeDBRecommendationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBRecommendationsPaginated`
    /// to access the nested member `[RDSClientTypes.DBRecommendation]`
    /// - Returns: `[RDSClientTypes.DBRecommendation]`
    public func dbRecommendations() async throws -> [RDSClientTypes.DBRecommendation] {
        return try await self.asyncCompactMap { item in item.dbRecommendations }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBSecurityGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSecurityGroupsOutput`
    public func describeDBSecurityGroupsPaginated(input: DescribeDBSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSecurityGroupsInput, DescribeDBSecurityGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBSecurityGroupsInput, DescribeDBSecurityGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBSecurityGroups(input:))
    }
}

extension DescribeDBSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSecurityGroupsInput {
        return DescribeDBSecurityGroupsInput(
            dbSecurityGroupName: self.dbSecurityGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBSecurityGroupsInput, OperationStackOutput == DescribeDBSecurityGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBSecurityGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBSecurityGroup]`
    /// - Returns: `[RDSClientTypes.DBSecurityGroup]`
    public func dbSecurityGroups() async throws -> [RDSClientTypes.DBSecurityGroup] {
        return try await self.asyncCompactMap { item in item.dbSecurityGroups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBSnapshotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSnapshotsOutput`
    public func describeDBSnapshotsPaginated(input: DescribeDBSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSnapshotsInput, DescribeDBSnapshotsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBSnapshotsInput, DescribeDBSnapshotsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBSnapshots(input:))
    }
}

extension DescribeDBSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSnapshotsInput {
        return DescribeDBSnapshotsInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            dbSnapshotIdentifier: self.dbSnapshotIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            includePublic: self.includePublic,
            includeShared: self.includeShared,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBSnapshotsInput, OperationStackOutput == DescribeDBSnapshotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBSnapshotsPaginated`
    /// to access the nested member `[RDSClientTypes.DBSnapshot]`
    /// - Returns: `[RDSClientTypes.DBSnapshot]`
    public func dbSnapshots() async throws -> [RDSClientTypes.DBSnapshot] {
        return try await self.asyncCompactMap { item in item.dbSnapshots }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBSnapshotTenantDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBSnapshotTenantDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSnapshotTenantDatabasesOutput`
    public func describeDBSnapshotTenantDatabasesPaginated(input: DescribeDBSnapshotTenantDatabasesInput) -> ClientRuntime.PaginatorSequence<DescribeDBSnapshotTenantDatabasesInput, DescribeDBSnapshotTenantDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBSnapshotTenantDatabasesInput, DescribeDBSnapshotTenantDatabasesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBSnapshotTenantDatabases(input:))
    }
}

extension DescribeDBSnapshotTenantDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSnapshotTenantDatabasesInput {
        return DescribeDBSnapshotTenantDatabasesInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            dbSnapshotIdentifier: self.dbSnapshotIdentifier,
            dbiResourceId: self.dbiResourceId,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotType: self.snapshotType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBSnapshotTenantDatabasesInput, OperationStackOutput == DescribeDBSnapshotTenantDatabasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBSnapshotTenantDatabasesPaginated`
    /// to access the nested member `[RDSClientTypes.DBSnapshotTenantDatabase]`
    /// - Returns: `[RDSClientTypes.DBSnapshotTenantDatabase]`
    public func dbSnapshotTenantDatabases() async throws -> [RDSClientTypes.DBSnapshotTenantDatabase] {
        return try await self.asyncCompactMap { item in item.dbSnapshotTenantDatabases }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeDBSubnetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDBSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDBSubnetGroupsOutput`
    public func describeDBSubnetGroupsPaginated(input: DescribeDBSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeDBSubnetGroupsInput, DescribeDBSubnetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDBSubnetGroupsInput, DescribeDBSubnetGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDBSubnetGroups(input:))
    }
}

extension DescribeDBSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDBSubnetGroupsInput {
        return DescribeDBSubnetGroupsInput(
            dbSubnetGroupName: self.dbSubnetGroupName,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDBSubnetGroupsInput, OperationStackOutput == DescribeDBSubnetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDBSubnetGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.DBSubnetGroup]`
    /// - Returns: `[RDSClientTypes.DBSubnetGroup]`
    public func dbSubnetGroups() async throws -> [RDSClientTypes.DBSubnetGroup] {
        return try await self.asyncCompactMap { item in item.dbSubnetGroups }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeEngineDefaultParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEngineDefaultParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEngineDefaultParametersOutput`
    public func describeEngineDefaultParametersPaginated(input: DescribeEngineDefaultParametersInput) -> ClientRuntime.PaginatorSequence<DescribeEngineDefaultParametersInput, DescribeEngineDefaultParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEngineDefaultParametersInput, DescribeEngineDefaultParametersOutput>(input: input, inputKey: \.marker, outputKey: \.engineDefaults?.marker, paginationFunction: self.describeEngineDefaultParameters(input:))
    }
}

extension DescribeEngineDefaultParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEngineDefaultParametersInput {
        return DescribeEngineDefaultParametersInput(
            dbParameterGroupFamily: self.dbParameterGroupFamily,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEngineDefaultParametersInput, OperationStackOutput == DescribeEngineDefaultParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEngineDefaultParametersPaginated`
    /// to access the nested member `[RDSClientTypes.Parameter]`
    /// - Returns: `[RDSClientTypes.Parameter]`
    public func parameters() async throws -> [RDSClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.engineDefaults?.parameters }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutput`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            eventCategories: self.eventCategories,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventsInput, OperationStackOutput == DescribeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[RDSClientTypes.Event]`
    /// - Returns: `[RDSClientTypes.Event]`
    public func events() async throws -> [RDSClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeEventSubscriptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventSubscriptionsOutput`
    public func describeEventSubscriptionsPaginated(input: DescribeEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEventSubscriptions(input:))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventSubscriptionsInput {
        return DescribeEventSubscriptionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventSubscriptionsInput, OperationStackOutput == DescribeEventSubscriptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventSubscriptionsPaginated`
    /// to access the nested member `[RDSClientTypes.EventSubscription]`
    /// - Returns: `[RDSClientTypes.EventSubscription]`
    public func eventSubscriptionsList() async throws -> [RDSClientTypes.EventSubscription] {
        return try await self.asyncCompactMap { item in item.eventSubscriptionsList }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeExportTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeExportTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeExportTasksOutput`
    public func describeExportTasksPaginated(input: DescribeExportTasksInput) -> ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeExportTasksInput, DescribeExportTasksOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeExportTasks(input:))
    }
}

extension DescribeExportTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeExportTasksInput {
        return DescribeExportTasksInput(
            exportTaskIdentifier: self.exportTaskIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            sourceArn: self.sourceArn,
            sourceType: self.sourceType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeExportTasksInput, OperationStackOutput == DescribeExportTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeExportTasksPaginated`
    /// to access the nested member `[RDSClientTypes.ExportTask]`
    /// - Returns: `[RDSClientTypes.ExportTask]`
    public func exportTasks() async throws -> [RDSClientTypes.ExportTask] {
        return try await self.asyncCompactMap { item in item.exportTasks }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeGlobalClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGlobalClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGlobalClustersOutput`
    public func describeGlobalClustersPaginated(input: DescribeGlobalClustersInput) -> ClientRuntime.PaginatorSequence<DescribeGlobalClustersInput, DescribeGlobalClustersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGlobalClustersInput, DescribeGlobalClustersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeGlobalClusters(input:))
    }
}

extension DescribeGlobalClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGlobalClustersInput {
        return DescribeGlobalClustersInput(
            filters: self.filters,
            globalClusterIdentifier: self.globalClusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGlobalClustersInput, OperationStackOutput == DescribeGlobalClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGlobalClustersPaginated`
    /// to access the nested member `[RDSClientTypes.GlobalCluster]`
    /// - Returns: `[RDSClientTypes.GlobalCluster]`
    public func globalClusters() async throws -> [RDSClientTypes.GlobalCluster] {
        return try await self.asyncCompactMap { item in item.globalClusters }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeIntegrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeIntegrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeIntegrationsOutput`
    public func describeIntegrationsPaginated(input: DescribeIntegrationsInput) -> ClientRuntime.PaginatorSequence<DescribeIntegrationsInput, DescribeIntegrationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeIntegrationsInput, DescribeIntegrationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeIntegrations(input:))
    }
}

extension DescribeIntegrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeIntegrationsInput {
        return DescribeIntegrationsInput(
            filters: self.filters,
            integrationIdentifier: self.integrationIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeIntegrationsInput, OperationStackOutput == DescribeIntegrationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeIntegrationsPaginated`
    /// to access the nested member `[RDSClientTypes.Integration]`
    /// - Returns: `[RDSClientTypes.Integration]`
    public func integrations() async throws -> [RDSClientTypes.Integration] {
        return try await self.asyncCompactMap { item in item.integrations }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeOptionGroupOptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOptionGroupOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOptionGroupOptionsOutput`
    public func describeOptionGroupOptionsPaginated(input: DescribeOptionGroupOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOptionGroupOptionsInput, DescribeOptionGroupOptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOptionGroupOptionsInput, DescribeOptionGroupOptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeOptionGroupOptions(input:))
    }
}

extension DescribeOptionGroupOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptionGroupOptionsInput {
        return DescribeOptionGroupOptionsInput(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOptionGroupOptionsInput, OperationStackOutput == DescribeOptionGroupOptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOptionGroupOptionsPaginated`
    /// to access the nested member `[RDSClientTypes.OptionGroupOption]`
    /// - Returns: `[RDSClientTypes.OptionGroupOption]`
    public func optionGroupOptions() async throws -> [RDSClientTypes.OptionGroupOption] {
        return try await self.asyncCompactMap { item in item.optionGroupOptions }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeOptionGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOptionGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOptionGroupsOutput`
    public func describeOptionGroupsPaginated(input: DescribeOptionGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeOptionGroupsInput, DescribeOptionGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOptionGroupsInput, DescribeOptionGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeOptionGroups(input:))
    }
}

extension DescribeOptionGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptionGroupsInput {
        return DescribeOptionGroupsInput(
            engineName: self.engineName,
            filters: self.filters,
            majorEngineVersion: self.majorEngineVersion,
            marker: token,
            maxRecords: self.maxRecords,
            optionGroupName: self.optionGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOptionGroupsInput, OperationStackOutput == DescribeOptionGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOptionGroupsPaginated`
    /// to access the nested member `[RDSClientTypes.OptionGroup]`
    /// - Returns: `[RDSClientTypes.OptionGroup]`
    public func optionGroupsList() async throws -> [RDSClientTypes.OptionGroup] {
        return try await self.asyncCompactMap { item in item.optionGroupsList }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeOrderableDBInstanceOptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOrderableDBInstanceOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOrderableDBInstanceOptionsOutput`
    public func describeOrderableDBInstanceOptionsPaginated(input: DescribeOrderableDBInstanceOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOrderableDBInstanceOptionsInput, DescribeOrderableDBInstanceOptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOrderableDBInstanceOptionsInput, DescribeOrderableDBInstanceOptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeOrderableDBInstanceOptions(input:))
    }
}

extension DescribeOrderableDBInstanceOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrderableDBInstanceOptionsInput {
        return DescribeOrderableDBInstanceOptionsInput(
            availabilityZoneGroup: self.availabilityZoneGroup,
            dbInstanceClass: self.dbInstanceClass,
            engine: self.engine,
            engineVersion: self.engineVersion,
            filters: self.filters,
            licenseModel: self.licenseModel,
            marker: token,
            maxRecords: self.maxRecords,
            vpc: self.vpc
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOrderableDBInstanceOptionsInput, OperationStackOutput == DescribeOrderableDBInstanceOptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOrderableDBInstanceOptionsPaginated`
    /// to access the nested member `[RDSClientTypes.OrderableDBInstanceOption]`
    /// - Returns: `[RDSClientTypes.OrderableDBInstanceOption]`
    public func orderableDBInstanceOptions() async throws -> [RDSClientTypes.OrderableDBInstanceOption] {
        return try await self.asyncCompactMap { item in item.orderableDBInstanceOptions }
    }
}
extension RDSClient {
    /// Paginate over `[DescribePendingMaintenanceActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePendingMaintenanceActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePendingMaintenanceActionsOutput`
    public func describePendingMaintenanceActionsPaginated(input: DescribePendingMaintenanceActionsInput) -> ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribePendingMaintenanceActionsInput, DescribePendingMaintenanceActionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describePendingMaintenanceActions(input:))
    }
}

extension DescribePendingMaintenanceActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePendingMaintenanceActionsInput {
        return DescribePendingMaintenanceActionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            resourceIdentifier: self.resourceIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePendingMaintenanceActionsInput, OperationStackOutput == DescribePendingMaintenanceActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePendingMaintenanceActionsPaginated`
    /// to access the nested member `[RDSClientTypes.ResourcePendingMaintenanceActions]`
    /// - Returns: `[RDSClientTypes.ResourcePendingMaintenanceActions]`
    public func pendingMaintenanceActions() async throws -> [RDSClientTypes.ResourcePendingMaintenanceActions] {
        return try await self.asyncCompactMap { item in item.pendingMaintenanceActions }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeReservedDBInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedDBInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedDBInstancesOutput`
    public func describeReservedDBInstancesPaginated(input: DescribeReservedDBInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesInput, DescribeReservedDBInstancesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesInput, DescribeReservedDBInstancesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeReservedDBInstances(input:))
    }
}

extension DescribeReservedDBInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedDBInstancesInput {
        return DescribeReservedDBInstancesInput(
            dbInstanceClass: self.dbInstanceClass,
            duration: self.duration,
            filters: self.filters,
            leaseId: self.leaseId,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstanceId: self.reservedDBInstanceId,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedDBInstancesInput, OperationStackOutput == DescribeReservedDBInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedDBInstancesPaginated`
    /// to access the nested member `[RDSClientTypes.ReservedDBInstance]`
    /// - Returns: `[RDSClientTypes.ReservedDBInstance]`
    public func reservedDBInstances() async throws -> [RDSClientTypes.ReservedDBInstance] {
        return try await self.asyncCompactMap { item in item.reservedDBInstances }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeReservedDBInstancesOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedDBInstancesOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedDBInstancesOfferingsOutput`
    public func describeReservedDBInstancesOfferingsPaginated(input: DescribeReservedDBInstancesOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesOfferingsInput, DescribeReservedDBInstancesOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedDBInstancesOfferingsInput, DescribeReservedDBInstancesOfferingsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeReservedDBInstancesOfferings(input:))
    }
}

extension DescribeReservedDBInstancesOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedDBInstancesOfferingsInput {
        return DescribeReservedDBInstancesOfferingsInput(
            dbInstanceClass: self.dbInstanceClass,
            duration: self.duration,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            multiAZ: self.multiAZ,
            offeringType: self.offeringType,
            productDescription: self.productDescription,
            reservedDBInstancesOfferingId: self.reservedDBInstancesOfferingId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedDBInstancesOfferingsInput, OperationStackOutput == DescribeReservedDBInstancesOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedDBInstancesOfferingsPaginated`
    /// to access the nested member `[RDSClientTypes.ReservedDBInstancesOffering]`
    /// - Returns: `[RDSClientTypes.ReservedDBInstancesOffering]`
    public func reservedDBInstancesOfferings() async throws -> [RDSClientTypes.ReservedDBInstancesOffering] {
        return try await self.asyncCompactMap { item in item.reservedDBInstancesOfferings }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeSourceRegionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSourceRegionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSourceRegionsOutput`
    public func describeSourceRegionsPaginated(input: DescribeSourceRegionsInput) -> ClientRuntime.PaginatorSequence<DescribeSourceRegionsInput, DescribeSourceRegionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSourceRegionsInput, DescribeSourceRegionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeSourceRegions(input:))
    }
}

extension DescribeSourceRegionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSourceRegionsInput {
        return DescribeSourceRegionsInput(
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            regionName: self.regionName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSourceRegionsInput, OperationStackOutput == DescribeSourceRegionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSourceRegionsPaginated`
    /// to access the nested member `[RDSClientTypes.SourceRegion]`
    /// - Returns: `[RDSClientTypes.SourceRegion]`
    public func sourceRegions() async throws -> [RDSClientTypes.SourceRegion] {
        return try await self.asyncCompactMap { item in item.sourceRegions }
    }
}
extension RDSClient {
    /// Paginate over `[DescribeTenantDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTenantDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTenantDatabasesOutput`
    public func describeTenantDatabasesPaginated(input: DescribeTenantDatabasesInput) -> ClientRuntime.PaginatorSequence<DescribeTenantDatabasesInput, DescribeTenantDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTenantDatabasesInput, DescribeTenantDatabasesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeTenantDatabases(input:))
    }
}

extension DescribeTenantDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTenantDatabasesInput {
        return DescribeTenantDatabasesInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            tenantDBName: self.tenantDBName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTenantDatabasesInput, OperationStackOutput == DescribeTenantDatabasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTenantDatabasesPaginated`
    /// to access the nested member `[RDSClientTypes.TenantDatabase]`
    /// - Returns: `[RDSClientTypes.TenantDatabase]`
    public func tenantDatabases() async throws -> [RDSClientTypes.TenantDatabase] {
        return try await self.asyncCompactMap { item in item.tenantDatabases }
    }
}
extension RDSClient {
    /// Paginate over `[DownloadDBLogFilePortionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DownloadDBLogFilePortionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DownloadDBLogFilePortionOutput`
    public func downloadDBLogFilePortionPaginated(input: DownloadDBLogFilePortionInput) -> ClientRuntime.PaginatorSequence<DownloadDBLogFilePortionInput, DownloadDBLogFilePortionOutput> {
        return ClientRuntime.PaginatorSequence<DownloadDBLogFilePortionInput, DownloadDBLogFilePortionOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.downloadDBLogFilePortion(input:))
    }
}

extension DownloadDBLogFilePortionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DownloadDBLogFilePortionInput {
        return DownloadDBLogFilePortionInput(
            dbInstanceIdentifier: self.dbInstanceIdentifier,
            logFileName: self.logFileName,
            marker: token,
            numberOfLines: self.numberOfLines
        )}
}
