//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ForecastClient {
    /// Paginate over `[ListDatasetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetGroupsOutput`
    public func listDatasetGroupsPaginated(input: ListDatasetGroupsInput) -> ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetGroupsInput, ListDatasetGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasetGroups(input:))
    }
}

extension ListDatasetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetGroupsInput {
        return ListDatasetGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatasetGroupsInput, OperationStackOutput == ListDatasetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetGroupsPaginated`
    /// to access the nested member `[ForecastClientTypes.DatasetGroupSummary]`
    /// - Returns: `[ForecastClientTypes.DatasetGroupSummary]`
    public func datasetGroups() async throws -> [ForecastClientTypes.DatasetGroupSummary] {
        return try await self.asyncCompactMap { item in item.datasetGroups }
    }
}
extension ForecastClient {
    /// Paginate over `[ListDatasetImportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetImportJobsOutput`
    public func listDatasetImportJobsPaginated(input: ListDatasetImportJobsInput) -> ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetImportJobsInput, ListDatasetImportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasetImportJobs(input:))
    }
}

extension ListDatasetImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetImportJobsInput {
        return ListDatasetImportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatasetImportJobsInput, OperationStackOutput == ListDatasetImportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetImportJobsPaginated`
    /// to access the nested member `[ForecastClientTypes.DatasetImportJobSummary]`
    /// - Returns: `[ForecastClientTypes.DatasetImportJobSummary]`
    public func datasetImportJobs() async throws -> [ForecastClientTypes.DatasetImportJobSummary] {
        return try await self.asyncCompactMap { item in item.datasetImportJobs }
    }
}
extension ForecastClient {
    /// Paginate over `[ListDatasetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetsOutput`
    public func listDatasetsPaginated(input: ListDatasetsInput) -> ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetsInput, ListDatasetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasets(input:))
    }
}

extension ListDatasetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetsInput {
        return ListDatasetsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatasetsInput, OperationStackOutput == ListDatasetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetsPaginated`
    /// to access the nested member `[ForecastClientTypes.DatasetSummary]`
    /// - Returns: `[ForecastClientTypes.DatasetSummary]`
    public func datasets() async throws -> [ForecastClientTypes.DatasetSummary] {
        return try await self.asyncCompactMap { item in item.datasets }
    }
}
extension ForecastClient {
    /// Paginate over `[ListExplainabilitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExplainabilitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExplainabilitiesOutput`
    public func listExplainabilitiesPaginated(input: ListExplainabilitiesInput) -> ClientRuntime.PaginatorSequence<ListExplainabilitiesInput, ListExplainabilitiesOutput> {
        return ClientRuntime.PaginatorSequence<ListExplainabilitiesInput, ListExplainabilitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listExplainabilities(input:))
    }
}

extension ListExplainabilitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExplainabilitiesInput {
        return ListExplainabilitiesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListExplainabilitiesInput, OperationStackOutput == ListExplainabilitiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listExplainabilitiesPaginated`
    /// to access the nested member `[ForecastClientTypes.ExplainabilitySummary]`
    /// - Returns: `[ForecastClientTypes.ExplainabilitySummary]`
    public func explainabilities() async throws -> [ForecastClientTypes.ExplainabilitySummary] {
        return try await self.asyncCompactMap { item in item.explainabilities }
    }
}
extension ForecastClient {
    /// Paginate over `[ListExplainabilityExportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExplainabilityExportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExplainabilityExportsOutput`
    public func listExplainabilityExportsPaginated(input: ListExplainabilityExportsInput) -> ClientRuntime.PaginatorSequence<ListExplainabilityExportsInput, ListExplainabilityExportsOutput> {
        return ClientRuntime.PaginatorSequence<ListExplainabilityExportsInput, ListExplainabilityExportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listExplainabilityExports(input:))
    }
}

extension ListExplainabilityExportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExplainabilityExportsInput {
        return ListExplainabilityExportsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListExplainabilityExportsInput, OperationStackOutput == ListExplainabilityExportsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listExplainabilityExportsPaginated`
    /// to access the nested member `[ForecastClientTypes.ExplainabilityExportSummary]`
    /// - Returns: `[ForecastClientTypes.ExplainabilityExportSummary]`
    public func explainabilityExports() async throws -> [ForecastClientTypes.ExplainabilityExportSummary] {
        return try await self.asyncCompactMap { item in item.explainabilityExports }
    }
}
extension ForecastClient {
    /// Paginate over `[ListForecastExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListForecastExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListForecastExportJobsOutput`
    public func listForecastExportJobsPaginated(input: ListForecastExportJobsInput) -> ClientRuntime.PaginatorSequence<ListForecastExportJobsInput, ListForecastExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListForecastExportJobsInput, ListForecastExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listForecastExportJobs(input:))
    }
}

extension ListForecastExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListForecastExportJobsInput {
        return ListForecastExportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListForecastExportJobsInput, OperationStackOutput == ListForecastExportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listForecastExportJobsPaginated`
    /// to access the nested member `[ForecastClientTypes.ForecastExportJobSummary]`
    /// - Returns: `[ForecastClientTypes.ForecastExportJobSummary]`
    public func forecastExportJobs() async throws -> [ForecastClientTypes.ForecastExportJobSummary] {
        return try await self.asyncCompactMap { item in item.forecastExportJobs }
    }
}
extension ForecastClient {
    /// Paginate over `[ListForecastsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListForecastsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListForecastsOutput`
    public func listForecastsPaginated(input: ListForecastsInput) -> ClientRuntime.PaginatorSequence<ListForecastsInput, ListForecastsOutput> {
        return ClientRuntime.PaginatorSequence<ListForecastsInput, ListForecastsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listForecasts(input:))
    }
}

extension ListForecastsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListForecastsInput {
        return ListForecastsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListForecastsInput, OperationStackOutput == ListForecastsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listForecastsPaginated`
    /// to access the nested member `[ForecastClientTypes.ForecastSummary]`
    /// - Returns: `[ForecastClientTypes.ForecastSummary]`
    public func forecasts() async throws -> [ForecastClientTypes.ForecastSummary] {
        return try await self.asyncCompactMap { item in item.forecasts }
    }
}
extension ForecastClient {
    /// Paginate over `[ListMonitorEvaluationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitorEvaluationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitorEvaluationsOutput`
    public func listMonitorEvaluationsPaginated(input: ListMonitorEvaluationsInput) -> ClientRuntime.PaginatorSequence<ListMonitorEvaluationsInput, ListMonitorEvaluationsOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitorEvaluationsInput, ListMonitorEvaluationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitorEvaluations(input:))
    }
}

extension ListMonitorEvaluationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitorEvaluationsInput {
        return ListMonitorEvaluationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            monitorArn: self.monitorArn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitorEvaluationsInput, OperationStackOutput == ListMonitorEvaluationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitorEvaluationsPaginated`
    /// to access the nested member `[ForecastClientTypes.PredictorMonitorEvaluation]`
    /// - Returns: `[ForecastClientTypes.PredictorMonitorEvaluation]`
    public func predictorMonitorEvaluations() async throws -> [ForecastClientTypes.PredictorMonitorEvaluation] {
        return try await self.asyncCompactMap { item in item.predictorMonitorEvaluations }
    }
}
extension ForecastClient {
    /// Paginate over `[ListMonitorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMonitorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMonitorsOutput`
    public func listMonitorsPaginated(input: ListMonitorsInput) -> ClientRuntime.PaginatorSequence<ListMonitorsInput, ListMonitorsOutput> {
        return ClientRuntime.PaginatorSequence<ListMonitorsInput, ListMonitorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMonitors(input:))
    }
}

extension ListMonitorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMonitorsInput {
        return ListMonitorsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMonitorsInput, OperationStackOutput == ListMonitorsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMonitorsPaginated`
    /// to access the nested member `[ForecastClientTypes.MonitorSummary]`
    /// - Returns: `[ForecastClientTypes.MonitorSummary]`
    public func monitors() async throws -> [ForecastClientTypes.MonitorSummary] {
        return try await self.asyncCompactMap { item in item.monitors }
    }
}
extension ForecastClient {
    /// Paginate over `[ListPredictorBacktestExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPredictorBacktestExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPredictorBacktestExportJobsOutput`
    public func listPredictorBacktestExportJobsPaginated(input: ListPredictorBacktestExportJobsInput) -> ClientRuntime.PaginatorSequence<ListPredictorBacktestExportJobsInput, ListPredictorBacktestExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListPredictorBacktestExportJobsInput, ListPredictorBacktestExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPredictorBacktestExportJobs(input:))
    }
}

extension ListPredictorBacktestExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPredictorBacktestExportJobsInput {
        return ListPredictorBacktestExportJobsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPredictorBacktestExportJobsInput, OperationStackOutput == ListPredictorBacktestExportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPredictorBacktestExportJobsPaginated`
    /// to access the nested member `[ForecastClientTypes.PredictorBacktestExportJobSummary]`
    /// - Returns: `[ForecastClientTypes.PredictorBacktestExportJobSummary]`
    public func predictorBacktestExportJobs() async throws -> [ForecastClientTypes.PredictorBacktestExportJobSummary] {
        return try await self.asyncCompactMap { item in item.predictorBacktestExportJobs }
    }
}
extension ForecastClient {
    /// Paginate over `[ListPredictorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPredictorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPredictorsOutput`
    public func listPredictorsPaginated(input: ListPredictorsInput) -> ClientRuntime.PaginatorSequence<ListPredictorsInput, ListPredictorsOutput> {
        return ClientRuntime.PaginatorSequence<ListPredictorsInput, ListPredictorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPredictors(input:))
    }
}

extension ListPredictorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPredictorsInput {
        return ListPredictorsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPredictorsInput, OperationStackOutput == ListPredictorsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPredictorsPaginated`
    /// to access the nested member `[ForecastClientTypes.PredictorSummary]`
    /// - Returns: `[ForecastClientTypes.PredictorSummary]`
    public func predictors() async throws -> [ForecastClientTypes.PredictorSummary] {
        return try await self.asyncCompactMap { item in item.predictors }
    }
}
extension ForecastClient {
    /// Paginate over `[ListWhatIfAnalysesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWhatIfAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWhatIfAnalysesOutput`
    public func listWhatIfAnalysesPaginated(input: ListWhatIfAnalysesInput) -> ClientRuntime.PaginatorSequence<ListWhatIfAnalysesInput, ListWhatIfAnalysesOutput> {
        return ClientRuntime.PaginatorSequence<ListWhatIfAnalysesInput, ListWhatIfAnalysesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWhatIfAnalyses(input:))
    }
}

extension ListWhatIfAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWhatIfAnalysesInput {
        return ListWhatIfAnalysesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWhatIfAnalysesInput, OperationStackOutput == ListWhatIfAnalysesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWhatIfAnalysesPaginated`
    /// to access the nested member `[ForecastClientTypes.WhatIfAnalysisSummary]`
    /// - Returns: `[ForecastClientTypes.WhatIfAnalysisSummary]`
    public func whatIfAnalyses() async throws -> [ForecastClientTypes.WhatIfAnalysisSummary] {
        return try await self.asyncCompactMap { item in item.whatIfAnalyses }
    }
}
extension ForecastClient {
    /// Paginate over `[ListWhatIfForecastExportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWhatIfForecastExportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWhatIfForecastExportsOutput`
    public func listWhatIfForecastExportsPaginated(input: ListWhatIfForecastExportsInput) -> ClientRuntime.PaginatorSequence<ListWhatIfForecastExportsInput, ListWhatIfForecastExportsOutput> {
        return ClientRuntime.PaginatorSequence<ListWhatIfForecastExportsInput, ListWhatIfForecastExportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWhatIfForecastExports(input:))
    }
}

extension ListWhatIfForecastExportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWhatIfForecastExportsInput {
        return ListWhatIfForecastExportsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWhatIfForecastExportsInput, OperationStackOutput == ListWhatIfForecastExportsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWhatIfForecastExportsPaginated`
    /// to access the nested member `[ForecastClientTypes.WhatIfForecastExportSummary]`
    /// - Returns: `[ForecastClientTypes.WhatIfForecastExportSummary]`
    public func whatIfForecastExports() async throws -> [ForecastClientTypes.WhatIfForecastExportSummary] {
        return try await self.asyncCompactMap { item in item.whatIfForecastExports }
    }
}
extension ForecastClient {
    /// Paginate over `[ListWhatIfForecastsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWhatIfForecastsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWhatIfForecastsOutput`
    public func listWhatIfForecastsPaginated(input: ListWhatIfForecastsInput) -> ClientRuntime.PaginatorSequence<ListWhatIfForecastsInput, ListWhatIfForecastsOutput> {
        return ClientRuntime.PaginatorSequence<ListWhatIfForecastsInput, ListWhatIfForecastsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWhatIfForecasts(input:))
    }
}

extension ListWhatIfForecastsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWhatIfForecastsInput {
        return ListWhatIfForecastsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWhatIfForecastsInput, OperationStackOutput == ListWhatIfForecastsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWhatIfForecastsPaginated`
    /// to access the nested member `[ForecastClientTypes.WhatIfForecastSummary]`
    /// - Returns: `[ForecastClientTypes.WhatIfForecastSummary]`
    public func whatIfForecasts() async throws -> [ForecastClientTypes.WhatIfForecastSummary] {
        return try await self.asyncCompactMap { item in item.whatIfForecasts }
    }
}
