//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct DeleteRescoreExecutionPlanOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRescoreExecutionPlanOutput: Swift.Sendable {

    public init() { }
}

/// You donâ€™t have sufficient access to perform this action. Please ensure you have the required permission policies and user accounts and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A conflict occurred with the request. Please fix any inconsistencies with your resources and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An issue occurred with the internal server used for your Amazon Kendra Intelligent Ranking service. Please wait a few minutes and try again, or contact [Support](http://aws.amazon.com/contact-us/) for help.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the set limits for your Amazon Kendra Intelligent Ranking service. Please see [Quotas](https://docs.aws.amazon.com/kendra/latest/dg/quotas.html) for more information, or contact [Support](http://aws.amazon.com/contact-us/) to inquire about an increase of limits.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Please reduce the number of requests and try again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints set by the Amazon Kendra Intelligent Ranking service. Please provide the correct input and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KendraRankingClientTypes {

    /// Sets additional capacity units configured for your rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API. You can add and remove capacity units to fit your usage requirements.
    public struct CapacityUnitsConfiguration: Swift.Sendable {
        /// The amount of extra capacity for your rescore execution plan. A single extra capacity unit for a rescore execution plan provides 0.01 rescore requests per second. You can add up to 1000 extra capacity units.
        /// This member is required.
        public var rescoreCapacityUnits: Swift.Int?

        public init(
            rescoreCapacityUnits: Swift.Int? = nil
        )
        {
            self.rescoreCapacityUnits = rescoreCapacityUnits
        }
    }
}

extension KendraRankingClientTypes {

    /// A key-value pair that identifies or categorizes a rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API. You can also use a tag to help control access to a rescore execution plan. A tag key and value can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public struct Tag: Swift.Sendable {
        /// The key for the tag. Keys are not case sensitive and must be unique.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag. The value can be an empty string but it can't be null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateRescoreExecutionPlanInput: Swift.Sendable {
    /// You can set additional capacity units to meet the needs of your rescore execution plan. You are given a single capacity unit by default. If you want to use the default capacity, you don't set additional capacity units. For more information on the default capacity and additional capacity units, see [Adjusting capacity](https://docs.aws.amazon.com/kendra/latest/dg/adjusting-capacity.html).
    public var capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration?
    /// A token that you provide to identify the request to create a rescore execution plan. Multiple calls to the CreateRescoreExecutionPlanRequest API with the same client token will create only one rescore execution plan.
    public var clientToken: Swift.String?
    /// A description for the rescore execution plan.
    public var description: Swift.String?
    /// A name for the rescore execution plan.
    /// This member is required.
    public var name: Swift.String?
    /// A list of key-value pairs that identify or categorize your rescore execution plan. You can also use tags to help control access to the rescore execution plan. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
    public var tags: [KendraRankingClientTypes.Tag]?

    public init(
        capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [KendraRankingClientTypes.Tag]? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct CreateRescoreExecutionPlanOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rescore execution plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The identifier of the rescore execution plan.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

/// The resource you want to use doesn't exist. Please check you have provided the correct resource and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteRescoreExecutionPlanInput: Swift.Sendable {
    /// The identifier of the rescore execution plan that you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DescribeRescoreExecutionPlanInput: Swift.Sendable {
    /// The identifier of the rescore execution plan that you want to get information on.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension KendraRankingClientTypes {

    public enum RescoreExecutionPlanStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [RescoreExecutionPlanStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeRescoreExecutionPlanOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rescore execution plan.
    public var arn: Swift.String?
    /// The capacity units set for the rescore execution plan. A capacity of zero indicates that the rescore execution plan is using the default capacity. For more information on the default capacity and additional capacity units, see [Adjusting capacity](https://docs.aws.amazon.com/kendra/latest/dg/adjusting-capacity.html).
    public var capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration?
    /// The Unix timestamp of when the rescore execution plan was created.
    public var createdAt: Foundation.Date?
    /// The description for the rescore execution plan.
    public var description: Swift.String?
    /// When the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var errorMessage: Swift.String?
    /// The identifier of the rescore execution plan.
    public var id: Swift.String?
    /// The name for the rescore execution plan.
    public var name: Swift.String?
    /// The current status of the rescore execution plan. When the value is ACTIVE, the rescore execution plan is ready for use. If the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
    public var status: KendraRankingClientTypes.RescoreExecutionPlanStatus?
    /// The Unix timestamp of when the rescore execution plan was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: KendraRankingClientTypes.RescoreExecutionPlanStatus? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.capacityUnits = capacityUnits
        self.createdAt = createdAt
        self.description = description
        self.errorMessage = errorMessage
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListRescoreExecutionPlansInput: Swift.Sendable {
    /// The maximum number of rescore execution plans to return.
    public var maxResults: Swift.Int?
    /// If the response is truncated, Amazon Kendra Intelligent Ranking returns a pagination token in the response. You can use this pagination token to retrieve the next set of rescore execution plans.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension KendraRankingClientTypes {

    /// Summary information for a rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API.
    public struct RescoreExecutionPlanSummary: Swift.Sendable {
        /// The Unix timestamp when the rescore execution plan was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the rescore execution plan.
        public var id: Swift.String?
        /// The name of the rescore execution plan.
        public var name: Swift.String?
        /// The current status of the rescore execution plan. When the value is ACTIVE, the rescore execution plan is ready for use.
        public var status: KendraRankingClientTypes.RescoreExecutionPlanStatus?
        /// The Unix timestamp when the rescore execution plan was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: KendraRankingClientTypes.RescoreExecutionPlanStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListRescoreExecutionPlansOutput: Swift.Sendable {
    /// If the response is truncated, Amazon Kendra Intelligent Ranking returns a pagination token in the response.
    public var nextToken: Swift.String?
    /// An array of summary information for one or more rescore execution plans.
    public var summaryItems: [KendraRankingClientTypes.RescoreExecutionPlanSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaryItems: [KendraRankingClientTypes.RescoreExecutionPlanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaryItems = summaryItems
    }
}

/// The resource you want to use is unavailable. Please check you have provided the correct resource information and try again.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request information for listing tags associated with a rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rescore execution plan to get a list of tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

/// If the action is successful, the service sends back an HTTP 200 response.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags associated with the rescore execution plan.
    public var tags: [KendraRankingClientTypes.Tag]?

    public init(
        tags: [KendraRankingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension KendraRankingClientTypes {

    /// Information about a document from a search service such as OpenSearch (self managed). Amazon Kendra Intelligent Ranking uses this information to rank and score on.
    public struct Document: Swift.Sendable {
        /// The body text of the search service's document.
        public var body: Swift.String?
        /// The optional group identifier of the document from the search service. Documents with the same group identifier are grouped together and processed as one document within the service.
        public var groupId: Swift.String?
        /// The identifier of the document from the search service.
        /// This member is required.
        public var id: Swift.String?
        /// The original document score or rank from the search service. Amazon Kendra Intelligent Ranking gives the document a new score or rank based on its intelligent search algorithms.
        /// This member is required.
        public var originalScore: Swift.Float?
        /// The title of the search service's document.
        public var title: Swift.String?
        /// The body text of the search service's document represented as a list of tokens or words. You must choose to provide Body or TokenizedBody. You cannot provide both.
        public var tokenizedBody: [Swift.String]?
        /// The title of the search service's document represented as a list of tokens or words. You must choose to provide Title or TokenizedTitle. You cannot provide both.
        public var tokenizedTitle: [Swift.String]?

        public init(
            body: Swift.String? = nil,
            groupId: Swift.String? = nil,
            id: Swift.String? = nil,
            originalScore: Swift.Float? = nil,
            title: Swift.String? = nil,
            tokenizedBody: [Swift.String]? = nil,
            tokenizedTitle: [Swift.String]? = nil
        )
        {
            self.body = body
            self.groupId = groupId
            self.id = id
            self.originalScore = originalScore
            self.title = title
            self.tokenizedBody = tokenizedBody
            self.tokenizedTitle = tokenizedTitle
        }
    }
}

public struct RescoreInput: Swift.Sendable {
    /// The list of documents for Amazon Kendra Intelligent Ranking to rescore or rank on.
    /// This member is required.
    public var documents: [KendraRankingClientTypes.Document]?
    /// The identifier of the rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API.
    /// This member is required.
    public var rescoreExecutionPlanId: Swift.String?
    /// The input query from the search service.
    /// This member is required.
    public var searchQuery: Swift.String?

    public init(
        documents: [KendraRankingClientTypes.Document]? = nil,
        rescoreExecutionPlanId: Swift.String? = nil,
        searchQuery: Swift.String? = nil
    )
    {
        self.documents = documents
        self.rescoreExecutionPlanId = rescoreExecutionPlanId
        self.searchQuery = searchQuery
    }
}

extension KendraRankingClientTypes {

    /// A result item for a document with a new relevancy score.
    public struct RescoreResultItem: Swift.Sendable {
        /// The identifier of the document from the search service.
        public var documentId: Swift.String?
        /// The relevancy score or rank that Amazon Kendra Intelligent Ranking gives to the result.
        public var score: Swift.Float?

        public init(
            documentId: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.documentId = documentId
            self.score = score
        }
    }
}

public struct RescoreOutput: Swift.Sendable {
    /// The identifier associated with the scores that Amazon Kendra Intelligent Ranking gives to the results. Amazon Kendra Intelligent Ranking rescores or re-ranks the results for the search service.
    public var rescoreId: Swift.String?
    /// A list of result items for documents with new relevancy scores. The results are in descending order.
    public var resultItems: [KendraRankingClientTypes.RescoreResultItem]?

    public init(
        rescoreId: Swift.String? = nil,
        resultItems: [KendraRankingClientTypes.RescoreResultItem]? = nil
    )
    {
        self.rescoreId = rescoreId
        self.resultItems = resultItems
    }
}

/// The request information for tagging a rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API.
public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rescore execution plan to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to add to a rescore execution plan. If a tag already exists, the existing value is replaced with the new value.
    /// This member is required.
    public var tags: [KendraRankingClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [KendraRankingClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

/// If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request information to remove a tag from a rescore execution plan. A rescore execution plan is an Amazon Kendra Intelligent Ranking resource used for provisioning the Rescore API.
public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rescore execution plan to remove the tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag keys to remove from the rescore execution plan. If a tag key does not exist on the resource, it is ignored.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

/// If the action is successful, the service sends back an HTTP 200 response with an empty HTTP body.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateRescoreExecutionPlanInput: Swift.Sendable {
    /// You can set additional capacity units to meet the needs of your rescore execution plan. You are given a single capacity unit by default. If you want to use the default capacity, you don't set additional capacity units. For more information on the default capacity and additional capacity units, see [Adjusting capacity](https://docs.aws.amazon.com/kendra/latest/dg/adjusting-capacity.html).
    public var capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration?
    /// A new description for the rescore execution plan.
    public var description: Swift.String?
    /// The identifier of the rescore execution plan that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// A new name for the rescore execution plan.
    public var name: Swift.String?

    public init(
        capacityUnits: KendraRankingClientTypes.CapacityUnitsConfiguration? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.capacityUnits = capacityUnits
        self.description = description
        self.id = id
        self.name = name
    }
}

extension CreateRescoreExecutionPlanInput {

    static func urlPathProvider(_ value: CreateRescoreExecutionPlanInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRescoreExecutionPlanInput {

    static func urlPathProvider(_ value: DeleteRescoreExecutionPlanInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRescoreExecutionPlanInput {

    static func urlPathProvider(_ value: DescribeRescoreExecutionPlanInput) -> Swift.String? {
        return "/"
    }
}

extension ListRescoreExecutionPlansInput {

    static func urlPathProvider(_ value: ListRescoreExecutionPlansInput) -> Swift.String? {
        return "/"
    }
}

extension ListRescoreExecutionPlansInput {

    static func queryItemProvider(_ value: ListRescoreExecutionPlansInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RescoreInput {

    static func urlPathProvider(_ value: RescoreInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRescoreExecutionPlanInput {

    static func urlPathProvider(_ value: UpdateRescoreExecutionPlanInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRescoreExecutionPlanInput {

    static func write(value: CreateRescoreExecutionPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityUnits"].write(value.capacityUnits, with: KendraRankingClientTypes.CapacityUnitsConfiguration.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KendraRankingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteRescoreExecutionPlanInput {

    static func write(value: DeleteRescoreExecutionPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeRescoreExecutionPlanInput {

    static func write(value: DescribeRescoreExecutionPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListRescoreExecutionPlansInput {

    static func write(value: ListRescoreExecutionPlansInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension RescoreInput {

    static func write(value: RescoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Documents"].writeList(value.documents, memberWritingClosure: KendraRankingClientTypes.Document.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SearchQuery"].write(value.searchQuery)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KendraRankingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRescoreExecutionPlanInput {

    static func write(value: UpdateRescoreExecutionPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityUnits"].write(value.capacityUnits, with: KendraRankingClientTypes.CapacityUnitsConfiguration.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension CreateRescoreExecutionPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRescoreExecutionPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRescoreExecutionPlanOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteRescoreExecutionPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRescoreExecutionPlanOutput {
        return DeleteRescoreExecutionPlanOutput()
    }
}

extension DescribeRescoreExecutionPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRescoreExecutionPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRescoreExecutionPlanOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.capacityUnits = try reader["CapacityUnits"].readIfPresent(with: KendraRankingClientTypes.CapacityUnitsConfiguration.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ListRescoreExecutionPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRescoreExecutionPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRescoreExecutionPlansOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.summaryItems = try reader["SummaryItems"].readListIfPresent(memberReadingClosure: KendraRankingClientTypes.RescoreExecutionPlanSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: KendraRankingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RescoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RescoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RescoreOutput()
        value.rescoreId = try reader["RescoreId"].readIfPresent()
        value.resultItems = try reader["ResultItems"].readListIfPresent(memberReadingClosure: KendraRankingClientTypes.RescoreResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateRescoreExecutionPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRescoreExecutionPlanOutput {
        return UpdateRescoreExecutionPlanOutput()
    }
}

enum CreateRescoreExecutionPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRescoreExecutionPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRescoreExecutionPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRescoreExecutionPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RescoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRescoreExecutionPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KendraRankingClientTypes.CapacityUnitsConfiguration {

    static func write(value: KendraRankingClientTypes.CapacityUnitsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RescoreCapacityUnits"].write(value.rescoreCapacityUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KendraRankingClientTypes.CapacityUnitsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KendraRankingClientTypes.CapacityUnitsConfiguration()
        value.rescoreCapacityUnits = try reader["RescoreCapacityUnits"].readIfPresent() ?? 0
        return value
    }
}

extension KendraRankingClientTypes.RescoreExecutionPlanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KendraRankingClientTypes.RescoreExecutionPlanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KendraRankingClientTypes.RescoreExecutionPlanSummary()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension KendraRankingClientTypes.Tag {

    static func write(value: KendraRankingClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KendraRankingClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KendraRankingClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension KendraRankingClientTypes.RescoreResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> KendraRankingClientTypes.RescoreResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KendraRankingClientTypes.RescoreResultItem()
        value.documentId = try reader["DocumentId"].readIfPresent()
        value.score = try reader["Score"].readIfPresent()
        return value
    }
}

extension KendraRankingClientTypes.Document {

    static func write(value: KendraRankingClientTypes.Document?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["GroupId"].write(value.groupId)
        try writer["Id"].write(value.id)
        try writer["OriginalScore"].write(value.originalScore)
        try writer["Title"].write(value.title)
        try writer["TokenizedBody"].writeList(value.tokenizedBody, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TokenizedTitle"].writeList(value.tokenizedTitle, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum KendraRankingClientTypes {}
