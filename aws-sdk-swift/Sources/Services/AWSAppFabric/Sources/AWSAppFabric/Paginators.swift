//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AppFabricClient {
    /// Paginate over `[ListAppAuthorizationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppAuthorizationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppAuthorizationsOutput`
    public func listAppAuthorizationsPaginated(input: ListAppAuthorizationsInput) -> ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppAuthorizationsInput, ListAppAuthorizationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAppAuthorizations(input:))
    }
}

extension ListAppAuthorizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppAuthorizationsInput {
        return ListAppAuthorizationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppAuthorizationsInput, OperationStackOutput == ListAppAuthorizationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppAuthorizationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppAuthorizationSummary]`
    /// - Returns: `[AppFabricClientTypes.AppAuthorizationSummary]`
    public func appAuthorizationSummaryList() async throws -> [AppFabricClientTypes.AppAuthorizationSummary] {
        return try await self.asyncCompactMap { item in item.appAuthorizationSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListAppBundlesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppBundlesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppBundlesOutput`
    public func listAppBundlesPaginated(input: ListAppBundlesInput) -> ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutput> {
        return ClientRuntime.PaginatorSequence<ListAppBundlesInput, ListAppBundlesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAppBundles(input:))
    }
}

extension ListAppBundlesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppBundlesInput {
        return ListAppBundlesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppBundlesInput, OperationStackOutput == ListAppBundlesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppBundlesPaginated`
    /// to access the nested member `[AppFabricClientTypes.AppBundleSummary]`
    /// - Returns: `[AppFabricClientTypes.AppBundleSummary]`
    public func appBundleSummaryList() async throws -> [AppFabricClientTypes.AppBundleSummary] {
        return try await self.asyncCompactMap { item in item.appBundleSummaryList }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionDestinationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionDestinationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionDestinationsOutput`
    public func listIngestionDestinationsPaginated(input: ListIngestionDestinationsInput) -> ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutput> {
        return ClientRuntime.PaginatorSequence<ListIngestionDestinationsInput, ListIngestionDestinationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIngestionDestinations(input:))
    }
}

extension ListIngestionDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionDestinationsInput {
        return ListIngestionDestinationsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            ingestionIdentifier: self.ingestionIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIngestionDestinationsInput, OperationStackOutput == ListIngestionDestinationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionDestinationsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionDestinationSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionDestinationSummary]`
    public func ingestionDestinations() async throws -> [AppFabricClientTypes.IngestionDestinationSummary] {
        return try await self.asyncCompactMap { item in item.ingestionDestinations }
    }
}
extension AppFabricClient {
    /// Paginate over `[ListIngestionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutput`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            appBundleIdentifier: self.appBundleIdentifier,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIngestionsInput, OperationStackOutput == ListIngestionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[AppFabricClientTypes.IngestionSummary]`
    /// - Returns: `[AppFabricClientTypes.IngestionSummary]`
    public func ingestions() async throws -> [AppFabricClientTypes.IngestionSummary] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
