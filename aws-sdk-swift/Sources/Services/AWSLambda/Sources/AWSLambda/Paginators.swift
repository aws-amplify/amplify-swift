//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension LambdaClient {
    /// Paginate over `[ListAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutput`
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            functionName: self.functionName,
            functionVersion: self.functionVersion,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListAliasesInput, OperationStackOutput == ListAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
    /// to access the nested member `[LambdaClientTypes.AliasConfiguration]`
    /// - Returns: `[LambdaClientTypes.AliasConfiguration]`
    public func aliases() async throws -> [LambdaClientTypes.AliasConfiguration] {
        return try await self.asyncCompactMap { item in item.aliases }
    }
}
extension LambdaClient {
    /// Paginate over `[ListCodeSigningConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCodeSigningConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCodeSigningConfigsOutput`
    public func listCodeSigningConfigsPaginated(input: ListCodeSigningConfigsInput) -> ClientRuntime.PaginatorSequence<ListCodeSigningConfigsInput, ListCodeSigningConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListCodeSigningConfigsInput, ListCodeSigningConfigsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listCodeSigningConfigs(input:))
    }
}

extension ListCodeSigningConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCodeSigningConfigsInput {
        return ListCodeSigningConfigsInput(
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListCodeSigningConfigsInput, OperationStackOutput == ListCodeSigningConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCodeSigningConfigsPaginated`
    /// to access the nested member `[LambdaClientTypes.CodeSigningConfig]`
    /// - Returns: `[LambdaClientTypes.CodeSigningConfig]`
    public func codeSigningConfigs() async throws -> [LambdaClientTypes.CodeSigningConfig] {
        return try await self.asyncCompactMap { item in item.codeSigningConfigs }
    }
}
extension LambdaClient {
    /// Paginate over `[ListEventSourceMappingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventSourceMappingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventSourceMappingsOutput`
    public func listEventSourceMappingsPaginated(input: ListEventSourceMappingsInput) -> ClientRuntime.PaginatorSequence<ListEventSourceMappingsInput, ListEventSourceMappingsOutput> {
        return ClientRuntime.PaginatorSequence<ListEventSourceMappingsInput, ListEventSourceMappingsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listEventSourceMappings(input:))
    }
}

extension ListEventSourceMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventSourceMappingsInput {
        return ListEventSourceMappingsInput(
            eventSourceArn: self.eventSourceArn,
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListEventSourceMappingsInput, OperationStackOutput == ListEventSourceMappingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEventSourceMappingsPaginated`
    /// to access the nested member `[LambdaClientTypes.EventSourceMappingConfiguration]`
    /// - Returns: `[LambdaClientTypes.EventSourceMappingConfiguration]`
    public func eventSourceMappings() async throws -> [LambdaClientTypes.EventSourceMappingConfiguration] {
        return try await self.asyncCompactMap { item in item.eventSourceMappings }
    }
}
extension LambdaClient {
    /// Paginate over `[ListFunctionEventInvokeConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionEventInvokeConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionEventInvokeConfigsOutput`
    public func listFunctionEventInvokeConfigsPaginated(input: ListFunctionEventInvokeConfigsInput) -> ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionEventInvokeConfigsInput, ListFunctionEventInvokeConfigsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listFunctionEventInvokeConfigs(input:))
    }
}

extension ListFunctionEventInvokeConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionEventInvokeConfigsInput {
        return ListFunctionEventInvokeConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionEventInvokeConfigsInput, OperationStackOutput == ListFunctionEventInvokeConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionEventInvokeConfigsPaginated`
    /// to access the nested member `[LambdaClientTypes.FunctionEventInvokeConfig]`
    /// - Returns: `[LambdaClientTypes.FunctionEventInvokeConfig]`
    public func functionEventInvokeConfigs() async throws -> [LambdaClientTypes.FunctionEventInvokeConfig] {
        return try await self.asyncCompactMap { item in item.functionEventInvokeConfigs }
    }
}
extension LambdaClient {
    /// Paginate over `[ListFunctionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionsOutput`
    public func listFunctionsPaginated(input: ListFunctionsInput) -> ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionsInput, ListFunctionsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listFunctions(input:))
    }
}

extension ListFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionsInput {
        return ListFunctionsInput(
            functionVersion: self.functionVersion,
            marker: token,
            masterRegion: self.masterRegion,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionsInput, OperationStackOutput == ListFunctionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionsPaginated`
    /// to access the nested member `[LambdaClientTypes.FunctionConfiguration]`
    /// - Returns: `[LambdaClientTypes.FunctionConfiguration]`
    public func functions() async throws -> [LambdaClientTypes.FunctionConfiguration] {
        return try await self.asyncCompactMap { item in item.functions }
    }
}
extension LambdaClient {
    /// Paginate over `[ListFunctionsByCodeSigningConfigOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionsByCodeSigningConfigInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionsByCodeSigningConfigOutput`
    public func listFunctionsByCodeSigningConfigPaginated(input: ListFunctionsByCodeSigningConfigInput) -> ClientRuntime.PaginatorSequence<ListFunctionsByCodeSigningConfigInput, ListFunctionsByCodeSigningConfigOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionsByCodeSigningConfigInput, ListFunctionsByCodeSigningConfigOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listFunctionsByCodeSigningConfig(input:))
    }
}

extension ListFunctionsByCodeSigningConfigInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionsByCodeSigningConfigInput {
        return ListFunctionsByCodeSigningConfigInput(
            codeSigningConfigArn: self.codeSigningConfigArn,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionsByCodeSigningConfigInput, OperationStackOutput == ListFunctionsByCodeSigningConfigOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionsByCodeSigningConfigPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func functionArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.functionArns }
    }
}
extension LambdaClient {
    /// Paginate over `[ListFunctionUrlConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFunctionUrlConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFunctionUrlConfigsOutput`
    public func listFunctionUrlConfigsPaginated(input: ListFunctionUrlConfigsInput) -> ClientRuntime.PaginatorSequence<ListFunctionUrlConfigsInput, ListFunctionUrlConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListFunctionUrlConfigsInput, ListFunctionUrlConfigsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listFunctionUrlConfigs(input:))
    }
}

extension ListFunctionUrlConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFunctionUrlConfigsInput {
        return ListFunctionUrlConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListFunctionUrlConfigsInput, OperationStackOutput == ListFunctionUrlConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFunctionUrlConfigsPaginated`
    /// to access the nested member `[LambdaClientTypes.FunctionUrlConfig]`
    /// - Returns: `[LambdaClientTypes.FunctionUrlConfig]`
    public func functionUrlConfigs() async throws -> [LambdaClientTypes.FunctionUrlConfig] {
        return try await self.asyncCompactMap { item in item.functionUrlConfigs }
    }
}
extension LambdaClient {
    /// Paginate over `[ListLayersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLayersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLayersOutput`
    public func listLayersPaginated(input: ListLayersInput) -> ClientRuntime.PaginatorSequence<ListLayersInput, ListLayersOutput> {
        return ClientRuntime.PaginatorSequence<ListLayersInput, ListLayersOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listLayers(input:))
    }
}

extension ListLayersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLayersInput {
        return ListLayersInput(
            compatibleArchitecture: self.compatibleArchitecture,
            compatibleRuntime: self.compatibleRuntime,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListLayersInput, OperationStackOutput == ListLayersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLayersPaginated`
    /// to access the nested member `[LambdaClientTypes.LayersListItem]`
    /// - Returns: `[LambdaClientTypes.LayersListItem]`
    public func layers() async throws -> [LambdaClientTypes.LayersListItem] {
        return try await self.asyncCompactMap { item in item.layers }
    }
}
extension LambdaClient {
    /// Paginate over `[ListLayerVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLayerVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLayerVersionsOutput`
    public func listLayerVersionsPaginated(input: ListLayerVersionsInput) -> ClientRuntime.PaginatorSequence<ListLayerVersionsInput, ListLayerVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListLayerVersionsInput, ListLayerVersionsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listLayerVersions(input:))
    }
}

extension ListLayerVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLayerVersionsInput {
        return ListLayerVersionsInput(
            compatibleArchitecture: self.compatibleArchitecture,
            compatibleRuntime: self.compatibleRuntime,
            layerName: self.layerName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListLayerVersionsInput, OperationStackOutput == ListLayerVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLayerVersionsPaginated`
    /// to access the nested member `[LambdaClientTypes.LayerVersionsListItem]`
    /// - Returns: `[LambdaClientTypes.LayerVersionsListItem]`
    public func layerVersions() async throws -> [LambdaClientTypes.LayerVersionsListItem] {
        return try await self.asyncCompactMap { item in item.layerVersions }
    }
}
extension LambdaClient {
    /// Paginate over `[ListProvisionedConcurrencyConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProvisionedConcurrencyConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProvisionedConcurrencyConfigsOutput`
    public func listProvisionedConcurrencyConfigsPaginated(input: ListProvisionedConcurrencyConfigsInput) -> ClientRuntime.PaginatorSequence<ListProvisionedConcurrencyConfigsInput, ListProvisionedConcurrencyConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListProvisionedConcurrencyConfigsInput, ListProvisionedConcurrencyConfigsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listProvisionedConcurrencyConfigs(input:))
    }
}

extension ListProvisionedConcurrencyConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisionedConcurrencyConfigsInput {
        return ListProvisionedConcurrencyConfigsInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListProvisionedConcurrencyConfigsInput, OperationStackOutput == ListProvisionedConcurrencyConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProvisionedConcurrencyConfigsPaginated`
    /// to access the nested member `[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]`
    /// - Returns: `[LambdaClientTypes.ProvisionedConcurrencyConfigListItem]`
    public func provisionedConcurrencyConfigs() async throws -> [LambdaClientTypes.ProvisionedConcurrencyConfigListItem] {
        return try await self.asyncCompactMap { item in item.provisionedConcurrencyConfigs }
    }
}
extension LambdaClient {
    /// Paginate over `[ListVersionsByFunctionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVersionsByFunctionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVersionsByFunctionOutput`
    public func listVersionsByFunctionPaginated(input: ListVersionsByFunctionInput) -> ClientRuntime.PaginatorSequence<ListVersionsByFunctionInput, ListVersionsByFunctionOutput> {
        return ClientRuntime.PaginatorSequence<ListVersionsByFunctionInput, ListVersionsByFunctionOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listVersionsByFunction(input:))
    }
}

extension ListVersionsByFunctionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVersionsByFunctionInput {
        return ListVersionsByFunctionInput(
            functionName: self.functionName,
            marker: token,
            maxItems: self.maxItems
        )}
}

extension PaginatorSequence where OperationStackInput == ListVersionsByFunctionInput, OperationStackOutput == ListVersionsByFunctionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listVersionsByFunctionPaginated`
    /// to access the nested member `[LambdaClientTypes.FunctionConfiguration]`
    /// - Returns: `[LambdaClientTypes.FunctionConfiguration]`
    public func versions() async throws -> [LambdaClientTypes.FunctionConfiguration] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}
