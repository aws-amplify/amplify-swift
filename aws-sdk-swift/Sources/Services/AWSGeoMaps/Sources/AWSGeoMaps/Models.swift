//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// The request was denied because of insufficient access or permissions. Check with an administrator to verify your permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoMapsClientTypes {

    public enum ColorScheme: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dark
        case light
        case sdkUnknown(Swift.String)

        public static var allCases: [ColorScheme] {
            return [
                .dark,
                .light
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dark: return "Dark"
            case .light: return "Light"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetGlyphsInput: Swift.Sendable {
    /// Name of the FontStack to retrieve. Example: Amazon Ember Bold,Noto Sans Bold. The supported font stacks are as follows:
    ///
    /// * Amazon Ember Bold
    ///
    /// * Amazon Ember Bold Italic
    ///
    /// * Amazon Ember Bold,Noto Sans Bold
    ///
    /// * Amazon Ember Bold,Noto Sans Bold,Noto Sans Arabic Bold
    ///
    /// * Amazon Ember Condensed RC BdItalic
    ///
    /// * Amazon Ember Condensed RC Bold
    ///
    /// * Amazon Ember Condensed RC Bold Italic
    ///
    /// * Amazon Ember Condensed RC Bold,Noto Sans Bold
    ///
    /// * Amazon Ember Condensed RC Bold,Noto Sans Bold,Noto Sans Arabic Condensed Bold
    ///
    /// * Amazon Ember Condensed RC Light
    ///
    /// * Amazon Ember Condensed RC Light Italic
    ///
    /// * Amazon Ember Condensed RC LtItalic
    ///
    /// * Amazon Ember Condensed RC Regular
    ///
    /// * Amazon Ember Condensed RC Regular Italic
    ///
    /// * Amazon Ember Condensed RC Regular,Noto Sans Regular
    ///
    /// * Amazon Ember Condensed RC Regular,Noto Sans Regular,Noto Sans Arabic Condensed Regular
    ///
    /// * Amazon Ember Condensed RC RgItalic
    ///
    /// * Amazon Ember Condensed RC ThItalic
    ///
    /// * Amazon Ember Condensed RC Thin
    ///
    /// * Amazon Ember Condensed RC Thin Italic
    ///
    /// * Amazon Ember Heavy
    ///
    /// * Amazon Ember Heavy Italic
    ///
    /// * Amazon Ember Light
    ///
    /// * Amazon Ember Light Italic
    ///
    /// * Amazon Ember Medium
    ///
    /// * Amazon Ember Medium Italic
    ///
    /// * Amazon Ember Medium,Noto Sans Medium
    ///
    /// * Amazon Ember Medium,Noto Sans Medium,Noto Sans Arabic Medium
    ///
    /// * Amazon Ember Regular
    ///
    /// * Amazon Ember Regular Italic
    ///
    /// * Amazon Ember Regular Italic,Noto Sans Italic
    ///
    /// * Amazon Ember Regular Italic,Noto Sans Italic,Noto Sans Arabic Regular
    ///
    /// * Amazon Ember Regular,Noto Sans Regular
    ///
    /// * Amazon Ember Regular,Noto Sans Regular,Noto Sans Arabic Regular
    ///
    /// * Amazon Ember Thin
    ///
    /// * Amazon Ember Thin Italic
    ///
    /// * AmazonEmberCdRC_Bd
    ///
    /// * AmazonEmberCdRC_BdIt
    ///
    /// * AmazonEmberCdRC_Lt
    ///
    /// * AmazonEmberCdRC_LtIt
    ///
    /// * AmazonEmberCdRC_Rg
    ///
    /// * AmazonEmberCdRC_RgIt
    ///
    /// * AmazonEmberCdRC_Th
    ///
    /// * AmazonEmberCdRC_ThIt
    ///
    /// * AmazonEmber_Bd
    ///
    /// * AmazonEmber_BdIt
    ///
    /// * AmazonEmber_He
    ///
    /// * AmazonEmber_HeIt
    ///
    /// * AmazonEmber_Lt
    ///
    /// * AmazonEmber_LtIt
    ///
    /// * AmazonEmber_Md
    ///
    /// * AmazonEmber_MdIt
    ///
    /// * AmazonEmber_Rg
    ///
    /// * AmazonEmber_RgIt
    ///
    /// * AmazonEmber_Th
    ///
    /// * AmazonEmber_ThIt
    ///
    /// * Noto Sans Black
    ///
    /// * Noto Sans Black Italic
    ///
    /// * Noto Sans Bold
    ///
    /// * Noto Sans Bold Italic
    ///
    /// * Noto Sans Extra Bold
    ///
    /// * Noto Sans Extra Bold Italic
    ///
    /// * Noto Sans Extra Light
    ///
    /// * Noto Sans Extra Light Italic
    ///
    /// * Noto Sans Italic
    ///
    /// * Noto Sans Light
    ///
    /// * Noto Sans Light Italic
    ///
    /// * Noto Sans Medium
    ///
    /// * Noto Sans Medium Italic
    ///
    /// * Noto Sans Regular
    ///
    /// * Noto Sans Semi Bold
    ///
    /// * Noto Sans Semi Bold Italic
    ///
    /// * Noto Sans Thin
    ///
    /// * Noto Sans Thin Italic
    ///
    /// * NotoSans-Bold
    ///
    /// * NotoSans-Italic
    ///
    /// * NotoSans-Medium
    ///
    /// * NotoSans-Regular
    ///
    /// * Open Sans Regular,Arial Unicode MS Regular
    /// This member is required.
    public var fontStack: Swift.String?
    /// A Unicode range of characters to download glyphs for. This must be aligned to multiples of 256. Example: 0-255.pdf
    /// This member is required.
    public var fontUnicodeRange: Swift.String?

    public init(
        fontStack: Swift.String? = nil,
        fontUnicodeRange: Swift.String? = nil
    )
    {
        self.fontStack = fontStack
        self.fontUnicodeRange = fontUnicodeRange
    }
}

public struct GetGlyphsOutput: Swift.Sendable {
    /// The Glyph, as a binary blob.
    public var blob: Foundation.Data?
    /// Header that instructs caching configuration for the client.
    public var cacheControl: Swift.String?
    /// Header that represents the format of the response. The response returns the following as the HTTP body.
    public var contentType: Swift.String?
    /// The glyph's Etag.
    public var eTag: Swift.String?

    public init(
        blob: Foundation.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.eTag = eTag
    }
}

extension GeoMapsClientTypes {

    public enum MapStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hybrid
        case monochrome
        case satellite
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [MapStyle] {
            return [
                .hybrid,
                .monochrome,
                .satellite,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hybrid: return "Hybrid"
            case .monochrome: return "Monochrome"
            case .satellite: return "Satellite"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoMapsClientTypes {

    public enum Variant: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [Variant] {
            return [
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "Default"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSpritesInput: Swift.Sendable {
    /// Sets color tone for map such as dark and light for specific map styles. It applies to only vector map styles such as Standard and Monochrome. Example: Light Default value: Light Valid values for ColorScheme are case sensitive.
    /// This member is required.
    public var colorScheme: GeoMapsClientTypes.ColorScheme?
    /// Sprites API: The name of the sprite ï¬le to retrieve, following pattern sprites(@2x)?\.(png|json). Example: sprites.png
    /// This member is required.
    public var fileName: Swift.String?
    /// Style specifies the desired map style for the Sprites APIs.
    /// This member is required.
    public var style: GeoMapsClientTypes.MapStyle?
    /// Optimizes map styles for specific use case or industry. You can choose allowed variant only with Standard map style. Example: Default Valid values for Variant are case sensitive.
    /// This member is required.
    public var variant: GeoMapsClientTypes.Variant?

    public init(
        colorScheme: GeoMapsClientTypes.ColorScheme? = nil,
        fileName: Swift.String? = nil,
        style: GeoMapsClientTypes.MapStyle? = nil,
        variant: GeoMapsClientTypes.Variant? = nil
    )
    {
        self.colorScheme = colorScheme
        self.fileName = fileName
        self.style = style
        self.variant = variant
    }
}

public struct GetSpritesOutput: Swift.Sendable {
    /// The body of the sprite sheet or JSON offset file (image/png or application/json, depending on input).
    public var blob: Foundation.Data?
    /// Header that instructs caching configuration for the client.
    public var cacheControl: Swift.String?
    /// Header that represents the format of the response. The response returns the following as the HTTP body.
    public var contentType: Swift.String?
    /// The sprite's Etag.
    public var eTag: Swift.String?

    public init(
        blob: Foundation.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.eTag = eTag
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GeoMapsClientTypes {

    /// The input fails to satisfy the constraints specified by the Amazon Location service.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the resource.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension GeoMapsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The input cannot be parsed. For example a required JSON document, ARN identifier, date value, or numeric field cannot be parsed.
        case cannotParse
        /// The input is present and parsable, but it is otherwise invalid. For example, a required numeric argument is outside the allowed range.
        case fieldValidationFailed
        /// The required input is missing.
        case missing
        /// The input is invalid but no more specific reason is applicable.
        case other
        /// No such field is supported.
        case unknownField
        /// No such operation is supported.
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .missing,
                .other,
                .unknownField,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CannotParse"
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .missing: return "Missing"
            case .other: return "Other"
            case .unknownField: return "UnknownField"
            case .unknownOperation: return "UnknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public internal(set) var fieldList: [GeoMapsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The field where thebb invalid entry was detected.
        /// This member is required.
        public internal(set) var reason: GeoMapsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [GeoMapsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: GeoMapsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension GeoMapsClientTypes {

    public enum ScaleBarUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kilometers
        case kilometersMiles
        case miles
        case milesKilometers
        case sdkUnknown(Swift.String)

        public static var allCases: [ScaleBarUnit] {
            return [
                .kilometers,
                .kilometersMiles,
                .miles,
                .milesKilometers
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kilometers: return "Kilometers"
            case .kilometersMiles: return "KilometersMiles"
            case .miles: return "Miles"
            case .milesKilometers: return "MilesKilometers"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GeoMapsClientTypes {

    public enum StaticMapStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case satellite
        case sdkUnknown(Swift.String)

        public static var allCases: [StaticMapStyle] {
            return [
                .satellite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .satellite: return "Satellite"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetStaticMapInput: Swift.Sendable {
    /// Takes in two or more pair of coordinates, [Lon, Lat], with each coordinate separated by a comma. The API will generate an image to encompass all of the provided coordinates. Cannot be used with Zoom and or Radius Example: 97.170451,78.039098,99.045536,27.176178
    public var boundedPositions: Swift.String?
    /// Takes in two pairs of coordinates, [Lon, Lat], denoting south-westerly and north-easterly edges of the image. The underlying area becomes the view of the image. Example: -123.17075,49.26959,-123.08125,49.31429
    public var boundingBox: Swift.String?
    /// Takes in a pair of coordinates, [Lon, Lat], which becomes the center point of the image. This parameter requires that either zoom or radius is set. Cannot be used with Zoom and or Radius Example: 49.295,-123.108
    public var center: Swift.String?
    /// Takes in a string to draw geometries on the image. The input is a comma separated format as follows format: [Lon, Lat] Example: line:-122.407653,37.798557,-122.413291,37.802443;color=%23DD0000;width=7;outline-color=#00DD00;outline-width=5yd|point:-122.40572,37.80004;label=Fog Hill Market;size=large;text-color=%23DD0000;color=#EE4B2B Currently it supports the following geometry types: point, line and polygon. It does not support multiPoint , multiLine and multiPolgyon.
    public var compactOverlay: Swift.String?
    /// The map scaling parameter to size the image, icons, and labels. It follows the pattern of ^map(@2x)?$. Example: map, map@2x
    /// This member is required.
    public var fileName: Swift.String?
    /// Takes in a string to draw geometries on the image. The input is a valid GeoJSON collection object. Example: {"type":"FeatureCollection","features": [{"type":"Feature","geometry":{"type":"MultiPoint","coordinates": [[-90.076345,51.504107],[-0.074451,51.506892]]},"properties": {"color":"#00DD00"}}]}
    public var geoJsonOverlay: Swift.String?
    /// Specifies the height of the map image.
    /// This member is required.
    public var height: Swift.Int?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Applies additional space (in pixels) around overlay feature to prevent them from being cut or obscured. Value for max and min is determined by: Min: 1 Max: min(height, width)/4 Example: 100
    public var padding: Swift.Int?
    /// Used with center parameter, it specifies the zoom of the image where you can control it on a granular level. Takes in any value >= 1. Example: 1500 Cannot be used with Zoom. Unit: Meters
    public var radius: Swift.Int?
    /// Displays a scale on the bottom right of the map image with the unit specified in the input. Example: KilometersMiles, Miles, Kilometers, MilesKilometers
    public var scaleBarUnit: GeoMapsClientTypes.ScaleBarUnit?
    /// Style specifies the desired map style for the Style APIs.
    public var style: GeoMapsClientTypes.StaticMapStyle?
    /// Specifies the width of the map image.
    /// This member is required.
    public var width: Swift.Int?
    /// Specifies the zoom level of the map image. Cannot be used with Radius.
    public var zoom: Swift.Float?

    public init(
        boundedPositions: Swift.String? = nil,
        boundingBox: Swift.String? = nil,
        center: Swift.String? = nil,
        compactOverlay: Swift.String? = nil,
        fileName: Swift.String? = nil,
        geoJsonOverlay: Swift.String? = nil,
        height: Swift.Int? = nil,
        key: Swift.String? = nil,
        padding: Swift.Int? = nil,
        radius: Swift.Int? = 0,
        scaleBarUnit: GeoMapsClientTypes.ScaleBarUnit? = nil,
        style: GeoMapsClientTypes.StaticMapStyle? = nil,
        width: Swift.Int? = nil,
        zoom: Swift.Float? = nil
    )
    {
        self.boundedPositions = boundedPositions
        self.boundingBox = boundingBox
        self.center = center
        self.compactOverlay = compactOverlay
        self.fileName = fileName
        self.geoJsonOverlay = geoJsonOverlay
        self.height = height
        self.key = key
        self.padding = padding
        self.radius = radius
        self.scaleBarUnit = scaleBarUnit
        self.style = style
        self.width = width
        self.zoom = zoom
    }
}

extension GetStaticMapInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStaticMapInput(boundedPositions: \(Swift.String(describing: boundedPositions)), boundingBox: \(Swift.String(describing: boundingBox)), center: \(Swift.String(describing: center)), compactOverlay: \(Swift.String(describing: compactOverlay)), fileName: \(Swift.String(describing: fileName)), geoJsonOverlay: \(Swift.String(describing: geoJsonOverlay)), height: \(Swift.String(describing: height)), padding: \(Swift.String(describing: padding)), radius: \(Swift.String(describing: radius)), scaleBarUnit: \(Swift.String(describing: scaleBarUnit)), style: \(Swift.String(describing: style)), width: \(Swift.String(describing: width)), zoom: \(Swift.String(describing: zoom)), key: \"CONTENT_REDACTED\")"}
}

public struct GetStaticMapOutput: Swift.Sendable {
    /// The blob represents a map image as a jpeg for the GetStaticMap API.
    public var blob: Foundation.Data?
    /// Header that instructs caching configuration for the client.
    public var cacheControl: Swift.String?
    /// Header that represents the format of the response. The response returns the following as the HTTP body.
    public var contentType: Swift.String?
    /// The static map's Etag.
    public var eTag: Swift.String?
    /// The pricing bucket for which the request is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?

    public init(
        blob: Foundation.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        pricingBucket: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.eTag = eTag
        self.pricingBucket = pricingBucket
    }
}

public struct GetStyleDescriptorInput: Swift.Sendable {
    /// Sets color tone for map such as dark and light for specific map styles. It applies to only vector map styles such as Standard and Monochrome. Example: Light Default value: Light Valid values for ColorScheme are case sensitive.
    public var colorScheme: GeoMapsClientTypes.ColorScheme?
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the political view using ISO 3166-2 or ISO 3166-3 country code format. The following political views are currently supported:
    ///
    /// * ARG: Argentina's view on the Southern Patagonian Ice Field and Tierra Del Fuego, including the Falkland Islands, South Georgia, and South Sandwich Islands
    ///
    /// * EGY: Egypt's view on Bir Tawil
    ///
    /// * IND: India's view on Gilgit-Baltistan
    ///
    /// * KEN: Kenya's view on the Ilemi Triangle
    ///
    /// * MAR: Morocco's view on Western Sahara
    ///
    /// * PAK: Pakistan's view on Jammu and Kashmir and the Junagadh Area
    ///
    /// * RUS: Russia's view on Crimea
    ///
    /// * SDN: Sudan's view on the Halaib Triangle
    ///
    /// * SRB: Serbia's view on Kosovo, Vukovar, and Sarengrad Islands
    ///
    /// * SUR: Suriname's view on the Courantyne Headwaters and Lawa Headwaters
    ///
    /// * SYR: Syria's view on the Golan Heights
    ///
    /// * TUR: Turkey's view on Cyprus and Northern Cyprus
    ///
    /// * TZA: Tanzania's view on Lake Malawi
    ///
    /// * URY: Uruguay's view on Rincon de Artigas
    ///
    /// * VNM: Vietnam's view on the Paracel Islands and Spratly Islands
    public var politicalView: Swift.String?
    /// Style specifies the desired map style.
    /// This member is required.
    public var style: GeoMapsClientTypes.MapStyle?

    public init(
        colorScheme: GeoMapsClientTypes.ColorScheme? = nil,
        key: Swift.String? = nil,
        politicalView: Swift.String? = nil,
        style: GeoMapsClientTypes.MapStyle? = nil
    )
    {
        self.colorScheme = colorScheme
        self.key = key
        self.politicalView = politicalView
        self.style = style
    }
}

extension GetStyleDescriptorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStyleDescriptorInput(colorScheme: \(Swift.String(describing: colorScheme)), politicalView: \(Swift.String(describing: politicalView)), style: \(Swift.String(describing: style)), key: \"CONTENT_REDACTED\")"}
}

public struct GetStyleDescriptorOutput: Swift.Sendable {
    /// This Blob contains the body of the style descriptor which is in application/json format.
    public var blob: Foundation.Data?
    /// Header that instructs caching configuration for the client.
    public var cacheControl: Swift.String?
    /// Header that represents the format of the response. The response returns the following as the HTTP body.
    public var contentType: Swift.String?
    /// The style descriptor's Etag.
    public var eTag: Swift.String?

    public init(
        blob: Foundation.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.eTag = eTag
    }
}

public struct GetTileInput: Swift.Sendable {
    /// Optional: The API key to be used for authorization. Either an API key or valid SigV4 signature must be provided when making a request.
    public var key: Swift.String?
    /// Specifies the desired tile set. Valid Values: raster.satellite | vector.basemap
    /// This member is required.
    public var tileset: Swift.String?
    /// The X axis value for the map tile. Must be between 0 and 19.
    /// This member is required.
    public var x: Swift.String?
    /// The Y axis value for the map tile.
    /// This member is required.
    public var y: Swift.String?
    /// The zoom value for the map tile.
    /// This member is required.
    public var z: Swift.String?

    public init(
        key: Swift.String? = nil,
        tileset: Swift.String? = nil,
        x: Swift.String? = nil,
        y: Swift.String? = nil,
        z: Swift.String? = nil
    )
    {
        self.key = key
        self.tileset = tileset
        self.x = x
        self.y = y
        self.z = z
    }
}

extension GetTileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTileInput(tileset: \(Swift.String(describing: tileset)), x: \(Swift.String(describing: x)), y: \(Swift.String(describing: y)), z: \(Swift.String(describing: z)), key: \"CONTENT_REDACTED\")"}
}

public struct GetTileOutput: Swift.Sendable {
    /// The blob represents a vector tile in mvt format for the GetTile API.
    public var blob: Foundation.Data?
    /// Header that instructs caching configuration for the client.
    public var cacheControl: Swift.String?
    /// Header that represents the format of the response. The response returns the following as the HTTP body.
    public var contentType: Swift.String?
    /// The pricing bucket for which the request is charged at.
    public var eTag: Swift.String?
    /// The pricing bucket for which the request is charged at.
    /// This member is required.
    public var pricingBucket: Swift.String?

    public init(
        blob: Foundation.Data? = nil,
        cacheControl: Swift.String? = nil,
        contentType: Swift.String? = nil,
        eTag: Swift.String? = nil,
        pricingBucket: Swift.String? = nil
    )
    {
        self.blob = blob
        self.cacheControl = cacheControl
        self.contentType = contentType
        self.eTag = eTag
        self.pricingBucket = pricingBucket
    }
}

extension GetGlyphsInput {

    static func urlPathProvider(_ value: GetGlyphsInput) -> Swift.String? {
        guard let fontStack = value.fontStack else {
            return nil
        }
        guard let fontUnicodeRange = value.fontUnicodeRange else {
            return nil
        }
        return "/glyphs/\(fontStack.urlPercentEncoding())/\(fontUnicodeRange.urlPercentEncoding())"
    }
}

extension GetSpritesInput {

    static func urlPathProvider(_ value: GetSpritesInput) -> Swift.String? {
        guard let style = value.style else {
            return nil
        }
        guard let colorScheme = value.colorScheme else {
            return nil
        }
        guard let variant = value.variant else {
            return nil
        }
        guard let fileName = value.fileName else {
            return nil
        }
        return "/styles/\(style.rawValue.urlPercentEncoding())/\(colorScheme.rawValue.urlPercentEncoding())/\(variant.rawValue.urlPercentEncoding())/sprites/\(fileName.urlPercentEncoding())"
    }
}

extension GetStaticMapInput {

    static func urlPathProvider(_ value: GetStaticMapInput) -> Swift.String? {
        guard let fileName = value.fileName else {
            return nil
        }
        return "/static/\(fileName.urlPercentEncoding())"
    }
}

extension GetStaticMapInput {

    static func queryItemProvider(_ value: GetStaticMapInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let compactOverlay = value.compactOverlay {
            let compactOverlayQueryItem = Smithy.URIQueryItem(name: "compact-overlay".urlPercentEncoding(), value: Swift.String(compactOverlay).urlPercentEncoding())
            items.append(compactOverlayQueryItem)
        }
        if let radius = value.radius {
            let radiusQueryItem = Smithy.URIQueryItem(name: "radius".urlPercentEncoding(), value: Swift.String(radius).urlPercentEncoding())
            items.append(radiusQueryItem)
        }
        if let center = value.center {
            let centerQueryItem = Smithy.URIQueryItem(name: "center".urlPercentEncoding(), value: Swift.String(center).urlPercentEncoding())
            items.append(centerQueryItem)
        }
        if let boundedPositions = value.boundedPositions {
            let boundedPositionsQueryItem = Smithy.URIQueryItem(name: "bounded-positions".urlPercentEncoding(), value: Swift.String(boundedPositions).urlPercentEncoding())
            items.append(boundedPositionsQueryItem)
        }
        if let scaleBarUnit = value.scaleBarUnit {
            let scaleBarUnitQueryItem = Smithy.URIQueryItem(name: "scale-unit".urlPercentEncoding(), value: Swift.String(scaleBarUnit.rawValue).urlPercentEncoding())
            items.append(scaleBarUnitQueryItem)
        }
        if let boundingBox = value.boundingBox {
            let boundingBoxQueryItem = Smithy.URIQueryItem(name: "bounding-box".urlPercentEncoding(), value: Swift.String(boundingBox).urlPercentEncoding())
            items.append(boundingBoxQueryItem)
        }
        if let geoJsonOverlay = value.geoJsonOverlay {
            let geoJsonOverlayQueryItem = Smithy.URIQueryItem(name: "geojson-overlay".urlPercentEncoding(), value: Swift.String(geoJsonOverlay).urlPercentEncoding())
            items.append(geoJsonOverlayQueryItem)
        }
        if let padding = value.padding {
            let paddingQueryItem = Smithy.URIQueryItem(name: "padding".urlPercentEncoding(), value: Swift.String(padding).urlPercentEncoding())
            items.append(paddingQueryItem)
        }
        if let style = value.style {
            let styleQueryItem = Smithy.URIQueryItem(name: "style".urlPercentEncoding(), value: Swift.String(style.rawValue).urlPercentEncoding())
            items.append(styleQueryItem)
        }
        if let zoom = value.zoom {
            let zoomQueryItem = Smithy.URIQueryItem(name: "zoom".urlPercentEncoding(), value: Swift.String(zoom).urlPercentEncoding())
            items.append(zoomQueryItem)
        }
        guard let height = value.height else {
            let message = "Creating a URL Query Item failed. height is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let heightQueryItem = Smithy.URIQueryItem(name: "height".urlPercentEncoding(), value: Swift.String(height).urlPercentEncoding())
        items.append(heightQueryItem)
        guard let width = value.width else {
            let message = "Creating a URL Query Item failed. width is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let widthQueryItem = Smithy.URIQueryItem(name: "width".urlPercentEncoding(), value: Swift.String(width).urlPercentEncoding())
        items.append(widthQueryItem)
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetStyleDescriptorInput {

    static func urlPathProvider(_ value: GetStyleDescriptorInput) -> Swift.String? {
        guard let style = value.style else {
            return nil
        }
        return "/styles/\(style.rawValue.urlPercentEncoding())/descriptor"
    }
}

extension GetStyleDescriptorInput {

    static func queryItemProvider(_ value: GetStyleDescriptorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let colorScheme = value.colorScheme {
            let colorSchemeQueryItem = Smithy.URIQueryItem(name: "color-scheme".urlPercentEncoding(), value: Swift.String(colorScheme.rawValue).urlPercentEncoding())
            items.append(colorSchemeQueryItem)
        }
        if let politicalView = value.politicalView {
            let politicalViewQueryItem = Smithy.URIQueryItem(name: "political-view".urlPercentEncoding(), value: Swift.String(politicalView).urlPercentEncoding())
            items.append(politicalViewQueryItem)
        }
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetTileInput {

    static func urlPathProvider(_ value: GetTileInput) -> Swift.String? {
        guard let tileset = value.tileset else {
            return nil
        }
        guard let z = value.z else {
            return nil
        }
        guard let x = value.x else {
            return nil
        }
        guard let y = value.y else {
            return nil
        }
        return "/tiles/\(tileset.urlPercentEncoding())/\(z.urlPercentEncoding())/\(x.urlPercentEncoding())/\(y.urlPercentEncoding())"
    }
}

extension GetTileInput {

    static func queryItemProvider(_ value: GetTileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let key = value.key {
            let keyQueryItem = Smithy.URIQueryItem(name: "key".urlPercentEncoding(), value: Swift.String(key).urlPercentEncoding())
            items.append(keyQueryItem)
        }
        return items
    }
}

extension GetGlyphsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlyphsOutput {
        var value = GetGlyphsOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

extension GetSpritesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSpritesOutput {
        var value = GetSpritesOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

extension GetStaticMapOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStaticMapOutput {
        var value = GetStaticMapOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

extension GetStyleDescriptorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStyleDescriptorOutput {
        var value = GetStyleDescriptorOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

extension GetTileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTileOutput {
        var value = GetTileOutput()
        if let cacheControlHeaderValue = httpResponse.headers.value(for: "Cache-Control") {
            value.cacheControl = cacheControlHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        if let pricingBucketHeaderValue = httpResponse.headers.value(for: "x-amz-geo-pricing-bucket") {
            value.pricingBucket = pricingBucketHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.blob = data
        case .stream(let stream):
            value.blob = try stream.readToEnd()
        case .noStream:
            value.blob = nil
        }
        return value
    }
}

enum GetGlyphsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSpritesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStaticMapOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStyleDescriptorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: GeoMapsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GeoMapsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> GeoMapsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GeoMapsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum GeoMapsClientTypes {}
