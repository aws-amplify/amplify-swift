//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension GlueClient {
    /// Paginate over `[GetBlueprintRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBlueprintRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBlueprintRunsOutput`
    public func getBlueprintRunsPaginated(input: GetBlueprintRunsInput) -> ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetBlueprintRunsInput, GetBlueprintRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBlueprintRuns(input:))
    }
}

extension GetBlueprintRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBlueprintRunsInput {
        return GetBlueprintRunsInput(
            blueprintName: self.blueprintName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetClassifiersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetClassifiersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetClassifiersOutput`
    public func getClassifiersPaginated(input: GetClassifiersInput) -> ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput> {
        return ClientRuntime.PaginatorSequence<GetClassifiersInput, GetClassifiersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getClassifiers(input:))
    }
}

extension GetClassifiersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetClassifiersInput {
        return GetClassifiersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetColumnStatisticsTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetColumnStatisticsTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetColumnStatisticsTaskRunsOutput`
    public func getColumnStatisticsTaskRunsPaginated(input: GetColumnStatisticsTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetColumnStatisticsTaskRunsInput, GetColumnStatisticsTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetColumnStatisticsTaskRunsInput, GetColumnStatisticsTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getColumnStatisticsTaskRuns(input:))
    }
}

extension GetColumnStatisticsTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetColumnStatisticsTaskRunsInput {
        return GetColumnStatisticsTaskRunsInput(
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutput`
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            catalogId: self.catalogId,
            filter: self.filter,
            hidePassword: self.hidePassword,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlerMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlerMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlerMetricsOutput`
    public func getCrawlerMetricsPaginated(input: GetCrawlerMetricsInput) -> ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlerMetricsInput, GetCrawlerMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCrawlerMetrics(input:))
    }
}

extension GetCrawlerMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlerMetricsInput {
        return GetCrawlerMetricsInput(
            crawlerNameList: self.crawlerNameList,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCrawlersOutput`
    public func getCrawlersPaginated(input: GetCrawlersInput) -> ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<GetCrawlersInput, GetCrawlersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCrawlers(input:))
    }
}

extension GetCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCrawlersInput {
        return GetCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetDatabasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDatabasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDatabasesOutput`
    public func getDatabasesPaginated(input: GetDatabasesInput) -> ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput> {
        return ClientRuntime.PaginatorSequence<GetDatabasesInput, GetDatabasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDatabases(input:))
    }
}

extension GetDatabasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDatabasesInput {
        return GetDatabasesInput(
            attributesToGet: self.attributesToGet,
            catalogId: self.catalogId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType
        )}
}
extension GlueClient {
    /// Paginate over `[GetDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDevEndpointsOutput`
    public func getDevEndpointsPaginated(input: GetDevEndpointsInput) -> ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<GetDevEndpointsInput, GetDevEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDevEndpoints(input:))
    }
}

extension GetDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevEndpointsInput {
        return GetDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[GetJobRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobRunsOutput`
    public func getJobRunsPaginated(input: GetJobRunsInput) -> ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobRunsInput, GetJobRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getJobRuns(input:))
    }
}

extension GetJobRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobRunsInput {
        return GetJobRunsInput(
            jobName: self.jobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetJobRunsInput, OperationStackOutput == GetJobRunsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getJobRunsPaginated`
    /// to access the nested member `[GlueClientTypes.JobRun]`
    /// - Returns: `[GlueClientTypes.JobRun]`
    public func jobRuns() async throws -> [GlueClientTypes.JobRun] {
        return try await self.asyncCompactMap { item in item.jobRuns }
    }
}
extension GlueClient {
    /// Paginate over `[GetJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetJobsOutput`
    public func getJobsPaginated(input: GetJobsInput) -> ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput> {
        return ClientRuntime.PaginatorSequence<GetJobsInput, GetJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getJobs(input:))
    }
}

extension GetJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetJobsInput {
        return GetJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetJobsInput, OperationStackOutput == GetJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getJobsPaginated`
    /// to access the nested member `[GlueClientTypes.Job]`
    /// - Returns: `[GlueClientTypes.Job]`
    public func jobs() async throws -> [GlueClientTypes.Job] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension GlueClient {
    /// Paginate over `[GetMLTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTaskRunsOutput`
    public func getMLTaskRunsPaginated(input: GetMLTaskRunsInput) -> ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTaskRunsInput, GetMLTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getMLTaskRuns(input:))
    }
}

extension GetMLTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTaskRunsInput {
        return GetMLTaskRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            transformId: self.transformId
        )}
}
extension GlueClient {
    /// Paginate over `[GetMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMLTransformsOutput`
    public func getMLTransformsPaginated(input: GetMLTransformsInput) -> ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<GetMLTransformsInput, GetMLTransformsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getMLTransforms(input:))
    }
}

extension GetMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMLTransformsInput {
        return GetMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}
extension GlueClient {
    /// Paginate over `[GetPartitionIndexesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionIndexesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionIndexesOutput`
    public func getPartitionIndexesPaginated(input: GetPartitionIndexesInput) -> ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionIndexesInput, GetPartitionIndexesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPartitionIndexes(input:))
    }
}

extension GetPartitionIndexesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionIndexesInput {
        return GetPartitionIndexesInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            nextToken: token,
            tableName: self.tableName
        )}
}

extension PaginatorSequence where OperationStackInput == GetPartitionIndexesInput, OperationStackOutput == GetPartitionIndexesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getPartitionIndexesPaginated`
    /// to access the nested member `[GlueClientTypes.PartitionIndexDescriptor]`
    /// - Returns: `[GlueClientTypes.PartitionIndexDescriptor]`
    public func partitionIndexDescriptorList() async throws -> [GlueClientTypes.PartitionIndexDescriptor] {
        return try await self.asyncCompactMap { item in item.partitionIndexDescriptorList }
    }
}
extension GlueClient {
    /// Paginate over `[GetPartitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPartitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPartitionsOutput`
    public func getPartitionsPaginated(input: GetPartitionsInput) -> ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput> {
        return ClientRuntime.PaginatorSequence<GetPartitionsInput, GetPartitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPartitions(input:))
    }
}

extension GetPartitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPartitionsInput {
        return GetPartitionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            excludeColumnSchema: self.excludeColumnSchema,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            segment: self.segment,
            tableName: self.tableName,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetResourcePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourcePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutput`
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetResourcePoliciesInput, OperationStackOutput == GetResourcePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getResourcePoliciesPaginated`
    /// to access the nested member `[GlueClientTypes.GluePolicy]`
    /// - Returns: `[GlueClientTypes.GluePolicy]`
    public func getResourcePoliciesResponseList() async throws -> [GlueClientTypes.GluePolicy] {
        return try await self.asyncCompactMap { item in item.getResourcePoliciesResponseList }
    }
}
extension GlueClient {
    /// Paginate over `[GetSecurityConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSecurityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSecurityConfigurationsOutput`
    public func getSecurityConfigurationsPaginated(input: GetSecurityConfigurationsInput) -> ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<GetSecurityConfigurationsInput, GetSecurityConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSecurityConfigurations(input:))
    }
}

extension GetSecurityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSecurityConfigurationsInput {
        return GetSecurityConfigurationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetSecurityConfigurationsInput, OperationStackOutput == GetSecurityConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getSecurityConfigurationsPaginated`
    /// to access the nested member `[GlueClientTypes.SecurityConfiguration]`
    /// - Returns: `[GlueClientTypes.SecurityConfiguration]`
    public func securityConfigurations() async throws -> [GlueClientTypes.SecurityConfiguration] {
        return try await self.asyncCompactMap { item in item.securityConfigurations }
    }
}
extension GlueClient {
    /// Paginate over `[GetTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTablesOutput`
    public func getTablesPaginated(input: GetTablesInput) -> ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput> {
        return ClientRuntime.PaginatorSequence<GetTablesInput, GetTablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTables(input:))
    }
}

extension GetTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTablesInput {
        return GetTablesInput(
            attributesToGet: self.attributesToGet,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            includeStatusDetails: self.includeStatusDetails,
            maxResults: self.maxResults,
            nextToken: token,
            queryAsOfTime: self.queryAsOfTime,
            transactionId: self.transactionId
        )}
}
extension GlueClient {
    /// Paginate over `[GetTableVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTableVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTableVersionsOutput`
    public func getTableVersionsPaginated(input: GetTableVersionsInput) -> ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetTableVersionsInput, GetTableVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTableVersions(input:))
    }
}

extension GetTableVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTableVersionsInput {
        return GetTableVersionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTriggersOutput`
    public func getTriggersPaginated(input: GetTriggersInput) -> ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput> {
        return ClientRuntime.PaginatorSequence<GetTriggersInput, GetTriggersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTriggers(input:))
    }
}

extension GetTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTriggersInput {
        return GetTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetTriggersInput, OperationStackOutput == GetTriggersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getTriggersPaginated`
    /// to access the nested member `[GlueClientTypes.Trigger]`
    /// - Returns: `[GlueClientTypes.Trigger]`
    public func triggers() async throws -> [GlueClientTypes.Trigger] {
        return try await self.asyncCompactMap { item in item.triggers }
    }
}
extension GlueClient {
    /// Paginate over `[GetUnfilteredPartitionsMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUnfilteredPartitionsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUnfilteredPartitionsMetadataOutput`
    public func getUnfilteredPartitionsMetadataPaginated(input: GetUnfilteredPartitionsMetadataInput) -> ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput> {
        return ClientRuntime.PaginatorSequence<GetUnfilteredPartitionsMetadataInput, GetUnfilteredPartitionsMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getUnfilteredPartitionsMetadata(input:))
    }
}

extension GetUnfilteredPartitionsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUnfilteredPartitionsMetadataInput {
        return GetUnfilteredPartitionsMetadataInput(
            auditContext: self.auditContext,
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            expression: self.expression,
            maxResults: self.maxResults,
            nextToken: token,
            querySessionContext: self.querySessionContext,
            region: self.region,
            segment: self.segment,
            supportedPermissionTypes: self.supportedPermissionTypes,
            tableName: self.tableName
        )}
}
extension GlueClient {
    /// Paginate over `[GetUserDefinedFunctionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUserDefinedFunctionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUserDefinedFunctionsOutput`
    public func getUserDefinedFunctionsPaginated(input: GetUserDefinedFunctionsInput) -> ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput> {
        return ClientRuntime.PaginatorSequence<GetUserDefinedFunctionsInput, GetUserDefinedFunctionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getUserDefinedFunctions(input:))
    }
}

extension GetUserDefinedFunctionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUserDefinedFunctionsInput {
        return GetUserDefinedFunctionsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            pattern: self.pattern
        )}
}
extension GlueClient {
    /// Paginate over `[GetWorkflowRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetWorkflowRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetWorkflowRunsOutput`
    public func getWorkflowRunsPaginated(input: GetWorkflowRunsInput) -> ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput> {
        return ClientRuntime.PaginatorSequence<GetWorkflowRunsInput, GetWorkflowRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getWorkflowRuns(input:))
    }
}

extension GetWorkflowRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetWorkflowRunsInput {
        return GetWorkflowRunsInput(
            includeGraph: self.includeGraph,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetWorkflowRunsInput, OperationStackOutput == GetWorkflowRunsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getWorkflowRunsPaginated`
    /// to access the nested member `[GlueClientTypes.WorkflowRun]`
    /// - Returns: `[GlueClientTypes.WorkflowRun]`
    public func runs() async throws -> [GlueClientTypes.WorkflowRun] {
        return try await self.asyncCompactMap { item in item.runs }
    }
}
extension GlueClient {
    /// Paginate over `[ListBlueprintsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBlueprintsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBlueprintsOutput`
    public func listBlueprintsPaginated(input: ListBlueprintsInput) -> ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput> {
        return ClientRuntime.PaginatorSequence<ListBlueprintsInput, ListBlueprintsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBlueprints(input:))
    }
}

extension ListBlueprintsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBlueprintsInput {
        return ListBlueprintsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

extension PaginatorSequence where OperationStackInput == ListBlueprintsInput, OperationStackOutput == ListBlueprintsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBlueprintsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func blueprints() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.blueprints }
    }
}
extension GlueClient {
    /// Paginate over `[ListColumnStatisticsTaskRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListColumnStatisticsTaskRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListColumnStatisticsTaskRunsOutput`
    public func listColumnStatisticsTaskRunsPaginated(input: ListColumnStatisticsTaskRunsInput) -> ClientRuntime.PaginatorSequence<ListColumnStatisticsTaskRunsInput, ListColumnStatisticsTaskRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListColumnStatisticsTaskRunsInput, ListColumnStatisticsTaskRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listColumnStatisticsTaskRuns(input:))
    }
}

extension ListColumnStatisticsTaskRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListColumnStatisticsTaskRunsInput {
        return ListColumnStatisticsTaskRunsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListCrawlersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCrawlersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCrawlersOutput`
    public func listCrawlersPaginated(input: ListCrawlersInput) -> ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput> {
        return ClientRuntime.PaginatorSequence<ListCrawlersInput, ListCrawlersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCrawlers(input:))
    }
}

extension ListCrawlersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCrawlersInput {
        return ListCrawlersInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListCustomEntityTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomEntityTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomEntityTypesOutput`
    public func listCustomEntityTypesPaginated(input: ListCustomEntityTypesInput) -> ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomEntityTypesInput, ListCustomEntityTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCustomEntityTypes(input:))
    }
}

extension ListCustomEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomEntityTypesInput {
        return ListCustomEntityTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityResultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityResultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityResultsOutput`
    public func listDataQualityResultsPaginated(input: ListDataQualityResultsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityResultsInput, ListDataQualityResultsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityResults(input:))
    }
}

extension ListDataQualityResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityResultsInput {
        return ListDataQualityResultsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRuleRecommendationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRuleRecommendationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRuleRecommendationRunsOutput`
    public func listDataQualityRuleRecommendationRunsPaginated(input: ListDataQualityRuleRecommendationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRuleRecommendationRunsInput, ListDataQualityRuleRecommendationRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRuleRecommendationRuns(input:))
    }
}

extension ListDataQualityRuleRecommendationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRuleRecommendationRunsInput {
        return ListDataQualityRuleRecommendationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetEvaluationRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetEvaluationRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetEvaluationRunsOutput`
    public func listDataQualityRulesetEvaluationRunsPaginated(input: ListDataQualityRulesetEvaluationRunsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetEvaluationRunsInput, ListDataQualityRulesetEvaluationRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRulesetEvaluationRuns(input:))
    }
}

extension ListDataQualityRulesetEvaluationRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetEvaluationRunsInput {
        return ListDataQualityRulesetEvaluationRunsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GlueClient {
    /// Paginate over `[ListDataQualityRulesetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataQualityRulesetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataQualityRulesetsOutput`
    public func listDataQualityRulesetsPaginated(input: ListDataQualityRulesetsInput) -> ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataQualityRulesetsInput, ListDataQualityRulesetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataQualityRulesets(input:))
    }
}

extension ListDataQualityRulesetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataQualityRulesetsInput {
        return ListDataQualityRulesetsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListDevEndpointsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevEndpointsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevEndpointsOutput`
    public func listDevEndpointsPaginated(input: ListDevEndpointsInput) -> ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevEndpointsInput, ListDevEndpointsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevEndpoints(input:))
    }
}

extension ListDevEndpointsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevEndpointsInput {
        return ListDevEndpointsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsInput, OperationStackOutput == ListJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func jobNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.jobNames }
    }
}
extension GlueClient {
    /// Paginate over `[ListMLTransformsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMLTransformsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMLTransformsOutput`
    public func listMLTransformsPaginated(input: ListMLTransformsInput) -> ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput> {
        return ClientRuntime.PaginatorSequence<ListMLTransformsInput, ListMLTransformsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMLTransforms(input:))
    }
}

extension ListMLTransformsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMLTransformsInput {
        return ListMLTransformsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListRegistriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRegistriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRegistriesOutput`
    public func listRegistriesPaginated(input: ListRegistriesInput) -> ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput> {
        return ClientRuntime.PaginatorSequence<ListRegistriesInput, ListRegistriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRegistries(input:))
    }
}

extension ListRegistriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistriesInput {
        return ListRegistriesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRegistriesInput, OperationStackOutput == ListRegistriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRegistriesPaginated`
    /// to access the nested member `[GlueClientTypes.RegistryListItem]`
    /// - Returns: `[GlueClientTypes.RegistryListItem]`
    public func registries() async throws -> [GlueClientTypes.RegistryListItem] {
        return try await self.asyncCompactMap { item in item.registries }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemasOutput`
    public func listSchemasPaginated(input: ListSchemasInput) -> ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemasInput, ListSchemasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemas(input:))
    }
}

extension ListSchemasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemasInput {
        return ListSchemasInput(
            maxResults: self.maxResults,
            nextToken: token,
            registryId: self.registryId
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemasInput, OperationStackOutput == ListSchemasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemasPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaListItem]`
    /// - Returns: `[GlueClientTypes.SchemaListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSchemaVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemaVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemaVersionsOutput`
    public func listSchemaVersionsPaginated(input: ListSchemaVersionsInput) -> ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemaVersionsInput, ListSchemaVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemaVersions(input:))
    }
}

extension ListSchemaVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaVersionsInput {
        return ListSchemaVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            schemaId: self.schemaId
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemaVersionsInput, OperationStackOutput == ListSchemaVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemaVersionsPaginated`
    /// to access the nested member `[GlueClientTypes.SchemaVersionListItem]`
    /// - Returns: `[GlueClientTypes.SchemaVersionListItem]`
    public func schemas() async throws -> [GlueClientTypes.SchemaVersionListItem] {
        return try await self.asyncCompactMap { item in item.schemas }
    }
}
extension GlueClient {
    /// Paginate over `[ListSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSessionsOutput`
    public func listSessionsPaginated(input: ListSessionsInput) -> ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSessionsInput, ListSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSessions(input:))
    }
}

extension ListSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionsInput {
        return ListSessionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            requestOrigin: self.requestOrigin,
            tags: self.tags
        )}
}
extension GlueClient {
    /// Paginate over `[ListTableOptimizerRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTableOptimizerRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTableOptimizerRunsOutput`
    public func listTableOptimizerRunsPaginated(input: ListTableOptimizerRunsInput) -> ClientRuntime.PaginatorSequence<ListTableOptimizerRunsInput, ListTableOptimizerRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListTableOptimizerRunsInput, ListTableOptimizerRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTableOptimizerRuns(input:))
    }
}

extension ListTableOptimizerRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableOptimizerRunsInput {
        return ListTableOptimizerRunsInput(
            catalogId: self.catalogId,
            databaseName: self.databaseName,
            maxResults: self.maxResults,
            nextToken: token,
            tableName: self.tableName,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListTableOptimizerRunsInput, OperationStackOutput == ListTableOptimizerRunsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTableOptimizerRunsPaginated`
    /// to access the nested member `[GlueClientTypes.TableOptimizerRun]`
    /// - Returns: `[GlueClientTypes.TableOptimizerRun]`
    public func tableOptimizerRuns() async throws -> [GlueClientTypes.TableOptimizerRun] {
        return try await self.asyncCompactMap { item in item.tableOptimizerRuns }
    }
}
extension GlueClient {
    /// Paginate over `[ListTriggersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTriggersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTriggersOutput`
    public func listTriggersPaginated(input: ListTriggersInput) -> ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput> {
        return ClientRuntime.PaginatorSequence<ListTriggersInput, ListTriggersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTriggers(input:))
    }
}

extension ListTriggersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTriggersInput {
        return ListTriggersInput(
            dependentJobName: self.dependentJobName,
            maxResults: self.maxResults,
            nextToken: token,
            tags: self.tags
        )}
}

extension PaginatorSequence where OperationStackInput == ListTriggersInput, OperationStackOutput == ListTriggersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTriggersPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func triggerNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.triggerNames }
    }
}
extension GlueClient {
    /// Paginate over `[ListUsageProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsageProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsageProfilesOutput`
    public func listUsageProfilesPaginated(input: ListUsageProfilesInput) -> ClientRuntime.PaginatorSequence<ListUsageProfilesInput, ListUsageProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListUsageProfilesInput, ListUsageProfilesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUsageProfiles(input:))
    }
}

extension ListUsageProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsageProfilesInput {
        return ListUsageProfilesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListUsageProfilesInput, OperationStackOutput == ListUsageProfilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUsageProfilesPaginated`
    /// to access the nested member `[GlueClientTypes.UsageProfileDefinition]`
    /// - Returns: `[GlueClientTypes.UsageProfileDefinition]`
    public func profiles() async throws -> [GlueClientTypes.UsageProfileDefinition] {
        return try await self.asyncCompactMap { item in item.profiles }
    }
}
extension GlueClient {
    /// Paginate over `[ListWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowsOutput`
    public func listWorkflowsPaginated(input: ListWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflows(input:))
    }
}

extension ListWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowsInput {
        return ListWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkflowsInput, OperationStackOutput == ListWorkflowsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func workflows() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.workflows }
    }
}
extension GlueClient {
    /// Paginate over `[SearchTablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchTablesOutput`
    public func searchTablesPaginated(input: SearchTablesInput) -> ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput> {
        return ClientRuntime.PaginatorSequence<SearchTablesInput, SearchTablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchTables(input:))
    }
}

extension SearchTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchTablesInput {
        return SearchTablesInput(
            catalogId: self.catalogId,
            filters: self.filters,
            includeStatusDetails: self.includeStatusDetails,
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareType: self.resourceShareType,
            searchText: self.searchText,
            sortCriteria: self.sortCriteria
        )}
}
