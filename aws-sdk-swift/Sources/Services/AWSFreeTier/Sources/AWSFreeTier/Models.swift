//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// An unexpected error occurred during the processing of your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FreeTierClientTypes {

    public enum Dimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case description
        case freeTierType
        case operation
        case region
        case service
        case usagePercentage
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .description,
                .freeTierType,
                .operation,
                .region,
                .service,
                .usagePercentage,
                .usageType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .description: return "DESCRIPTION"
            case .freeTierType: return "FREE_TIER_TYPE"
            case .operation: return "OPERATION"
            case .region: return "REGION"
            case .service: return "SERVICE"
            case .usagePercentage: return "USAGE_PERCENTAGE"
            case .usageType: return "USAGE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    /// Contains the specifications for the filters to use for your request.
    public struct DimensionValues: Swift.Sendable {
        /// The name of the dimension that you want to filter on.
        /// This member is required.
        public var key: FreeTierClientTypes.Dimension?
        /// The match options that you can use to filter your results. You can specify only one of these values in the array.
        /// This member is required.
        public var matchOptions: [FreeTierClientTypes.MatchOption]?
        /// The metadata values you can specify to filter upon, so that the results all match at least one of the specified values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: FreeTierClientTypes.Dimension? = nil,
            matchOptions: [FreeTierClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension FreeTierClientTypes {

    /// Consists of a Amazon Web Services Free Tier offer’s metadata and your data usage for the offer.
    public struct FreeTierUsage: Swift.Sendable {
        /// Describes the actual usage accrued month-to-day (MTD) that you've used so far.
        public var actualUsageAmount: Swift.Double
        /// The description of the Free Tier offer.
        public var description: Swift.String?
        /// Describes the forecasted usage by the month that you're expected to use.
        public var forecastedUsageAmount: Swift.Double
        /// Describes the type of the Free Tier offer. For example, the offer can be "12 Months Free", "Always Free", and "Free Trial".
        public var freeTierType: Swift.String?
        /// Describes the maximum usage allowed in Free Tier.
        public var limit: Swift.Double
        /// Describes usageType more granularly with the specific Amazon Web Service API operation. For example, this can be the RunInstances API operation for Amazon Elastic Compute Cloud.
        public var operation: Swift.String?
        /// Describes the Amazon Web Services Region for which this offer is applicable
        public var region: Swift.String?
        /// The name of the Amazon Web Service providing the Free Tier offer. For example, this can be Amazon Elastic Compute Cloud.
        public var service: Swift.String?
        /// Describes the unit of the usageType, such as Hrs.
        public var unit: Swift.String?
        /// Describes the usage details of the offer. For example, this might be Global-BoxUsage:freetrial.
        public var usageType: Swift.String?

        public init(
            actualUsageAmount: Swift.Double = 0.0,
            description: Swift.String? = nil,
            forecastedUsageAmount: Swift.Double = 0.0,
            freeTierType: Swift.String? = nil,
            limit: Swift.Double = 0.0,
            operation: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.actualUsageAmount = actualUsageAmount
            self.description = description
            self.forecastedUsageAmount = forecastedUsageAmount
            self.freeTierType = freeTierType
            self.limit = limit
            self.operation = operation
            self.region = region
            self.service = service
            self.unit = unit
            self.usageType = usageType
        }
    }
}

public struct GetFreeTierUsageOutput: Swift.Sendable {
    /// The list of Free Tier usage objects that meet your filter expression.
    /// This member is required.
    public var freeTierUsages: [FreeTierClientTypes.FreeTierUsage]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        freeTierUsages: [FreeTierClientTypes.FreeTierUsage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.freeTierUsages = freeTierUsages
        self.nextToken = nextToken
    }
}

extension FreeTierClientTypes {

    /// Use Expression to filter in the GetFreeTierUsage API operation. You can use the following patterns:
    ///
    /// * Simple dimension values (Dimensions root operator)
    ///
    /// * Complex expressions with logical operators (AND, NOT, and OR root operators).
    ///
    ///
    /// For simple dimension values, you can set the dimension name, values, and match type for the filters that you plan to use. Example for simple dimension values You can filter to match exactly for REGION==us-east-1 OR REGION==us-west-1. The corresponding Expression appears like the following: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] } } As shown in the previous example, lists of dimension values are combined with OR when you apply the filter. For complex expressions with logical operators, you can have nested expressions to use the logical operators and specify advanced filtering. Example for complex expressions with logical operators You can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (SERVICE CONTAINS AWSLambda)) AND (USAGE_TYPE !CONTAINS DataTransfer). The corresponding Expression appears like the following: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] }}, {"Dimensions": { "Key": "SERVICE", "Values": ["AWSLambda"], "MatchOptions": ["CONTAINS"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"], "MatchOptions": ["CONTAINS"] }}} ] } In the following Contents, you must specify exactly one of the following root operators.
    public struct Expression: Swift.Sendable {
        /// Return results that match all Expressions that you specified in the array.
        public var and: [FreeTierClientTypes.Expression]?
        /// The specific dimension, values, and match type to filter objects with.
        public var dimensions: FreeTierClientTypes.DimensionValues?
        /// Return results that don’t match the Expression that you specified.
        @Indirect public var not: FreeTierClientTypes.Expression?
        /// Return results that match any of the Expressions that you specified. in the array.
        public var or: [FreeTierClientTypes.Expression]?

        public init(
            and: [FreeTierClientTypes.Expression]? = nil,
            dimensions: FreeTierClientTypes.DimensionValues? = nil,
            not: FreeTierClientTypes.Expression? = nil,
            or: [FreeTierClientTypes.Expression]? = nil
        )
        {
            self.and = and
            self.dimensions = dimensions
            self.not = not
            self.or = or
        }
    }
}

public struct GetFreeTierUsageInput: Swift.Sendable {
    /// An expression that specifies the conditions that you want each FreeTierUsage object to meet.
    public var filter: FreeTierClientTypes.Expression?
    /// The maximum number of results to return in the response. MaxResults means that there can be up to the specified number of values, but there might be fewer results based on your filters.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        filter: FreeTierClientTypes.Expression? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GetFreeTierUsageInput {

    static func urlPathProvider(_ value: GetFreeTierUsageInput) -> Swift.String? {
        return "/"
    }
}

extension GetFreeTierUsageInput {

    static func write(value: GetFreeTierUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: FreeTierClientTypes.Expression.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetFreeTierUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFreeTierUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFreeTierUsageOutput()
        value.freeTierUsages = try reader["freeTierUsages"].readListIfPresent(memberReadingClosure: FreeTierClientTypes.FreeTierUsage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

enum GetFreeTierUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FreeTierClientTypes.FreeTierUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> FreeTierClientTypes.FreeTierUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FreeTierClientTypes.FreeTierUsage()
        value.service = try reader["service"].readIfPresent()
        value.operation = try reader["operation"].readIfPresent()
        value.usageType = try reader["usageType"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.actualUsageAmount = try reader["actualUsageAmount"].readIfPresent() ?? 0
        value.forecastedUsageAmount = try reader["forecastedUsageAmount"].readIfPresent() ?? 0
        value.limit = try reader["limit"].readIfPresent() ?? 0
        value.unit = try reader["unit"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.freeTierType = try reader["freeTierType"].readIfPresent()
        return value
    }
}

extension FreeTierClientTypes.Expression {

    static func write(value: FreeTierClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["And"].writeList(value.and, memberWritingClosure: FreeTierClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dimensions"].write(value.dimensions, with: FreeTierClientTypes.DimensionValues.write(value:to:))
        try writer["Not"].write(value.not, with: FreeTierClientTypes.Expression.write(value:to:))
        try writer["Or"].writeList(value.or, memberWritingClosure: FreeTierClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension FreeTierClientTypes.DimensionValues {

    static func write(value: FreeTierClientTypes.DimensionValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["MatchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<FreeTierClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum FreeTierClientTypes {}
