//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct DeleteRecordOutput: Swift.Sendable {

    public init() { }
}

public struct PutRecordOutput: Swift.Sendable {

    public init() { }
}

/// You do not have permission to perform an action.
public struct AccessForbidden: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessForbidden" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal failure occurred. Try your request again. If the problem persists, contact Amazon Web Services customer support.
public struct InternalFailure: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailure" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailable: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailable" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was an error validating your request.
public struct ValidationError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    public enum ExpirationTimeResponse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationTimeResponse] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    /// The identifier that identifies the batch of Records you are retrieving in a batch.
    public struct BatchGetRecordIdentifier: Swift.Sendable {
        /// The name or Amazon Resource Name (ARN) of the FeatureGroup containing the records you are retrieving in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
        public var featureNames: [Swift.String]?
        /// The value for a list of record identifiers in string format.
        /// This member is required.
        public var recordIdentifiersValueAsString: [Swift.String]?

        public init(
            featureGroupName: Swift.String? = nil,
            featureNames: [Swift.String]? = nil,
            recordIdentifiersValueAsString: [Swift.String]? = nil
        )
        {
            self.featureGroupName = featureGroupName
            self.featureNames = featureNames
            self.recordIdentifiersValueAsString = recordIdentifiersValueAsString
        }
    }
}

public struct BatchGetRecordInput: Swift.Sendable {
    /// Parameter to request ExpiresAt in response. If Enabled, BatchGetRecord will return the value of ExpiresAt, if it is not null. If Disabled and null, BatchGetRecord will return null.
    public var expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse?
    /// A list containing the name or Amazon Resource Name (ARN) of the FeatureGroup, the list of names of Features to be retrieved, and the corresponding RecordIdentifier values as strings.
    /// This member is required.
    public var identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init(
        expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse? = nil,
        identifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.expirationTimeResponse = expirationTimeResponse
        self.identifiers = identifiers
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    /// The error that has occurred when attempting to retrieve a batch of Records.
    public struct BatchGetRecordError: Swift.Sendable {
        /// The error code of an error that has occurred when attempting to retrieve a batch of Records. For more information on errors, see [Errors](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_GetRecord.html#API_feature_store_GetRecord_Errors).
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message of an error that has occurred when attempting to retrieve a record in the batch.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the feature group that the record belongs to.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The value for the RecordIdentifier in string format of a Record from a FeatureGroup that is causing an error when attempting to be retrieved.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.featureGroupName = featureGroupName
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    /// The value associated with a feature.
    public struct FeatureValue: Swift.Sendable {
        /// The name of a feature that a feature value corresponds to.
        /// This member is required.
        public var featureName: Swift.String?
        /// The value in string format associated with a feature. Used when your CollectionType is None. Note that features types can be String, Integral, or Fractional. This value represents all three types as a string.
        public var valueAsString: Swift.String?
        /// The list of values in string format associated with a feature. Used when your CollectionType is a List, Set, or Vector. Note that features types can be String, Integral, or Fractional. These values represents all three types as a string.
        public var valueAsStringList: [Swift.String]?

        public init(
            featureName: Swift.String? = nil,
            valueAsString: Swift.String? = nil,
            valueAsStringList: [Swift.String]? = nil
        )
        {
            self.featureName = featureName
            self.valueAsString = valueAsString
            self.valueAsStringList = valueAsStringList
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    /// The output of records that have been retrieved in a batch.
    public struct BatchGetRecordResultDetail: Swift.Sendable {
        /// The ExpiresAt ISO string of the requested record.
        public var expiresAt: Swift.String?
        /// The FeatureGroupName containing Records you retrieved in a batch.
        /// This member is required.
        public var featureGroupName: Swift.String?
        /// The Record retrieved.
        /// This member is required.
        public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
        /// The value of the record identifier in string format.
        /// This member is required.
        public var recordIdentifierValueAsString: Swift.String?

        public init(
            expiresAt: Swift.String? = nil,
            featureGroupName: Swift.String? = nil,
            record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
            recordIdentifierValueAsString: Swift.String? = nil
        )
        {
            self.expiresAt = expiresAt
            self.featureGroupName = featureGroupName
            self.record = record
            self.recordIdentifierValueAsString = recordIdentifierValueAsString
        }
    }
}

public struct BatchGetRecordOutput: Swift.Sendable {
    /// A list of errors that have occurred when retrieving a batch of Records.
    /// This member is required.
    public var errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]?
    /// A list of Records you requested to be retrieved in batch.
    /// This member is required.
    public var records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]?
    /// A unprocessed list of FeatureGroup names, with their corresponding RecordIdentifier value, and Feature name.
    /// This member is required.
    public var unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]?

    public init(
        errors: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError]? = nil,
        records: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail]? = nil,
        unprocessedIdentifiers: [SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier]? = nil
    )
    {
        self.errors = errors
        self.records = records
        self.unprocessedIdentifiers = unprocessedIdentifiers
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    public enum DeletionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hardDelete
        case softDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [DeletionMode] {
            return [
                .hardDelete,
                .softDelete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hardDelete: return "HardDelete"
            case .softDelete: return "SoftDelete"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    public enum TargetStore: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offlineStore
        case onlineStore
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStore] {
            return [
                .offlineStore,
                .onlineStore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offlineStore: return "OfflineStore"
            case .onlineStore: return "OnlineStore"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteRecordInput: Swift.Sendable {
    /// The name of the deletion mode for deleting the record. By default, the deletion mode is set to SoftDelete.
    public var deletionMode: SageMakerFeatureStoreRuntimeClientTypes.DeletionMode?
    /// Timestamp indicating when the deletion event occurred. EventTime can be used to query data at a certain point in time.
    /// This member is required.
    public var eventTime: Swift.String?
    /// The name or Amazon Resource Name (ARN) of the feature group to delete the record from.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// The value for the RecordIdentifier that uniquely identifies the record, in string format.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?
    /// A list of stores from which you're deleting the record. By default, Feature Store deletes the record from all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?

    public init(
        deletionMode: SageMakerFeatureStoreRuntimeClientTypes.DeletionMode? = nil,
        eventTime: Swift.String? = nil,
        featureGroupName: Swift.String? = nil,
        recordIdentifierValueAsString: Swift.String? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil
    )
    {
        self.deletionMode = deletionMode
        self.eventTime = eventTime
        self.featureGroupName = featureGroupName
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
        self.targetStores = targetStores
    }
}

/// A resource that is required to perform an action was not found.
public struct ResourceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetRecordInput: Swift.Sendable {
    /// Parameter to request ExpiresAt in response. If Enabled, GetRecord will return the value of ExpiresAt, if it is not null. If Disabled and null, GetRecord will return null.
    public var expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse?
    /// The name or Amazon Resource Name (ARN) of the feature group from which you want to retrieve a record.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of names of Features to be retrieved. If not specified, the latest value for all the Features are returned.
    public var featureNames: [Swift.String]?
    /// The value that corresponds to RecordIdentifier type and uniquely identifies the record in the FeatureGroup.
    /// This member is required.
    public var recordIdentifierValueAsString: Swift.String?

    public init(
        expirationTimeResponse: SageMakerFeatureStoreRuntimeClientTypes.ExpirationTimeResponse? = nil,
        featureGroupName: Swift.String? = nil,
        featureNames: [Swift.String]? = nil,
        recordIdentifierValueAsString: Swift.String? = nil
    )
    {
        self.expirationTimeResponse = expirationTimeResponse
        self.featureGroupName = featureGroupName
        self.featureNames = featureNames
        self.recordIdentifierValueAsString = recordIdentifierValueAsString
    }
}

public struct GetRecordOutput: Swift.Sendable {
    /// The ExpiresAt ISO string of the requested record.
    public var expiresAt: Swift.String?
    /// The record you requested. A list of FeatureValues.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?

    public init(
        expiresAt: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil
    )
    {
        self.expiresAt = expiresAt
        self.record = record
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    public enum TtlDurationUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case hours
        case minutes
        case seconds
        case weeks
        case sdkUnknown(Swift.String)

        public static var allCases: [TtlDurationUnit] {
            return [
                .days,
                .hours,
                .minutes,
                .seconds,
                .weeks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "Days"
            case .hours: return "Hours"
            case .minutes: return "Minutes"
            case .seconds: return "Seconds"
            case .weeks: return "Weeks"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes {

    /// Time to live duration, where the record is hard deleted after the expiration time is reached; ExpiresAt = EventTime + TtlDuration. For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
    public struct TtlDuration: Swift.Sendable {
        /// TtlDuration time unit.
        /// This member is required.
        public var unit: SageMakerFeatureStoreRuntimeClientTypes.TtlDurationUnit?
        /// TtlDuration time value.
        /// This member is required.
        public var value: Swift.Int?

        public init(
            unit: SageMakerFeatureStoreRuntimeClientTypes.TtlDurationUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }
}

public struct PutRecordInput: Swift.Sendable {
    /// The name or Amazon Resource Name (ARN) of the feature group that you want to insert the record into.
    /// This member is required.
    public var featureGroupName: Swift.String?
    /// List of FeatureValues to be inserted. This will be a full over-write. If you only want to update few of the feature values, do the following:
    ///
    /// * Use GetRecord to retrieve the latest record.
    ///
    /// * Update the record returned from GetRecord.
    ///
    /// * Use PutRecord to update feature values.
    /// This member is required.
    public var record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]?
    /// A list of stores to which you're adding the record. By default, Feature Store adds the record to all of the stores that you're using for the FeatureGroup.
    public var targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]?
    /// Time to live duration, where the record is hard deleted after the expiration time is reached; ExpiresAt = EventTime + TtlDuration. For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
    public var ttlDuration: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration?

    public init(
        featureGroupName: Swift.String? = nil,
        record: [SageMakerFeatureStoreRuntimeClientTypes.FeatureValue]? = nil,
        targetStores: [SageMakerFeatureStoreRuntimeClientTypes.TargetStore]? = nil,
        ttlDuration: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration? = nil
    )
    {
        self.featureGroupName = featureGroupName
        self.record = record
        self.targetStores = targetStores
        self.ttlDuration = ttlDuration
    }
}

extension BatchGetRecordInput {

    static func urlPathProvider(_ value: BatchGetRecordInput) -> Swift.String? {
        return "/BatchGetRecord"
    }
}

extension DeleteRecordInput {

    static func urlPathProvider(_ value: DeleteRecordInput) -> Swift.String? {
        guard let featureGroupName = value.featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

extension DeleteRecordInput {

    static func queryItemProvider(_ value: DeleteRecordInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let recordIdentifierValueAsString = value.recordIdentifierValueAsString else {
            let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let recordIdentifierValueAsStringQueryItem = Smithy.URIQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
        items.append(recordIdentifierValueAsStringQueryItem)
        if let targetStores = value.targetStores {
            targetStores.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "TargetStores".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        guard let eventTime = value.eventTime else {
            let message = "Creating a URL Query Item failed. eventTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let eventTimeQueryItem = Smithy.URIQueryItem(name: "EventTime".urlPercentEncoding(), value: Swift.String(eventTime).urlPercentEncoding())
        items.append(eventTimeQueryItem)
        if let deletionMode = value.deletionMode {
            let deletionModeQueryItem = Smithy.URIQueryItem(name: "DeletionMode".urlPercentEncoding(), value: Swift.String(deletionMode.rawValue).urlPercentEncoding())
            items.append(deletionModeQueryItem)
        }
        return items
    }
}

extension GetRecordInput {

    static func urlPathProvider(_ value: GetRecordInput) -> Swift.String? {
        guard let featureGroupName = value.featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

extension GetRecordInput {

    static func queryItemProvider(_ value: GetRecordInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let recordIdentifierValueAsString = value.recordIdentifierValueAsString else {
            let message = "Creating a URL Query Item failed. recordIdentifierValueAsString is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let recordIdentifierValueAsStringQueryItem = Smithy.URIQueryItem(name: "RecordIdentifierValueAsString".urlPercentEncoding(), value: Swift.String(recordIdentifierValueAsString).urlPercentEncoding())
        items.append(recordIdentifierValueAsStringQueryItem)
        if let expirationTimeResponse = value.expirationTimeResponse {
            let expirationTimeResponseQueryItem = Smithy.URIQueryItem(name: "ExpirationTimeResponse".urlPercentEncoding(), value: Swift.String(expirationTimeResponse.rawValue).urlPercentEncoding())
            items.append(expirationTimeResponseQueryItem)
        }
        if let featureNames = value.featureNames {
            featureNames.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "FeatureName".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension PutRecordInput {

    static func urlPathProvider(_ value: PutRecordInput) -> Swift.String? {
        guard let featureGroupName = value.featureGroupName else {
            return nil
        }
        return "/FeatureGroup/\(featureGroupName.urlPercentEncoding())"
    }
}

extension BatchGetRecordInput {

    static func write(value: BatchGetRecordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExpirationTimeResponse"].write(value.expirationTimeResponse)
        try writer["Identifiers"].writeList(value.identifiers, memberWritingClosure: SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutRecordInput {

    static func write(value: PutRecordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Record"].writeList(value.record, memberWritingClosure: SageMakerFeatureStoreRuntimeClientTypes.FeatureValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetStores"].writeList(value.targetStores, memberWritingClosure: SmithyReadWrite.WritingClosureBox<SageMakerFeatureStoreRuntimeClientTypes.TargetStore>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TtlDuration"].write(value.ttlDuration, with: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration.write(value:to:))
    }
}

extension BatchGetRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetRecordOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.records = try reader["Records"].readListIfPresent(memberReadingClosure: SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unprocessedIdentifiers = try reader["UnprocessedIdentifiers"].readListIfPresent(memberReadingClosure: SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DeleteRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRecordOutput {
        return DeleteRecordOutput()
    }
}

extension GetRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecordOutput()
        value.expiresAt = try reader["ExpiresAt"].readIfPresent()
        value.record = try reader["Record"].readListIfPresent(memberReadingClosure: SageMakerFeatureStoreRuntimeClientTypes.FeatureValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRecordOutput {
        return PutRecordOutput()
    }
}

enum BatchGetRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessForbidden": return try AccessForbidden.makeError(baseError: baseError)
            case "InternalFailure": return try InternalFailure.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailable.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessForbidden": return try AccessForbidden.makeError(baseError: baseError)
            case "InternalFailure": return try InternalFailure.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailable.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessForbidden": return try AccessForbidden.makeError(baseError: baseError)
            case "InternalFailure": return try InternalFailure.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailable.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessForbidden": return try AccessForbidden.makeError(baseError: baseError)
            case "InternalFailure": return try InternalFailure.makeError(baseError: baseError)
            case "ServiceUnavailable": return try ServiceUnavailable.makeError(baseError: baseError)
            case "ValidationError": return try ValidationError.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessForbidden {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessForbidden {
        let reader = baseError.errorBodyReader
        var value = AccessForbidden()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailable {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailable {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailable()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationError {
        let reader = baseError.errorBodyReader
        var value = ValidationError()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailure {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailure {
        let reader = baseError.errorBodyReader
        var value = InternalFailure()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFound {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFound {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordResultDetail()
        value.featureGroupName = try reader["FeatureGroupName"].readIfPresent() ?? ""
        value.recordIdentifierValueAsString = try reader["RecordIdentifierValueAsString"].readIfPresent() ?? ""
        value.record = try reader["Record"].readListIfPresent(memberReadingClosure: SageMakerFeatureStoreRuntimeClientTypes.FeatureValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.expiresAt = try reader["ExpiresAt"].readIfPresent()
        return value
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.FeatureValue {

    static func write(value: SageMakerFeatureStoreRuntimeClientTypes.FeatureValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeatureName"].write(value.featureName)
        try writer["ValueAsString"].write(value.valueAsString)
        try writer["ValueAsStringList"].writeList(value.valueAsStringList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerFeatureStoreRuntimeClientTypes.FeatureValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerFeatureStoreRuntimeClientTypes.FeatureValue()
        value.featureName = try reader["FeatureName"].readIfPresent() ?? ""
        value.valueAsString = try reader["ValueAsString"].readIfPresent()
        value.valueAsStringList = try reader["ValueAsStringList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError {

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordError()
        value.featureGroupName = try reader["FeatureGroupName"].readIfPresent() ?? ""
        value.recordIdentifierValueAsString = try reader["RecordIdentifierValueAsString"].readIfPresent() ?? ""
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier {

    static func write(value: SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeatureGroupName"].write(value.featureGroupName)
        try writer["FeatureNames"].writeList(value.featureNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordIdentifiersValueAsString"].writeList(value.recordIdentifiersValueAsString, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SageMakerFeatureStoreRuntimeClientTypes.BatchGetRecordIdentifier()
        value.featureGroupName = try reader["FeatureGroupName"].readIfPresent() ?? ""
        value.recordIdentifiersValueAsString = try reader["RecordIdentifiersValueAsString"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.featureNames = try reader["FeatureNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SageMakerFeatureStoreRuntimeClientTypes.TtlDuration {

    static func write(value: SageMakerFeatureStoreRuntimeClientTypes.TtlDuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }
}

public enum SageMakerFeatureStoreRuntimeClientTypes {}
