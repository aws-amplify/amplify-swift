//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Access to a resource was denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Two processes are trying to modify a resource simultaneously.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A specified entity does not exist.
public struct EntityNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal service error occurred.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input provided was not valid.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation timed out.
public struct OperationTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LakeFormationClientTypes {

    /// A structure containing an LF-tag key-value pair.
    public struct LFTagPair: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            catalogId: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.catalogId = catalogId
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure for the catalog object.
    public struct CatalogResource: Swift.Sendable {

        public init() { }
    }
}

extension LakeFormationClientTypes {

    /// A structure for the database object.
    public struct DatabaseResource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The name of the database resource. Unique to the Data Catalog.
        /// This member is required.
        public var name: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.name = name
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure for a data cells filter resource.
    public struct DataCellsFilterResource: Swift.Sendable {
        /// A database in the Glue Data Catalog.
        public var databaseName: Swift.String?
        /// The name of the data cells filter.
        public var name: Swift.String?
        /// The ID of the catalog to which the table belongs.
        public var tableCatalogId: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            tableCatalogId: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.name = name
            self.tableCatalogId = tableCatalogId
            self.tableName = tableName
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure for a data location object where permissions are granted or revoked.
    public struct DataLocationResource: Swift.Sendable {
        /// The identifier for the Data Catalog where the location is registered with Lake Formation. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The Amazon Resource Name (ARN) that uniquely identifies the data location resource.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.resourceArn = resourceArn
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure containing an LF-tag key and values for a resource.
    public struct LFTagKeyResource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            catalogId: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.catalogId = catalogId
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure that allows an admin to grant user permissions on certain conditions. For example, granting a role access to all columns that do not have the LF-tag 'PII' in tables that have the LF-tag 'Prod'.
    public struct LFTag: Swift.Sendable {
        /// The key-name for the LF-tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A list of possible values an attribute can take. The maximum number of values that can be defined for a LF-Tag is 1000. A single API call supports 50 values. You can use multiple API calls to add more values.
        /// This member is required.
        public var tagValues: [Swift.String]?

        public init(
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }
}

extension LakeFormationClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case database
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .database,
                .table
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .database: return "DATABASE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure containing a list of LF-tag conditions that apply to a resource's LF-tag policy.
    public struct LFTagPolicyResource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalogId: Swift.String?
        /// A list of LF-tag conditions that apply to the resource's LF-tag policy.
        /// This member is required.
        public var expression: [LakeFormationClientTypes.LFTag]?
        /// The resource type for which the LF-tag policy applies.
        /// This member is required.
        public var resourceType: LakeFormationClientTypes.ResourceType?

        public init(
            catalogId: Swift.String? = nil,
            expression: [LakeFormationClientTypes.LFTag]? = nil,
            resourceType: LakeFormationClientTypes.ResourceType? = nil
        )
        {
            self.catalogId = catalogId
            self.expression = expression
            self.resourceType = resourceType
        }
    }
}

extension LakeFormationClientTypes {

    /// A wildcard object representing every table under a database.
    public struct TableWildcard: Swift.Sendable {

        public init() { }
    }
}

extension LakeFormationClientTypes {

    /// A structure for the table object. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
    public struct TableResource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The name of the database for the table. Unique to a Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the table.
        public var name: Swift.String?
        /// A wildcard object representing every table under a database. At least one of TableResource$Name or TableResource$TableWildcard is required.
        public var tableWildcard: LakeFormationClientTypes.TableWildcard?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            tableWildcard: LakeFormationClientTypes.TableWildcard? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.name = name
            self.tableWildcard = tableWildcard
        }
    }
}

extension LakeFormationClientTypes {

    /// A wildcard object, consisting of an optional list of excluded column names or indexes.
    public struct ColumnWildcard: Swift.Sendable {
        /// Excludes column names. Any column with this name will be excluded.
        public var excludedColumnNames: [Swift.String]?

        public init(
            excludedColumnNames: [Swift.String]? = nil
        )
        {
            self.excludedColumnNames = excludedColumnNames
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure for a table with columns object. This object is only used when granting a SELECT permission. This object must take a value for at least one of ColumnsNames, ColumnsIndexes, or ColumnsWildcard.
    public struct TableWithColumnsResource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, it is the account ID of the caller.
        public var catalogId: Swift.String?
        /// The list of column names for the table. At least one of ColumnNames or ColumnWildcard is required.
        public var columnNames: [Swift.String]?
        /// A wildcard specified by a ColumnWildcard object. At least one of ColumnNames or ColumnWildcard is required.
        public var columnWildcard: LakeFormationClientTypes.ColumnWildcard?
        /// The name of the database for the table with columns resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database privileges to a principal.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the table resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
        /// This member is required.
        public var name: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            columnNames: [Swift.String]? = nil,
            columnWildcard: LakeFormationClientTypes.ColumnWildcard? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.columnNames = columnNames
            self.columnWildcard = columnWildcard
            self.databaseName = databaseName
            self.name = name
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure for the resource.
    public struct Resource: Swift.Sendable {
        /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
        public var catalog: LakeFormationClientTypes.CatalogResource?
        /// A data cell filter.
        public var dataCellsFilter: LakeFormationClientTypes.DataCellsFilterResource?
        /// The location of an Amazon S3 path where permissions are granted or revoked.
        public var dataLocation: LakeFormationClientTypes.DataLocationResource?
        /// The database for the resource. Unique to the Data Catalog. A database is a set of associated table definitions organized into a logical group. You can Grant and Revoke database permissions to a principal.
        public var database: LakeFormationClientTypes.DatabaseResource?
        /// The LF-tag key and values attached to a resource.
        public var lfTag: LakeFormationClientTypes.LFTagKeyResource?
        /// A list of LF-tag conditions that define a resource's LF-tag policy.
        public var lfTagPolicy: LakeFormationClientTypes.LFTagPolicyResource?
        /// The table for the resource. A table is a metadata definition that represents your data. You can Grant and Revoke table privileges to a principal.
        public var table: LakeFormationClientTypes.TableResource?
        /// The table with columns for the resource. A principal with permissions to this resource can select metadata from the columns of a table in the Data Catalog and the underlying data in Amazon S3.
        public var tableWithColumns: LakeFormationClientTypes.TableWithColumnsResource?

        public init(
            catalog: LakeFormationClientTypes.CatalogResource? = nil,
            dataCellsFilter: LakeFormationClientTypes.DataCellsFilterResource? = nil,
            dataLocation: LakeFormationClientTypes.DataLocationResource? = nil,
            database: LakeFormationClientTypes.DatabaseResource? = nil,
            lfTag: LakeFormationClientTypes.LFTagKeyResource? = nil,
            lfTagPolicy: LakeFormationClientTypes.LFTagPolicyResource? = nil,
            table: LakeFormationClientTypes.TableResource? = nil,
            tableWithColumns: LakeFormationClientTypes.TableWithColumnsResource? = nil
        )
        {
            self.catalog = catalog
            self.dataCellsFilter = dataCellsFilter
            self.dataLocation = dataLocation
            self.database = database
            self.lfTag = lfTag
            self.lfTagPolicy = lfTagPolicy
            self.table = table
            self.tableWithColumns = tableWithColumns
        }
    }
}

public struct AddLFTagsToResourceInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The LF-tags to attach to the resource.
    /// This member is required.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// The database, table, or column resource to which to attach an LF-tag.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lfTags = lfTags
        self.resource = resource
    }
}

extension LakeFormationClientTypes {

    /// Contains details about an error.
    public struct ErrorDetail: Swift.Sendable {
        /// The code associated with this error.
        public var errorCode: Swift.String?
        /// A message describing the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure containing an error related to a TagResource or UnTagResource operation.
    public struct LFTagError: Swift.Sendable {
        /// An error that occurred with the attachment or detachment of the LF-tag.
        public var error: LakeFormationClientTypes.ErrorDetail?
        /// The key-name of the LF-tag.
        public var lfTag: LakeFormationClientTypes.LFTagPair?

        public init(
            error: LakeFormationClientTypes.ErrorDetail? = nil,
            lfTag: LakeFormationClientTypes.LFTagPair? = nil
        )
        {
            self.error = error
            self.lfTag = lfTag
        }
    }
}

public struct AddLFTagsToResourceOutput: Swift.Sendable {
    /// A list of failures to tag the resource.
    public var failures: [LakeFormationClientTypes.LFTagError]?

    public init(
        failures: [LakeFormationClientTypes.LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

extension LakeFormationClientTypes {

    /// A new object to add to the governed table.
    public struct AddObjectInput: Swift.Sendable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        /// This member is required.
        public var eTag: Swift.String?
        /// A list of partition values for the object. A value must be specified for each partition key associated with the table. The supported data types are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.
        public var partitionValues: [Swift.String]?
        /// The size of the Amazon S3 object in bytes.
        /// This member is required.
        public var size: Swift.Int
        /// The Amazon S3 location of the object.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            partitionValues: [Swift.String]? = nil,
            size: Swift.Int = 0,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.partitionValues = partitionValues
            self.size = size
            self.uri = uri
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure that you pass to indicate you want all rows in a filter.
    public struct AllRowsWildcard: Swift.Sendable {

        public init() { }
    }
}

/// A resource to be created or added already exists.
public struct AlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LakeFormationClientTypes {

    public enum ApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssumeDecoratedRoleWithSAMLInput: Swift.Sendable {
    /// The time period, between 900 and 43,200 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the IdP.
    /// This member is required.
    public var principalArn: Swift.String?
    /// The role that represents an IAM principal whose scope down policy allows it to call credential vending APIs such as GetTemporaryTableCredentials. The caller must also have iam:PassRole permission on this role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A SAML assertion consisting of an assertion statement for the user who needs temporary credentials. This must match the SAML assertion that was issued to IAM. This must be Base64 encoded.
    /// This member is required.
    public var samlAssertion: Swift.String?

    public init(
        durationSeconds: Swift.Int? = nil,
        principalArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        samlAssertion: Swift.String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.principalArn = principalArn
        self.roleArn = roleArn
        self.samlAssertion = samlAssertion
    }
}

public struct AssumeDecoratedRoleWithSAMLOutput: Swift.Sendable {
    /// The access key ID for the temporary credentials. (The access key consists of an access key ID and a secret key).
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: Foundation.Date?
    /// The secret key for the temporary credentials. (The access key consists of an access key ID and a secret key).
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

extension LakeFormationClientTypes {

    /// A structure used to include auditing information on the privileged API.
    public struct AuditContext: Swift.Sendable {
        /// The filter engine can populate the 'AdditionalAuditContext' information with the request ID for you to track. This information will be displayed in CloudTrail log in your account.
        public var additionalAuditContext: Swift.String?

        public init(
            additionalAuditContext: Swift.String? = nil
        )
        {
            self.additionalAuditContext = additionalAuditContext
        }
    }
}

extension LakeFormationClientTypes {

    public enum Permission: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case alter
        case associate
        case createDatabase
        case createLfTag
        case createTable
        case dataLocationAccess
        case delete
        case describe
        case drop
        case grantWithLfTagExpression
        case insert
        case select
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .all,
                .alter,
                .associate,
                .createDatabase,
                .createLfTag,
                .createTable,
                .dataLocationAccess,
                .delete,
                .describe,
                .drop,
                .grantWithLfTagExpression,
                .insert,
                .select
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .alter: return "ALTER"
            case .associate: return "ASSOCIATE"
            case .createDatabase: return "CREATE_DATABASE"
            case .createLfTag: return "CREATE_LF_TAG"
            case .createTable: return "CREATE_TABLE"
            case .dataLocationAccess: return "DATA_LOCATION_ACCESS"
            case .delete: return "DELETE"
            case .describe: return "DESCRIBE"
            case .drop: return "DROP"
            case .grantWithLfTagExpression: return "GRANT_WITH_LF_TAG_EXPRESSION"
            case .insert: return "INSERT"
            case .select: return "SELECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LakeFormationClientTypes {

    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    public struct DataLakePrincipal: Swift.Sendable {
        /// An identifier for the Lake Formation principal.
        public var dataLakePrincipalIdentifier: Swift.String?

        public init(
            dataLakePrincipalIdentifier: Swift.String? = nil
        )
        {
            self.dataLakePrincipalIdentifier = dataLakePrincipalIdentifier
        }
    }
}

extension LakeFormationClientTypes {

    /// A permission to a resource granted by batch operation to the principal.
    public struct BatchPermissionsRequestEntry: Swift.Sendable {
        /// A unique identifier for the batch permissions request entry.
        /// This member is required.
        public var id: Swift.String?
        /// The permissions to be granted.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// Indicates if the option to pass permissions is granted.
        public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
        /// The principal to be granted a permission.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// The resource to which the principal is to be granted a permission.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            id: Swift.String? = nil,
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.id = id
            self.permissions = permissions
            self.permissionsWithGrantOption = permissionsWithGrantOption
            self.principal = principal
            self.resource = resource
        }
    }
}

public struct BatchGrantPermissionsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of up to 20 entries for resource permissions to be granted by batch operation to the principal.
    /// This member is required.
    public var entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?

    public init(
        catalogId: Swift.String? = nil,
        entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

extension LakeFormationClientTypes {

    /// A list of failures when performing a batch grant or batch revoke operation.
    public struct BatchPermissionsFailureEntry: Swift.Sendable {
        /// An error message that applies to the failure of the entry.
        public var error: LakeFormationClientTypes.ErrorDetail?
        /// An identifier for an entry of the batch request.
        public var requestEntry: LakeFormationClientTypes.BatchPermissionsRequestEntry?

        public init(
            error: LakeFormationClientTypes.ErrorDetail? = nil,
            requestEntry: LakeFormationClientTypes.BatchPermissionsRequestEntry? = nil
        )
        {
            self.error = error
            self.requestEntry = requestEntry
        }
    }
}

public struct BatchGrantPermissionsOutput: Swift.Sendable {
    /// A list of failures to grant permissions to the resources.
    public var failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?

    public init(
        failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

public struct BatchRevokePermissionsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of up to 20 entries for resource permissions to be revoked by batch operation to the principal.
    /// This member is required.
    public var entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]?

    public init(
        catalogId: Swift.String? = nil,
        entries: [LakeFormationClientTypes.BatchPermissionsRequestEntry]? = nil
    )
    {
        self.catalogId = catalogId
        self.entries = entries
    }
}

public struct BatchRevokePermissionsOutput: Swift.Sendable {
    /// A list of failures to revoke permissions to the resources.
    public var failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]?

    public init(
        failures: [LakeFormationClientTypes.BatchPermissionsFailureEntry]? = nil
    )
    {
        self.failures = failures
    }
}

/// Contains details about an error related to a transaction commit that was in progress.
public struct TransactionCommitInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCommitInProgressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains details about an error where the specified transaction has already been committed and cannot be used for UpdateTableObjects.
public struct TransactionCommittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCommittedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelTransactionInput: Swift.Sendable {
    /// The transaction to cancel.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

public struct CancelTransactionOutput: Swift.Sendable {

    public init() { }
}

/// Contains details about an error related to a transaction that was cancelled.
public struct TransactionCanceledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TransactionCanceledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CommitTransactionInput: Swift.Sendable {
    /// The transaction to commit.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

extension LakeFormationClientTypes {

    public enum TransactionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case active
        case committed
        case commitInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionStatus] {
            return [
                .aborted,
                .active,
                .committed,
                .commitInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .active: return "ACTIVE"
            case .committed: return "COMMITTED"
            case .commitInProgress: return "COMMIT_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CommitTransactionOutput: Swift.Sendable {
    /// The status of the transaction.
    public var transactionStatus: LakeFormationClientTypes.TransactionStatus?

    public init(
        transactionStatus: LakeFormationClientTypes.TransactionStatus? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

/// A resource numerical limit was exceeded.
public struct ResourceNumberLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNumberLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LakeFormationClientTypes {

    /// A PartiQL predicate.
    public struct RowFilter: Swift.Sendable {
        /// A wildcard for all rows.
        public var allRowsWildcard: LakeFormationClientTypes.AllRowsWildcard?
        /// A filter expression.
        public var filterExpression: Swift.String?

        public init(
            allRowsWildcard: LakeFormationClientTypes.AllRowsWildcard? = nil,
            filterExpression: Swift.String? = nil
        )
        {
            self.allRowsWildcard = allRowsWildcard
            self.filterExpression = filterExpression
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure that describes certain columns on certain rows.
    public struct DataCellsFilter: Swift.Sendable {
        /// A list of column names and/or nested column attributes. When specifying nested attributes, use a qualified dot (.) delimited format such as "address"."zip". Nested attributes within this list may not exceed a depth of 5.
        public var columnNames: [Swift.String]?
        /// A wildcard with exclusions. You must specify either a ColumnNames list or the ColumnWildCard.
        public var columnWildcard: LakeFormationClientTypes.ColumnWildcard?
        /// A database in the Glue Data Catalog.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name given by the user to the data filter cell.
        /// This member is required.
        public var name: Swift.String?
        /// A PartiQL predicate.
        public var rowFilter: LakeFormationClientTypes.RowFilter?
        /// The ID of the catalog to which the table belongs.
        /// This member is required.
        public var tableCatalogId: Swift.String?
        /// A table in the database.
        /// This member is required.
        public var tableName: Swift.String?
        /// The ID of the data cells filter version.
        public var versionId: Swift.String?

        public init(
            columnNames: [Swift.String]? = nil,
            columnWildcard: LakeFormationClientTypes.ColumnWildcard? = nil,
            databaseName: Swift.String? = nil,
            name: Swift.String? = nil,
            rowFilter: LakeFormationClientTypes.RowFilter? = nil,
            tableCatalogId: Swift.String? = nil,
            tableName: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.columnNames = columnNames
            self.columnWildcard = columnWildcard
            self.databaseName = databaseName
            self.name = name
            self.rowFilter = rowFilter
            self.tableCatalogId = tableCatalogId
            self.tableName = tableName
            self.versionId = versionId
        }
    }
}

public struct CreateDataCellsFilterInput: Swift.Sendable {
    /// A DataCellsFilter structure containing information about the data cells filter.
    /// This member is required.
    public var tableData: LakeFormationClientTypes.DataCellsFilter?

    public init(
        tableData: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.tableData = tableData
    }
}

public struct CreateDataCellsFilterOutput: Swift.Sendable {

    public init() { }
}

extension LakeFormationClientTypes {

    public enum EnableStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EnableStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LakeFormationClientTypes {

    /// Configuration for enabling external data filtering for third-party applications to access data managed by Lake Formation .
    public struct ExternalFilteringConfiguration: Swift.Sendable {
        /// List of third-party application ARNs integrated with Lake Formation.
        /// This member is required.
        public var authorizedTargets: [Swift.String]?
        /// Allows to enable or disable the third-party applications that are allowed to access data managed by Lake Formation.
        /// This member is required.
        public var status: LakeFormationClientTypes.EnableStatus?

        public init(
            authorizedTargets: [Swift.String]? = nil,
            status: LakeFormationClientTypes.EnableStatus? = nil
        )
        {
            self.authorizedTargets = authorizedTargets
            self.status = status
        }
    }
}

public struct CreateLakeFormationIdentityCenterConfigurationInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of the account IDs of Amazon Web Services accounts of third-party applications that are allowed to access data managed by Lake Formation.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
    /// The ARN of the IAM Identity Center instance for which the operation will be executed. For more information about ARNs, see Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// A list of Amazon Web Services account IDs and/or Amazon Web Services organization/organizational unit ARNs that are allowed to access data managed by Lake Formation. If the ShareRecipients list includes valid values, a resource share is created with the principals you want to have access to the resources. If the ShareRecipients value is null or the list is empty, no resource share is created.
    public var shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]?

    public init(
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil,
        instanceArn: Swift.String? = nil,
        shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]? = nil
    )
    {
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
        self.instanceArn = instanceArn
        self.shareRecipients = shareRecipients
    }
}

public struct CreateLakeFormationIdentityCenterConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Lake Formation application integrated with IAM Identity Center.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

public struct CreateLakeFormationOptInInput: Swift.Sendable {
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.principal = principal
        self.resource = resource
    }
}

public struct CreateLakeFormationOptInOutput: Swift.Sendable {

    public init() { }
}

public struct CreateLFTagInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    /// This member is required.
    public var tagKey: Swift.String?
    /// A list of possible values an attribute can take.
    /// This member is required.
    public var tagValues: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

public struct CreateLFTagOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDataCellsFilterInput: Swift.Sendable {
    /// A database in the Glue Data Catalog.
    public var databaseName: Swift.String?
    /// The name given by the user to the data filter cell.
    public var name: Swift.String?
    /// The ID of the catalog to which the table belongs.
    public var tableCatalogId: Swift.String?
    /// A table in the database.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        tableCatalogId: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.name = name
        self.tableCatalogId = tableCatalogId
        self.tableName = tableName
    }
}

public struct DeleteDataCellsFilterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLakeFormationIdentityCenterConfigurationInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definition, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

public struct DeleteLakeFormationIdentityCenterConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLakeFormationOptInInput: Swift.Sendable {
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.principal = principal
        self.resource = resource
    }
}

public struct DeleteLakeFormationOptInOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteLFTagInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag to delete.
    /// This member is required.
    public var tagKey: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

public struct DeleteLFTagOutput: Swift.Sendable {

    public init() { }
}

/// Contains details about an error related to a resource which is not ready for a transaction.
public struct ResourceNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LakeFormationClientTypes {

    /// An object that defines an Amazon S3 object to be deleted if a transaction cancels, provided that VirtualPut was called before writing the object.
    public struct VirtualObject: Swift.Sendable {
        /// The ETag of the Amazon S3 object.
        public var eTag: Swift.String?
        /// The path to the Amazon S3 object. Must start with s3://
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.uri = uri
        }
    }
}

public struct DeleteObjectsOnCancelInput: Swift.Sendable {
    /// The Glue data catalog that contains the governed table. Defaults to the current account ID.
    public var catalogId: Swift.String?
    /// The database that contains the governed table.
    /// This member is required.
    public var databaseName: Swift.String?
    /// A list of VirtualObject structures, which indicates the Amazon S3 objects to be deleted if the transaction cancels.
    /// This member is required.
    public var objects: [LakeFormationClientTypes.VirtualObject]?
    /// The name of the governed table.
    /// This member is required.
    public var tableName: Swift.String?
    /// ID of the transaction that the writes occur in.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        objects: [LakeFormationClientTypes.VirtualObject]? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.objects = objects
        self.tableName = tableName
        self.transactionId = transactionId
    }
}

public struct DeleteObjectsOnCancelOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to deregister.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeregisterResourceOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeLakeFormationIdentityCenterConfigurationInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

public struct DescribeLakeFormationIdentityCenterConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Lake Formation application integrated with IAM Identity Center.
    public var applicationArn: Swift.String?
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// Indicates if external filtering is enabled.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
    /// The Amazon Resource Name (ARN) of the connection.
    public var instanceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the RAM share.
    public var resourceShare: Swift.String?
    /// A list of Amazon Web Services account IDs or Amazon Web Services organization/organizational unit ARNs that are allowed to access data managed by Lake Formation. If the ShareRecipients list includes valid values, a resource share is created with the principals you want to have access to the resources as the ShareRecipients. If the ShareRecipients value is null or the list is empty, no resource share is created.
    public var shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]?

    public init(
        applicationArn: Swift.String? = nil,
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil,
        instanceArn: Swift.String? = nil,
        resourceShare: Swift.String? = nil,
        shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
        self.instanceArn = instanceArn
        self.resourceShare = resourceShare
        self.shareRecipients = shareRecipients
    }
}

public struct DescribeResourceInput: Swift.Sendable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension LakeFormationClientTypes {

    /// A structure containing information about an Lake Formation resource.
    public struct ResourceInfo: Swift.Sendable {
        /// Indicates whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
        public var hybridAccessEnabled: Swift.Bool?
        /// The date and time the resource was last modified.
        public var lastModified: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// The IAM role that registered a resource.
        public var roleArn: Swift.String?
        /// Whether or not the resource is a federated resource.
        public var withFederation: Swift.Bool?

        public init(
            hybridAccessEnabled: Swift.Bool? = nil,
            lastModified: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            withFederation: Swift.Bool? = nil
        )
        {
            self.hybridAccessEnabled = hybridAccessEnabled
            self.lastModified = lastModified
            self.resourceArn = resourceArn
            self.roleArn = roleArn
            self.withFederation = withFederation
        }
    }
}

public struct DescribeResourceOutput: Swift.Sendable {
    /// A structure containing information about an Lake Formation resource.
    public var resourceInfo: LakeFormationClientTypes.ResourceInfo?

    public init(
        resourceInfo: LakeFormationClientTypes.ResourceInfo? = nil
    )
    {
        self.resourceInfo = resourceInfo
    }
}

public struct DescribeTransactionInput: Swift.Sendable {
    /// The transaction for which to return status.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

extension LakeFormationClientTypes {

    /// A structure that contains information about a transaction.
    public struct TransactionDescription: Swift.Sendable {
        /// The time when the transaction committed or aborted, if it is not currently active.
        public var transactionEndTime: Foundation.Date?
        /// The ID of the transaction.
        public var transactionId: Swift.String?
        /// The time when the transaction started.
        public var transactionStartTime: Foundation.Date?
        /// A status of ACTIVE, COMMITTED, or ABORTED.
        public var transactionStatus: LakeFormationClientTypes.TransactionStatus?

        public init(
            transactionEndTime: Foundation.Date? = nil,
            transactionId: Swift.String? = nil,
            transactionStartTime: Foundation.Date? = nil,
            transactionStatus: LakeFormationClientTypes.TransactionStatus? = nil
        )
        {
            self.transactionEndTime = transactionEndTime
            self.transactionId = transactionId
            self.transactionStartTime = transactionStartTime
            self.transactionStatus = transactionStatus
        }
    }
}

public struct DescribeTransactionOutput: Swift.Sendable {
    /// Returns a TransactionDescription object containing information about the transaction.
    public var transactionDescription: LakeFormationClientTypes.TransactionDescription?

    public init(
        transactionDescription: LakeFormationClientTypes.TransactionDescription? = nil
    )
    {
        self.transactionDescription = transactionDescription
    }
}

public struct ExtendTransactionInput: Swift.Sendable {
    /// The transaction to extend.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

public struct ExtendTransactionOutput: Swift.Sendable {

    public init() { }
}

public struct GetDataCellsFilterInput: Swift.Sendable {
    /// A database in the Glue Data Catalog.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The name given by the user to the data filter cell.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the catalog to which the table belongs.
    /// This member is required.
    public var tableCatalogId: Swift.String?
    /// A table in the database.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        databaseName: Swift.String? = nil,
        name: Swift.String? = nil,
        tableCatalogId: Swift.String? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.databaseName = databaseName
        self.name = name
        self.tableCatalogId = tableCatalogId
        self.tableName = tableName
    }
}

public struct GetDataCellsFilterOutput: Swift.Sendable {
    /// A structure that describes certain columns on certain rows.
    public var dataCellsFilter: LakeFormationClientTypes.DataCellsFilter?

    public init(
        dataCellsFilter: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.dataCellsFilter = dataCellsFilter
    }
}

public struct GetDataLakePrincipalInput: Swift.Sendable {

    public init() { }
}

public struct GetDataLakePrincipalOutput: Swift.Sendable {
    /// A unique identifier of the invoking principal.
    public var identity: Swift.String?

    public init(
        identity: Swift.String? = nil
    )
    {
        self.identity = identity
    }
}

public struct GetDataLakeSettingsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?

    public init(
        catalogId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
    }
}

extension LakeFormationClientTypes {

    /// Permissions granted to a principal.
    public struct PrincipalPermissions: Swift.Sendable {
        /// The permissions that are granted to the principal.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// The principal who is granted permissions.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?

        public init(
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil
        )
        {
            self.permissions = permissions
            self.principal = principal
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure representing a list of Lake Formation principals designated as data lake administrators and lists of principal permission entries for default create database and default create table permissions.
    public struct DataLakeSettings: Swift.Sendable {
        /// Whether to allow Amazon EMR clusters to access data managed by Lake Formation. If true, you allow Amazon EMR clusters to access data in Amazon S3 locations that are registered with Lake Formation. If false or null, no Amazon EMR clusters will be able to access data in Amazon S3 locations that are registered with Lake Formation. For more information, see [(Optional) Allow external data filtering](https://docs.aws.amazon.com/lake-formation/latest/dg/initial-LF-setup.html#external-data-filter).
        public var allowExternalDataFiltering: Swift.Bool?
        /// Whether to allow a third-party query engine to get data access credentials without session tags when a caller has full data access permissions.
        public var allowFullTableExternalDataAccess: Swift.Bool?
        /// Lake Formation relies on a privileged process secured by Amazon EMR or the third party integrator to tag the user's role while assuming it. Lake Formation will publish the acceptable key-value pair, for example key = "LakeFormationTrustedCaller" and value = "TRUE" and the third party integrator must properly tag the temporary security credentials that will be used to call Lake Formation's administrative APIs.
        public var authorizedSessionTagValueList: [Swift.String]?
        /// Specifies whether access control on newly created database is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS. For more information, see [Changing the Default Security Settings for Your Data Lake](https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html).
        public var createDatabaseDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]?
        /// Specifies whether access control on newly created table is managed by Lake Formation permissions or exclusively by IAM permissions. A null value indicates access control by Lake Formation permissions. A value that assigns ALL to IAM_ALLOWED_PRINCIPALS indicates access control by IAM permissions. This is referred to as the setting "Use only IAM access control," and is for backward compatibility with the Glue permission model implemented by IAM permissions. The only permitted values are an empty array or an array that contains a single JSON object that grants ALL to IAM_ALLOWED_PRINCIPALS. For more information, see [Changing the Default Security Settings for Your Data Lake](https://docs.aws.amazon.com/lake-formation/latest/dg/change-settings.html).
        public var createTableDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]?
        /// A list of Lake Formation principals. Supported principals are IAM users or IAM roles.
        public var dataLakeAdmins: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A list of the account IDs of Amazon Web Services accounts with Amazon EMR clusters that are to perform data filtering.>
        public var externalDataFilteringAllowList: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A key-value map that provides an additional configuration on your data lake. CROSS_ACCOUNT_VERSION is the key you can configure in the Parameters field. Accepted values for the CrossAccountVersion key are 1, 2, 3, and 4.
        public var parameters: [Swift.String: Swift.String]?
        /// A list of Lake Formation principals with only view access to the resources, without the ability to make changes. Supported principals are IAM users or IAM roles.
        public var readOnlyAdmins: [LakeFormationClientTypes.DataLakePrincipal]?
        /// A list of the resource-owning account IDs that the caller's account can use to share their user access details (user ARNs). The user ARNs can be logged in the resource owner's CloudTrail log. You may want to specify this property when you are in a high-trust boundary, such as the same team or company.
        public var trustedResourceOwners: [Swift.String]?

        public init(
            allowExternalDataFiltering: Swift.Bool? = nil,
            allowFullTableExternalDataAccess: Swift.Bool? = nil,
            authorizedSessionTagValueList: [Swift.String]? = nil,
            createDatabaseDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]? = nil,
            createTableDefaultPermissions: [LakeFormationClientTypes.PrincipalPermissions]? = nil,
            dataLakeAdmins: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            externalDataFilteringAllowList: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            readOnlyAdmins: [LakeFormationClientTypes.DataLakePrincipal]? = nil,
            trustedResourceOwners: [Swift.String]? = nil
        )
        {
            self.allowExternalDataFiltering = allowExternalDataFiltering
            self.allowFullTableExternalDataAccess = allowFullTableExternalDataAccess
            self.authorizedSessionTagValueList = authorizedSessionTagValueList
            self.createDatabaseDefaultPermissions = createDatabaseDefaultPermissions
            self.createTableDefaultPermissions = createTableDefaultPermissions
            self.dataLakeAdmins = dataLakeAdmins
            self.externalDataFilteringAllowList = externalDataFilteringAllowList
            self.parameters = parameters
            self.readOnlyAdmins = readOnlyAdmins
            self.trustedResourceOwners = trustedResourceOwners
        }
    }
}

public struct GetDataLakeSettingsOutput: Swift.Sendable {
    /// A structure representing a list of Lake Formation principals designated as data lake administrators.
    public var dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?

    public init(
        dataLakeSettings: LakeFormationClientTypes.DataLakeSettings? = nil
    )
    {
        self.dataLakeSettings = dataLakeSettings
    }
}

public struct GetEffectivePermissionsForPathInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource for which you want to get permissions.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension LakeFormationClientTypes {

    /// A structure containing the additional details to be returned in the AdditionalDetails attribute of PrincipalResourcePermissions. If a catalog resource is shared through Resource Access Manager (RAM), then there will exist a corresponding RAM resource share ARN.
    public struct DetailsMap: Swift.Sendable {
        /// A resource share ARN for a catalog resource shared through RAM.
        public var resourceShare: [Swift.String]?

        public init(
            resourceShare: [Swift.String]? = nil
        )
        {
            self.resourceShare = resourceShare
        }
    }
}

extension LakeFormationClientTypes {

    /// The permissions granted or revoked on a resource.
    public struct PrincipalResourcePermissions: Swift.Sendable {
        /// This attribute can be used to return any additional details of PrincipalResourcePermissions. Currently returns only as a RAM resource share ARN.
        public var additionalDetails: LakeFormationClientTypes.DetailsMap?
        /// The date and time when the resource was last updated.
        public var lastUpdated: Foundation.Date?
        /// The user who updated the record.
        public var lastUpdatedBy: Swift.String?
        /// The permissions to be granted or revoked on the resource.
        public var permissions: [LakeFormationClientTypes.Permission]?
        /// Indicates whether to grant the ability to grant permissions (as a subset of permissions granted).
        public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
        /// The Data Lake principal to be granted or revoked permissions.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// The resource where permissions are to be granted or revoked.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            additionalDetails: LakeFormationClientTypes.DetailsMap? = nil,
            lastUpdated: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            permissions: [LakeFormationClientTypes.Permission]? = nil,
            permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.additionalDetails = additionalDetails
            self.lastUpdated = lastUpdated
            self.lastUpdatedBy = lastUpdatedBy
            self.permissions = permissions
            self.permissionsWithGrantOption = permissionsWithGrantOption
            self.principal = principal
            self.resource = resource
        }
    }
}

public struct GetEffectivePermissionsForPathOutput: Swift.Sendable {
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// A list of the permissions for the specified table or database resource located at the path in Amazon S3.
    public var permissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

public struct GetLFTagInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    /// This member is required.
    public var tagKey: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
    }
}

public struct GetLFTagOutput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag.
    public var tagKey: Swift.String?
    /// A list of possible values an attribute can take.
    public var tagValues: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValues: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValues = tagValues
    }
}

public struct GetQueryStateInput: Swift.Sendable {
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

extension LakeFormationClientTypes {

    public enum QueryStateString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case expired
        case finished
        case pending
        case workunitsAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryStateString] {
            return [
                .error,
                .expired,
                .finished,
                .pending,
                .workunitsAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .expired: return "EXPIRED"
            case .finished: return "FINISHED"
            case .pending: return "PENDING"
            case .workunitsAvailable: return "WORKUNITS_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A structure for the output.
public struct GetQueryStateOutput: Swift.Sendable {
    /// An error message when the operation fails.
    public var error: Swift.String?
    /// The state of a query previously submitted. The possible states are:
    ///
    /// * PENDING: the query is pending.
    ///
    /// * WORKUNITS_AVAILABLE: some work units are ready for retrieval and execution.
    ///
    /// * FINISHED: the query planning finished successfully, and all work units are ready for retrieval and execution.
    ///
    /// * ERROR: an error occurred with the query, such as an invalid query ID or a backend error.
    /// This member is required.
    public var state: LakeFormationClientTypes.QueryStateString?

    public init(
        error: Swift.String? = nil,
        state: LakeFormationClientTypes.QueryStateString? = nil
    )
    {
        self.error = error
        self.state = state
    }
}

/// Contains details about an error where the query request expired.
public struct ExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains details about an error related to statistics not being ready.
public struct StatisticsNotReadyYetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StatisticsNotReadyYetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Contains details about an error where the query request was throttled.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetQueryStatisticsInput: Swift.Sendable {
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

extension LakeFormationClientTypes {

    /// Statistics related to the processing of a query statement.
    public struct ExecutionStatistics: Swift.Sendable {
        /// The average time the request took to be executed.
        public var averageExecutionTimeMillis: Swift.Int
        /// The amount of data that was scanned in bytes.
        public var dataScannedBytes: Swift.Int
        /// The number of work units executed.
        public var workUnitsExecutedCount: Swift.Int

        public init(
            averageExecutionTimeMillis: Swift.Int = 0,
            dataScannedBytes: Swift.Int = 0,
            workUnitsExecutedCount: Swift.Int = 0
        )
        {
            self.averageExecutionTimeMillis = averageExecutionTimeMillis
            self.dataScannedBytes = dataScannedBytes
            self.workUnitsExecutedCount = workUnitsExecutedCount
        }
    }
}

extension LakeFormationClientTypes {

    /// Statistics related to the processing of a query statement.
    public struct PlanningStatistics: Swift.Sendable {
        /// An estimate of the data that was scanned in bytes.
        public var estimatedDataToScanBytes: Swift.Int
        /// The time that it took to process the request.
        public var planningTimeMillis: Swift.Int
        /// The time the request was in queue to be processed.
        public var queueTimeMillis: Swift.Int
        /// The number of work units generated.
        public var workUnitsGeneratedCount: Swift.Int

        public init(
            estimatedDataToScanBytes: Swift.Int = 0,
            planningTimeMillis: Swift.Int = 0,
            queueTimeMillis: Swift.Int = 0,
            workUnitsGeneratedCount: Swift.Int = 0
        )
        {
            self.estimatedDataToScanBytes = estimatedDataToScanBytes
            self.planningTimeMillis = planningTimeMillis
            self.queueTimeMillis = queueTimeMillis
            self.workUnitsGeneratedCount = workUnitsGeneratedCount
        }
    }
}

public struct GetQueryStatisticsOutput: Swift.Sendable {
    /// An ExecutionStatistics structure containing execution statistics.
    public var executionStatistics: LakeFormationClientTypes.ExecutionStatistics?
    /// A PlanningStatistics structure containing query planning statistics.
    public var planningStatistics: LakeFormationClientTypes.PlanningStatistics?
    /// The time that the query was submitted.
    public var querySubmissionTime: Foundation.Date?

    public init(
        executionStatistics: LakeFormationClientTypes.ExecutionStatistics? = nil,
        planningStatistics: LakeFormationClientTypes.PlanningStatistics? = nil,
        querySubmissionTime: Foundation.Date? = nil
    )
    {
        self.executionStatistics = executionStatistics
        self.planningStatistics = planningStatistics
        self.querySubmissionTime = querySubmissionTime
    }
}

/// An encryption operation failed.
public struct GlueEncryptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GlueEncryptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetResourceLFTagsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The database, table, or column resource for which you want to return LF-tags.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?
    /// Indicates whether to show the assigned LF-tags.
    public var showAssignedLFTags: Swift.Bool?

    public init(
        catalogId: Swift.String? = nil,
        resource: LakeFormationClientTypes.Resource? = nil,
        showAssignedLFTags: Swift.Bool? = nil
    )
    {
        self.catalogId = catalogId
        self.resource = resource
        self.showAssignedLFTags = showAssignedLFTags
    }
}

extension LakeFormationClientTypes {

    /// A structure containing the name of a column resource and the LF-tags attached to it.
    public struct ColumnLFTag: Swift.Sendable {
        /// The LF-tags attached to a column resource.
        public var lfTags: [LakeFormationClientTypes.LFTagPair]?
        /// The name of a column resource.
        public var name: Swift.String?

        public init(
            lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
            name: Swift.String? = nil
        )
        {
            self.lfTags = lfTags
            self.name = name
        }
    }
}

public struct GetResourceLFTagsOutput: Swift.Sendable {
    /// A list of LF-tags applied to a database resource.
    public var lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]?
    /// A list of LF-tags applied to a column resource.
    public var lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]?
    /// A list of LF-tags applied to a table resource.
    public var lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]?

    public init(
        lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]? = nil,
        lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]? = nil,
        lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]? = nil
    )
    {
        self.lfTagOnDatabase = lfTagOnDatabase
        self.lfTagsOnColumns = lfTagsOnColumns
        self.lfTagsOnTable = lfTagsOnTable
    }
}

public struct GetTableObjectsInput: Swift.Sendable {
    /// The catalog containing the governed table. Defaults to the callers account.
    public var catalogId: Swift.String?
    /// The database containing the governed table.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Specifies how many values to return in a page.
    public var maxResults: Swift.Int?
    /// A continuation token if this is not the first call to retrieve these objects.
    public var nextToken: Swift.String?
    /// A predicate to filter the objects returned based on the partition keys defined in the governed table.
    ///
    /// * The comparison operators supported are: =, >, <, >=, <=
    ///
    /// * The logical operators supported are: AND
    ///
    /// * The data types supported are integer, long, date(yyyy-MM-dd), timestamp(yyyy-MM-dd HH:mm:ssXXX or yyyy-MM-dd HH:mm:ss"), string and decimal.
    public var partitionPredicate: Swift.String?
    /// The time as of when to read the governed table contents. If not set, the most recent transaction commit time is used. Cannot be specified along with TransactionId.
    public var queryAsOfTime: Foundation.Date?
    /// The governed table for which to retrieve objects.
    /// This member is required.
    public var tableName: Swift.String?
    /// The transaction ID at which to read the governed table contents. If this transaction has aborted, an error is returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with QueryAsOfTime.
    public var transactionId: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partitionPredicate: Swift.String? = nil,
        queryAsOfTime: Foundation.Date? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partitionPredicate = partitionPredicate
        self.queryAsOfTime = queryAsOfTime
        self.tableName = tableName
        self.transactionId = transactionId
    }
}

extension LakeFormationClientTypes {

    /// Specifies the details of a governed table.
    public struct TableObject: Swift.Sendable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        public var eTag: Swift.String?
        /// The size of the Amazon S3 object in bytes.
        public var size: Swift.Int
        /// The Amazon S3 location of the object.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            size: Swift.Int = 0,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.size = size
            self.uri = uri
        }
    }
}

extension LakeFormationClientTypes {

    /// A structure containing a list of partition values and table objects.
    public struct PartitionObjects: Swift.Sendable {
        /// A list of table objects
        public var objects: [LakeFormationClientTypes.TableObject]?
        /// A list of partition values.
        public var partitionValues: [Swift.String]?

        public init(
            objects: [LakeFormationClientTypes.TableObject]? = nil,
            partitionValues: [Swift.String]? = nil
        )
        {
            self.objects = objects
            self.partitionValues = partitionValues
        }
    }
}

public struct GetTableObjectsOutput: Swift.Sendable {
    /// A continuation token indicating whether additional data is available.
    public var nextToken: Swift.String?
    /// A list of objects organized by partition keys.
    public var objects: [LakeFormationClientTypes.PartitionObjects]?

    public init(
        nextToken: Swift.String? = nil,
        objects: [LakeFormationClientTypes.PartitionObjects]? = nil
    )
    {
        self.nextToken = nextToken
        self.objects = objects
    }
}

/// The engine does not support filtering data based on the enforced permissions. For example, if you call the GetTemporaryGlueTableCredentials operation with SupportedPermissionType equal to ColumnPermission, but cell-level permissions exist on the table, this exception is thrown.
public struct PermissionTypeMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the problem.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionTypeMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LakeFormationClientTypes {

    /// Contains a list of values defining partitions.
    public struct PartitionValueList: Swift.Sendable {
        /// The list of partition values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }
}

extension LakeFormationClientTypes {

    public enum PermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cellFilterPermission
        case columnPermission
        case nestedCellPermission
        case nestedPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .cellFilterPermission,
                .columnPermission,
                .nestedCellPermission,
                .nestedPermission
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cellFilterPermission: return "CELL_FILTER_PERMISSION"
            case .columnPermission: return "COLUMN_PERMISSION"
            case .nestedCellPermission: return "NESTED_CELL_PERMISSION"
            case .nestedPermission: return "NESTED_PERMISSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTemporaryGluePartitionCredentialsInput: Swift.Sendable {
    /// A structure representing context to access a resource (column names, query ID, etc).
    public var auditContext: LakeFormationClientTypes.AuditContext?
    /// The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// A list of partition values identifying a single partition.
    /// This member is required.
    public var partition: LakeFormationClientTypes.PartitionValueList?
    /// Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// A list of supported permission types for the partition. Valid values are COLUMN_PERMISSION and CELL_FILTER_PERMISSION.
    public var supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
    /// The ARN of the partitions' table.
    /// This member is required.
    public var tableArn: Swift.String?

    public init(
        auditContext: LakeFormationClientTypes.AuditContext? = nil,
        durationSeconds: Swift.Int? = nil,
        partition: LakeFormationClientTypes.PartitionValueList? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]? = nil,
        tableArn: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.durationSeconds = durationSeconds
        self.partition = partition
        self.permissions = permissions
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableArn = tableArn
    }
}

public struct GetTemporaryGluePartitionCredentialsOutput: Swift.Sendable {
    /// The access key ID for the temporary credentials.
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: Foundation.Date?
    /// The secret key for the temporary credentials.
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

extension LakeFormationClientTypes {

    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public struct QuerySessionContext: Swift.Sendable {
        /// An opaque string-string map passed by the query engine.
        public var additionalContext: [Swift.String: Swift.String]?
        /// An identifier string for the consumer cluster.
        public var clusterId: Swift.String?
        /// A cryptographically generated query identifier generated by Glue or Lake Formation.
        public var queryAuthorizationId: Swift.String?
        /// A unique identifier generated by the query engine for the query.
        public var queryId: Swift.String?
        /// A timestamp provided by the query engine for when the query started.
        public var queryStartTime: Foundation.Date?

        public init(
            additionalContext: [Swift.String: Swift.String]? = nil,
            clusterId: Swift.String? = nil,
            queryAuthorizationId: Swift.String? = nil,
            queryId: Swift.String? = nil,
            queryStartTime: Foundation.Date? = nil
        )
        {
            self.additionalContext = additionalContext
            self.clusterId = clusterId
            self.queryAuthorizationId = queryAuthorizationId
            self.queryId = queryId
            self.queryStartTime = queryStartTime
        }
    }
}

public struct GetTemporaryGlueTableCredentialsInput: Swift.Sendable {
    /// A structure representing context to access a resource (column names, query ID, etc).
    public var auditContext: LakeFormationClientTypes.AuditContext?
    /// The time period, between 900 and 21,600 seconds, for the timeout of the temporary credentials.
    public var durationSeconds: Swift.Int?
    /// Filters the request based on the user having been granted a list of specified permissions on the requested resource(s).
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a Lake Formation generated authorization identifier and information from the request's authorization context.
    public var querySessionContext: LakeFormationClientTypes.QuerySessionContext?
    /// The Amazon S3 path for the table.
    public var s3Path: Swift.String?
    /// A list of supported permission types for the table. Valid values are COLUMN_PERMISSION and CELL_FILTER_PERMISSION.
    public var supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]?
    /// The ARN identifying a table in the Data Catalog for the temporary credentials request.
    /// This member is required.
    public var tableArn: Swift.String?

    public init(
        auditContext: LakeFormationClientTypes.AuditContext? = nil,
        durationSeconds: Swift.Int? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        querySessionContext: LakeFormationClientTypes.QuerySessionContext? = nil,
        s3Path: Swift.String? = nil,
        supportedPermissionTypes: [LakeFormationClientTypes.PermissionType]? = nil,
        tableArn: Swift.String? = nil
    )
    {
        self.auditContext = auditContext
        self.durationSeconds = durationSeconds
        self.permissions = permissions
        self.querySessionContext = querySessionContext
        self.s3Path = s3Path
        self.supportedPermissionTypes = supportedPermissionTypes
        self.tableArn = tableArn
    }
}

public struct GetTemporaryGlueTableCredentialsOutput: Swift.Sendable {
    /// The access key ID for the temporary credentials.
    public var accessKeyId: Swift.String?
    /// The date and time when the temporary credentials expire.
    public var expiration: Foundation.Date?
    /// The secret key for the temporary credentials.
    public var secretAccessKey: Swift.String?
    /// The session token for the temporary credentials.
    public var sessionToken: Swift.String?
    /// The Amazon S3 path for the temporary credentials.
    public var vendedS3Path: [Swift.String]?

    public init(
        accessKeyId: Swift.String? = nil,
        expiration: Foundation.Date? = nil,
        secretAccessKey: Swift.String? = nil,
        sessionToken: Swift.String? = nil,
        vendedS3Path: [Swift.String]? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
        self.vendedS3Path = vendedS3Path
    }
}

public struct GetWorkUnitResultsInput: Swift.Sendable {
    /// The ID of the plan query operation for which to get results.
    /// This member is required.
    public var queryId: Swift.String?
    /// The work unit ID for which to get results. Value generated by enumerating WorkUnitIdMin to WorkUnitIdMax (inclusive) from the WorkUnitRange in the output of GetWorkUnits.
    /// This member is required.
    public var workUnitId: Swift.Int?
    /// A work token used to query the execution service. Token output from GetWorkUnits.
    /// This member is required.
    public var workUnitToken: Swift.String?

    public init(
        queryId: Swift.String? = nil,
        workUnitId: Swift.Int? = 0,
        workUnitToken: Swift.String? = nil
    )
    {
        self.queryId = queryId
        self.workUnitId = workUnitId
        self.workUnitToken = workUnitToken
    }
}

extension GetWorkUnitResultsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetWorkUnitResultsInput(queryId: \(Swift.String(describing: queryId)), workUnitId: \(Swift.String(describing: workUnitId)), workUnitToken: \"CONTENT_REDACTED\")"}
}

/// A structure for the output.
public struct GetWorkUnitResultsOutput: Swift.Sendable {
    /// Rows returned from the GetWorkUnitResults operation as a stream of Apache Arrow v1.0 messages.
    public var resultStream: Smithy.ByteStream?

    public init(
        resultStream: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data("".utf8))
    )
    {
        self.resultStream = resultStream
    }
}

/// Contains details about an error related to work units not being ready.
public struct WorkUnitsNotReadyYetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message describing the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "WorkUnitsNotReadyYetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetWorkUnitsInput: Swift.Sendable {
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The size of each page to get in the Amazon Web Services service call. This does not affect the number of items returned in the command's output. Setting a smaller page size results in more calls to the Amazon Web Services service, retrieving fewer items in each call. This can help prevent the Amazon Web Services service calls from timing out.
    public var pageSize: Swift.Int?
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queryId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.queryId = queryId
    }
}

extension LakeFormationClientTypes {

    /// Defines the valid range of work unit IDs for querying the execution service.
    public struct WorkUnitRange: Swift.Sendable {
        /// Defines the maximum work unit ID in the range. The maximum value is inclusive.
        /// This member is required.
        public var workUnitIdMax: Swift.Int
        /// Defines the minimum work unit ID in the range.
        /// This member is required.
        public var workUnitIdMin: Swift.Int
        /// A work token used to query the execution service.
        /// This member is required.
        public var workUnitToken: Swift.String?

        public init(
            workUnitIdMax: Swift.Int = 0,
            workUnitIdMin: Swift.Int = 0,
            workUnitToken: Swift.String? = nil
        )
        {
            self.workUnitIdMax = workUnitIdMax
            self.workUnitIdMin = workUnitIdMin
            self.workUnitToken = workUnitToken
        }
    }
}

/// A structure for the output.
public struct GetWorkUnitsOutput: Swift.Sendable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// The ID of the plan query operation.
    /// This member is required.
    public var queryId: Swift.String?
    /// A WorkUnitRangeList object that specifies the valid range of work unit IDs for querying the execution service.
    /// This member is required.
    public var workUnitRanges: [LakeFormationClientTypes.WorkUnitRange]?

    public init(
        nextToken: Swift.String? = nil,
        queryId: Swift.String? = nil,
        workUnitRanges: [LakeFormationClientTypes.WorkUnitRange]? = nil
    )
    {
        self.nextToken = nextToken
        self.queryId = queryId
        self.workUnitRanges = workUnitRanges
    }
}

public struct GrantPermissionsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The permissions granted to the principal on the resource. Lake Formation defines privileges to grant and revoke access to metadata in the Data Catalog and data organized in underlying data storage such as Amazon S3. Lake Formation requires that each principal be authorized to perform a specific task on Lake Formation resources.
    /// This member is required.
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// Indicates a list of the granted permissions that the principal may pass to other users. These permissions may only be a subset of the permissions granted in the Privileges.
    public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
    /// The principal to be granted the permissions on the resource. Supported principals are IAM users or IAM roles, and they are defined by their principal type and their ARN. Note that if you define a resource with a particular ARN, then later delete, and recreate a resource with that same ARN, the resource maintains the permissions already granted.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// The resource to which permissions are to be granted. Resources in Lake Formation are the Data Catalog, databases, and tables.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

public struct GrantPermissionsOutput: Swift.Sendable {

    public init() { }
}

public struct ListDataCellsFilterInput: Swift.Sendable {
    /// The maximum size of the response.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// A table in the Glue Data Catalog.
    public var table: LakeFormationClientTypes.TableResource?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        table: LakeFormationClientTypes.TableResource? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.table = table
    }
}

public struct ListDataCellsFilterOutput: Swift.Sendable {
    /// A list of DataCellFilter structures.
    public var dataCellsFilters: [LakeFormationClientTypes.DataCellsFilter]?
    /// A continuation token, if not all requested data cell filters have been returned.
    public var nextToken: Swift.String?

    public init(
        dataCellsFilters: [LakeFormationClientTypes.DataCellsFilter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataCellsFilters = dataCellsFilters
        self.nextToken = nextToken
    }
}

public struct ListLakeFormationOptInsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A structure for the resource.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resource = resource
    }
}

extension LakeFormationClientTypes {

    /// A single principal-resource pair that has Lake Formation permissins enforced.
    public struct LakeFormationOptInsInfo: Swift.Sendable {
        /// The last modified date and time of the record.
        public var lastModified: Foundation.Date?
        /// The user who updated the record.
        public var lastUpdatedBy: Swift.String?
        /// The Lake Formation principal. Supported principals are IAM users or IAM roles.
        public var principal: LakeFormationClientTypes.DataLakePrincipal?
        /// A structure for the resource.
        public var resource: LakeFormationClientTypes.Resource?

        public init(
            lastModified: Foundation.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
            resource: LakeFormationClientTypes.Resource? = nil
        )
        {
            self.lastModified = lastModified
            self.lastUpdatedBy = lastUpdatedBy
            self.principal = principal
            self.resource = resource
        }
    }
}

public struct ListLakeFormationOptInsOutput: Swift.Sendable {
    /// A list of principal-resource pairs that have Lake Formation permissins enforced.
    public var lakeFormationOptInsInfoList: [LakeFormationClientTypes.LakeFormationOptInsInfo]?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        lakeFormationOptInsInfoList: [LakeFormationClientTypes.LakeFormationOptInsInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lakeFormationOptInsInfoList = lakeFormationOptInsInfoList
        self.nextToken = nextToken
    }
}

extension LakeFormationClientTypes {

    public enum ResourceShareType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case foreign
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareType] {
            return [
                .all,
                .foreign
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .foreign: return "FOREIGN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListLFTagsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// If resource share type is ALL, returns both in-account LF-tags and shared LF-tags that the requester has permission to view. If resource share type is FOREIGN, returns all share LF-tags that the requester can view. If no resource share type is passed, lists LF-tags in the given catalog ID that the requester has permission to view.
    public var resourceShareType: LakeFormationClientTypes.ResourceShareType?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareType: LakeFormationClientTypes.ResourceShareType? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareType = resourceShareType
    }
}

public struct ListLFTagsOutput: Swift.Sendable {
    /// A list of LF-tags that the requested has permission to view.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?

    public init(
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lfTags = lfTags
        self.nextToken = nextToken
    }
}

extension LakeFormationClientTypes {

    public enum DataLakeResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case catalog
        case database
        case dataLocation
        case lfTag
        case lfTagPolicy
        case lfTagPolicyDatabase
        case lfTagPolicyTable
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLakeResourceType] {
            return [
                .catalog,
                .database,
                .dataLocation,
                .lfTag,
                .lfTagPolicy,
                .lfTagPolicyDatabase,
                .lfTagPolicyTable,
                .table
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .catalog: return "CATALOG"
            case .database: return "DATABASE"
            case .dataLocation: return "DATA_LOCATION"
            case .lfTag: return "LF_TAG"
            case .lfTagPolicy: return "LF_TAG_POLICY"
            case .lfTagPolicyDatabase: return "LF_TAG_POLICY_DATABASE"
            case .lfTagPolicyTable: return "LF_TAG_POLICY_TABLE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListPermissionsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// Indicates that related permissions should be included in the results.
    public var includeRelated: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// Specifies a principal to filter the permissions returned.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// A resource where you will get a list of the principal permissions. This operation does not support getting privileges on a table with columns. Instead, call this operation on the table, and the operation returns the table and the table w columns.
    public var resource: LakeFormationClientTypes.Resource?
    /// Specifies a resource type to filter the permissions returned.
    public var resourceType: LakeFormationClientTypes.DataLakeResourceType?

    public init(
        catalogId: Swift.String? = nil,
        includeRelated: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil,
        resourceType: LakeFormationClientTypes.DataLakeResourceType? = nil
    )
    {
        self.catalogId = catalogId
        self.includeRelated = includeRelated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resource = resource
        self.resourceType = resourceType
    }
}

public struct ListPermissionsOutput: Swift.Sendable {
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?
    /// A list of principals and their permissions on the resource for the specified principal and resource types.
    public var principalResourcePermissions: [LakeFormationClientTypes.PrincipalResourcePermissions]?

    public init(
        nextToken: Swift.String? = nil,
        principalResourcePermissions: [LakeFormationClientTypes.PrincipalResourcePermissions]? = nil
    )
    {
        self.nextToken = nextToken
        self.principalResourcePermissions = principalResourcePermissions
    }
}

extension LakeFormationClientTypes {

    public enum ComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case between
        case contains
        case eq
        case ge
        case gt
        case `in`
        case le
        case lt
        case ne
        case notContains
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .between,
                .contains,
                .eq,
                .ge,
                .gt,
                .in,
                .le,
                .lt,
                .ne,
                .notContains
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .eq: return "EQ"
            case .ge: return "GE"
            case .gt: return "GT"
            case .in: return "IN"
            case .le: return "LE"
            case .lt: return "LT"
            case .ne: return "NE"
            case .notContains: return "NOT_CONTAINS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LakeFormationClientTypes {

    public enum FieldNameString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lastModified
        case resourceArn
        case roleArn
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldNameString] {
            return [
                .lastModified,
                .resourceArn,
                .roleArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lastModified: return "LAST_MODIFIED"
            case .resourceArn: return "RESOURCE_ARN"
            case .roleArn: return "ROLE_ARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LakeFormationClientTypes {

    /// This structure describes the filtering of columns in a table based on a filter condition.
    public struct FilterCondition: Swift.Sendable {
        /// The comparison operator used in the filter condition.
        public var comparisonOperator: LakeFormationClientTypes.ComparisonOperator?
        /// The field to filter in the filter condition.
        public var field: LakeFormationClientTypes.FieldNameString?
        /// A string with values used in evaluating the filter condition.
        public var stringValueList: [Swift.String]?

        public init(
            comparisonOperator: LakeFormationClientTypes.ComparisonOperator? = nil,
            field: LakeFormationClientTypes.FieldNameString? = nil,
            stringValueList: [Swift.String]? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.field = field
            self.stringValueList = stringValueList
        }
    }
}

public struct ListResourcesInput: Swift.Sendable {
    /// Any applicable row-level and/or column-level filtering conditions for the resources.
    public var filterConditionList: [LakeFormationClientTypes.FilterCondition]?
    /// The maximum number of resource results.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve these resources.
    public var nextToken: Swift.String?

    public init(
        filterConditionList: [LakeFormationClientTypes.FilterCondition]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterConditionList = filterConditionList
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResourcesOutput: Swift.Sendable {
    /// A continuation token, if this is not the first call to retrieve these resources.
    public var nextToken: Swift.String?
    /// A summary of the data lake resources.
    public var resourceInfoList: [LakeFormationClientTypes.ResourceInfo]?

    public init(
        nextToken: Swift.String? = nil,
        resourceInfoList: [LakeFormationClientTypes.ResourceInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceInfoList = resourceInfoList
    }
}

extension LakeFormationClientTypes {

    public enum OptimizerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compaction
        case garbageCollection
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [OptimizerType] {
            return [
                .compaction,
                .garbageCollection,
                .generic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compaction: return "COMPACTION"
            case .garbageCollection: return "GARBAGE_COLLECTION"
            case .generic: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListTableStorageOptimizersInput: Swift.Sendable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// Name of the database where the table is present.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The number of storage optimizers to return on each call.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is a continuation call.
    public var nextToken: Swift.String?
    /// The specific type of storage optimizers to list. The supported value is compaction.
    public var storageOptimizerType: LakeFormationClientTypes.OptimizerType?
    /// Name of the table.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        storageOptimizerType: LakeFormationClientTypes.OptimizerType? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageOptimizerType = storageOptimizerType
        self.tableName = tableName
    }
}

extension LakeFormationClientTypes {

    /// A structure describing the configuration and details of a storage optimizer.
    public struct StorageOptimizer: Swift.Sendable {
        /// A map of the storage optimizer configuration. Currently contains only one key-value pair: is_enabled indicates true or false for acceleration.
        public var config: [Swift.String: Swift.String]?
        /// A message that contains information about any error (if present). When an acceleration result has an enabled status, the error message is empty. When an acceleration result has a disabled status, the message describes an error or simply indicates "disabled by the user".
        public var errorMessage: Swift.String?
        /// When an acceleration result has an enabled status, contains the details of the last job run.
        public var lastRunDetails: Swift.String?
        /// The specific type of storage optimizer. The supported value is compaction.
        public var storageOptimizerType: LakeFormationClientTypes.OptimizerType?
        /// A message that contains information about any warnings (if present).
        public var warnings: Swift.String?

        public init(
            config: [Swift.String: Swift.String]? = nil,
            errorMessage: Swift.String? = nil,
            lastRunDetails: Swift.String? = nil,
            storageOptimizerType: LakeFormationClientTypes.OptimizerType? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.config = config
            self.errorMessage = errorMessage
            self.lastRunDetails = lastRunDetails
            self.storageOptimizerType = storageOptimizerType
            self.warnings = warnings
        }
    }
}

public struct ListTableStorageOptimizersOutput: Swift.Sendable {
    /// A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.
    public var nextToken: Swift.String?
    /// A list of the storage optimizers associated with a table.
    public var storageOptimizerList: [LakeFormationClientTypes.StorageOptimizer]?

    public init(
        nextToken: Swift.String? = nil,
        storageOptimizerList: [LakeFormationClientTypes.StorageOptimizer]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageOptimizerList = storageOptimizerList
    }
}

extension LakeFormationClientTypes {

    public enum TransactionStatusFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case active
        case all
        case committed
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionStatusFilter] {
            return [
                .aborted,
                .active,
                .all,
                .committed,
                .completed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .active: return "ACTIVE"
            case .all: return "ALL"
            case .committed: return "COMMITTED"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListTransactionsInput: Swift.Sendable {
    /// The catalog for which to list transactions. Defaults to the account ID of the caller.
    public var catalogId: Swift.String?
    /// The maximum number of transactions to return in a single call.
    public var maxResults: Swift.Int?
    /// A continuation token if this is not the first call to retrieve transactions.
    public var nextToken: Swift.String?
    /// A filter indicating the status of transactions to return. Options are ALL | COMPLETED | COMMITTED | ABORTED | ACTIVE. The default is ALL.
    public var statusFilter: LakeFormationClientTypes.TransactionStatusFilter?

    public init(
        catalogId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        statusFilter: LakeFormationClientTypes.TransactionStatusFilter? = nil
    )
    {
        self.catalogId = catalogId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

public struct ListTransactionsOutput: Swift.Sendable {
    /// A continuation token indicating whether additional data is available.
    public var nextToken: Swift.String?
    /// A list of transactions. The record for each transaction is a TransactionDescription object.
    public var transactions: [LakeFormationClientTypes.TransactionDescription]?

    public init(
        nextToken: Swift.String? = nil,
        transactions: [LakeFormationClientTypes.TransactionDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.transactions = transactions
    }
}

public struct PutDataLakeSettingsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A structure representing a list of Lake Formation principals designated as data lake administrators.
    /// This member is required.
    public var dataLakeSettings: LakeFormationClientTypes.DataLakeSettings?

    public init(
        catalogId: Swift.String? = nil,
        dataLakeSettings: LakeFormationClientTypes.DataLakeSettings? = nil
    )
    {
        self.catalogId = catalogId
        self.dataLakeSettings = dataLakeSettings
    }
}

public struct PutDataLakeSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct RegisterResourceInput: Swift.Sendable {
    /// Specifies whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
    public var hybridAccessEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource that you want to register.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The identifier for the role that registers the resource.
    public var roleArn: Swift.String?
    /// Designates an Identity and Access Management (IAM) service-linked role by registering this role with the Data Catalog. A service-linked role is a unique type of IAM role that is linked directly to Lake Formation. For more information, see [Using Service-Linked Roles for Lake Formation](https://docs.aws.amazon.com/lake-formation/latest/dg/service-linked-roles.html).
    public var useServiceLinkedRole: Swift.Bool?
    /// Whether or not the resource is a federated resource.
    public var withFederation: Swift.Bool?

    public init(
        hybridAccessEnabled: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        useServiceLinkedRole: Swift.Bool? = nil,
        withFederation: Swift.Bool? = nil
    )
    {
        self.hybridAccessEnabled = hybridAccessEnabled
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.useServiceLinkedRole = useServiceLinkedRole
        self.withFederation = withFederation
    }
}

public struct RegisterResourceOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveLFTagsFromResourceInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The LF-tags to be removed from the resource.
    /// This member is required.
    public var lfTags: [LakeFormationClientTypes.LFTagPair]?
    /// The database, table, or column resource where you want to remove an LF-tag.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        lfTags: [LakeFormationClientTypes.LFTagPair]? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.lfTags = lfTags
        self.resource = resource
    }
}

public struct RemoveLFTagsFromResourceOutput: Swift.Sendable {
    /// A list of failures to untag a resource.
    public var failures: [LakeFormationClientTypes.LFTagError]?

    public init(
        failures: [LakeFormationClientTypes.LFTagError]? = nil
    )
    {
        self.failures = failures
    }
}

public struct RevokePermissionsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The permissions revoked to the principal on the resource. For information about permissions, see [Security and Access Control to Metadata and Data](https://docs.aws.amazon.com/lake-formation/latest/dg/security-data-access.html).
    /// This member is required.
    public var permissions: [LakeFormationClientTypes.Permission]?
    /// Indicates a list of permissions for which to revoke the grant option allowing the principal to pass permissions to other principals.
    public var permissionsWithGrantOption: [LakeFormationClientTypes.Permission]?
    /// The principal to be revoked permissions on the resource.
    /// This member is required.
    public var principal: LakeFormationClientTypes.DataLakePrincipal?
    /// The resource to which permissions are to be revoked.
    /// This member is required.
    public var resource: LakeFormationClientTypes.Resource?

    public init(
        catalogId: Swift.String? = nil,
        permissions: [LakeFormationClientTypes.Permission]? = nil,
        permissionsWithGrantOption: [LakeFormationClientTypes.Permission]? = nil,
        principal: LakeFormationClientTypes.DataLakePrincipal? = nil,
        resource: LakeFormationClientTypes.Resource? = nil
    )
    {
        self.catalogId = catalogId
        self.permissions = permissions
        self.permissionsWithGrantOption = permissionsWithGrantOption
        self.principal = principal
        self.resource = resource
    }
}

public struct RevokePermissionsOutput: Swift.Sendable {

    public init() { }
}

public struct SearchDatabasesByLFTagsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of conditions (LFTag structures) to search for in database resources.
    /// This member is required.
    public var expression: [LakeFormationClientTypes.LFTag]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        expression: [LakeFormationClientTypes.LFTag]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LakeFormationClientTypes {

    /// A structure describing a database resource with LF-tags.
    public struct TaggedDatabase: Swift.Sendable {
        /// A database that has LF-tags attached to it.
        public var database: LakeFormationClientTypes.DatabaseResource?
        /// A list of LF-tags attached to the database.
        public var lfTags: [LakeFormationClientTypes.LFTagPair]?

        public init(
            database: LakeFormationClientTypes.DatabaseResource? = nil,
            lfTags: [LakeFormationClientTypes.LFTagPair]? = nil
        )
        {
            self.database = database
            self.lfTags = lfTags
        }
    }
}

public struct SearchDatabasesByLFTagsOutput: Swift.Sendable {
    /// A list of databases that meet the LF-tag conditions.
    public var databaseList: [LakeFormationClientTypes.TaggedDatabase]?
    /// A continuation token, present if the current list segment is not the last.
    public var nextToken: Swift.String?

    public init(
        databaseList: [LakeFormationClientTypes.TaggedDatabase]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.databaseList = databaseList
        self.nextToken = nextToken
    }
}

public struct SearchTablesByLFTagsInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of conditions (LFTag structures) to search for in table resources.
    /// This member is required.
    public var expression: [LakeFormationClientTypes.LFTag]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A continuation token, if this is not the first call to retrieve this list.
    public var nextToken: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        expression: [LakeFormationClientTypes.LFTag]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.expression = expression
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LakeFormationClientTypes {

    /// A structure describing a table resource with LF-tags.
    public struct TaggedTable: Swift.Sendable {
        /// A list of LF-tags attached to the database where the table resides.
        public var lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]?
        /// A list of LF-tags attached to columns in the table.
        public var lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]?
        /// A list of LF-tags attached to the table.
        public var lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]?
        /// A table that has LF-tags attached to it.
        public var table: LakeFormationClientTypes.TableResource?

        public init(
            lfTagOnDatabase: [LakeFormationClientTypes.LFTagPair]? = nil,
            lfTagsOnColumns: [LakeFormationClientTypes.ColumnLFTag]? = nil,
            lfTagsOnTable: [LakeFormationClientTypes.LFTagPair]? = nil,
            table: LakeFormationClientTypes.TableResource? = nil
        )
        {
            self.lfTagOnDatabase = lfTagOnDatabase
            self.lfTagsOnColumns = lfTagsOnColumns
            self.lfTagsOnTable = lfTagsOnTable
            self.table = table
        }
    }
}

public struct SearchTablesByLFTagsOutput: Swift.Sendable {
    /// A continuation token, present if the current list segment is not the last. On the first run, if you include a not null (a value) token you can get empty pages.
    public var nextToken: Swift.String?
    /// A list of tables that meet the LF-tag conditions.
    public var tableList: [LakeFormationClientTypes.TaggedTable]?

    public init(
        nextToken: Swift.String? = nil,
        tableList: [LakeFormationClientTypes.TaggedTable]? = nil
    )
    {
        self.nextToken = nextToken
        self.tableList = tableList
    }
}

extension LakeFormationClientTypes {

    /// A structure containing information about the query plan.
    public struct QueryPlanningContext: Swift.Sendable {
        /// The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon Web Services account ID is used by default.
        public var catalogId: Swift.String?
        /// The database containing the table.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The time as of when to read the table contents. If not set, the most recent transaction commit time will be used. Cannot be specified along with TransactionId.
        public var queryAsOfTime: Foundation.Date?
        /// A map consisting of key-value pairs.
        public var queryParameters: [Swift.String: Swift.String]?
        /// The transaction ID at which to read the table contents. If this transaction is not committed, the read will be treated as part of that transaction and will see its writes. If this transaction has aborted, an error will be returned. If not set, defaults to the most recent committed transaction. Cannot be specified along with QueryAsOfTime.
        public var transactionId: Swift.String?

        public init(
            catalogId: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            queryAsOfTime: Foundation.Date? = nil,
            queryParameters: [Swift.String: Swift.String]? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.catalogId = catalogId
            self.databaseName = databaseName
            self.queryAsOfTime = queryAsOfTime
            self.queryParameters = queryParameters
            self.transactionId = transactionId
        }
    }
}

public struct StartQueryPlanningInput: Swift.Sendable {
    /// A structure containing information about the query plan.
    /// This member is required.
    public var queryPlanningContext: LakeFormationClientTypes.QueryPlanningContext?
    /// A PartiQL query statement used as an input to the planner service.
    /// This member is required.
    public var queryString: Swift.String?

    public init(
        queryPlanningContext: LakeFormationClientTypes.QueryPlanningContext? = nil,
        queryString: Swift.String? = nil
    )
    {
        self.queryPlanningContext = queryPlanningContext
        self.queryString = queryString
    }
}

extension StartQueryPlanningInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartQueryPlanningInput(queryPlanningContext: \(Swift.String(describing: queryPlanningContext)), queryString: \"CONTENT_REDACTED\")"}
}

/// A structure for the output.
public struct StartQueryPlanningOutput: Swift.Sendable {
    /// The ID of the plan query operation can be used to fetch the actual work unit descriptors that are produced as the result of the operation. The ID is also used to get the query state and as an input to the Execute operation.
    /// This member is required.
    public var queryId: Swift.String?

    public init(
        queryId: Swift.String? = nil
    )
    {
        self.queryId = queryId
    }
}

extension LakeFormationClientTypes {

    public enum TransactionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case readAndWrite
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [TransactionType] {
            return [
                .readAndWrite,
                .readOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .readAndWrite: return "READ_AND_WRITE"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartTransactionInput: Swift.Sendable {
    /// Indicates whether this transaction should be read only or read and write. Writes made using a read-only transaction ID will be rejected. Read-only transactions do not need to be committed.
    public var transactionType: LakeFormationClientTypes.TransactionType?

    public init(
        transactionType: LakeFormationClientTypes.TransactionType? = nil
    )
    {
        self.transactionType = transactionType
    }
}

public struct StartTransactionOutput: Swift.Sendable {
    /// An opaque identifier for the transaction.
    public var transactionId: Swift.String?

    public init(
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

public struct UpdateDataCellsFilterInput: Swift.Sendable {
    /// A DataCellsFilter structure containing information about the data cells filter.
    /// This member is required.
    public var tableData: LakeFormationClientTypes.DataCellsFilter?

    public init(
        tableData: LakeFormationClientTypes.DataCellsFilter? = nil
    )
    {
        self.tableData = tableData
    }
}

public struct UpdateDataCellsFilterOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLakeFormationIdentityCenterConfigurationInput: Swift.Sendable {
    /// Allows to enable or disable the IAM Identity Center connection.
    public var applicationStatus: LakeFormationClientTypes.ApplicationStatus?
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, view definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// A list of the account IDs of Amazon Web Services accounts of third-party applications that are allowed to access data managed by Lake Formation.
    public var externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration?
    /// A list of Amazon Web Services account IDs or Amazon Web Services organization/organizational unit ARNs that are allowed to access to access data managed by Lake Formation. If the ShareRecipients list includes valid values, then the resource share is updated with the principals you want to have access to the resources. If the ShareRecipients value is null, both the list of share recipients and the resource share remain unchanged. If the ShareRecipients value is an empty list, then the existing share recipients list will be cleared, and the resource share will be deleted.
    public var shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]?

    public init(
        applicationStatus: LakeFormationClientTypes.ApplicationStatus? = nil,
        catalogId: Swift.String? = nil,
        externalFiltering: LakeFormationClientTypes.ExternalFilteringConfiguration? = nil,
        shareRecipients: [LakeFormationClientTypes.DataLakePrincipal]? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.catalogId = catalogId
        self.externalFiltering = externalFiltering
        self.shareRecipients = shareRecipients
    }
}

public struct UpdateLakeFormationIdentityCenterConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLFTagInput: Swift.Sendable {
    /// The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.
    public var catalogId: Swift.String?
    /// The key-name for the LF-tag for which to add or delete values.
    /// This member is required.
    public var tagKey: Swift.String?
    /// A list of LF-tag values to add from the LF-tag.
    public var tagValuesToAdd: [Swift.String]?
    /// A list of LF-tag values to delete from the LF-tag.
    public var tagValuesToDelete: [Swift.String]?

    public init(
        catalogId: Swift.String? = nil,
        tagKey: Swift.String? = nil,
        tagValuesToAdd: [Swift.String]? = nil,
        tagValuesToDelete: [Swift.String]? = nil
    )
    {
        self.catalogId = catalogId
        self.tagKey = tagKey
        self.tagValuesToAdd = tagValuesToAdd
        self.tagValuesToDelete = tagValuesToDelete
    }
}

public struct UpdateLFTagOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateResourceInput: Swift.Sendable {
    /// Specifies whether the data access of tables pointing to the location can be managed by both Lake Formation permissions as well as Amazon S3 bucket policies.
    public var hybridAccessEnabled: Swift.Bool?
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The new role to use for the given resource registered in Lake Formation.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Whether or not the resource is a federated resource.
    public var withFederation: Swift.Bool?

    public init(
        hybridAccessEnabled: Swift.Bool? = nil,
        resourceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        withFederation: Swift.Bool? = nil
    )
    {
        self.hybridAccessEnabled = hybridAccessEnabled
        self.resourceArn = resourceArn
        self.roleArn = roleArn
        self.withFederation = withFederation
    }
}

public struct UpdateResourceOutput: Swift.Sendable {

    public init() { }
}

extension LakeFormationClientTypes {

    /// An object to delete from the governed table.
    public struct DeleteObjectInput: Swift.Sendable {
        /// The Amazon S3 ETag of the object. Returned by GetTableObjects for validation and used to identify changes to the underlying data.
        public var eTag: Swift.String?
        /// A list of partition values for the object. A value must be specified for each partition key associated with the governed table.
        public var partitionValues: [Swift.String]?
        /// The Amazon S3 location of the object to delete.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eTag: Swift.String? = nil,
            partitionValues: [Swift.String]? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eTag = eTag
            self.partitionValues = partitionValues
            self.uri = uri
        }
    }
}

extension LakeFormationClientTypes {

    /// Defines an object to add to or delete from a governed table.
    public struct WriteOperation: Swift.Sendable {
        /// A new object to add to the governed table.
        public var addObject: LakeFormationClientTypes.AddObjectInput?
        /// An object to delete from the governed table.
        public var deleteObject: LakeFormationClientTypes.DeleteObjectInput?

        public init(
            addObject: LakeFormationClientTypes.AddObjectInput? = nil,
            deleteObject: LakeFormationClientTypes.DeleteObjectInput? = nil
        )
        {
            self.addObject = addObject
            self.deleteObject = deleteObject
        }
    }
}

public struct UpdateTableObjectsInput: Swift.Sendable {
    /// The catalog containing the governed table to update. Defaults to the callers account ID.
    public var catalogId: Swift.String?
    /// The database containing the governed table to update.
    /// This member is required.
    public var databaseName: Swift.String?
    /// The governed table to update.
    /// This member is required.
    public var tableName: Swift.String?
    /// The transaction at which to do the write.
    public var transactionId: Swift.String?
    /// A list of WriteOperation objects that define an object to add to or delete from the manifest for a governed table.
    /// This member is required.
    public var writeOperations: [LakeFormationClientTypes.WriteOperation]?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        tableName: Swift.String? = nil,
        transactionId: Swift.String? = nil,
        writeOperations: [LakeFormationClientTypes.WriteOperation]? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.tableName = tableName
        self.transactionId = transactionId
        self.writeOperations = writeOperations
    }
}

public struct UpdateTableObjectsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateTableStorageOptimizerInput: Swift.Sendable {
    /// The Catalog ID of the table.
    public var catalogId: Swift.String?
    /// Name of the database where the table is present.
    /// This member is required.
    public var databaseName: Swift.String?
    /// Name of the table for which to enable the storage optimizer.
    /// This member is required.
    public var storageOptimizerConfig: [Swift.String: [Swift.String: Swift.String]]?
    /// Name of the table for which to enable the storage optimizer.
    /// This member is required.
    public var tableName: Swift.String?

    public init(
        catalogId: Swift.String? = nil,
        databaseName: Swift.String? = nil,
        storageOptimizerConfig: [Swift.String: [Swift.String: Swift.String]]? = nil,
        tableName: Swift.String? = nil
    )
    {
        self.catalogId = catalogId
        self.databaseName = databaseName
        self.storageOptimizerConfig = storageOptimizerConfig
        self.tableName = tableName
    }
}

public struct UpdateTableStorageOptimizerOutput: Swift.Sendable {
    /// A response indicating the success of failure of the operation.
    public var result: Swift.String?

    public init(
        result: Swift.String? = nil
    )
    {
        self.result = result
    }
}

extension AddLFTagsToResourceInput {

    static func urlPathProvider(_ value: AddLFTagsToResourceInput) -> Swift.String? {
        return "/AddLFTagsToResource"
    }
}

extension AssumeDecoratedRoleWithSAMLInput {

    static func urlPathProvider(_ value: AssumeDecoratedRoleWithSAMLInput) -> Swift.String? {
        return "/AssumeDecoratedRoleWithSAML"
    }
}

extension BatchGrantPermissionsInput {

    static func urlPathProvider(_ value: BatchGrantPermissionsInput) -> Swift.String? {
        return "/BatchGrantPermissions"
    }
}

extension BatchRevokePermissionsInput {

    static func urlPathProvider(_ value: BatchRevokePermissionsInput) -> Swift.String? {
        return "/BatchRevokePermissions"
    }
}

extension CancelTransactionInput {

    static func urlPathProvider(_ value: CancelTransactionInput) -> Swift.String? {
        return "/CancelTransaction"
    }
}

extension CommitTransactionInput {

    static func urlPathProvider(_ value: CommitTransactionInput) -> Swift.String? {
        return "/CommitTransaction"
    }
}

extension CreateDataCellsFilterInput {

    static func urlPathProvider(_ value: CreateDataCellsFilterInput) -> Swift.String? {
        return "/CreateDataCellsFilter"
    }
}

extension CreateLakeFormationIdentityCenterConfigurationInput {

    static func urlPathProvider(_ value: CreateLakeFormationIdentityCenterConfigurationInput) -> Swift.String? {
        return "/CreateLakeFormationIdentityCenterConfiguration"
    }
}

extension CreateLakeFormationOptInInput {

    static func urlPathProvider(_ value: CreateLakeFormationOptInInput) -> Swift.String? {
        return "/CreateLakeFormationOptIn"
    }
}

extension CreateLFTagInput {

    static func urlPathProvider(_ value: CreateLFTagInput) -> Swift.String? {
        return "/CreateLFTag"
    }
}

extension DeleteDataCellsFilterInput {

    static func urlPathProvider(_ value: DeleteDataCellsFilterInput) -> Swift.String? {
        return "/DeleteDataCellsFilter"
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationInput {

    static func urlPathProvider(_ value: DeleteLakeFormationIdentityCenterConfigurationInput) -> Swift.String? {
        return "/DeleteLakeFormationIdentityCenterConfiguration"
    }
}

extension DeleteLakeFormationOptInInput {

    static func urlPathProvider(_ value: DeleteLakeFormationOptInInput) -> Swift.String? {
        return "/DeleteLakeFormationOptIn"
    }
}

extension DeleteLFTagInput {

    static func urlPathProvider(_ value: DeleteLFTagInput) -> Swift.String? {
        return "/DeleteLFTag"
    }
}

extension DeleteObjectsOnCancelInput {

    static func urlPathProvider(_ value: DeleteObjectsOnCancelInput) -> Swift.String? {
        return "/DeleteObjectsOnCancel"
    }
}

extension DeregisterResourceInput {

    static func urlPathProvider(_ value: DeregisterResourceInput) -> Swift.String? {
        return "/DeregisterResource"
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationInput {

    static func urlPathProvider(_ value: DescribeLakeFormationIdentityCenterConfigurationInput) -> Swift.String? {
        return "/DescribeLakeFormationIdentityCenterConfiguration"
    }
}

extension DescribeResourceInput {

    static func urlPathProvider(_ value: DescribeResourceInput) -> Swift.String? {
        return "/DescribeResource"
    }
}

extension DescribeTransactionInput {

    static func urlPathProvider(_ value: DescribeTransactionInput) -> Swift.String? {
        return "/DescribeTransaction"
    }
}

extension ExtendTransactionInput {

    static func urlPathProvider(_ value: ExtendTransactionInput) -> Swift.String? {
        return "/ExtendTransaction"
    }
}

extension GetDataCellsFilterInput {

    static func urlPathProvider(_ value: GetDataCellsFilterInput) -> Swift.String? {
        return "/GetDataCellsFilter"
    }
}

extension GetDataLakePrincipalInput {

    static func urlPathProvider(_ value: GetDataLakePrincipalInput) -> Swift.String? {
        return "/GetDataLakePrincipal"
    }
}

extension GetDataLakeSettingsInput {

    static func urlPathProvider(_ value: GetDataLakeSettingsInput) -> Swift.String? {
        return "/GetDataLakeSettings"
    }
}

extension GetEffectivePermissionsForPathInput {

    static func urlPathProvider(_ value: GetEffectivePermissionsForPathInput) -> Swift.String? {
        return "/GetEffectivePermissionsForPath"
    }
}

extension GetLFTagInput {

    static func urlPathProvider(_ value: GetLFTagInput) -> Swift.String? {
        return "/GetLFTag"
    }
}

extension GetQueryStateInput {

    static func urlPathProvider(_ value: GetQueryStateInput) -> Swift.String? {
        return "/GetQueryState"
    }
}

extension GetQueryStatisticsInput {

    static func urlPathProvider(_ value: GetQueryStatisticsInput) -> Swift.String? {
        return "/GetQueryStatistics"
    }
}

extension GetResourceLFTagsInput {

    static func urlPathProvider(_ value: GetResourceLFTagsInput) -> Swift.String? {
        return "/GetResourceLFTags"
    }
}

extension GetTableObjectsInput {

    static func urlPathProvider(_ value: GetTableObjectsInput) -> Swift.String? {
        return "/GetTableObjects"
    }
}

extension GetTemporaryGluePartitionCredentialsInput {

    static func urlPathProvider(_ value: GetTemporaryGluePartitionCredentialsInput) -> Swift.String? {
        return "/GetTemporaryGluePartitionCredentials"
    }
}

extension GetTemporaryGlueTableCredentialsInput {

    static func urlPathProvider(_ value: GetTemporaryGlueTableCredentialsInput) -> Swift.String? {
        return "/GetTemporaryGlueTableCredentials"
    }
}

extension GetWorkUnitResultsInput {

    static func urlPathProvider(_ value: GetWorkUnitResultsInput) -> Swift.String? {
        return "/GetWorkUnitResults"
    }
}

extension GetWorkUnitsInput {

    static func urlPathProvider(_ value: GetWorkUnitsInput) -> Swift.String? {
        return "/GetWorkUnits"
    }
}

extension GrantPermissionsInput {

    static func urlPathProvider(_ value: GrantPermissionsInput) -> Swift.String? {
        return "/GrantPermissions"
    }
}

extension ListDataCellsFilterInput {

    static func urlPathProvider(_ value: ListDataCellsFilterInput) -> Swift.String? {
        return "/ListDataCellsFilter"
    }
}

extension ListLakeFormationOptInsInput {

    static func urlPathProvider(_ value: ListLakeFormationOptInsInput) -> Swift.String? {
        return "/ListLakeFormationOptIns"
    }
}

extension ListLFTagsInput {

    static func urlPathProvider(_ value: ListLFTagsInput) -> Swift.String? {
        return "/ListLFTags"
    }
}

extension ListPermissionsInput {

    static func urlPathProvider(_ value: ListPermissionsInput) -> Swift.String? {
        return "/ListPermissions"
    }
}

extension ListResourcesInput {

    static func urlPathProvider(_ value: ListResourcesInput) -> Swift.String? {
        return "/ListResources"
    }
}

extension ListTableStorageOptimizersInput {

    static func urlPathProvider(_ value: ListTableStorageOptimizersInput) -> Swift.String? {
        return "/ListTableStorageOptimizers"
    }
}

extension ListTransactionsInput {

    static func urlPathProvider(_ value: ListTransactionsInput) -> Swift.String? {
        return "/ListTransactions"
    }
}

extension PutDataLakeSettingsInput {

    static func urlPathProvider(_ value: PutDataLakeSettingsInput) -> Swift.String? {
        return "/PutDataLakeSettings"
    }
}

extension RegisterResourceInput {

    static func urlPathProvider(_ value: RegisterResourceInput) -> Swift.String? {
        return "/RegisterResource"
    }
}

extension RemoveLFTagsFromResourceInput {

    static func urlPathProvider(_ value: RemoveLFTagsFromResourceInput) -> Swift.String? {
        return "/RemoveLFTagsFromResource"
    }
}

extension RevokePermissionsInput {

    static func urlPathProvider(_ value: RevokePermissionsInput) -> Swift.String? {
        return "/RevokePermissions"
    }
}

extension SearchDatabasesByLFTagsInput {

    static func urlPathProvider(_ value: SearchDatabasesByLFTagsInput) -> Swift.String? {
        return "/SearchDatabasesByLFTags"
    }
}

extension SearchTablesByLFTagsInput {

    static func urlPathProvider(_ value: SearchTablesByLFTagsInput) -> Swift.String? {
        return "/SearchTablesByLFTags"
    }
}

extension StartQueryPlanningInput {

    static func urlPathProvider(_ value: StartQueryPlanningInput) -> Swift.String? {
        return "/StartQueryPlanning"
    }
}

extension StartTransactionInput {

    static func urlPathProvider(_ value: StartTransactionInput) -> Swift.String? {
        return "/StartTransaction"
    }
}

extension UpdateDataCellsFilterInput {

    static func urlPathProvider(_ value: UpdateDataCellsFilterInput) -> Swift.String? {
        return "/UpdateDataCellsFilter"
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationInput {

    static func urlPathProvider(_ value: UpdateLakeFormationIdentityCenterConfigurationInput) -> Swift.String? {
        return "/UpdateLakeFormationIdentityCenterConfiguration"
    }
}

extension UpdateLFTagInput {

    static func urlPathProvider(_ value: UpdateLFTagInput) -> Swift.String? {
        return "/UpdateLFTag"
    }
}

extension UpdateResourceInput {

    static func urlPathProvider(_ value: UpdateResourceInput) -> Swift.String? {
        return "/UpdateResource"
    }
}

extension UpdateTableObjectsInput {

    static func urlPathProvider(_ value: UpdateTableObjectsInput) -> Swift.String? {
        return "/UpdateTableObjects"
    }
}

extension UpdateTableStorageOptimizerInput {

    static func urlPathProvider(_ value: UpdateTableStorageOptimizerInput) -> Swift.String? {
        return "/UpdateTableStorageOptimizer"
    }
}

extension AddLFTagsToResourceInput {

    static func write(value: AddLFTagsToResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["LFTags"].writeList(value.lfTags, memberWritingClosure: LakeFormationClientTypes.LFTagPair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension AssumeDecoratedRoleWithSAMLInput {

    static func write(value: AssumeDecoratedRoleWithSAMLInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["PrincipalArn"].write(value.principalArn)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SAMLAssertion"].write(value.samlAssertion)
    }
}

extension BatchGrantPermissionsInput {

    static func write(value: BatchGrantPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Entries"].writeList(value.entries, memberWritingClosure: LakeFormationClientTypes.BatchPermissionsRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchRevokePermissionsInput {

    static func write(value: BatchRevokePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Entries"].writeList(value.entries, memberWritingClosure: LakeFormationClientTypes.BatchPermissionsRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelTransactionInput {

    static func write(value: CancelTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension CommitTransactionInput {

    static func write(value: CommitTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension CreateDataCellsFilterInput {

    static func write(value: CreateDataCellsFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TableData"].write(value.tableData, with: LakeFormationClientTypes.DataCellsFilter.write(value:to:))
    }
}

extension CreateLakeFormationIdentityCenterConfigurationInput {

    static func write(value: CreateLakeFormationIdentityCenterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ExternalFiltering"].write(value.externalFiltering, with: LakeFormationClientTypes.ExternalFilteringConfiguration.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ShareRecipients"].writeList(value.shareRecipients, memberWritingClosure: LakeFormationClientTypes.DataLakePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLakeFormationOptInInput {

    static func write(value: CreateLakeFormationOptInInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension CreateLFTagInput {

    static func write(value: CreateLFTagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteDataCellsFilterInput {

    static func write(value: DeleteDataCellsFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["TableCatalogId"].write(value.tableCatalogId)
        try writer["TableName"].write(value.tableName)
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationInput {

    static func write(value: DeleteLakeFormationIdentityCenterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension DeleteLakeFormationOptInInput {

    static func write(value: DeleteLakeFormationOptInInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension DeleteLFTagInput {

    static func write(value: DeleteLFTagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
    }
}

extension DeleteObjectsOnCancelInput {

    static func write(value: DeleteObjectsOnCancelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Objects"].writeList(value.objects, memberWritingClosure: LakeFormationClientTypes.VirtualObject.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableName"].write(value.tableName)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension DeregisterResourceInput {

    static func write(value: DeregisterResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationInput {

    static func write(value: DescribeLakeFormationIdentityCenterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension DescribeResourceInput {

    static func write(value: DescribeResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DescribeTransactionInput {

    static func write(value: DescribeTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension ExtendTransactionInput {

    static func write(value: ExtendTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension GetDataCellsFilterInput {

    static func write(value: GetDataCellsFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["TableCatalogId"].write(value.tableCatalogId)
        try writer["TableName"].write(value.tableName)
    }
}

extension GetDataLakeSettingsInput {

    static func write(value: GetDataLakeSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
    }
}

extension GetEffectivePermissionsForPathInput {

    static func write(value: GetEffectivePermissionsForPathInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetLFTagInput {

    static func write(value: GetLFTagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
    }
}

extension GetQueryStateInput {

    static func write(value: GetQueryStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryId"].write(value.queryId)
    }
}

extension GetQueryStatisticsInput {

    static func write(value: GetQueryStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryId"].write(value.queryId)
    }
}

extension GetResourceLFTagsInput {

    static func write(value: GetResourceLFTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
        try writer["ShowAssignedLFTags"].write(value.showAssignedLFTags)
    }
}

extension GetTableObjectsInput {

    static func write(value: GetTableObjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PartitionPredicate"].write(value.partitionPredicate)
        try writer["QueryAsOfTime"].writeTimestamp(value.queryAsOfTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TableName"].write(value.tableName)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension GetTemporaryGluePartitionCredentialsInput {

    static func write(value: GetTemporaryGluePartitionCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditContext"].write(value.auditContext, with: LakeFormationClientTypes.AuditContext.write(value:to:))
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["Partition"].write(value.partition, with: LakeFormationClientTypes.PartitionValueList.write(value:to:))
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SupportedPermissionTypes"].writeList(value.supportedPermissionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableArn"].write(value.tableArn)
    }
}

extension GetTemporaryGlueTableCredentialsInput {

    static func write(value: GetTemporaryGlueTableCredentialsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditContext"].write(value.auditContext, with: LakeFormationClientTypes.AuditContext.write(value:to:))
        try writer["DurationSeconds"].write(value.durationSeconds)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QuerySessionContext"].write(value.querySessionContext, with: LakeFormationClientTypes.QuerySessionContext.write(value:to:))
        try writer["S3Path"].write(value.s3Path)
        try writer["SupportedPermissionTypes"].writeList(value.supportedPermissionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableArn"].write(value.tableArn)
    }
}

extension GetWorkUnitResultsInput {

    static func write(value: GetWorkUnitResultsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryId"].write(value.queryId)
        try writer["WorkUnitId"].write(value.workUnitId)
        try writer["WorkUnitToken"].write(value.workUnitToken)
    }
}

extension GetWorkUnitsInput {

    static func write(value: GetWorkUnitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageSize"].write(value.pageSize)
        try writer["QueryId"].write(value.queryId)
    }
}

extension GrantPermissionsInput {

    static func write(value: GrantPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PermissionsWithGrantOption"].writeList(value.permissionsWithGrantOption, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension ListDataCellsFilterInput {

    static func write(value: ListDataCellsFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Table"].write(value.table, with: LakeFormationClientTypes.TableResource.write(value:to:))
    }
}

extension ListLakeFormationOptInsInput {

    static func write(value: ListLakeFormationOptInsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension ListLFTagsInput {

    static func write(value: ListLFTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceShareType"].write(value.resourceShareType)
    }
}

extension ListPermissionsInput {

    static func write(value: ListPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["IncludeRelated"].write(value.includeRelated)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListResourcesInput {

    static func write(value: ListResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterConditionList"].writeList(value.filterConditionList, memberWritingClosure: LakeFormationClientTypes.FilterCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTableStorageOptimizersInput {

    static func write(value: ListTableStorageOptimizersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StorageOptimizerType"].write(value.storageOptimizerType)
        try writer["TableName"].write(value.tableName)
    }
}

extension ListTransactionsInput {

    static func write(value: ListTransactionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StatusFilter"].write(value.statusFilter)
    }
}

extension PutDataLakeSettingsInput {

    static func write(value: PutDataLakeSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DataLakeSettings"].write(value.dataLakeSettings, with: LakeFormationClientTypes.DataLakeSettings.write(value:to:))
    }
}

extension RegisterResourceInput {

    static func write(value: RegisterResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HybridAccessEnabled"].write(value.hybridAccessEnabled)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["RoleArn"].write(value.roleArn)
        try writer["UseServiceLinkedRole"].write(value.useServiceLinkedRole)
        try writer["WithFederation"].write(value.withFederation)
    }
}

extension RemoveLFTagsFromResourceInput {

    static func write(value: RemoveLFTagsFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["LFTags"].writeList(value.lfTags, memberWritingClosure: LakeFormationClientTypes.LFTagPair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension RevokePermissionsInput {

    static func write(value: RevokePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PermissionsWithGrantOption"].writeList(value.permissionsWithGrantOption, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }
}

extension SearchDatabasesByLFTagsInput {

    static func write(value: SearchDatabasesByLFTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Expression"].writeList(value.expression, memberWritingClosure: LakeFormationClientTypes.LFTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchTablesByLFTagsInput {

    static func write(value: SearchTablesByLFTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Expression"].writeList(value.expression, memberWritingClosure: LakeFormationClientTypes.LFTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension StartQueryPlanningInput {

    static func write(value: StartQueryPlanningInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryPlanningContext"].write(value.queryPlanningContext, with: LakeFormationClientTypes.QueryPlanningContext.write(value:to:))
        try writer["QueryString"].write(value.queryString)
    }
}

extension StartTransactionInput {

    static func write(value: StartTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TransactionType"].write(value.transactionType)
    }
}

extension UpdateDataCellsFilterInput {

    static func write(value: UpdateDataCellsFilterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TableData"].write(value.tableData, with: LakeFormationClientTypes.DataCellsFilter.write(value:to:))
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationInput {

    static func write(value: UpdateLakeFormationIdentityCenterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationStatus"].write(value.applicationStatus)
        try writer["CatalogId"].write(value.catalogId)
        try writer["ExternalFiltering"].write(value.externalFiltering, with: LakeFormationClientTypes.ExternalFilteringConfiguration.write(value:to:))
        try writer["ShareRecipients"].writeList(value.shareRecipients, memberWritingClosure: LakeFormationClientTypes.DataLakePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLFTagInput {

    static func write(value: UpdateLFTagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValuesToAdd"].writeList(value.tagValuesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagValuesToDelete"].writeList(value.tagValuesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResourceInput {

    static func write(value: UpdateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HybridAccessEnabled"].write(value.hybridAccessEnabled)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["RoleArn"].write(value.roleArn)
        try writer["WithFederation"].write(value.withFederation)
    }
}

extension UpdateTableObjectsInput {

    static func write(value: UpdateTableObjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["TableName"].write(value.tableName)
        try writer["TransactionId"].write(value.transactionId)
        try writer["WriteOperations"].writeList(value.writeOperations, memberWritingClosure: LakeFormationClientTypes.WriteOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTableStorageOptimizerInput {

    static func write(value: UpdateTableStorageOptimizerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["StorageOptimizerConfig"].writeMap(value.storageOptimizerConfig, valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TableName"].write(value.tableName)
    }
}

extension AddLFTagsToResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddLFTagsToResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddLFTagsToResourceOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AssumeDecoratedRoleWithSAMLOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeDecoratedRoleWithSAMLOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeDecoratedRoleWithSAMLOutput()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.expiration = try reader["Expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent()
        value.sessionToken = try reader["SessionToken"].readIfPresent()
        return value
    }
}

extension BatchGrantPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGrantPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGrantPermissionsOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.BatchPermissionsFailureEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchRevokePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchRevokePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchRevokePermissionsOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.BatchPermissionsFailureEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelTransactionOutput {
        return CancelTransactionOutput()
    }
}

extension CommitTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CommitTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CommitTransactionOutput()
        value.transactionStatus = try reader["TransactionStatus"].readIfPresent()
        return value
    }
}

extension CreateDataCellsFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataCellsFilterOutput {
        return CreateDataCellsFilterOutput()
    }
}

extension CreateLakeFormationIdentityCenterConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLakeFormationIdentityCenterConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLakeFormationIdentityCenterConfigurationOutput()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        return value
    }
}

extension CreateLakeFormationOptInOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLakeFormationOptInOutput {
        return CreateLakeFormationOptInOutput()
    }
}

extension CreateLFTagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLFTagOutput {
        return CreateLFTagOutput()
    }
}

extension DeleteDataCellsFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataCellsFilterOutput {
        return DeleteDataCellsFilterOutput()
    }
}

extension DeleteLakeFormationIdentityCenterConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLakeFormationIdentityCenterConfigurationOutput {
        return DeleteLakeFormationIdentityCenterConfigurationOutput()
    }
}

extension DeleteLakeFormationOptInOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLakeFormationOptInOutput {
        return DeleteLakeFormationOptInOutput()
    }
}

extension DeleteLFTagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLFTagOutput {
        return DeleteLFTagOutput()
    }
}

extension DeleteObjectsOnCancelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteObjectsOnCancelOutput {
        return DeleteObjectsOnCancelOutput()
    }
}

extension DeregisterResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterResourceOutput {
        return DeregisterResourceOutput()
    }
}

extension DescribeLakeFormationIdentityCenterConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLakeFormationIdentityCenterConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLakeFormationIdentityCenterConfigurationOutput()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.externalFiltering = try reader["ExternalFiltering"].readIfPresent(with: LakeFormationClientTypes.ExternalFilteringConfiguration.read(from:))
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.resourceShare = try reader["ResourceShare"].readIfPresent()
        value.shareRecipients = try reader["ShareRecipients"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.DataLakePrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeResourceOutput()
        value.resourceInfo = try reader["ResourceInfo"].readIfPresent(with: LakeFormationClientTypes.ResourceInfo.read(from:))
        return value
    }
}

extension DescribeTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTransactionOutput()
        value.transactionDescription = try reader["TransactionDescription"].readIfPresent(with: LakeFormationClientTypes.TransactionDescription.read(from:))
        return value
    }
}

extension ExtendTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExtendTransactionOutput {
        return ExtendTransactionOutput()
    }
}

extension GetDataCellsFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataCellsFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataCellsFilterOutput()
        value.dataCellsFilter = try reader["DataCellsFilter"].readIfPresent(with: LakeFormationClientTypes.DataCellsFilter.read(from:))
        return value
    }
}

extension GetDataLakePrincipalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataLakePrincipalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataLakePrincipalOutput()
        value.identity = try reader["Identity"].readIfPresent()
        return value
    }
}

extension GetDataLakeSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataLakeSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataLakeSettingsOutput()
        value.dataLakeSettings = try reader["DataLakeSettings"].readIfPresent(with: LakeFormationClientTypes.DataLakeSettings.read(from:))
        return value
    }
}

extension GetEffectivePermissionsForPathOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEffectivePermissionsForPathOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEffectivePermissionsForPathOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.PrincipalResourcePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetLFTagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLFTagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLFTagOutput()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.tagKey = try reader["TagKey"].readIfPresent()
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetQueryStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStateOutput()
        value.error = try reader["Error"].readIfPresent()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetQueryStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueryStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueryStatisticsOutput()
        value.executionStatistics = try reader["ExecutionStatistics"].readIfPresent(with: LakeFormationClientTypes.ExecutionStatistics.read(from:))
        value.planningStatistics = try reader["PlanningStatistics"].readIfPresent(with: LakeFormationClientTypes.PlanningStatistics.read(from:))
        value.querySubmissionTime = try reader["QuerySubmissionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetResourceLFTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceLFTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceLFTagsOutput()
        value.lfTagOnDatabase = try reader["LFTagOnDatabase"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lfTagsOnColumns = try reader["LFTagsOnColumns"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.ColumnLFTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lfTagsOnTable = try reader["LFTagsOnTable"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTableObjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableObjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableObjectsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.objects = try reader["Objects"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.PartitionObjects.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetTemporaryGluePartitionCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTemporaryGluePartitionCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTemporaryGluePartitionCredentialsOutput()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.expiration = try reader["Expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent()
        value.sessionToken = try reader["SessionToken"].readIfPresent()
        return value
    }
}

extension GetTemporaryGlueTableCredentialsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTemporaryGlueTableCredentialsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTemporaryGlueTableCredentialsOutput()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.expiration = try reader["Expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.secretAccessKey = try reader["SecretAccessKey"].readIfPresent()
        value.sessionToken = try reader["SessionToken"].readIfPresent()
        value.vendedS3Path = try reader["VendedS3Path"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetWorkUnitResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkUnitResultsOutput {
        var value = GetWorkUnitResultsOutput()
        switch httpResponse.body {
        case .data(let data):
            value.resultStream = .data(data)
        case .stream(let stream):
            value.resultStream = .stream(stream)
        case .noStream:
            value.resultStream = nil
        }
        return value
    }
}

extension GetWorkUnitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkUnitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkUnitsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.queryId = try reader["QueryId"].readIfPresent() ?? ""
        value.workUnitRanges = try reader["WorkUnitRanges"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.WorkUnitRange.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GrantPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GrantPermissionsOutput {
        return GrantPermissionsOutput()
    }
}

extension ListDataCellsFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataCellsFilterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataCellsFilterOutput()
        value.dataCellsFilters = try reader["DataCellsFilters"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.DataCellsFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLakeFormationOptInsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLakeFormationOptInsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLakeFormationOptInsOutput()
        value.lakeFormationOptInsInfoList = try reader["LakeFormationOptInsInfoList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LakeFormationOptInsInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLFTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLFTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLFTagsOutput()
        value.lfTags = try reader["LFTags"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPermissionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.principalResourcePermissions = try reader["PrincipalResourcePermissions"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.PrincipalResourcePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceInfoList = try reader["ResourceInfoList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.ResourceInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTableStorageOptimizersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTableStorageOptimizersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableStorageOptimizersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.storageOptimizerList = try reader["StorageOptimizerList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.StorageOptimizer.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTransactionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTransactionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTransactionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.transactions = try reader["Transactions"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.TransactionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutDataLakeSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDataLakeSettingsOutput {
        return PutDataLakeSettingsOutput()
    }
}

extension RegisterResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterResourceOutput {
        return RegisterResourceOutput()
    }
}

extension RemoveLFTagsFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveLFTagsFromResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveLFTagsFromResourceOutput()
        value.failures = try reader["Failures"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RevokePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokePermissionsOutput {
        return RevokePermissionsOutput()
    }
}

extension SearchDatabasesByLFTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDatabasesByLFTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDatabasesByLFTagsOutput()
        value.databaseList = try reader["DatabaseList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.TaggedDatabase.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SearchTablesByLFTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTablesByLFTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTablesByLFTagsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tableList = try reader["TableList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.TaggedTable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartQueryPlanningOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartQueryPlanningOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartQueryPlanningOutput()
        value.queryId = try reader["QueryId"].readIfPresent() ?? ""
        return value
    }
}

extension StartTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTransactionOutput()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        return value
    }
}

extension UpdateDataCellsFilterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataCellsFilterOutput {
        return UpdateDataCellsFilterOutput()
    }
}

extension UpdateLakeFormationIdentityCenterConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLakeFormationIdentityCenterConfigurationOutput {
        return UpdateLakeFormationIdentityCenterConfigurationOutput()
    }
}

extension UpdateLFTagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLFTagOutput {
        return UpdateLFTagOutput()
    }
}

extension UpdateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceOutput {
        return UpdateResourceOutput()
    }
}

extension UpdateTableObjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableObjectsOutput {
        return UpdateTableObjectsOutput()
    }
}

extension UpdateTableStorageOptimizerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableStorageOptimizerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTableStorageOptimizerOutput()
        value.result = try reader["Result"].readIfPresent()
        return value
    }
}

enum AddLFTagsToResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeDecoratedRoleWithSAMLOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGrantPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchRevokePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "TransactionCommitInProgressException": return try TransactionCommitInProgressException.makeError(baseError: baseError)
            case "TransactionCommittedException": return try TransactionCommittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CommitTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "TransactionCanceledException": return try TransactionCanceledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataCellsFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLakeFormationIdentityCenterConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLakeFormationOptInOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLFTagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataCellsFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLakeFormationIdentityCenterConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLakeFormationOptInOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLFTagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteObjectsOnCancelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "TransactionCanceledException": return try TransactionCanceledException.makeError(baseError: baseError)
            case "TransactionCommittedException": return try TransactionCommittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLakeFormationIdentityCenterConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExtendTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "TransactionCanceledException": return try TransactionCanceledException.makeError(baseError: baseError)
            case "TransactionCommitInProgressException": return try TransactionCommitInProgressException.makeError(baseError: baseError)
            case "TransactionCommittedException": return try TransactionCommittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataCellsFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataLakePrincipalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataLakeSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEffectivePermissionsForPathOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLFTagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueryStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredException": return try ExpiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "StatisticsNotReadyYetException": return try StatisticsNotReadyYetException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceLFTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableObjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "TransactionCanceledException": return try TransactionCanceledException.makeError(baseError: baseError)
            case "TransactionCommittedException": return try TransactionCommittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTemporaryGluePartitionCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "PermissionTypeMismatchException": return try PermissionTypeMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTemporaryGlueTableCredentialsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "PermissionTypeMismatchException": return try PermissionTypeMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkUnitResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredException": return try ExpiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkUnitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredException": return try ExpiredException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "WorkUnitsNotReadyYetException": return try WorkUnitsNotReadyYetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GrantPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataCellsFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLakeFormationOptInsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLFTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTableStorageOptimizersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTransactionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDataLakeSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AlreadyExistsException": return try AlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNumberLimitExceededException": return try ResourceNumberLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveLFTagsFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDatabasesByLFTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTablesByLFTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "GlueEncryptionException": return try GlueEncryptionException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartQueryPlanningOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ThrottledException": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataCellsFilterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLakeFormationIdentityCenterConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLFTagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableObjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "OperationTimeoutException": return try OperationTimeoutException.makeError(baseError: baseError)
            case "ResourceNotReadyException": return try ResourceNotReadyException.makeError(baseError: baseError)
            case "TransactionCanceledException": return try TransactionCanceledException.makeError(baseError: baseError)
            case "TransactionCommitInProgressException": return try TransactionCommitInProgressException.makeError(baseError: baseError)
            case "TransactionCommittedException": return try TransactionCommittedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableStorageOptimizerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> OperationTimeoutException {
        let reader = baseError.errorBodyReader
        var value = OperationTimeoutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EntityNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EntityNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransactionCommitInProgressException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransactionCommitInProgressException {
        let reader = baseError.errorBodyReader
        var value = TransactionCommitInProgressException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransactionCommittedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransactionCommittedException {
        let reader = baseError.errorBodyReader
        var value = TransactionCommittedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TransactionCanceledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TransactionCanceledException {
        let reader = baseError.errorBodyReader
        var value = TransactionCanceledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNumberLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNumberLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceNumberLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = AlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotReadyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ExpiredException {
        let reader = baseError.errorBodyReader
        var value = ExpiredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StatisticsNotReadyYetException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StatisticsNotReadyYetException {
        let reader = baseError.errorBodyReader
        var value = StatisticsNotReadyYetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GlueEncryptionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> GlueEncryptionException {
        let reader = baseError.errorBodyReader
        var value = GlueEncryptionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PermissionTypeMismatchException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PermissionTypeMismatchException {
        let reader = baseError.errorBodyReader
        var value = PermissionTypeMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkUnitsNotReadyYetException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> WorkUnitsNotReadyYetException {
        let reader = baseError.errorBodyReader
        var value = WorkUnitsNotReadyYetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LakeFormationClientTypes.LFTagError {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LFTagError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LFTagError()
        value.lfTag = try reader["LFTag"].readIfPresent(with: LakeFormationClientTypes.LFTagPair.read(from:))
        value.error = try reader["Error"].readIfPresent(with: LakeFormationClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ErrorDetail()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.LFTagPair {

    static func write(value: LakeFormationClientTypes.LFTagPair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LFTagPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LFTagPair()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.tagKey = try reader["TagKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LakeFormationClientTypes.BatchPermissionsFailureEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.BatchPermissionsFailureEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.BatchPermissionsFailureEntry()
        value.requestEntry = try reader["RequestEntry"].readIfPresent(with: LakeFormationClientTypes.BatchPermissionsRequestEntry.read(from:))
        value.error = try reader["Error"].readIfPresent(with: LakeFormationClientTypes.ErrorDetail.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.BatchPermissionsRequestEntry {

    static func write(value: LakeFormationClientTypes.BatchPermissionsRequestEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PermissionsWithGrantOption"].writeList(value.permissionsWithGrantOption, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
        try writer["Resource"].write(value.resource, with: LakeFormationClientTypes.Resource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.BatchPermissionsRequestEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.BatchPermissionsRequestEntry()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.principal = try reader["Principal"].readIfPresent(with: LakeFormationClientTypes.DataLakePrincipal.read(from:))
        value.resource = try reader["Resource"].readIfPresent(with: LakeFormationClientTypes.Resource.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LakeFormationClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionsWithGrantOption = try reader["PermissionsWithGrantOption"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LakeFormationClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.Resource {

    static func write(value: LakeFormationClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog, with: LakeFormationClientTypes.CatalogResource.write(value:to:))
        try writer["DataCellsFilter"].write(value.dataCellsFilter, with: LakeFormationClientTypes.DataCellsFilterResource.write(value:to:))
        try writer["DataLocation"].write(value.dataLocation, with: LakeFormationClientTypes.DataLocationResource.write(value:to:))
        try writer["Database"].write(value.database, with: LakeFormationClientTypes.DatabaseResource.write(value:to:))
        try writer["LFTag"].write(value.lfTag, with: LakeFormationClientTypes.LFTagKeyResource.write(value:to:))
        try writer["LFTagPolicy"].write(value.lfTagPolicy, with: LakeFormationClientTypes.LFTagPolicyResource.write(value:to:))
        try writer["Table"].write(value.table, with: LakeFormationClientTypes.TableResource.write(value:to:))
        try writer["TableWithColumns"].write(value.tableWithColumns, with: LakeFormationClientTypes.TableWithColumnsResource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.Resource()
        value.catalog = try reader["Catalog"].readIfPresent(with: LakeFormationClientTypes.CatalogResource.read(from:))
        value.database = try reader["Database"].readIfPresent(with: LakeFormationClientTypes.DatabaseResource.read(from:))
        value.table = try reader["Table"].readIfPresent(with: LakeFormationClientTypes.TableResource.read(from:))
        value.tableWithColumns = try reader["TableWithColumns"].readIfPresent(with: LakeFormationClientTypes.TableWithColumnsResource.read(from:))
        value.dataLocation = try reader["DataLocation"].readIfPresent(with: LakeFormationClientTypes.DataLocationResource.read(from:))
        value.dataCellsFilter = try reader["DataCellsFilter"].readIfPresent(with: LakeFormationClientTypes.DataCellsFilterResource.read(from:))
        value.lfTag = try reader["LFTag"].readIfPresent(with: LakeFormationClientTypes.LFTagKeyResource.read(from:))
        value.lfTagPolicy = try reader["LFTagPolicy"].readIfPresent(with: LakeFormationClientTypes.LFTagPolicyResource.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.LFTagPolicyResource {

    static func write(value: LakeFormationClientTypes.LFTagPolicyResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Expression"].writeList(value.expression, memberWritingClosure: LakeFormationClientTypes.LFTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LFTagPolicyResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LFTagPolicyResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? .sdkUnknown("")
        value.expression = try reader["Expression"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LakeFormationClientTypes.LFTag {

    static func write(value: LakeFormationClientTypes.LFTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LFTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LFTag()
        value.tagKey = try reader["TagKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LakeFormationClientTypes.LFTagKeyResource {

    static func write(value: LakeFormationClientTypes.LFTagKeyResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagValues"].writeList(value.tagValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LFTagKeyResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LFTagKeyResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.tagKey = try reader["TagKey"].readIfPresent() ?? ""
        value.tagValues = try reader["TagValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LakeFormationClientTypes.DataCellsFilterResource {

    static func write(value: LakeFormationClientTypes.DataCellsFilterResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["TableCatalogId"].write(value.tableCatalogId)
        try writer["TableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DataCellsFilterResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DataCellsFilterResource()
        value.tableCatalogId = try reader["TableCatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.DataLocationResource {

    static func write(value: LakeFormationClientTypes.DataLocationResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DataLocationResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DataLocationResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension LakeFormationClientTypes.TableWithColumnsResource {

    static func write(value: LakeFormationClientTypes.TableWithColumnsResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["ColumnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnWildcard"].write(value.columnWildcard, with: LakeFormationClientTypes.ColumnWildcard.write(value:to:))
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TableWithColumnsResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TableWithColumnsResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.columnNames = try reader["ColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnWildcard = try reader["ColumnWildcard"].readIfPresent(with: LakeFormationClientTypes.ColumnWildcard.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.ColumnWildcard {

    static func write(value: LakeFormationClientTypes.ColumnWildcard?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExcludedColumnNames"].writeList(value.excludedColumnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ColumnWildcard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ColumnWildcard()
        value.excludedColumnNames = try reader["ExcludedColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.TableResource {

    static func write(value: LakeFormationClientTypes.TableResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["TableWildcard"].write(value.tableWildcard, with: LakeFormationClientTypes.TableWildcard.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TableResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TableResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.tableWildcard = try reader["TableWildcard"].readIfPresent(with: LakeFormationClientTypes.TableWildcard.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.TableWildcard {

    static func write(value: LakeFormationClientTypes.TableWildcard?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TableWildcard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return LakeFormationClientTypes.TableWildcard()
    }
}

extension LakeFormationClientTypes.DatabaseResource {

    static func write(value: LakeFormationClientTypes.DatabaseResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DatabaseResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DatabaseResource()
        value.catalogId = try reader["CatalogId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension LakeFormationClientTypes.CatalogResource {

    static func write(value: LakeFormationClientTypes.CatalogResource?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.CatalogResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return LakeFormationClientTypes.CatalogResource()
    }
}

extension LakeFormationClientTypes.DataLakePrincipal {

    static func write(value: LakeFormationClientTypes.DataLakePrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataLakePrincipalIdentifier"].write(value.dataLakePrincipalIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DataLakePrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DataLakePrincipal()
        value.dataLakePrincipalIdentifier = try reader["DataLakePrincipalIdentifier"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.ExternalFilteringConfiguration {

    static func write(value: LakeFormationClientTypes.ExternalFilteringConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedTargets"].writeList(value.authorizedTargets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ExternalFilteringConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ExternalFilteringConfiguration()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.authorizedTargets = try reader["AuthorizedTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension LakeFormationClientTypes.ResourceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ResourceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ResourceInfo()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.withFederation = try reader["WithFederation"].readIfPresent()
        value.hybridAccessEnabled = try reader["HybridAccessEnabled"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.TransactionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TransactionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TransactionDescription()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        value.transactionStatus = try reader["TransactionStatus"].readIfPresent()
        value.transactionStartTime = try reader["TransactionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.transactionEndTime = try reader["TransactionEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LakeFormationClientTypes.DataCellsFilter {

    static func write(value: LakeFormationClientTypes.DataCellsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnWildcard"].write(value.columnWildcard, with: LakeFormationClientTypes.ColumnWildcard.write(value:to:))
        try writer["DatabaseName"].write(value.databaseName)
        try writer["Name"].write(value.name)
        try writer["RowFilter"].write(value.rowFilter, with: LakeFormationClientTypes.RowFilter.write(value:to:))
        try writer["TableCatalogId"].write(value.tableCatalogId)
        try writer["TableName"].write(value.tableName)
        try writer["VersionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DataCellsFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DataCellsFilter()
        value.tableCatalogId = try reader["TableCatalogId"].readIfPresent() ?? ""
        value.databaseName = try reader["DatabaseName"].readIfPresent() ?? ""
        value.tableName = try reader["TableName"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.rowFilter = try reader["RowFilter"].readIfPresent(with: LakeFormationClientTypes.RowFilter.read(from:))
        value.columnNames = try reader["ColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnWildcard = try reader["ColumnWildcard"].readIfPresent(with: LakeFormationClientTypes.ColumnWildcard.read(from:))
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.RowFilter {

    static func write(value: LakeFormationClientTypes.RowFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllRowsWildcard"].write(value.allRowsWildcard, with: LakeFormationClientTypes.AllRowsWildcard.write(value:to:))
        try writer["FilterExpression"].write(value.filterExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.RowFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.RowFilter()
        value.filterExpression = try reader["FilterExpression"].readIfPresent()
        value.allRowsWildcard = try reader["AllRowsWildcard"].readIfPresent(with: LakeFormationClientTypes.AllRowsWildcard.read(from:))
        return value
    }
}

extension LakeFormationClientTypes.AllRowsWildcard {

    static func write(value: LakeFormationClientTypes.AllRowsWildcard?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.AllRowsWildcard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return LakeFormationClientTypes.AllRowsWildcard()
    }
}

extension LakeFormationClientTypes.DataLakeSettings {

    static func write(value: LakeFormationClientTypes.DataLakeSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowExternalDataFiltering"].write(value.allowExternalDataFiltering)
        try writer["AllowFullTableExternalDataAccess"].write(value.allowFullTableExternalDataAccess)
        try writer["AuthorizedSessionTagValueList"].writeList(value.authorizedSessionTagValueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateDatabaseDefaultPermissions"].writeList(value.createDatabaseDefaultPermissions, memberWritingClosure: LakeFormationClientTypes.PrincipalPermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateTableDefaultPermissions"].writeList(value.createTableDefaultPermissions, memberWritingClosure: LakeFormationClientTypes.PrincipalPermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataLakeAdmins"].writeList(value.dataLakeAdmins, memberWritingClosure: LakeFormationClientTypes.DataLakePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExternalDataFilteringAllowList"].writeList(value.externalDataFilteringAllowList, memberWritingClosure: LakeFormationClientTypes.DataLakePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ReadOnlyAdmins"].writeList(value.readOnlyAdmins, memberWritingClosure: LakeFormationClientTypes.DataLakePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrustedResourceOwners"].writeList(value.trustedResourceOwners, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DataLakeSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DataLakeSettings()
        value.dataLakeAdmins = try reader["DataLakeAdmins"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.DataLakePrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.readOnlyAdmins = try reader["ReadOnlyAdmins"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.DataLakePrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createDatabaseDefaultPermissions = try reader["CreateDatabaseDefaultPermissions"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.PrincipalPermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createTableDefaultPermissions = try reader["CreateTableDefaultPermissions"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.PrincipalPermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.trustedResourceOwners = try reader["TrustedResourceOwners"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowExternalDataFiltering = try reader["AllowExternalDataFiltering"].readIfPresent()
        value.allowFullTableExternalDataAccess = try reader["AllowFullTableExternalDataAccess"].readIfPresent()
        value.externalDataFilteringAllowList = try reader["ExternalDataFilteringAllowList"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.DataLakePrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.authorizedSessionTagValueList = try reader["AuthorizedSessionTagValueList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.PrincipalPermissions {

    static func write(value: LakeFormationClientTypes.PrincipalPermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<LakeFormationClientTypes.Permission>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal, with: LakeFormationClientTypes.DataLakePrincipal.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.PrincipalPermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.PrincipalPermissions()
        value.principal = try reader["Principal"].readIfPresent(with: LakeFormationClientTypes.DataLakePrincipal.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LakeFormationClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.PrincipalResourcePermissions {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.PrincipalResourcePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.PrincipalResourcePermissions()
        value.principal = try reader["Principal"].readIfPresent(with: LakeFormationClientTypes.DataLakePrincipal.read(from:))
        value.resource = try reader["Resource"].readIfPresent(with: LakeFormationClientTypes.Resource.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LakeFormationClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionsWithGrantOption = try reader["PermissionsWithGrantOption"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<LakeFormationClientTypes.Permission>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalDetails = try reader["AdditionalDetails"].readIfPresent(with: LakeFormationClientTypes.DetailsMap.read(from:))
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["LastUpdatedBy"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.DetailsMap {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.DetailsMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.DetailsMap()
        value.resourceShare = try reader["ResourceShare"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.ExecutionStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ExecutionStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ExecutionStatistics()
        value.averageExecutionTimeMillis = try reader["AverageExecutionTimeMillis"].readIfPresent() ?? 0
        value.dataScannedBytes = try reader["DataScannedBytes"].readIfPresent() ?? 0
        value.workUnitsExecutedCount = try reader["WorkUnitsExecutedCount"].readIfPresent() ?? 0
        return value
    }
}

extension LakeFormationClientTypes.PlanningStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.PlanningStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.PlanningStatistics()
        value.estimatedDataToScanBytes = try reader["EstimatedDataToScanBytes"].readIfPresent() ?? 0
        value.planningTimeMillis = try reader["PlanningTimeMillis"].readIfPresent() ?? 0
        value.queueTimeMillis = try reader["QueueTimeMillis"].readIfPresent() ?? 0
        value.workUnitsGeneratedCount = try reader["WorkUnitsGeneratedCount"].readIfPresent() ?? 0
        return value
    }
}

extension LakeFormationClientTypes.ColumnLFTag {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.ColumnLFTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.ColumnLFTag()
        value.name = try reader["Name"].readIfPresent()
        value.lfTags = try reader["LFTags"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.PartitionObjects {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.PartitionObjects {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.PartitionObjects()
        value.partitionValues = try reader["PartitionValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.objects = try reader["Objects"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.TableObject.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.TableObject {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TableObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TableObject()
        value.uri = try reader["Uri"].readIfPresent()
        value.eTag = try reader["ETag"].readIfPresent()
        value.size = try reader["Size"].readIfPresent() ?? 0
        return value
    }
}

extension LakeFormationClientTypes.WorkUnitRange {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.WorkUnitRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.WorkUnitRange()
        value.workUnitIdMax = try reader["WorkUnitIdMax"].readIfPresent() ?? 0
        value.workUnitIdMin = try reader["WorkUnitIdMin"].readIfPresent() ?? 0
        value.workUnitToken = try reader["WorkUnitToken"].readIfPresent() ?? ""
        return value
    }
}

extension LakeFormationClientTypes.LakeFormationOptInsInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.LakeFormationOptInsInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.LakeFormationOptInsInfo()
        value.resource = try reader["Resource"].readIfPresent(with: LakeFormationClientTypes.Resource.read(from:))
        value.principal = try reader["Principal"].readIfPresent(with: LakeFormationClientTypes.DataLakePrincipal.read(from:))
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedBy = try reader["LastUpdatedBy"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.StorageOptimizer {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.StorageOptimizer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.StorageOptimizer()
        value.storageOptimizerType = try reader["StorageOptimizerType"].readIfPresent()
        value.config = try reader["Config"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.warnings = try reader["Warnings"].readIfPresent()
        value.lastRunDetails = try reader["LastRunDetails"].readIfPresent()
        return value
    }
}

extension LakeFormationClientTypes.TaggedDatabase {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TaggedDatabase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TaggedDatabase()
        value.database = try reader["Database"].readIfPresent(with: LakeFormationClientTypes.DatabaseResource.read(from:))
        value.lfTags = try reader["LFTags"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.TaggedTable {

    static func read(from reader: SmithyJSON.Reader) throws -> LakeFormationClientTypes.TaggedTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LakeFormationClientTypes.TaggedTable()
        value.table = try reader["Table"].readIfPresent(with: LakeFormationClientTypes.TableResource.read(from:))
        value.lfTagOnDatabase = try reader["LFTagOnDatabase"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lfTagsOnTable = try reader["LFTagsOnTable"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.LFTagPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lfTagsOnColumns = try reader["LFTagsOnColumns"].readListIfPresent(memberReadingClosure: LakeFormationClientTypes.ColumnLFTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LakeFormationClientTypes.VirtualObject {

    static func write(value: LakeFormationClientTypes.VirtualObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ETag"].write(value.eTag)
        try writer["Uri"].write(value.uri)
    }
}

extension LakeFormationClientTypes.PartitionValueList {

    static func write(value: LakeFormationClientTypes.PartitionValueList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LakeFormationClientTypes.AuditContext {

    static func write(value: LakeFormationClientTypes.AuditContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalAuditContext"].write(value.additionalAuditContext)
    }
}

extension LakeFormationClientTypes.QuerySessionContext {

    static func write(value: LakeFormationClientTypes.QuerySessionContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalContext"].writeMap(value.additionalContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ClusterId"].write(value.clusterId)
        try writer["QueryAuthorizationId"].write(value.queryAuthorizationId)
        try writer["QueryId"].write(value.queryId)
        try writer["QueryStartTime"].writeTimestamp(value.queryStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension LakeFormationClientTypes.FilterCondition {

    static func write(value: LakeFormationClientTypes.FilterCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["Field"].write(value.field)
        try writer["StringValueList"].writeList(value.stringValueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension LakeFormationClientTypes.QueryPlanningContext {

    static func write(value: LakeFormationClientTypes.QueryPlanningContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CatalogId"].write(value.catalogId)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["QueryAsOfTime"].writeTimestamp(value.queryAsOfTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["QueryParameters"].writeMap(value.queryParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension LakeFormationClientTypes.WriteOperation {

    static func write(value: LakeFormationClientTypes.WriteOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddObject"].write(value.addObject, with: LakeFormationClientTypes.AddObjectInput.write(value:to:))
        try writer["DeleteObject"].write(value.deleteObject, with: LakeFormationClientTypes.DeleteObjectInput.write(value:to:))
    }
}

extension LakeFormationClientTypes.DeleteObjectInput {

    static func write(value: LakeFormationClientTypes.DeleteObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ETag"].write(value.eTag)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Uri"].write(value.uri)
    }
}

extension LakeFormationClientTypes.AddObjectInput {

    static func write(value: LakeFormationClientTypes.AddObjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ETag"].write(value.eTag)
        try writer["PartitionValues"].writeList(value.partitionValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Size"].write(value.size)
        try writer["Uri"].write(value.uri)
    }
}

public enum LakeFormationClientTypes {}
