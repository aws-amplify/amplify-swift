//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension QuickSightClient {
    /// Paginate over `[DescribeFolderPermissionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFolderPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFolderPermissionsOutput`
    public func describeFolderPermissionsPaginated(input: DescribeFolderPermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeFolderPermissionsInput, DescribeFolderPermissionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFolderPermissionsInput, DescribeFolderPermissionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFolderPermissions(input:))
    }
}

extension DescribeFolderPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFolderPermissionsInput {
        return DescribeFolderPermissionsInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFolderPermissionsInput, OperationStackOutput == DescribeFolderPermissionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFolderPermissionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ResourcePermission]`
    /// - Returns: `[QuickSightClientTypes.ResourcePermission]`
    public func permissions() async throws -> [QuickSightClientTypes.ResourcePermission] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}
extension QuickSightClient {
    /// Paginate over `[DescribeFolderResolvedPermissionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFolderResolvedPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFolderResolvedPermissionsOutput`
    public func describeFolderResolvedPermissionsPaginated(input: DescribeFolderResolvedPermissionsInput) -> ClientRuntime.PaginatorSequence<DescribeFolderResolvedPermissionsInput, DescribeFolderResolvedPermissionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFolderResolvedPermissionsInput, DescribeFolderResolvedPermissionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFolderResolvedPermissions(input:))
    }
}

extension DescribeFolderResolvedPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFolderResolvedPermissionsInput {
        return DescribeFolderResolvedPermissionsInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFolderResolvedPermissionsInput, OperationStackOutput == DescribeFolderResolvedPermissionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFolderResolvedPermissionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ResourcePermission]`
    /// - Returns: `[QuickSightClientTypes.ResourcePermission]`
    public func permissions() async throws -> [QuickSightClientTypes.ResourcePermission] {
        return try await self.asyncCompactMap { item in item.permissions }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAnalysesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAnalysesOutput`
    public func listAnalysesPaginated(input: ListAnalysesInput) -> ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutput> {
        return ClientRuntime.PaginatorSequence<ListAnalysesInput, ListAnalysesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAnalyses(input:))
    }
}

extension ListAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAnalysesInput {
        return ListAnalysesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAnalysesInput, OperationStackOutput == ListAnalysesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAssetBundleExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetBundleExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetBundleExportJobsOutput`
    public func listAssetBundleExportJobsPaginated(input: ListAssetBundleExportJobsInput) -> ClientRuntime.PaginatorSequence<ListAssetBundleExportJobsInput, ListAssetBundleExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetBundleExportJobsInput, ListAssetBundleExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetBundleExportJobs(input:))
    }
}

extension ListAssetBundleExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetBundleExportJobsInput {
        return ListAssetBundleExportJobsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetBundleExportJobsInput, OperationStackOutput == ListAssetBundleExportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetBundleExportJobsPaginated`
    /// to access the nested member `[QuickSightClientTypes.AssetBundleExportJobSummary]`
    /// - Returns: `[QuickSightClientTypes.AssetBundleExportJobSummary]`
    public func assetBundleExportJobSummaryList() async throws -> [QuickSightClientTypes.AssetBundleExportJobSummary] {
        return try await self.asyncCompactMap { item in item.assetBundleExportJobSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListAssetBundleImportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssetBundleImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssetBundleImportJobsOutput`
    public func listAssetBundleImportJobsPaginated(input: ListAssetBundleImportJobsInput) -> ClientRuntime.PaginatorSequence<ListAssetBundleImportJobsInput, ListAssetBundleImportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssetBundleImportJobsInput, ListAssetBundleImportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssetBundleImportJobs(input:))
    }
}

extension ListAssetBundleImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssetBundleImportJobsInput {
        return ListAssetBundleImportJobsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAssetBundleImportJobsInput, OperationStackOutput == ListAssetBundleImportJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAssetBundleImportJobsPaginated`
    /// to access the nested member `[QuickSightClientTypes.AssetBundleImportJobSummary]`
    /// - Returns: `[QuickSightClientTypes.AssetBundleImportJobSummary]`
    public func assetBundleImportJobSummaryList() async throws -> [QuickSightClientTypes.AssetBundleImportJobSummary] {
        return try await self.asyncCompactMap { item in item.assetBundleImportJobSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardsOutput`
    public func listDashboardsPaginated(input: ListDashboardsInput) -> ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutput> {
        return ClientRuntime.PaginatorSequence<ListDashboardsInput, ListDashboardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDashboards(input:))
    }
}

extension ListDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardsInput {
        return ListDashboardsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDashboardsInput, OperationStackOutput == ListDashboardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDashboardVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDashboardVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDashboardVersionsOutput`
    public func listDashboardVersionsPaginated(input: ListDashboardVersionsInput) -> ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListDashboardVersionsInput, ListDashboardVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDashboardVersions(input:))
    }
}

extension ListDashboardVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDashboardVersionsInput {
        return ListDashboardVersionsInput(
            awsAccountId: self.awsAccountId,
            dashboardId: self.dashboardId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDashboardVersionsInput, OperationStackOutput == ListDashboardVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDashboardVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardVersionSummary]`
    public func dashboardVersionSummaryList() async throws -> [QuickSightClientTypes.DashboardVersionSummary] {
        return try await self.asyncCompactMap { item in item.dashboardVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSetsOutput`
    public func listDataSetsPaginated(input: ListDataSetsInput) -> ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListDataSetsInput, ListDataSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataSets(input:))
    }
}

extension ListDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSetsInput {
        return ListDataSetsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDataSetsInput, OperationStackOutput == ListDataSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListDataSourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDataSourcesOutput`
    public func listDataSourcesPaginated(input: ListDataSourcesInput) -> ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListDataSourcesInput, ListDataSourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDataSources(input:))
    }
}

extension ListDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDataSourcesInput {
        return ListDataSourcesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDataSourcesInput, OperationStackOutput == ListDataSourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSource]`
    /// - Returns: `[QuickSightClientTypes.DataSource]`
    public func dataSources() async throws -> [QuickSightClientTypes.DataSource] {
        return try await self.asyncCompactMap { item in item.dataSources }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListFolderMembersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFolderMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFolderMembersOutput`
    public func listFolderMembersPaginated(input: ListFolderMembersInput) -> ClientRuntime.PaginatorSequence<ListFolderMembersInput, ListFolderMembersOutput> {
        return ClientRuntime.PaginatorSequence<ListFolderMembersInput, ListFolderMembersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFolderMembers(input:))
    }
}

extension ListFolderMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFolderMembersInput {
        return ListFolderMembersInput(
            awsAccountId: self.awsAccountId,
            folderId: self.folderId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFolderMembersInput, OperationStackOutput == ListFolderMembersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFolderMembersPaginated`
    /// to access the nested member `[QuickSightClientTypes.MemberIdArnPair]`
    /// - Returns: `[QuickSightClientTypes.MemberIdArnPair]`
    public func folderMemberList() async throws -> [QuickSightClientTypes.MemberIdArnPair] {
        return try await self.asyncCompactMap { item in item.folderMemberList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListFoldersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFoldersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFoldersOutput`
    public func listFoldersPaginated(input: ListFoldersInput) -> ClientRuntime.PaginatorSequence<ListFoldersInput, ListFoldersOutput> {
        return ClientRuntime.PaginatorSequence<ListFoldersInput, ListFoldersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFolders(input:))
    }
}

extension ListFoldersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFoldersInput {
        return ListFoldersInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFoldersInput, OperationStackOutput == ListFoldersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFoldersPaginated`
    /// to access the nested member `[QuickSightClientTypes.FolderSummary]`
    /// - Returns: `[QuickSightClientTypes.FolderSummary]`
    public func folderSummaryList() async throws -> [QuickSightClientTypes.FolderSummary] {
        return try await self.asyncCompactMap { item in item.folderSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListFoldersForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFoldersForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFoldersForResourceOutput`
    public func listFoldersForResourcePaginated(input: ListFoldersForResourceInput) -> ClientRuntime.PaginatorSequence<ListFoldersForResourceInput, ListFoldersForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListFoldersForResourceInput, ListFoldersForResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFoldersForResource(input:))
    }
}

extension ListFoldersForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFoldersForResourceInput {
        return ListFoldersForResourceInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListFoldersForResourceInput, OperationStackOutput == ListFoldersForResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFoldersForResourcePaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func folders() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.folders }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListGroupMembershipsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupMembershipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupMembershipsOutput`
    public func listGroupMembershipsPaginated(input: ListGroupMembershipsInput) -> ClientRuntime.PaginatorSequence<ListGroupMembershipsInput, ListGroupMembershipsOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupMembershipsInput, ListGroupMembershipsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroupMemberships(input:))
    }
}

extension ListGroupMembershipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupMembershipsInput {
        return ListGroupMembershipsInput(
            awsAccountId: self.awsAccountId,
            groupName: self.groupName,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupMembershipsInput, OperationStackOutput == ListGroupMembershipsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupMembershipsPaginated`
    /// to access the nested member `[QuickSightClientTypes.GroupMember]`
    /// - Returns: `[QuickSightClientTypes.GroupMember]`
    public func groupMemberList() async throws -> [QuickSightClientTypes.GroupMember] {
        return try await self.asyncCompactMap { item in item.groupMemberList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutput`
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListGroupsInput, OperationStackOutput == ListGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIAMPolicyAssignmentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIAMPolicyAssignmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIAMPolicyAssignmentsOutput`
    public func listIAMPolicyAssignmentsPaginated(input: ListIAMPolicyAssignmentsInput) -> ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsInput, ListIAMPolicyAssignmentsOutput> {
        return ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsInput, ListIAMPolicyAssignmentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIAMPolicyAssignments(input:))
    }
}

extension ListIAMPolicyAssignmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIAMPolicyAssignmentsInput {
        return ListIAMPolicyAssignmentsInput(
            assignmentStatus: self.assignmentStatus,
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIAMPolicyAssignmentsInput, OperationStackOutput == ListIAMPolicyAssignmentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIAMPolicyAssignmentsPaginated`
    /// to access the nested member `[QuickSightClientTypes.IAMPolicyAssignmentSummary]`
    /// - Returns: `[QuickSightClientTypes.IAMPolicyAssignmentSummary]`
    public func iamPolicyAssignments() async throws -> [QuickSightClientTypes.IAMPolicyAssignmentSummary] {
        return try await self.asyncCompactMap { item in item.iamPolicyAssignments }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIAMPolicyAssignmentsForUserOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIAMPolicyAssignmentsForUserInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIAMPolicyAssignmentsForUserOutput`
    public func listIAMPolicyAssignmentsForUserPaginated(input: ListIAMPolicyAssignmentsForUserInput) -> ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsForUserInput, ListIAMPolicyAssignmentsForUserOutput> {
        return ClientRuntime.PaginatorSequence<ListIAMPolicyAssignmentsForUserInput, ListIAMPolicyAssignmentsForUserOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIAMPolicyAssignmentsForUser(input:))
    }
}

extension ListIAMPolicyAssignmentsForUserInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIAMPolicyAssignmentsForUserInput {
        return ListIAMPolicyAssignmentsForUserInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListIAMPolicyAssignmentsForUserInput, OperationStackOutput == ListIAMPolicyAssignmentsForUserOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIAMPolicyAssignmentsForUserPaginated`
    /// to access the nested member `[QuickSightClientTypes.ActiveIAMPolicyAssignment]`
    /// - Returns: `[QuickSightClientTypes.ActiveIAMPolicyAssignment]`
    public func activeAssignments() async throws -> [QuickSightClientTypes.ActiveIAMPolicyAssignment] {
        return try await self.asyncCompactMap { item in item.activeAssignments }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListIngestionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIngestionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIngestionsOutput`
    public func listIngestionsPaginated(input: ListIngestionsInput) -> ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput> {
        return ClientRuntime.PaginatorSequence<ListIngestionsInput, ListIngestionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIngestions(input:))
    }
}

extension ListIngestionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIngestionsInput {
        return ListIngestionsInput(
            awsAccountId: self.awsAccountId,
            dataSetId: self.dataSetId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIngestionsInput, OperationStackOutput == ListIngestionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIngestionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Ingestion]`
    /// - Returns: `[QuickSightClientTypes.Ingestion]`
    public func ingestions() async throws -> [QuickSightClientTypes.Ingestion] {
        return try await self.asyncCompactMap { item in item.ingestions }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListNamespacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNamespacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNamespacesOutput`
    public func listNamespacesPaginated(input: ListNamespacesInput) -> ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutput> {
        return ClientRuntime.PaginatorSequence<ListNamespacesInput, ListNamespacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNamespaces(input:))
    }
}

extension ListNamespacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNamespacesInput {
        return ListNamespacesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListNamespacesInput, OperationStackOutput == ListNamespacesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNamespacesPaginated`
    /// to access the nested member `[QuickSightClientTypes.NamespaceInfoV2]`
    /// - Returns: `[QuickSightClientTypes.NamespaceInfoV2]`
    public func namespaces() async throws -> [QuickSightClientTypes.NamespaceInfoV2] {
        return try await self.asyncCompactMap { item in item.namespaces }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListRoleMembershipsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRoleMembershipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRoleMembershipsOutput`
    public func listRoleMembershipsPaginated(input: ListRoleMembershipsInput) -> ClientRuntime.PaginatorSequence<ListRoleMembershipsInput, ListRoleMembershipsOutput> {
        return ClientRuntime.PaginatorSequence<ListRoleMembershipsInput, ListRoleMembershipsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRoleMemberships(input:))
    }
}

extension ListRoleMembershipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoleMembershipsInput {
        return ListRoleMembershipsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            role: self.role
        )}
}

extension PaginatorSequence where OperationStackInput == ListRoleMembershipsInput, OperationStackOutput == ListRoleMembershipsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRoleMembershipsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func membersList() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.membersList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateAliasesOutput`
    public func listTemplateAliasesPaginated(input: ListTemplateAliasesInput) -> ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListTemplateAliasesInput, ListTemplateAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTemplateAliases(input:))
    }
}

extension ListTemplateAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateAliasesInput {
        return ListTemplateAliasesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where OperationStackInput == ListTemplateAliasesInput, OperationStackOutput == ListTemplateAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateAliasesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateAlias]`
    /// - Returns: `[QuickSightClientTypes.TemplateAlias]`
    public func templateAliasList() async throws -> [QuickSightClientTypes.TemplateAlias] {
        return try await self.asyncCompactMap { item in item.templateAliasList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplatesOutput`
    public func listTemplatesPaginated(input: ListTemplatesInput) -> ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListTemplatesInput, ListTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTemplates(input:))
    }
}

extension ListTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplatesInput {
        return ListTemplatesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListTemplatesInput, OperationStackOutput == ListTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplatesPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateSummary]`
    public func templateSummaryList() async throws -> [QuickSightClientTypes.TemplateSummary] {
        return try await self.asyncCompactMap { item in item.templateSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTemplateVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateVersionsOutput`
    public func listTemplateVersionsPaginated(input: ListTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTemplateVersionsInput, ListTemplateVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTemplateVersions(input:))
    }
}

extension ListTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateVersionsInput {
        return ListTemplateVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            templateId: self.templateId
        )}
}

extension PaginatorSequence where OperationStackInput == ListTemplateVersionsInput, OperationStackOutput == ListTemplateVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTemplateVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.TemplateVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.TemplateVersionSummary]`
    public func templateVersionSummaryList() async throws -> [QuickSightClientTypes.TemplateVersionSummary] {
        return try await self.asyncCompactMap { item in item.templateVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemesOutput`
    public func listThemesPaginated(input: ListThemesInput) -> ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutput> {
        return ClientRuntime.PaginatorSequence<ListThemesInput, ListThemesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThemes(input:))
    }
}

extension ListThemesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemesInput {
        return ListThemesInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListThemesInput, OperationStackOutput == ListThemesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThemesPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeSummary]`
    public func themeSummaryList() async throws -> [QuickSightClientTypes.ThemeSummary] {
        return try await self.asyncCompactMap { item in item.themeSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListThemeVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThemeVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThemeVersionsOutput`
    public func listThemeVersionsPaginated(input: ListThemeVersionsInput) -> ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListThemeVersionsInput, ListThemeVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThemeVersions(input:))
    }
}

extension ListThemeVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThemeVersionsInput {
        return ListThemeVersionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token,
            themeId: self.themeId
        )}
}

extension PaginatorSequence where OperationStackInput == ListThemeVersionsInput, OperationStackOutput == ListThemeVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThemeVersionsPaginated`
    /// to access the nested member `[QuickSightClientTypes.ThemeVersionSummary]`
    /// - Returns: `[QuickSightClientTypes.ThemeVersionSummary]`
    public func themeVersionSummaryList() async throws -> [QuickSightClientTypes.ThemeVersionSummary] {
        return try await self.asyncCompactMap { item in item.themeVersionSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListTopicsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTopicsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTopicsOutput`
    public func listTopicsPaginated(input: ListTopicsInput) -> ClientRuntime.PaginatorSequence<ListTopicsInput, ListTopicsOutput> {
        return ClientRuntime.PaginatorSequence<ListTopicsInput, ListTopicsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTopics(input:))
    }
}

extension ListTopicsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicsInput {
        return ListTopicsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension QuickSightClient {
    /// Paginate over `[ListUserGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUserGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUserGroupsOutput`
    public func listUserGroupsPaginated(input: ListUserGroupsInput) -> ClientRuntime.PaginatorSequence<ListUserGroupsInput, ListUserGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListUserGroupsInput, ListUserGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUserGroups(input:))
    }
}

extension ListUserGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUserGroupsInput {
        return ListUserGroupsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == ListUserGroupsInput, OperationStackOutput == ListUserGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUserGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutput`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListUsersInput, OperationStackOutput == ListUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
    /// to access the nested member `[QuickSightClientTypes.User]`
    /// - Returns: `[QuickSightClientTypes.User]`
    public func userList() async throws -> [QuickSightClientTypes.User] {
        return try await self.asyncCompactMap { item in item.userList }
    }
}
extension QuickSightClient {
    /// Paginate over `[ListVPCConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVPCConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVPCConnectionsOutput`
    public func listVPCConnectionsPaginated(input: ListVPCConnectionsInput) -> ClientRuntime.PaginatorSequence<ListVPCConnectionsInput, ListVPCConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListVPCConnectionsInput, ListVPCConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listVPCConnections(input:))
    }
}

extension ListVPCConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVPCConnectionsInput {
        return ListVPCConnectionsInput(
            awsAccountId: self.awsAccountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension QuickSightClient {
    /// Paginate over `[SearchAnalysesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchAnalysesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchAnalysesOutput`
    public func searchAnalysesPaginated(input: SearchAnalysesInput) -> ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutput> {
        return ClientRuntime.PaginatorSequence<SearchAnalysesInput, SearchAnalysesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchAnalyses(input:))
    }
}

extension SearchAnalysesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchAnalysesInput {
        return SearchAnalysesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchAnalysesInput, OperationStackOutput == SearchAnalysesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchAnalysesPaginated`
    /// to access the nested member `[QuickSightClientTypes.AnalysisSummary]`
    /// - Returns: `[QuickSightClientTypes.AnalysisSummary]`
    public func analysisSummaryList() async throws -> [QuickSightClientTypes.AnalysisSummary] {
        return try await self.asyncCompactMap { item in item.analysisSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDashboardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDashboardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDashboardsOutput`
    public func searchDashboardsPaginated(input: SearchDashboardsInput) -> ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutput> {
        return ClientRuntime.PaginatorSequence<SearchDashboardsInput, SearchDashboardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchDashboards(input:))
    }
}

extension SearchDashboardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDashboardsInput {
        return SearchDashboardsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchDashboardsInput, OperationStackOutput == SearchDashboardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchDashboardsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DashboardSummary]`
    /// - Returns: `[QuickSightClientTypes.DashboardSummary]`
    public func dashboardSummaryList() async throws -> [QuickSightClientTypes.DashboardSummary] {
        return try await self.asyncCompactMap { item in item.dashboardSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSetsOutput`
    public func searchDataSetsPaginated(input: SearchDataSetsInput) -> ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutput> {
        return ClientRuntime.PaginatorSequence<SearchDataSetsInput, SearchDataSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchDataSets(input:))
    }
}

extension SearchDataSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSetsInput {
        return SearchDataSetsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchDataSetsInput, OperationStackOutput == SearchDataSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSetsPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSetSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSetSummary]`
    public func dataSetSummaries() async throws -> [QuickSightClientTypes.DataSetSummary] {
        return try await self.asyncCompactMap { item in item.dataSetSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchDataSourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchDataSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchDataSourcesOutput`
    public func searchDataSourcesPaginated(input: SearchDataSourcesInput) -> ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutput> {
        return ClientRuntime.PaginatorSequence<SearchDataSourcesInput, SearchDataSourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchDataSources(input:))
    }
}

extension SearchDataSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchDataSourcesInput {
        return SearchDataSourcesInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchDataSourcesInput, OperationStackOutput == SearchDataSourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchDataSourcesPaginated`
    /// to access the nested member `[QuickSightClientTypes.DataSourceSummary]`
    /// - Returns: `[QuickSightClientTypes.DataSourceSummary]`
    public func dataSourceSummaries() async throws -> [QuickSightClientTypes.DataSourceSummary] {
        return try await self.asyncCompactMap { item in item.dataSourceSummaries }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchFoldersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchFoldersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchFoldersOutput`
    public func searchFoldersPaginated(input: SearchFoldersInput) -> ClientRuntime.PaginatorSequence<SearchFoldersInput, SearchFoldersOutput> {
        return ClientRuntime.PaginatorSequence<SearchFoldersInput, SearchFoldersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchFolders(input:))
    }
}

extension SearchFoldersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchFoldersInput {
        return SearchFoldersInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchFoldersInput, OperationStackOutput == SearchFoldersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchFoldersPaginated`
    /// to access the nested member `[QuickSightClientTypes.FolderSummary]`
    /// - Returns: `[QuickSightClientTypes.FolderSummary]`
    public func folderSummaryList() async throws -> [QuickSightClientTypes.FolderSummary] {
        return try await self.asyncCompactMap { item in item.folderSummaryList }
    }
}
extension QuickSightClient {
    /// Paginate over `[SearchGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchGroupsOutput`
    public func searchGroupsPaginated(input: SearchGroupsInput) -> ClientRuntime.PaginatorSequence<SearchGroupsInput, SearchGroupsOutput> {
        return ClientRuntime.PaginatorSequence<SearchGroupsInput, SearchGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchGroups(input:))
    }
}

extension SearchGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchGroupsInput {
        return SearchGroupsInput(
            awsAccountId: self.awsAccountId,
            filters: self.filters,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == SearchGroupsInput, OperationStackOutput == SearchGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchGroupsPaginated`
    /// to access the nested member `[QuickSightClientTypes.Group]`
    /// - Returns: `[QuickSightClientTypes.Group]`
    public func groupList() async throws -> [QuickSightClientTypes.Group] {
        return try await self.asyncCompactMap { item in item.groupList }
    }
}
