//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.timestampWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have access to this item. The provided credentials couldn't be validated. You might not be authorized to carry out the request. Make sure that your account is authorized to use the Amazon QuickSight service, that your policies have the correct permissions, and that you are using the correct credentials.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    /// The Amazon QuickSight customizations associated with your Amazon Web Services account or a QuickSight namespace in a specific Amazon Web Services Region.
    public struct AccountCustomization: Swift.Sendable {
        /// The default email customization template.
        public var defaultEmailCustomizationTemplate: Swift.String?
        /// The default theme for this Amazon QuickSight subscription.
        public var defaultTheme: Swift.String?

        public init(
            defaultEmailCustomizationTemplate: Swift.String? = nil,
            defaultTheme: Swift.String? = nil
        )
        {
            self.defaultEmailCustomizationTemplate = defaultEmailCustomizationTemplate
            self.defaultTheme = defaultTheme
        }
    }
}

extension QuickSightClientTypes {

    public enum Edition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterprise
        case enterpriseAndQ
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [Edition] {
            return [
                .enterprise,
                .enterpriseAndQ,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .enterpriseAndQ: return "ENTERPRISE_AND_Q"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the following account information elements:
    ///
    /// * Your Amazon QuickSight account name.
    ///
    /// * The edition of Amazon QuickSight that your account is using.
    ///
    /// * The notification email address that is associated with the Amazon QuickSight account.
    ///
    /// * The authentication type of the Amazon QuickSight account.
    ///
    /// * The status of the Amazon QuickSight account's subscription.
    public struct AccountInfo: Swift.Sendable {
        /// The account name that you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It's unique over all of Amazon Web Services, and it appears only when users sign in.
        public var accountName: Swift.String?
        /// The status of your account subscription.
        public var accountSubscriptionStatus: Swift.String?
        /// The way that your Amazon QuickSight account is authenticated.
        public var authenticationType: Swift.String?
        /// The edition of your Amazon QuickSight account.
        public var edition: QuickSightClientTypes.Edition?
        /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public var iamIdentityCenterInstanceArn: Swift.String?
        /// The email address that will be used for Amazon QuickSight to send notifications regarding your Amazon Web Services account or Amazon QuickSight subscription.
        public var notificationEmail: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            accountSubscriptionStatus: Swift.String? = nil,
            authenticationType: Swift.String? = nil,
            edition: QuickSightClientTypes.Edition? = nil,
            iamIdentityCenterInstanceArn: Swift.String? = nil,
            notificationEmail: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountSubscriptionStatus = accountSubscriptionStatus
            self.authenticationType = authenticationType
            self.edition = edition
            self.iamIdentityCenterInstanceArn = iamIdentityCenterInstanceArn
            self.notificationEmail = notificationEmail
        }
    }
}

extension QuickSightClientTypes {

    /// The Amazon QuickSight settings associated with your Amazon Web Services account.
    public struct AccountSettings: Swift.Sendable {
        /// The "account name" you provided for the Amazon QuickSight subscription in your Amazon Web Services account. You create this name when you sign up for Amazon QuickSight. It is unique in all of Amazon Web Services and it appears only when users sign in.
        public var accountName: Swift.String?
        /// The default Amazon QuickSight namespace for your Amazon Web Services account.
        public var defaultNamespace: Swift.String?
        /// The edition of Amazon QuickSight that you're currently subscribed to: Enterprise edition or Standard edition.
        public var edition: QuickSightClientTypes.Edition?
        /// The main notification email for your Amazon QuickSight subscription.
        public var notificationEmail: Swift.String?
        /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account. For more information about turning on public sharing, see [UpdatePublicSharingSettings](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html).
        public var publicSharingEnabled: Swift.Bool
        /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubsctiption request. A False value will allow the ccount to be deleted.
        public var terminationProtectionEnabled: Swift.Bool

        public init(
            accountName: Swift.String? = nil,
            defaultNamespace: Swift.String? = nil,
            edition: QuickSightClientTypes.Edition? = nil,
            notificationEmail: Swift.String? = nil,
            publicSharingEnabled: Swift.Bool = false,
            terminationProtectionEnabled: Swift.Bool = false
        )
        {
            self.accountName = accountName
            self.defaultNamespace = defaultNamespace
            self.edition = edition
            self.notificationEmail = notificationEmail
            self.publicSharingEnabled = publicSharingEnabled
            self.terminationProtectionEnabled = terminationProtectionEnabled
        }
    }
}

extension QuickSightClientTypes {

    /// The active Identity and Access Management (IAM) policy assignment.
    public struct ActiveIAMPolicyAssignment: Swift.Sendable {
        /// A name for the IAM policy assignment.
        public var assignmentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource.
        public var policyArn: Swift.String?

        public init(
            assignmentName: Swift.String? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentName = assignmentName
            self.policyArn = policyArn
        }
    }
}

extension QuickSightClientTypes {

    public enum DashboardBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardBehavior] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An ad hoc (one-time) filtering option.
    public struct AdHocFilteringOption: Swift.Sendable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    public enum AggType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case column
        case count
        case custom
        case distinctCount
        case max
        case median
        case min
        case percentile
        case ptdAverage
        case ptdCount
        case ptdDistinctCount
        case ptdMax
        case ptdMin
        case ptdSum
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [AggType] {
            return [
                .average,
                .column,
                .count,
                .custom,
                .distinctCount,
                .max,
                .median,
                .min,
                .percentile,
                .ptdAverage,
                .ptdCount,
                .ptdDistinctCount,
                .ptdMax,
                .ptdMin,
                .ptdSum,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .column: return "COLUMN"
            case .count: return "COUNT"
            case .custom: return "CUSTOM"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .percentile: return "PERCENTILE"
            case .ptdAverage: return "PTD_AVERAGE"
            case .ptdCount: return "PTD_COUNT"
            case .ptdDistinctCount: return "PTD_DISTINCT_COUNT"
            case .ptdMax: return "PTD_MAX"
            case .ptdMin: return "PTD_MIN"
            case .ptdSum: return "PTD_SUM"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicTimeGranularity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case quarter
        case second
        case week
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicTimeGranularity] {
            return [
                .day,
                .hour,
                .minute,
                .month,
                .quarter,
                .second,
                .week,
                .year
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .quarter: return "QUARTER"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition of an Agg function.
    public struct AggFunction: Swift.Sendable {
        /// The aggregation of an Agg function.
        public var aggregation: QuickSightClientTypes.AggType?
        /// The aggregation parameters for an Agg function.
        public var aggregationFunctionParameters: [Swift.String: Swift.String]?
        /// The period of an Agg function.
        public var period: QuickSightClientTypes.TopicTimeGranularity?
        /// The period field for an Agg function.
        public var periodField: Swift.String?

        public init(
            aggregation: QuickSightClientTypes.AggType? = nil,
            aggregationFunctionParameters: [Swift.String: Swift.String]? = nil,
            period: QuickSightClientTypes.TopicTimeGranularity? = nil,
            periodField: Swift.String? = nil
        )
        {
            self.aggregation = aggregation
            self.aggregationFunctionParameters = aggregationFunctionParameters
            self.period = period
            self.periodField = periodField
        }
    }
}

extension QuickSightClientTypes {

    public enum SimpleAttributeAggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case uniqueValue
        case sdkUnknown(Swift.String)

        public static var allCases: [SimpleAttributeAggregationFunction] {
            return [
                .uniqueValue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .uniqueValue: return "UNIQUE_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Aggregation for attributes.
    public struct AttributeAggregationFunction: Swift.Sendable {
        /// The built-in aggregation functions for attributes.
        ///
        /// * UNIQUE_VALUE: Returns the unique value for a field, aggregated by the dimension fields.
        public var simpleAttributeAggregation: QuickSightClientTypes.SimpleAttributeAggregationFunction?
        /// Used by the UNIQUE_VALUE aggregation function. If there are multiple values for the field used by the aggregation, the value for this property will be returned instead. Defaults to '*'.
        public var valueForMultipleValues: Swift.String?

        public init(
            simpleAttributeAggregation: QuickSightClientTypes.SimpleAttributeAggregationFunction? = nil,
            valueForMultipleValues: Swift.String? = nil
        )
        {
            self.simpleAttributeAggregation = simpleAttributeAggregation
            self.valueForMultipleValues = valueForMultipleValues
        }
    }
}

extension QuickSightClientTypes {

    public enum CategoricalAggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case count
        case distinctCount
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoricalAggregationFunction] {
            return [
                .count,
                .distinctCount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum DateAggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case count
        case distinctCount
        case max
        case min
        case sdkUnknown(Swift.String)

        public static var allCases: [DateAggregationFunction] {
            return [
                .count,
                .distinctCount,
                .max,
                .min
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .min: return "MIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An aggregation based on the percentile of values in a dimension or measure.
    public struct PercentileAggregation: Swift.Sendable {
        /// The percentile value. This value can be any numeric constant 0â€“100. A percentile value of 50 computes the median value of the measure.
        public var percentileValue: Swift.Double?

        public init(
            percentileValue: Swift.Double? = nil
        )
        {
            self.percentileValue = percentileValue
        }
    }
}

extension QuickSightClientTypes {

    public enum SimpleNumericalAggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case distinctCount
        case max
        case median
        case min
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [SimpleNumericalAggregationFunction] {
            return [
                .average,
                .count,
                .distinctCount,
                .max,
                .median,
                .min,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Aggregation for numerical values.
    public struct NumericalAggregationFunction: Swift.Sendable {
        /// An aggregation based on the percentile of values in a dimension or measure.
        public var percentileAggregation: QuickSightClientTypes.PercentileAggregation?
        /// Built-in aggregation functions for numerical values.
        ///
        /// * SUM: The sum of a dimension or measure.
        ///
        /// * AVERAGE: The average of a dimension or measure.
        ///
        /// * MIN: The minimum value of a dimension or measure.
        ///
        /// * MAX: The maximum value of a dimension or measure.
        ///
        /// * COUNT: The count of a dimension or measure.
        ///
        /// * DISTINCT_COUNT: The count of distinct values in a dimension or measure.
        ///
        /// * VAR: The variance of a dimension or measure.
        ///
        /// * VARP: The partitioned variance of a dimension or measure.
        ///
        /// * STDEV: The standard deviation of a dimension or measure.
        ///
        /// * STDEVP: The partitioned standard deviation of a dimension or measure.
        ///
        /// * MEDIAN: The median value of a dimension or measure.
        public var simpleNumericalAggregation: QuickSightClientTypes.SimpleNumericalAggregationFunction?

        public init(
            percentileAggregation: QuickSightClientTypes.PercentileAggregation? = nil,
            simpleNumericalAggregation: QuickSightClientTypes.SimpleNumericalAggregationFunction? = nil
        )
        {
            self.percentileAggregation = percentileAggregation
            self.simpleNumericalAggregation = simpleNumericalAggregation
        }
    }
}

extension QuickSightClientTypes {

    /// An aggregation function aggregates values from a dimension or measure. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AggregationFunction: Swift.Sendable {
        /// Aggregation for attributes.
        public var attributeAggregationFunction: QuickSightClientTypes.AttributeAggregationFunction?
        /// Aggregation for categorical values.
        ///
        /// * COUNT: Aggregate by the total number of values, including duplicates.
        ///
        /// * DISTINCT_COUNT: Aggregate by the total number of distinct values.
        public var categoricalAggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction?
        /// Aggregation for date values.
        ///
        /// * COUNT: Aggregate by the total number of values, including duplicates.
        ///
        /// * DISTINCT_COUNT: Aggregate by the total number of distinct values.
        ///
        /// * MIN: Select the smallest date value.
        ///
        /// * MAX: Select the largest date value.
        public var dateAggregationFunction: QuickSightClientTypes.DateAggregationFunction?
        /// Aggregation for numerical values.
        public var numericalAggregationFunction: QuickSightClientTypes.NumericalAggregationFunction?

        public init(
            attributeAggregationFunction: QuickSightClientTypes.AttributeAggregationFunction? = nil,
            categoricalAggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction? = nil,
            dateAggregationFunction: QuickSightClientTypes.DateAggregationFunction? = nil,
            numericalAggregationFunction: QuickSightClientTypes.NumericalAggregationFunction? = nil
        )
        {
            self.attributeAggregationFunction = attributeAggregationFunction
            self.categoricalAggregationFunction = categoricalAggregationFunction
            self.dateAggregationFunction = dateAggregationFunction
            self.numericalAggregationFunction = numericalAggregationFunction
        }
    }
}

extension QuickSightClientTypes {

    public enum TimeGranularity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case millisecond
        case minute
        case month
        case quarter
        case second
        case week
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeGranularity] {
            return [
                .day,
                .hour,
                .millisecond,
                .minute,
                .month,
                .quarter,
                .second,
                .week,
                .year
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .millisecond: return "MILLISECOND"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .quarter: return "QUARTER"
            case .second: return "SECOND"
            case .week: return "WEEK"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition of an AggregationPartitionBy.
    public struct AggregationPartitionBy: Swift.Sendable {
        /// The field Name for an AggregationPartitionBy.
        public var fieldName: Swift.String?
        /// The TimeGranularity for an AggregationPartitionBy.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            fieldName: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.fieldName = fieldName
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// A column of a data set.
    public struct ColumnIdentifier: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The data set that the column belongs to.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            dataSetIdentifier: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.dataSetIdentifier = dataSetIdentifier
        }
    }
}

extension QuickSightClientTypes {

    public enum SortDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration options to sort aggregated values.
    public struct AggregationSortConfiguration: Swift.Sendable {
        /// The function that aggregates the values in Column.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that determines the sort order of aggregated values.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The sort direction of values.
        ///
        /// * ASC: Sort in ascending order.
        ///
        /// * DESC: Sort in descending order.
        /// This member is required.
        public var sortDirection: QuickSightClientTypes.SortDirection?

        public init(
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            sortDirection: QuickSightClientTypes.SortDirection? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.sortDirection = sortDirection
        }
    }
}

extension QuickSightClientTypes {

    /// An empty object that represents that the AllSheets option is the chosen value for the FilterScopeConfiguration parameter. This structure applies the filter to all visuals on all sheets of an Analysis, Dashboard, or Template. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AllSheetsFilterScopeConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension QuickSightClientTypes {

    /// The parameters for OpenSearch.
    public struct AmazonElasticsearchParameters: Swift.Sendable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init(
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for OpenSearch.
    public struct AmazonOpenSearchParameters: Swift.Sendable {
        /// The OpenSearch domain.
        /// This member is required.
        public var domain: Swift.String?

        public init(
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }
}

extension QuickSightClientTypes {

    public enum AnalysisErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An object, structure, or sub-structure of an analysis, template, or dashboard.
    public struct Entity: Swift.Sendable {
        /// The hierarchical path of the entity within the analysis, template, or dashboard definition tree.
        public var path: Swift.String?

        public init(
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }
}

extension QuickSightClientTypes {

    /// Analysis error.
    public struct AnalysisError: Swift.Sendable {
        /// The message associated with the analysis error.
        public var message: Swift.String?
        /// The type of the analysis error.
        public var type: QuickSightClientTypes.AnalysisErrorType?
        /// Lists the violated entities that caused the analysis error
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.AnalysisErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }
}

extension QuickSightClientTypes {

    /// A sheet, which is an object that contains a set of visuals that are viewed together on one page in Amazon QuickSight. Every analysis and dashboard contains at least one sheet. Each sheet contains at least one visualization widget, for example a chart, pivot table, or narrative insight. Sheets can be associated with other components, such as controls, filters, and so on.
    public struct Sheet: Swift.Sendable {
        /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The unique identifier associated with a sheet.
        public var sheetId: Swift.String?

        public init(
            name: Swift.String? = nil,
            sheetId: Swift.String? = nil
        )
        {
            self.name = name
            self.sheetId = sheetId
        }
    }
}

extension QuickSightClientTypes {

    public enum ResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case creationSuccessful
        case deleted
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .creationSuccessful,
                .deleted,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .creationSuccessful: return "CREATION_SUCCESSFUL"
            case .deleted: return "DELETED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Metadata structure for an analysis in Amazon QuickSight
    public struct Analysis: Swift.Sendable {
        /// The ID of the analysis.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) of the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: Foundation.Date?
        /// The ARNs of the datasets of the analysis.
        public var dataSetArns: [Swift.String]?
        /// Errors associated with the analysis.
        public var errors: [QuickSightClientTypes.AnalysisError]?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The descriptive name of the analysis.
        public var name: Swift.String?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Status associated with the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme of the analysis.
        public var themeArn: Swift.String?

        public init(
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            errors: [QuickSightClientTypes.AnalysisError]? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.errors = errors
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sheets = sheets
            self.status = status
            self.themeArn = themeArn
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the sizing of the canvas used in a free-form layout.
    public struct FreeFormLayoutScreenCanvasSizeOptions: Swift.Sendable {
        /// The width that the view port will be optimized for when the layout renders.
        /// This member is required.
        public var optimizedViewPortWidth: Swift.String?

        public init(
            optimizedViewPortWidth: Swift.String? = nil
        )
        {
            self.optimizedViewPortWidth = optimizedViewPortWidth
        }
    }
}

extension QuickSightClientTypes {

    /// Configuration options for the canvas of a free-form layout.
    public struct FreeFormLayoutCanvasSizeOptions: Swift.Sendable {
        /// The options that determine the sizing of the canvas used in a free-form layout.
        public var screenCanvasSizeOptions: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions?

        public init(
            screenCanvasSizeOptions: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions? = nil
        )
        {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default settings of a free-form layout configuration.
    public struct DefaultFreeFormLayoutConfiguration: Swift.Sendable {
        /// Determines the screen canvas size options for a free-form layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions?

        public init(
            canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum ResizeOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixed
        case responsive
        case sdkUnknown(Swift.String)

        public static var allCases: [ResizeOption] {
            return [
                .fixed,
                .responsive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixed: return "FIXED"
            case .responsive: return "RESPONSIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the sizing of the canvas used in a grid layout.
    public struct GridLayoutScreenCanvasSizeOptions: Swift.Sendable {
        /// The width that the view port will be optimized for when the layout renders.
        public var optimizedViewPortWidth: Swift.String?
        /// This value determines the layout behavior when the viewport is resized.
        ///
        /// * FIXED: A fixed width will be used when optimizing the layout. In the Amazon QuickSight console, this option is called Classic.
        ///
        /// * RESPONSIVE: The width of the canvas will be responsive and optimized to the view port. In the Amazon QuickSight console, this option is called Tiled.
        /// This member is required.
        public var resizeOption: QuickSightClientTypes.ResizeOption?

        public init(
            optimizedViewPortWidth: Swift.String? = nil,
            resizeOption: QuickSightClientTypes.ResizeOption? = nil
        )
        {
            self.optimizedViewPortWidth = optimizedViewPortWidth
            self.resizeOption = resizeOption
        }
    }
}

extension QuickSightClientTypes {

    /// Configuration options for the canvas of a grid layout.
    public struct GridLayoutCanvasSizeOptions: Swift.Sendable {
        /// The options that determine the sizing of the canvas used in a grid layout.
        public var screenCanvasSizeOptions: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions?

        public init(
            screenCanvasSizeOptions: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions? = nil
        )
        {
            self.screenCanvasSizeOptions = screenCanvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default settings for a grid layout configuration.
    public struct DefaultGridLayoutConfiguration: Swift.Sendable {
        /// Determines the screen canvas size options for a grid layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions?

        public init(
            canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default settings for interactive layout configuration.
    public struct DefaultInteractiveLayoutConfiguration: Swift.Sendable {
        /// The options that determine the default settings of a free-form layout configuration.
        public var freeForm: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration?
        /// The options that determine the default settings for a grid layout configuration.
        public var grid: QuickSightClientTypes.DefaultGridLayoutConfiguration?

        public init(
            freeForm: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration? = nil,
            grid: QuickSightClientTypes.DefaultGridLayoutConfiguration? = nil
        )
        {
            self.freeForm = freeForm
            self.grid = grid
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of spacing (often a margin or padding).
    public struct Spacing: Swift.Sendable {
        /// Define the bottom spacing.
        public var bottom: Swift.String?
        /// Define the left spacing.
        public var `left`: Swift.String?
        /// Define the right spacing.
        public var `right`: Swift.String?
        /// Define the top spacing.
        public var top: Swift.String?

        public init(
            bottom: Swift.String? = nil,
            `left`: Swift.String? = nil,
            `right`: Swift.String? = nil,
            top: Swift.String? = nil
        )
        {
            self.bottom = bottom
            self.`left` = `left`
            self.`right` = `right`
            self.top = top
        }
    }
}

extension QuickSightClientTypes {

    public enum PaperOrientation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case landscape
        case portrait
        case sdkUnknown(Swift.String)

        public static var allCases: [PaperOrientation] {
            return [
                .landscape,
                .portrait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .landscape: return "LANDSCAPE"
            case .portrait: return "PORTRAIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum PaperSize: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case a0
        case a1
        case a2
        case a3
        case a4
        case a5
        case jisB4
        case jisB5
        case usLegal
        case usLetter
        case usTabloidLedger
        case sdkUnknown(Swift.String)

        public static var allCases: [PaperSize] {
            return [
                .a0,
                .a1,
                .a2,
                .a3,
                .a4,
                .a5,
                .jisB4,
                .jisB5,
                .usLegal,
                .usLetter,
                .usTabloidLedger
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .a0: return "A0"
            case .a1: return "A1"
            case .a2: return "A2"
            case .a3: return "A3"
            case .a4: return "A4"
            case .a5: return "A5"
            case .jisB4: return "JIS_B4"
            case .jisB5: return "JIS_B5"
            case .usLegal: return "US_LEGAL"
            case .usLetter: return "US_LETTER"
            case .usTabloidLedger: return "US_TABLOID_LEDGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options for a paper canvas of a section-based layout.
    public struct SectionBasedLayoutPaperCanvasSizeOptions: Swift.Sendable {
        /// Defines the spacing between the canvas content and the top, bottom, left, and right edges.
        public var paperMargin: QuickSightClientTypes.Spacing?
        /// The paper orientation that is used to define canvas dimensions. Choose one of the following options:
        ///
        /// * PORTRAIT
        ///
        /// * LANDSCAPE
        public var paperOrientation: QuickSightClientTypes.PaperOrientation?
        /// The paper size that is used to define canvas dimensions.
        public var paperSize: QuickSightClientTypes.PaperSize?

        public init(
            paperMargin: QuickSightClientTypes.Spacing? = nil,
            paperOrientation: QuickSightClientTypes.PaperOrientation? = nil,
            paperSize: QuickSightClientTypes.PaperSize? = nil
        )
        {
            self.paperMargin = paperMargin
            self.paperOrientation = paperOrientation
            self.paperSize = paperSize
        }
    }
}

extension QuickSightClientTypes {

    /// The options for the canvas of a section-based layout.
    public struct SectionBasedLayoutCanvasSizeOptions: Swift.Sendable {
        /// The options for a paper canvas of a section-based layout.
        public var paperCanvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions?

        public init(
            paperCanvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions? = nil
        )
        {
            self.paperCanvasSizeOptions = paperCanvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default settings for a section-based layout configuration.
    public struct DefaultSectionBasedLayoutConfiguration: Swift.Sendable {
        /// Determines the screen canvas size options for a section-based layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions?

        public init(
            canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default settings for a paginated layout configuration.
    public struct DefaultPaginatedLayoutConfiguration: Swift.Sendable {
        /// The options that determine the default settings for a section-based layout configuration.
        public var sectionBased: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration?

        public init(
            sectionBased: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration? = nil
        )
        {
            self.sectionBased = sectionBased
        }
    }
}

extension QuickSightClientTypes {

    public enum SheetContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interactive
        case paginated
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetContentType] {
            return [
                .interactive,
                .paginated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .paginated: return "PAGINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for default new sheet settings.
    public struct DefaultNewSheetConfiguration: Swift.Sendable {
        /// The options that determine the default settings for interactive layout configuration.
        public var interactiveLayoutConfiguration: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration?
        /// The options that determine the default settings for a paginated layout configuration.
        public var paginatedLayoutConfiguration: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration?
        /// The option that determines the sheet content type.
        public var sheetContentType: QuickSightClientTypes.SheetContentType?

        public init(
            interactiveLayoutConfiguration: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration? = nil,
            paginatedLayoutConfiguration: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration? = nil,
            sheetContentType: QuickSightClientTypes.SheetContentType? = nil
        )
        {
            self.interactiveLayoutConfiguration = interactiveLayoutConfiguration
            self.paginatedLayoutConfiguration = paginatedLayoutConfiguration
            self.sheetContentType = sheetContentType
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for default analysis settings.
    public struct AnalysisDefaults: Swift.Sendable {
        /// The configuration for default new sheet settings.
        /// This member is required.
        public var defaultNewSheetConfiguration: QuickSightClientTypes.DefaultNewSheetConfiguration?

        public init(
            defaultNewSheetConfiguration: QuickSightClientTypes.DefaultNewSheetConfiguration? = nil
        )
        {
            self.defaultNewSheetConfiguration = defaultNewSheetConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The calculated field of an analysis.
    public struct CalculatedField: Swift.Sendable {
        /// The data set that is used in this calculated field.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The expression of the calculated field.
        /// This member is required.
        public var expression: Swift.String?
        /// The name of the calculated field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            dataSetIdentifier: Swift.String? = nil,
            expression: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
            self.name = name
        }
    }
}

extension QuickSightClientTypes.CalculatedField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedField(dataSetIdentifier: \(Swift.String(describing: dataSetIdentifier)), name: \(Swift.String(describing: name)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum SpecialValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case empty
        case null
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [SpecialValue] {
            return [
                .empty,
                .null,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .empty: return "EMPTY"
            case .null: return "NULL"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the color that's applied to a particular data value in a column.
    public struct CustomColor: Swift.Sendable {
        /// The color that is applied to the data value.
        /// This member is required.
        public var color: Swift.String?
        /// The data value that the color is applied to.
        public var fieldValue: Swift.String?
        /// The value of a special data value.
        public var specialValue: QuickSightClientTypes.SpecialValue?

        public init(
            color: Swift.String? = nil,
            fieldValue: Swift.String? = nil,
            specialValue: QuickSightClientTypes.SpecialValue? = nil
        )
        {
            self.color = color
            self.fieldValue = fieldValue
            self.specialValue = specialValue
        }
    }
}

extension QuickSightClientTypes.CustomColor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomColor(color: \(Swift.String(describing: color)), specialValue: \(Swift.String(describing: specialValue)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The color configurations for a column.
    public struct ColorsConfiguration: Swift.Sendable {
        /// A list of up to 50 custom colors.
        public var customColors: [QuickSightClientTypes.CustomColor]?

        public init(
            customColors: [QuickSightClientTypes.CustomColor]? = nil
        )
        {
            self.customColors = customColors
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the null value format configuration.
    public struct NullValueFormatConfiguration: Swift.Sendable {
        /// Determines the null string of null values.
        /// This member is required.
        public var nullString: Swift.String?

        public init(
            nullString: Swift.String? = nil
        )
        {
            self.nullString = nullString
        }
    }
}

extension QuickSightClientTypes.NullValueFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NullValueFormatConfiguration(nullString: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The option that determines the decimal places configuration.
    public struct DecimalPlacesConfiguration: Swift.Sendable {
        /// The values of the decimal places.
        /// This member is required.
        public var decimalPlaces: Swift.Int?

        public init(
            decimalPlaces: Swift.Int? = nil
        )
        {
            self.decimalPlaces = decimalPlaces
        }
    }
}

extension QuickSightClientTypes {

    public enum NegativeValueDisplayMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case negative
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [NegativeValueDisplayMode] {
            return [
                .negative,
                .positive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case .positive: return "POSITIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the negative value configuration.
    public struct NegativeValueConfiguration: Swift.Sendable {
        /// Determines the display mode of the negative value configuration.
        /// This member is required.
        public var displayMode: QuickSightClientTypes.NegativeValueDisplayMode?

        public init(
            displayMode: QuickSightClientTypes.NegativeValueDisplayMode? = nil
        )
        {
            self.displayMode = displayMode
        }
    }
}

extension QuickSightClientTypes {

    public enum NumberScale: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case billions
        case millions
        case `none`
        case thousands
        case trillions
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberScale] {
            return [
                .auto,
                .billions,
                .millions,
                .none,
                .thousands,
                .trillions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .billions: return "BILLIONS"
            case .millions: return "MILLIONS"
            case .none: return "NONE"
            case .thousands: return "THOUSANDS"
            case .trillions: return "TRILLIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum NumericSeparatorSymbol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comma
        case dot
        case space
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericSeparatorSymbol] {
            return [
                .comma,
                .dot,
                .space
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comma: return "COMMA"
            case .dot: return "DOT"
            case .space: return "SPACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum Visibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hidden
        case visible
        case sdkUnknown(Swift.String)

        public static var allCases: [Visibility] {
            return [
                .hidden,
                .visible
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hidden: return "HIDDEN"
            case .visible: return "VISIBLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the thousands separator configuration.
    public struct ThousandSeparatorOptions: Swift.Sendable {
        /// Determines the thousands separator symbol.
        public var symbol: QuickSightClientTypes.NumericSeparatorSymbol?
        /// Determines the visibility of the thousands separator.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            symbol: QuickSightClientTypes.NumericSeparatorSymbol? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.symbol = symbol
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the numeric separator configuration.
    public struct NumericSeparatorConfiguration: Swift.Sendable {
        /// Determines the decimal separator.
        public var decimalSeparator: QuickSightClientTypes.NumericSeparatorSymbol?
        /// The options that determine the thousands separator configuration.
        public var thousandsSeparator: QuickSightClientTypes.ThousandSeparatorOptions?

        public init(
            decimalSeparator: QuickSightClientTypes.NumericSeparatorSymbol? = nil,
            thousandsSeparator: QuickSightClientTypes.ThousandSeparatorOptions? = nil
        )
        {
            self.decimalSeparator = decimalSeparator
            self.thousandsSeparator = thousandsSeparator
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the currency display format configuration.
    public struct CurrencyDisplayFormatConfiguration: Swift.Sendable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the number scale value for the currency format.
        public var numberScale: QuickSightClientTypes.NumberScale?
        /// Determines the prefix value of the currency format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the currency format.
        public var suffix: Swift.String?
        /// Determines the symbol for the currency format.
        public var symbol: Swift.String?

        public init(
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numberScale: QuickSightClientTypes.NumberScale? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil,
            symbol: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
            self.symbol = symbol
        }
    }
}

extension QuickSightClientTypes.CurrencyDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CurrencyDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), numberScale: \(Swift.String(describing: numberScale)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), symbol: \(Swift.String(describing: symbol)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The options that determine the number display format configuration.
    public struct NumberDisplayFormatConfiguration: Swift.Sendable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the number scale value of the number format.
        public var numberScale: QuickSightClientTypes.NumberScale?
        /// Determines the prefix value of the number format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the number format.
        public var suffix: Swift.String?

        public init(
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numberScale: QuickSightClientTypes.NumberScale? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numberScale = numberScale
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }
    }
}

extension QuickSightClientTypes.NumberDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NumberDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), numberScale: \(Swift.String(describing: numberScale)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The options that determine the percentage display format configuration.
    public struct PercentageDisplayFormatConfiguration: Swift.Sendable {
        /// The option that determines the decimal places configuration.
        public var decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration?
        /// The options that determine the negative value configuration.
        public var negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// Determines the prefix value of the percentage format.
        public var `prefix`: Swift.String?
        /// The options that determine the numeric separator configuration.
        public var separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration?
        /// Determines the suffix value of the percentage format.
        public var suffix: Swift.String?

        public init(
            decimalPlacesConfiguration: QuickSightClientTypes.DecimalPlacesConfiguration? = nil,
            negativeValueConfiguration: QuickSightClientTypes.NegativeValueConfiguration? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            `prefix`: Swift.String? = nil,
            separatorConfiguration: QuickSightClientTypes.NumericSeparatorConfiguration? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.decimalPlacesConfiguration = decimalPlacesConfiguration
            self.negativeValueConfiguration = negativeValueConfiguration
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.`prefix` = `prefix`
            self.separatorConfiguration = separatorConfiguration
            self.suffix = suffix
        }
    }
}

extension QuickSightClientTypes.PercentageDisplayFormatConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PercentageDisplayFormatConfiguration(decimalPlacesConfiguration: \(Swift.String(describing: decimalPlacesConfiguration)), negativeValueConfiguration: \(Swift.String(describing: negativeValueConfiguration)), nullValueFormatConfiguration: \(Swift.String(describing: nullValueFormatConfiguration)), separatorConfiguration: \(Swift.String(describing: separatorConfiguration)), prefix: \"CONTENT_REDACTED\", suffix: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The options that determine the numeric format configuration. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct NumericFormatConfiguration: Swift.Sendable {
        /// The options that determine the currency display format configuration.
        public var currencyDisplayFormatConfiguration: QuickSightClientTypes.CurrencyDisplayFormatConfiguration?
        /// The options that determine the number display format configuration.
        public var numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration?
        /// The options that determine the percentage display format configuration.
        public var percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration?

        public init(
            currencyDisplayFormatConfiguration: QuickSightClientTypes.CurrencyDisplayFormatConfiguration? = nil,
            numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration? = nil,
            percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration? = nil
        )
        {
            self.currencyDisplayFormatConfiguration = currencyDisplayFormatConfiguration
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// Formatting configuration for DateTime fields.
    public struct DateTimeFormatConfiguration: Swift.Sendable {
        /// Determines the DateTime format.
        public var dateTimeFormat: Swift.String?
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// The formatting configuration for numeric DateTime fields.
        public var numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init(
            dateTimeFormat: Swift.String? = nil,
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.dateTimeFormat = dateTimeFormat
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// Formatting configuration for number fields.
    public struct NumberFormatConfiguration: Swift.Sendable {
        /// The options that determine the numeric format configuration.
        public var formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init(
            formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.formatConfiguration = formatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// Formatting configuration for string fields.
    public struct StringFormatConfiguration: Swift.Sendable {
        /// The options that determine the null value format configuration.
        public var nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration?
        /// The formatting configuration for numeric strings.
        public var numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?

        public init(
            nullValueFormatConfiguration: QuickSightClientTypes.NullValueFormatConfiguration? = nil,
            numericFormatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil
        )
        {
            self.nullValueFormatConfiguration = nullValueFormatConfiguration
            self.numericFormatConfiguration = numericFormatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The formatting configuration for all types of field.
    public struct FormatConfiguration: Swift.Sendable {
        /// Formatting configuration for DateTime fields.
        public var dateTimeFormatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?
        /// Formatting configuration for number fields.
        public var numberFormatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?
        /// Formatting configuration for string fields.
        public var stringFormatConfiguration: QuickSightClientTypes.StringFormatConfiguration?

        public init(
            dateTimeFormatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil,
            numberFormatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil,
            stringFormatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil
        )
        {
            self.dateTimeFormatConfiguration = dateTimeFormatConfiguration
            self.numberFormatConfiguration = numberFormatConfiguration
            self.stringFormatConfiguration = stringFormatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    public enum ColumnRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dimension
        case measure
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnRole] {
            return [
                .dimension,
                .measure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dimension: return "DIMENSION"
            case .measure: return "MEASURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The general configuration of a column.
    public struct ColumnConfiguration: Swift.Sendable {
        /// The color configurations of the column.
        public var colorsConfiguration: QuickSightClientTypes.ColorsConfiguration?
        /// The column.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The format configuration of a column.
        public var formatConfiguration: QuickSightClientTypes.FormatConfiguration?
        /// The role of the column.
        public var role: QuickSightClientTypes.ColumnRole?

        public init(
            colorsConfiguration: QuickSightClientTypes.ColorsConfiguration? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            formatConfiguration: QuickSightClientTypes.FormatConfiguration? = nil,
            role: QuickSightClientTypes.ColumnRole? = nil
        )
        {
            self.colorsConfiguration = colorsConfiguration
            self.column = column
            self.formatConfiguration = formatConfiguration
            self.role = role
        }
    }
}

extension QuickSightClientTypes {

    /// A data set.
    public struct DataSetIdentifierDeclaration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the data set.
        /// This member is required.
        public var dataSetArn: Swift.String?
        /// The identifier of the data set, typically the data set's name.
        /// This member is required.
        public var identifier: Swift.String?

        public init(
            dataSetArn: Swift.String? = nil,
            identifier: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.identifier = identifier
        }
    }
}

extension QuickSightClientTypes {

    public enum CrossDatasetTypes: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allDatasets
        case singleDataset
        case sdkUnknown(Swift.String)

        public static var allCases: [CrossDatasetTypes] {
            return [
                .allDatasets,
                .singleDataset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allDatasets: return "ALL_DATASETS"
            case .singleDataset: return "SINGLE_DATASET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum CategoryFilterMatchOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case doesNotContain
        case doesNotEqual
        case endsWith
        case equals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterMatchOperator] {
            return [
                .contains,
                .doesNotContain,
                .doesNotEqual,
                .endsWith,
                .equals,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .doesNotContain: return "DOES_NOT_CONTAIN"
            case .doesNotEqual: return "DOES_NOT_EQUAL"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum FilterNullOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allValues
        case nonNullsOnly
        case nullsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterNullOption] {
            return [
                .allValues,
                .nonNullsOnly,
                .nullsOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allValues: return "ALL_VALUES"
            case .nonNullsOnly: return "NON_NULLS_ONLY"
            case .nullsOnly: return "NULLS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum CategoryFilterSelectAllOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case filterAllValues
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterSelectAllOptions] {
            return [
                .filterAllValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .filterAllValues: return "FILTER_ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A custom filter that filters based on a single value. This filter can be partially matched.
    public struct CustomFilterConfiguration: Swift.Sendable {
        /// The category value for the filter. This field is mutually exclusive to ParameterName.
        public var categoryValue: Swift.String?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to CategoryValue.
        public var parameterName: Swift.String?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init(
            categoryValue: Swift.String? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValue = categoryValue
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A list of custom filter values.
    public struct CustomFilterListConfiguration: Swift.Sendable {
        /// The list of category values for the filter.
        public var categoryValues: [Swift.String]?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init(
            categoryValues: [Swift.String]? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A list of filter configurations.
    public struct FilterListConfiguration: Swift.Sendable {
        /// The list of category values for the filter.
        public var categoryValues: [Swift.String]?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions?

        public init(
            categoryValues: [Swift.String]? = nil,
            matchOperator: QuickSightClientTypes.CategoryFilterMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            selectAllOptions: QuickSightClientTypes.CategoryFilterSelectAllOptions? = nil
        )
        {
            self.categoryValues = categoryValues
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.selectAllOptions = selectAllOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a CategoryFilter. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CategoryFilterConfiguration: Swift.Sendable {
        /// A custom filter that filters based on a single value. This filter can be partially matched.
        public var customFilterConfiguration: QuickSightClientTypes.CustomFilterConfiguration?
        /// A list of custom filter values. In the Amazon QuickSight console, this filter type is called a custom filter list.
        public var customFilterListConfiguration: QuickSightClientTypes.CustomFilterListConfiguration?
        /// A list of filter configurations. In the Amazon QuickSight console, this filter type is called a filter list.
        public var filterListConfiguration: QuickSightClientTypes.FilterListConfiguration?

        public init(
            customFilterConfiguration: QuickSightClientTypes.CustomFilterConfiguration? = nil,
            customFilterListConfiguration: QuickSightClientTypes.CustomFilterListConfiguration? = nil,
            filterListConfiguration: QuickSightClientTypes.FilterListConfiguration? = nil
        )
        {
            self.customFilterConfiguration = customFilterConfiguration
            self.customFilterListConfiguration = customFilterListConfiguration
            self.filterListConfiguration = filterListConfiguration
        }
    }
}

extension QuickSightClientTypes {

    public enum CommitMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [CommitMode] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display info icons for filters and parameters.
    public struct SheetControlInfoIconLabelOptions: Swift.Sendable {
        /// The text content of info icon.
        public var infoIconText: Swift.String?
        /// The visibility configuration of info icon label options.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            infoIconText: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.infoIconText = infoIconText
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum FontDecoration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case underline
        case sdkUnknown(Swift.String)

        public static var allCases: [FontDecoration] {
            return [
                .none,
                .underline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .underline: return "UNDERLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum RelativeFontSize: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case extraLarge
        case extraSmall
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeFontSize] {
            return [
                .extraLarge,
                .extraSmall,
                .large,
                .medium,
                .small
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .extraLarge: return "EXTRA_LARGE"
            case .extraSmall: return "EXTRA_SMALL"
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the text display size.
    public struct FontSize: Swift.Sendable {
        /// The lexical name for the text size, proportional to its surrounding context.
        public var relative: QuickSightClientTypes.RelativeFontSize?

        public init(
            relative: QuickSightClientTypes.RelativeFontSize? = nil
        )
        {
            self.relative = relative
        }
    }
}

extension QuickSightClientTypes {

    public enum FontStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case italic
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [FontStyle] {
            return [
                .italic,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .italic: return "ITALIC"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum FontWeightName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bold
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [FontWeightName] {
            return [
                .bold,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bold: return "BOLD"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the text display weight, or boldness.
    public struct FontWeight: Swift.Sendable {
        /// The lexical name for the level of boldness of the text display.
        public var name: QuickSightClientTypes.FontWeightName?

        public init(
            name: QuickSightClientTypes.FontWeightName? = nil
        )
        {
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// Configures the display properties of the given text.
    public struct FontConfiguration: Swift.Sendable {
        /// Determines the color of the text.
        public var fontColor: Swift.String?
        /// Determines the appearance of decorative lines on the text.
        public var fontDecoration: QuickSightClientTypes.FontDecoration?
        /// The option that determines the text display size.
        public var fontSize: QuickSightClientTypes.FontSize?
        /// Determines the text display face that is inherited by the given font family.
        public var fontStyle: QuickSightClientTypes.FontStyle?
        /// The option that determines the text display weight, or boldness.
        public var fontWeight: QuickSightClientTypes.FontWeight?

        public init(
            fontColor: Swift.String? = nil,
            fontDecoration: QuickSightClientTypes.FontDecoration? = nil,
            fontSize: QuickSightClientTypes.FontSize? = nil,
            fontStyle: QuickSightClientTypes.FontStyle? = nil,
            fontWeight: QuickSightClientTypes.FontWeight? = nil
        )
        {
            self.fontColor = fontColor
            self.fontDecoration = fontDecoration
            self.fontSize = fontSize
            self.fontStyle = fontStyle
            self.fontWeight = fontWeight
        }
    }
}

extension QuickSightClientTypes {

    /// The share label options for the labels.
    public struct LabelOptions: Swift.Sendable {
        /// The text for the label.
        public var customLabel: Swift.String?
        /// The font configuration of the label.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines whether or not the label is visible.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            customLabel: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct DateTimePickerControlDisplayOptions: Swift.Sendable {
        /// The date icon visibility of the DateTimePickerControlDisplayOptions.
        public var dateIconVisibility: QuickSightClientTypes.Visibility?
        /// Customize how dates are formatted in controls.
        public var dateTimeFormat: Swift.String?
        /// The helper text visibility of the DateTimePickerControlDisplayOptions.
        public var helperTextVisibility: QuickSightClientTypes.Visibility?
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            dateIconVisibility: QuickSightClientTypes.Visibility? = nil,
            dateTimeFormat: Swift.String? = nil,
            helperTextVisibility: QuickSightClientTypes.Visibility? = nil,
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.dateIconVisibility = dateIconVisibility
            self.dateTimeFormat = dateTimeFormat
            self.helperTextVisibility = helperTextVisibility
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum SheetControlDateTimePickerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dateRange
        case singleValued
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlDateTimePickerType] {
            return [
                .dateRange,
                .singleValued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dateRange: return "DATE_RANGE"
            case .singleValued: return "SINGLE_VALUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the filter control type of a DateTimePicker.
    public struct DefaultDateTimePickerControlOptions: Swift.Sendable {
        /// The visibility configuration of the Apply button on a DateTimePickerControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions?
        /// The date time picker type of the DefaultDateTimePickerControlOptions. Choose one of the following options:
        ///
        /// * SINGLE_VALUED: The filter condition is a fixed date.
        ///
        /// * DATE_RANGE: The filter condition is a date time range.
        public var type: QuickSightClientTypes.SheetControlDateTimePickerType?

        public init(
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions? = nil,
            type: QuickSightClientTypes.SheetControlDateTimePickerType? = nil
        )
        {
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of the Select all options in a list control.
    public struct ListControlSelectAllOptions: Swift.Sendable {
        /// The visibility configuration of the Select all options in a list control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct DropDownControlDisplayOptions: Swift.Sendable {
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The configuration of the Select all options in a dropdown control.
        public var selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A list of selectable values that are used in a control.
    public struct FilterSelectableValues: Swift.Sendable {
        /// The values that are used in the FilterSelectableValues.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    public enum SheetControlListType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiSelect
        case singleSelect
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlListType] {
            return [
                .multiSelect,
                .singleSelect
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiSelect: return "MULTI_SELECT"
            case .singleSelect: return "SINGLE_SELECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the Dropdown filter control type.
    public struct DefaultFilterDropDownControlOptions: Swift.Sendable {
        /// The visibility configuration of the Apply button on a FilterDropDownControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The type of the FilterDropDownControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from a dropdown menu.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.selectableValues = selectableValues
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of the search options in a list control.
    public struct ListControlSearchOptions: Swift.Sendable {
        /// The visibility configuration of the search options in a list control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct ListControlDisplayOptions: Swift.Sendable {
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The configuration of the search options in a list control.
        public var searchOptions: QuickSightClientTypes.ListControlSearchOptions?
        /// The configuration of the Select all options in a list control.
        public var selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            searchOptions: QuickSightClientTypes.ListControlSearchOptions? = nil,
            selectAllOptions: QuickSightClientTypes.ListControlSelectAllOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.searchOptions = searchOptions
            self.selectAllOptions = selectAllOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the List filter control type.
    public struct DefaultFilterListControlOptions: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.ListControlDisplayOptions?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The type of the DefaultFilterListControlOptions. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from the list.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from the list.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            displayOptions: QuickSightClientTypes.ListControlDisplayOptions? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.displayOptions = displayOptions
            self.selectableValues = selectableValues
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct RelativeDateTimeControlDisplayOptions: Swift.Sendable {
        /// Customize how dates are formatted in controls.
        public var dateTimeFormat: Swift.String?
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            dateTimeFormat: Swift.String? = nil,
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.dateTimeFormat = dateTimeFormat
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the RelativeDateTime filter control type.
    public struct DefaultRelativeDateTimeControlOptions: Swift.Sendable {
        /// The visibility configuration of the Apply button on a RelativeDateTimeControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions?

        public init(
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions? = nil
        )
        {
            self.commitMode = commitMode
            self.displayOptions = displayOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct SliderControlDisplayOptions: Swift.Sendable {
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum SheetControlSliderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case range
        case singlePoint
        case sdkUnknown(Swift.String)

        public static var allCases: [SheetControlSliderType] {
            return [
                .range,
                .singlePoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .range: return "RANGE"
            case .singlePoint: return "SINGLE_POINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the Slider filter control type.
    public struct DefaultSliderControlOptions: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.SliderControlDisplayOptions?
        /// The larger value that is displayed at the right of the slider.
        /// This member is required.
        public var maximumValue: Swift.Double
        /// The smaller value that is displayed at the left of the slider.
        /// This member is required.
        public var minimumValue: Swift.Double
        /// The number of increments that the slider bar is divided into.
        /// This member is required.
        public var stepSize: Swift.Double
        /// The type of the DefaultSliderControlOptions. Choose one of the following options:
        ///
        /// * SINGLE_POINT: Filter against(equals) a single data point.
        ///
        /// * RANGE: Filter data that is in a specified range.
        public var type: QuickSightClientTypes.SheetControlSliderType?

        public init(
            displayOptions: QuickSightClientTypes.SliderControlDisplayOptions? = nil,
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            stepSize: Swift.Double = 0.0,
            type: QuickSightClientTypes.SheetControlSliderType? = nil
        )
        {
            self.displayOptions = displayOptions
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.stepSize = stepSize
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of the placeholder options in a text control.
    public struct TextControlPlaceholderOptions: Swift.Sendable {
        /// The visibility configuration of the placeholder options in a text control.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct TextAreaControlDisplayOptions: Swift.Sendable {
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The configuration of the placeholder options in a text area control.
        public var placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the TextArea filter control type.
    public struct DefaultTextAreaControlOptions: Swift.Sendable {
        /// The delimiter that is used to separate the lines in text.
        public var delimiter: Swift.String?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions?

        public init(
            delimiter: Swift.String? = nil,
            displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions? = nil
        )
        {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The display options of a control.
    public struct TextFieldControlDisplayOptions: Swift.Sendable {
        /// The configuration of info icon label options.
        public var infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions?
        /// The configuration of the placeholder options in a text field control.
        public var placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions?
        /// The options to configure the title visibility, name, and font size.
        public var titleOptions: QuickSightClientTypes.LabelOptions?

        public init(
            infoIconLabelOptions: QuickSightClientTypes.SheetControlInfoIconLabelOptions? = nil,
            placeholderOptions: QuickSightClientTypes.TextControlPlaceholderOptions? = nil,
            titleOptions: QuickSightClientTypes.LabelOptions? = nil
        )
        {
            self.infoIconLabelOptions = infoIconLabelOptions
            self.placeholderOptions = placeholderOptions
            self.titleOptions = titleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The default options that correspond to the TextField filter control type.
    public struct DefaultTextFieldControlOptions: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions?

        public init(
            displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions? = nil
        )
        {
            self.displayOptions = displayOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The option that corresponds to the control type of the filter.
    public struct DefaultFilterControlOptions: Swift.Sendable {
        /// The default options that correspond to the filter control type of a DateTimePicker.
        public var defaultDateTimePickerOptions: QuickSightClientTypes.DefaultDateTimePickerControlOptions?
        /// The default options that correspond to the Dropdown filter control type.
        public var defaultDropdownOptions: QuickSightClientTypes.DefaultFilterDropDownControlOptions?
        /// The default options that correspond to the List filter control type.
        public var defaultListOptions: QuickSightClientTypes.DefaultFilterListControlOptions?
        /// The default options that correspond to the RelativeDateTime filter control type.
        public var defaultRelativeDateTimeOptions: QuickSightClientTypes.DefaultRelativeDateTimeControlOptions?
        /// The default options that correspond to the Slider filter control type.
        public var defaultSliderOptions: QuickSightClientTypes.DefaultSliderControlOptions?
        /// The default options that correspond to the TextArea filter control type.
        public var defaultTextAreaOptions: QuickSightClientTypes.DefaultTextAreaControlOptions?
        /// The default options that correspond to the TextField filter control type.
        public var defaultTextFieldOptions: QuickSightClientTypes.DefaultTextFieldControlOptions?

        public init(
            defaultDateTimePickerOptions: QuickSightClientTypes.DefaultDateTimePickerControlOptions? = nil,
            defaultDropdownOptions: QuickSightClientTypes.DefaultFilterDropDownControlOptions? = nil,
            defaultListOptions: QuickSightClientTypes.DefaultFilterListControlOptions? = nil,
            defaultRelativeDateTimeOptions: QuickSightClientTypes.DefaultRelativeDateTimeControlOptions? = nil,
            defaultSliderOptions: QuickSightClientTypes.DefaultSliderControlOptions? = nil,
            defaultTextAreaOptions: QuickSightClientTypes.DefaultTextAreaControlOptions? = nil,
            defaultTextFieldOptions: QuickSightClientTypes.DefaultTextFieldControlOptions? = nil
        )
        {
            self.defaultDateTimePickerOptions = defaultDateTimePickerOptions
            self.defaultDropdownOptions = defaultDropdownOptions
            self.defaultListOptions = defaultListOptions
            self.defaultRelativeDateTimeOptions = defaultRelativeDateTimeOptions
            self.defaultSliderOptions = defaultSliderOptions
            self.defaultTextAreaOptions = defaultTextAreaOptions
            self.defaultTextFieldOptions = defaultTextFieldOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The default configuration for all dependent controls of the filter.
    public struct DefaultFilterControlConfiguration: Swift.Sendable {
        /// The control option for the DefaultFilterControlConfiguration.
        /// This member is required.
        public var controlOptions: QuickSightClientTypes.DefaultFilterControlOptions?
        /// The title of the DefaultFilterControlConfiguration. This title is shared by all controls that are tied to this filter.
        /// This member is required.
        public var title: Swift.String?

        public init(
            controlOptions: QuickSightClientTypes.DefaultFilterControlOptions? = nil,
            title: Swift.String? = nil
        )
        {
            self.controlOptions = controlOptions
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A CategoryFilter filters text values. For more information, see [Adding text filters](https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html) in the Amazon QuickSight User Guide.
    public struct CategoryFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The configuration for a CategoryFilter.
        /// This member is required.
        public var configuration: QuickSightClientTypes.CategoryFilterConfiguration?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            configuration: QuickSightClientTypes.CategoryFilterConfiguration? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            filterId: Swift.String? = nil
        )
        {
            self.column = column
            self.configuration = configuration
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.filterId = filterId
        }
    }
}

extension QuickSightClientTypes {

    /// A CategoryInnerFilter filters text values for the NestedFilter.
    public struct CategoryInnerFilter: Swift.Sendable {
        /// A column of a data set.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The configuration for a CategoryFilter. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var configuration: QuickSightClientTypes.CategoryFilterConfiguration?
        /// The default configuration for all dependent controls of the filter.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            configuration: QuickSightClientTypes.CategoryFilterConfiguration? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil
        )
        {
            self.column = column
            self.configuration = configuration
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The InnerFilter defines the subset of data to be used with the NestedFilter.
    public struct InnerFilter: Swift.Sendable {
        /// A CategoryInnerFilter filters text values for the NestedFilter.
        public var categoryInnerFilter: QuickSightClientTypes.CategoryInnerFilter?

        public init(
            categoryInnerFilter: QuickSightClientTypes.CategoryInnerFilter? = nil
        )
        {
            self.categoryInnerFilter = categoryInnerFilter
        }
    }
}

extension QuickSightClientTypes {

    /// A NestedFilter filters data with a subset of data that is defined by the nested inner filter.
    public struct NestedFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// A boolean condition to include or exclude the subset that is defined by the values of the nested inner filter.
        /// This member is required.
        public var includeInnerSet: Swift.Bool
        /// The InnerFilter defines the subset of data to be used with the NestedFilter.
        /// This member is required.
        public var innerFilter: QuickSightClientTypes.InnerFilter?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            filterId: Swift.String? = nil,
            includeInnerSet: Swift.Bool = false,
            innerFilter: QuickSightClientTypes.InnerFilter? = nil
        )
        {
            self.column = column
            self.filterId = filterId
            self.includeInnerSet = includeInnerSet
            self.innerFilter = innerFilter
        }
    }
}

extension QuickSightClientTypes {

    public enum NumericEqualityMatchOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doesNotEqual
        case equals
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericEqualityMatchOperator] {
            return [
                .doesNotEqual,
                .equals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doesNotEqual: return "DOES_NOT_EQUAL"
            case .equals: return "EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum NumericFilterSelectAllOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case filterAllValues
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericFilterSelectAllOptions] {
            return [
                .filterAllValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .filterAllValues: return "FILTER_ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A NumericEqualityFilter filters values that are equal to the specified value.
    public struct NumericEqualityFilter: Swift.Sendable {
        /// The aggregation function of the filter.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The match operator that is used to determine if a filter should be applied.
        /// This member is required.
        public var matchOperator: QuickSightClientTypes.NumericEqualityMatchOperator?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions?
        /// The input value.
        public var value: Swift.Double?

        public init(
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            filterId: Swift.String? = nil,
            matchOperator: QuickSightClientTypes.NumericEqualityMatchOperator? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions? = nil,
            value: Swift.Double? = 0.0
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.filterId = filterId
            self.matchOperator = matchOperator
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.selectAllOptions = selectAllOptions
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The value input pf the numeric range filter.
    public struct NumericRangeFilterValue: Swift.Sendable {
        /// The parameter that is used in the numeric range.
        public var parameter: Swift.String?
        /// The static value of the numeric range filter.
        public var staticValue: Swift.Double?

        public init(
            parameter: Swift.String? = nil,
            staticValue: Swift.Double? = 0.0
        )
        {
            self.parameter = parameter
            self.staticValue = staticValue
        }
    }
}

extension QuickSightClientTypes {

    /// A NumericRangeFilter filters values that are within the value range.
    public struct NumericRangeFilter: Swift.Sendable {
        /// The aggregation function of the filter.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public var includeMaximum: Swift.Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public var includeMinimum: Swift.Bool?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The maximum value for the filter value range.
        public var rangeMaximum: QuickSightClientTypes.NumericRangeFilterValue?
        /// The minimum value for the filter value range.
        public var rangeMinimum: QuickSightClientTypes.NumericRangeFilterValue?
        /// Select all of the values. Null is not the assigned value of select all.
        ///
        /// * FILTER_ALL_VALUES
        public var selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions?

        public init(
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            filterId: Swift.String? = nil,
            includeMaximum: Swift.Bool? = false,
            includeMinimum: Swift.Bool? = false,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            rangeMaximum: QuickSightClientTypes.NumericRangeFilterValue? = nil,
            rangeMinimum: QuickSightClientTypes.NumericRangeFilterValue? = nil,
            selectAllOptions: QuickSightClientTypes.NumericFilterSelectAllOptions? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.selectAllOptions = selectAllOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum AnchorOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case now
        case sdkUnknown(Swift.String)

        public static var allCases: [AnchorOption] {
            return [
                .now
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .now: return "NOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The date configuration of the filter.
    public struct AnchorDateConfiguration: Swift.Sendable {
        /// The options for the date configuration. Choose one of the options below:
        ///
        /// * NOW
        public var anchorOption: QuickSightClientTypes.AnchorOption?
        /// The name of the parameter that is used for the anchor date configuration.
        public var parameterName: Swift.String?

        public init(
            anchorOption: QuickSightClientTypes.AnchorOption? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.anchorOption = anchorOption
            self.parameterName = parameterName
        }
    }
}

extension QuickSightClientTypes {

    public enum WidgetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WidgetStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The exclude period of TimeRangeFilter or RelativeDatesFilter.
    public struct ExcludePeriodConfiguration: Swift.Sendable {
        /// The amount or number of the exclude period.
        /// This member is required.
        public var amount: Swift.Int?
        /// The granularity or unit (day, month, year) of the exclude period.
        /// This member is required.
        public var granularity: QuickSightClientTypes.TimeGranularity?
        /// The status of the exclude period. Choose from the following options:
        ///
        /// * ENABLED
        ///
        /// * DISABLED
        public var status: QuickSightClientTypes.WidgetStatus?

        public init(
            amount: Swift.Int? = 0,
            granularity: QuickSightClientTypes.TimeGranularity? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.amount = amount
            self.granularity = granularity
            self.status = status
        }
    }
}

extension QuickSightClientTypes {

    public enum RelativeDateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case last
        case next
        case now
        case previous
        case `this`
        case sdkUnknown(Swift.String)

        public static var allCases: [RelativeDateType] {
            return [
                .last,
                .next,
                .now,
                .previous,
                .this
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .last: return "LAST"
            case .next: return "NEXT"
            case .now: return "NOW"
            case .previous: return "PREVIOUS"
            case .this: return "THIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A RelativeDatesFilter filters relative dates values.
    public struct RelativeDatesFilter: Swift.Sendable {
        /// The date configuration of the filter.
        /// This member is required.
        public var anchorDateConfiguration: QuickSightClientTypes.AnchorDateConfiguration?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// The configuration for the exclude period of the filter.
        public var excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The minimum granularity (period granularity) of the relative dates filter.
        public var minimumGranularity: QuickSightClientTypes.TimeGranularity?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// The range date type of the filter. Choose one of the options below:
        ///
        /// * PREVIOUS
        ///
        /// * THIS
        ///
        /// * LAST
        ///
        /// * NOW
        ///
        /// * NEXT
        /// This member is required.
        public var relativeDateType: QuickSightClientTypes.RelativeDateType?
        /// The date value of the filter.
        public var relativeDateValue: Swift.Int?
        /// The level of time precision that is used to aggregate DateTime values.
        /// This member is required.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            anchorDateConfiguration: QuickSightClientTypes.AnchorDateConfiguration? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration? = nil,
            filterId: Swift.String? = nil,
            minimumGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            parameterName: Swift.String? = nil,
            relativeDateType: QuickSightClientTypes.RelativeDateType? = nil,
            relativeDateValue: Swift.Int? = 0,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.anchorDateConfiguration = anchorDateConfiguration
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.minimumGranularity = minimumGranularity
            self.nullOption = nullOption
            self.parameterName = parameterName
            self.relativeDateType = relativeDateType
            self.relativeDateValue = relativeDateValue
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// The rolling date configuration of a date time filter.
    public struct RollingDateConfiguration: Swift.Sendable {
        /// The data set that is used in the rolling date configuration.
        public var dataSetIdentifier: Swift.String?
        /// The expression of the rolling date configuration.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            dataSetIdentifier: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.dataSetIdentifier = dataSetIdentifier
            self.expression = expression
        }
    }
}

extension QuickSightClientTypes.RollingDateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RollingDateConfiguration(dataSetIdentifier: \(Swift.String(describing: dataSetIdentifier)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A TimeEqualityFilter filters values that are equal to a given value.
    public struct TimeEqualityFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The parameter whose value should be used for the filter value. This field is mutually exclusive to Value and RollingDate.
        public var parameterName: Swift.String?
        /// The rolling date input for the TimeEquality filter. This field is mutually exclusive to Value and ParameterName.
        public var rollingDate: QuickSightClientTypes.RollingDateConfiguration?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The value of a TimeEquality filter. This field is mutually exclusive to RollingDate and ParameterName.
        public var value: Foundation.Date?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            filterId: Swift.String? = nil,
            parameterName: Swift.String? = nil,
            rollingDate: QuickSightClientTypes.RollingDateConfiguration? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            value: Foundation.Date? = nil
        )
        {
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.filterId = filterId
            self.parameterName = parameterName
            self.rollingDate = rollingDate
            self.timeGranularity = timeGranularity
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The value of a time range filter. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TimeRangeFilterValue: Swift.Sendable {
        /// The parameter type input value.
        public var parameter: Swift.String?
        /// The rolling date input value.
        public var rollingDate: QuickSightClientTypes.RollingDateConfiguration?
        /// The static input value.
        public var staticValue: Foundation.Date?

        public init(
            parameter: Swift.String? = nil,
            rollingDate: QuickSightClientTypes.RollingDateConfiguration? = nil,
            staticValue: Foundation.Date? = nil
        )
        {
            self.parameter = parameter
            self.rollingDate = rollingDate
            self.staticValue = staticValue
        }
    }
}

extension QuickSightClientTypes {

    /// A TimeRangeFilter filters values that are between two specified values.
    public struct TimeRangeFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// The exclude period of the time range filter.
        public var excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// Determines whether the maximum value in the filter value range should be included in the filtered results.
        public var includeMaximum: Swift.Bool?
        /// Determines whether the minimum value in the filter value range should be included in the filtered results.
        public var includeMinimum: Swift.Bool?
        /// This option determines how null values should be treated when filtering data.
        ///
        /// * ALL_VALUES: Include null values in filtered results.
        ///
        /// * NULLS_ONLY: Only include null values in filtered results.
        ///
        /// * NON_NULLS_ONLY: Exclude null values from filtered results.
        /// This member is required.
        public var nullOption: QuickSightClientTypes.FilterNullOption?
        /// The maximum value for the filter value range.
        public var rangeMaximumValue: QuickSightClientTypes.TimeRangeFilterValue?
        /// The minimum value for the filter value range.
        public var rangeMinimumValue: QuickSightClientTypes.TimeRangeFilterValue?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            excludePeriodConfiguration: QuickSightClientTypes.ExcludePeriodConfiguration? = nil,
            filterId: Swift.String? = nil,
            includeMaximum: Swift.Bool? = false,
            includeMinimum: Swift.Bool? = false,
            nullOption: QuickSightClientTypes.FilterNullOption? = nil,
            rangeMaximumValue: QuickSightClientTypes.TimeRangeFilterValue? = nil,
            rangeMinimumValue: QuickSightClientTypes.TimeRangeFilterValue? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.excludePeriodConfiguration = excludePeriodConfiguration
            self.filterId = filterId
            self.includeMaximum = includeMaximum
            self.includeMinimum = includeMinimum
            self.nullOption = nullOption
            self.rangeMaximumValue = rangeMaximumValue
            self.rangeMinimumValue = rangeMinimumValue
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// A TopBottomFilter filters values that are at the top or the bottom.
    public struct TopBottomFilter: Swift.Sendable {
        /// The aggregation and sort configuration of the top bottom filter.
        /// This member is required.
        public var aggregationSortConfigurations: [QuickSightClientTypes.AggregationSortConfiguration]?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The default configurations for the associated controls. This applies only for filters that are scoped to multiple sheets.
        public var defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration?
        /// An identifier that uniquely identifies a filter within a dashboard, analysis, or template.
        /// This member is required.
        public var filterId: Swift.String?
        /// The number of items to include in the top bottom filter results.
        public var limit: Swift.Int?
        /// The parameter whose value should be used for the filter value.
        public var parameterName: Swift.String?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            aggregationSortConfigurations: [QuickSightClientTypes.AggregationSortConfiguration]? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            defaultFilterControlConfiguration: QuickSightClientTypes.DefaultFilterControlConfiguration? = nil,
            filterId: Swift.String? = nil,
            limit: Swift.Int? = 0,
            parameterName: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.aggregationSortConfigurations = aggregationSortConfigurations
            self.column = column
            self.defaultFilterControlConfiguration = defaultFilterControlConfiguration
            self.filterId = filterId
            self.limit = limit
            self.parameterName = parameterName
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// With a Filter, you can remove portions of data from a particular visual or view. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Filter: Swift.Sendable {
        /// A CategoryFilter filters text values. For more information, see [Adding text filters](https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html) in the Amazon QuickSight User Guide.
        public var categoryFilter: QuickSightClientTypes.CategoryFilter?
        /// A NestedFilter filters data with a subset of data that is defined by the nested inner filter.
        public var nestedFilter: QuickSightClientTypes.NestedFilter?
        /// A NumericEqualityFilter filters numeric values that equal or do not equal a given numeric value.
        public var numericEqualityFilter: QuickSightClientTypes.NumericEqualityFilter?
        /// A NumericRangeFilter filters numeric values that are either inside or outside a given numeric range.
        public var numericRangeFilter: QuickSightClientTypes.NumericRangeFilter?
        /// A RelativeDatesFilter filters date values that are relative to a given date.
        public var relativeDatesFilter: QuickSightClientTypes.RelativeDatesFilter?
        /// A TimeEqualityFilter filters date-time values that equal or do not equal a given date/time value.
        public var timeEqualityFilter: QuickSightClientTypes.TimeEqualityFilter?
        /// A TimeRangeFilter filters date-time values that are either inside or outside a given date/time range.
        public var timeRangeFilter: QuickSightClientTypes.TimeRangeFilter?
        /// A TopBottomFilter filters data to the top or bottom values for a given column.
        public var topBottomFilter: QuickSightClientTypes.TopBottomFilter?

        public init(
            categoryFilter: QuickSightClientTypes.CategoryFilter? = nil,
            nestedFilter: QuickSightClientTypes.NestedFilter? = nil,
            numericEqualityFilter: QuickSightClientTypes.NumericEqualityFilter? = nil,
            numericRangeFilter: QuickSightClientTypes.NumericRangeFilter? = nil,
            relativeDatesFilter: QuickSightClientTypes.RelativeDatesFilter? = nil,
            timeEqualityFilter: QuickSightClientTypes.TimeEqualityFilter? = nil,
            timeRangeFilter: QuickSightClientTypes.TimeRangeFilter? = nil,
            topBottomFilter: QuickSightClientTypes.TopBottomFilter? = nil
        )
        {
            self.categoryFilter = categoryFilter
            self.nestedFilter = nestedFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.relativeDatesFilter = relativeDatesFilter
            self.timeEqualityFilter = timeEqualityFilter
            self.timeRangeFilter = timeRangeFilter
            self.topBottomFilter = topBottomFilter
        }
    }
}

extension QuickSightClientTypes {

    public enum FilterVisualScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allVisuals
        case selectedVisuals
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterVisualScope] {
            return [
                .allVisuals,
                .selectedVisuals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allVisuals: return "ALL_VISUALS"
            case .selectedVisuals: return "SELECTED_VISUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The filter that is applied to the options.
    public struct SheetVisualScopingConfiguration: Swift.Sendable {
        /// The scope of the applied entities. Choose one of the following options:
        ///
        /// * ALL_VISUALS
        ///
        /// * SELECTED_VISUALS
        /// This member is required.
        public var scope: QuickSightClientTypes.FilterVisualScope?
        /// The selected sheet that the filter is applied to.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The selected visuals that the filter is applied to.
        public var visualIds: [Swift.String]?

        public init(
            scope: QuickSightClientTypes.FilterVisualScope? = nil,
            sheetId: Swift.String? = nil,
            visualIds: [Swift.String]? = nil
        )
        {
            self.scope = scope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for applying a filter to specific sheets or visuals. You can apply this filter to multiple visuals that are on one sheet or to all visuals on a sheet. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SelectedSheetsFilterScopeConfiguration: Swift.Sendable {
        /// The sheet ID and visual IDs of the sheet and visuals that the filter is applied to.
        public var sheetVisualScopingConfigurations: [QuickSightClientTypes.SheetVisualScopingConfiguration]?

        public init(
            sheetVisualScopingConfigurations: [QuickSightClientTypes.SheetVisualScopingConfiguration]? = nil
        )
        {
            self.sheetVisualScopingConfigurations = sheetVisualScopingConfigurations
        }
    }
}

extension QuickSightClientTypes {

    /// The scope configuration for a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterScopeConfiguration: Swift.Sendable {
        /// The configuration that applies a filter to all sheets. When you choose AllSheets as the value for a FilterScopeConfiguration, this filter is applied to all visuals of all sheets in an Analysis, Dashboard, or Template. The AllSheetsFilterScopeConfiguration is chosen.
        public var allSheets: QuickSightClientTypes.AllSheetsFilterScopeConfiguration?
        /// The configuration for applying a filter to specific sheets.
        public var selectedSheets: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration?

        public init(
            allSheets: QuickSightClientTypes.AllSheetsFilterScopeConfiguration? = nil,
            selectedSheets: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration? = nil
        )
        {
            self.allSheets = allSheets
            self.selectedSheets = selectedSheets
        }
    }
}

extension QuickSightClientTypes {

    /// A grouping of individual filters. Filter groups are applied to the same group of visuals. For more information, see [Adding filter conditions (group filters) with AND and OR operators](https://docs.aws.amazon.com/quicksight/latest/user/add-a-compound-filter.html) in the Amazon QuickSight User Guide.
    public struct FilterGroup: Swift.Sendable {
        /// The filter new feature which can apply filter group to all data sets. Choose one of the following options:
        ///
        /// * ALL_DATASETS
        ///
        /// * SINGLE_DATASET
        /// This member is required.
        public var crossDataset: QuickSightClientTypes.CrossDatasetTypes?
        /// The value that uniquely identifies a FilterGroup within a dashboard, template, or analysis.
        /// This member is required.
        public var filterGroupId: Swift.String?
        /// The list of filters that are present in a FilterGroup.
        /// This member is required.
        public var filters: [QuickSightClientTypes.Filter]?
        /// The configuration that specifies what scope to apply to a FilterGroup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var scopeConfiguration: QuickSightClientTypes.FilterScopeConfiguration?
        /// The status of the FilterGroup.
        public var status: QuickSightClientTypes.WidgetStatus?

        public init(
            crossDataset: QuickSightClientTypes.CrossDatasetTypes? = nil,
            filterGroupId: Swift.String? = nil,
            filters: [QuickSightClientTypes.Filter]? = nil,
            scopeConfiguration: QuickSightClientTypes.FilterScopeConfiguration? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.crossDataset = crossDataset
            self.filterGroupId = filterGroupId
            self.filters = filters
            self.scopeConfiguration = scopeConfiguration
            self.status = status
        }
    }
}

extension QuickSightClientTypes {

    public enum DayOfTheWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfTheWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An array of analysis level configurations.
    public struct AssetOptions: Swift.Sendable {
        /// Determines the timezone for the analysis.
        public var timezone: Swift.String?
        /// Determines the week start day for an analysis.
        public var weekStart: QuickSightClientTypes.DayOfTheWeek?

        public init(
            timezone: Swift.String? = nil,
            weekStart: QuickSightClientTypes.DayOfTheWeek? = nil
        )
        {
            self.timezone = timezone
            self.weekStart = weekStart
        }
    }
}

extension QuickSightClientTypes {

    /// Defines different defaults to the users or groups based on mapping.
    public struct DynamicDefaultValue: Swift.Sendable {
        /// The column that contains the default value of each user or group.
        /// This member is required.
        public var defaultValueColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The column that contains the group name.
        public var groupNameColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The column that contains the username.
        public var userNameColumn: QuickSightClientTypes.ColumnIdentifier?

        public init(
            defaultValueColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            groupNameColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            userNameColumn: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.defaultValueColumn = defaultValueColumn
            self.groupNameColumn = groupNameColumn
            self.userNameColumn = userNameColumn
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of the DateTimeParameterDeclaration.
    public struct DateTimeDefaultValues: Swift.Sendable {
        /// The dynamic value of the DataTimeDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The rolling date of the DataTimeDefaultValues. The date is determined from the dataset based on input expression.
        public var rollingDate: QuickSightClientTypes.RollingDateConfiguration?
        /// The static values of the DataTimeDefaultValues.
        public var staticValues: [Foundation.Date]?

        public init(
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            rollingDate: QuickSightClientTypes.RollingDateConfiguration? = nil,
            staticValues: [Foundation.Date]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.rollingDate = rollingDate
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes.DateTimeDefaultValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateTimeDefaultValues(dynamicValue: \(Swift.String(describing: dynamicValue)), rollingDate: \(Swift.String(describing: rollingDate)), staticValues: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A dataset parameter that is mapped to an analysis parameter.
    public struct MappedDataSetParameter: Swift.Sendable {
        /// A unique name that identifies a dataset within the analysis or dashboard.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The name of the dataset parameter.
        /// This member is required.
        public var dataSetParameterName: Swift.String?

        public init(
            dataSetIdentifier: Swift.String? = nil,
            dataSetParameterName: Swift.String? = nil
        )
        {
            self.dataSetIdentifier = dataSetIdentifier
            self.dataSetParameterName = dataSetParameterName
        }
    }
}

extension QuickSightClientTypes {

    public enum ValueWhenUnsetOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case null
        case recommendedValue
        case sdkUnknown(Swift.String)

        public static var allCases: [ValueWhenUnsetOption] {
            return [
                .null,
                .recommendedValue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .null: return "NULL"
            case .recommendedValue: return "RECOMMENDED_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
    public struct DateTimeValueWhenUnsetConfiguration: Swift.Sendable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Foundation.Date?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init(
            customValue: Foundation.Date? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }
}

extension QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateTimeValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A parameter declaration for the DateTime data type.
    public struct DateTimeParameterDeclaration: Swift.Sendable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.DateTimeDefaultValues?
        /// A list of dataset parameters that are mapped to an analysis parameter.
        public var mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The configuration that defines the default value of a DateTime parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration?

        public init(
            defaultValues: QuickSightClientTypes.DateTimeDefaultValues? = nil,
            mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]? = nil,
            name: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            valueWhenUnset: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueWhenUnset = valueWhenUnset
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of the DecimalParameterDeclaration.
    public struct DecimalDefaultValues: Swift.Sendable {
        /// The dynamic value of the DecimalDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public var staticValues: [Swift.Double]?

        public init(
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.Double]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes.DecimalDefaultValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecimalDefaultValues(dynamicValue: \(Swift.String(describing: dynamicValue)), staticValues: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum ParameterValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiValued
        case singleValued
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterValueType] {
            return [
                .multiValued,
                .singleValued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiValued: return "MULTI_VALUED"
            case .singleValued: return "SINGLE_VALUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
    public struct DecimalValueWhenUnsetConfiguration: Swift.Sendable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.Double?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init(
            customValue: Swift.Double? = 0.0,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }
}

extension QuickSightClientTypes.DecimalValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecimalValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A parameter declaration for the Decimal data type.
    public struct DecimalParameterDeclaration: Swift.Sendable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.DecimalDefaultValues?
        /// A list of dataset parameters that are mapped to an analysis parameter.
        public var mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// The configuration that defines the default value of a Decimal parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration?

        public init(
            defaultValues: QuickSightClientTypes.DecimalDefaultValues? = nil,
            mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of the IntegerParameterDeclaration.
    public struct IntegerDefaultValues: Swift.Sendable {
        /// The dynamic value of the IntegerDefaultValues. Different defaults are displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the IntegerDefaultValues.
        public var staticValues: [Swift.Int]?

        public init(
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.Int]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes.IntegerDefaultValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerDefaultValues(dynamicValue: \(Swift.String(describing: dynamicValue)), staticValues: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A parameter declaration for the Integer data type. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct IntegerValueWhenUnsetConfiguration: Swift.Sendable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.Int?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init(
            customValue: Swift.Int? = 0,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }
}

extension QuickSightClientTypes.IntegerValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A parameter declaration for the Integer data type.
    public struct IntegerParameterDeclaration: Swift.Sendable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.IntegerDefaultValues?
        /// A list of dataset parameters that are mapped to an analysis parameter.
        public var mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// A parameter declaration for the Integer data type.
        public var valueWhenUnset: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration?

        public init(
            defaultValues: QuickSightClientTypes.IntegerDefaultValues? = nil,
            mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of the StringParameterDeclaration.
    public struct StringDefaultValues: Swift.Sendable {
        /// The dynamic value of the StringDefaultValues. Different defaults displayed according to users, groups, and values mapping.
        public var dynamicValue: QuickSightClientTypes.DynamicDefaultValue?
        /// The static values of the DecimalDefaultValues.
        public var staticValues: [Swift.String]?

        public init(
            dynamicValue: QuickSightClientTypes.DynamicDefaultValue? = nil,
            staticValues: [Swift.String]? = nil
        )
        {
            self.dynamicValue = dynamicValue
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes.StringDefaultValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StringDefaultValues(dynamicValue: \(Swift.String(describing: dynamicValue)), staticValues: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The configuration that defines the default value of a String parameter when a value has not been set.
    public struct StringValueWhenUnsetConfiguration: Swift.Sendable {
        /// A custom value that's used when the value of a parameter isn't set.
        public var customValue: Swift.String?
        /// The built-in options for default values. The value can be one of the following:
        ///
        /// * RECOMMENDED: The recommended value.
        ///
        /// * NULL: The NULL value.
        public var valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption?

        public init(
            customValue: Swift.String? = nil,
            valueWhenUnsetOption: QuickSightClientTypes.ValueWhenUnsetOption? = nil
        )
        {
            self.customValue = customValue
            self.valueWhenUnsetOption = valueWhenUnsetOption
        }
    }
}

extension QuickSightClientTypes.StringValueWhenUnsetConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StringValueWhenUnsetConfiguration(valueWhenUnsetOption: \(Swift.String(describing: valueWhenUnsetOption)), customValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A parameter declaration for the String data type.
    public struct StringParameterDeclaration: Swift.Sendable {
        /// The default values of a parameter. If the parameter is a single-value parameter, a maximum of one default value can be provided.
        public var defaultValues: QuickSightClientTypes.StringDefaultValues?
        /// A list of dataset parameters that are mapped to an analysis parameter.
        public var mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]?
        /// The name of the parameter that is being declared.
        /// This member is required.
        public var name: Swift.String?
        /// The value type determines whether the parameter is a single-value or multi-value parameter.
        /// This member is required.
        public var parameterValueType: QuickSightClientTypes.ParameterValueType?
        /// The configuration that defines the default value of a String parameter when a value has not been set.
        public var valueWhenUnset: QuickSightClientTypes.StringValueWhenUnsetConfiguration?

        public init(
            defaultValues: QuickSightClientTypes.StringDefaultValues? = nil,
            mappedDataSetParameters: [QuickSightClientTypes.MappedDataSetParameter]? = nil,
            name: Swift.String? = nil,
            parameterValueType: QuickSightClientTypes.ParameterValueType? = nil,
            valueWhenUnset: QuickSightClientTypes.StringValueWhenUnsetConfiguration? = nil
        )
        {
            self.defaultValues = defaultValues
            self.mappedDataSetParameters = mappedDataSetParameters
            self.name = name
            self.parameterValueType = parameterValueType
            self.valueWhenUnset = valueWhenUnset
        }
    }
}

extension QuickSightClientTypes {

    /// The declaration definition of a parameter. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ParameterDeclaration: Swift.Sendable {
        /// A parameter declaration for the DateTime data type.
        public var dateTimeParameterDeclaration: QuickSightClientTypes.DateTimeParameterDeclaration?
        /// A parameter declaration for the Decimal data type.
        public var decimalParameterDeclaration: QuickSightClientTypes.DecimalParameterDeclaration?
        /// A parameter declaration for the Integer data type.
        public var integerParameterDeclaration: QuickSightClientTypes.IntegerParameterDeclaration?
        /// A parameter declaration for the String data type.
        public var stringParameterDeclaration: QuickSightClientTypes.StringParameterDeclaration?

        public init(
            dateTimeParameterDeclaration: QuickSightClientTypes.DateTimeParameterDeclaration? = nil,
            decimalParameterDeclaration: QuickSightClientTypes.DecimalParameterDeclaration? = nil,
            integerParameterDeclaration: QuickSightClientTypes.IntegerParameterDeclaration? = nil,
            stringParameterDeclaration: QuickSightClientTypes.StringParameterDeclaration? = nil
        )
        {
            self.dateTimeParameterDeclaration = dateTimeParameterDeclaration
            self.decimalParameterDeclaration = decimalParameterDeclaration
            self.integerParameterDeclaration = integerParameterDeclaration
            self.stringParameterDeclaration = stringParameterDeclaration
        }
    }
}

extension QuickSightClientTypes {

    public enum QueryExecutionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryExecutionMode] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that describes the query execution options.
    public struct QueryExecutionOptions: Swift.Sendable {
        /// A structure that describes the query execution mode.
        public var queryExecutionMode: QuickSightClientTypes.QueryExecutionMode?

        public init(
            queryExecutionMode: QuickSightClientTypes.QueryExecutionMode? = nil
        )
        {
            self.queryExecutionMode = queryExecutionMode
        }
    }
}

extension QuickSightClientTypes {

    /// The source controls that are used in a CascadingControlConfiguration.
    public struct CascadingControlSource: Swift.Sendable {
        /// The column identifier that determines which column to look up for the source sheet control.
        public var columnToMatch: QuickSightClientTypes.ColumnIdentifier?
        /// The source sheet control ID of a CascadingControlSource.
        public var sourceSheetControlId: Swift.String?

        public init(
            columnToMatch: QuickSightClientTypes.ColumnIdentifier? = nil,
            sourceSheetControlId: Swift.String? = nil
        )
        {
            self.columnToMatch = columnToMatch
            self.sourceSheetControlId = sourceSheetControlId
        }
    }
}

extension QuickSightClientTypes {

    /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
    public struct CascadingControlConfiguration: Swift.Sendable {
        /// A list of source controls that determine the values that are used in the current control.
        public var sourceControls: [QuickSightClientTypes.CascadingControlSource]?

        public init(
            sourceControls: [QuickSightClientTypes.CascadingControlSource]? = nil
        )
        {
            self.sourceControls = sourceControls
        }
    }
}

extension QuickSightClientTypes {

    /// A control from a filter that is scoped across more than one sheet. This represents your filter control on a sheet
    public struct FilterCrossSheetControl: Swift.Sendable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The ID of the FilterCrossSheetControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterCrossSheetControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?

        public init(
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
        }
    }
}

extension QuickSightClientTypes {

    /// A control from a date filter that is used to specify date and time.
    public struct FilterDateTimePickerControl: Swift.Sendable {
        /// The visibility configurationof the Apply button on a DateTimePickerControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions?
        /// The ID of the FilterDateTimePickerControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterDateTimePickerControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterDateTimePickerControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the FilterDropDownControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from a dropdown menu.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public var type: QuickSightClientTypes.SheetControlDateTimePickerType?

        public init(
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlDateTimePickerType? = nil
        )
        {
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a dropdown list with buttons that are used to select a single value.
    public struct FilterDropDownControl: Swift.Sendable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The visibility configuration of the Apply button on a FilterDropDownControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of the FilterDropDownControl.
        public var displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions?
        /// The ID of the FilterDropDownControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The source filter ID of the FilterDropDownControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterDropDownControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the FilterDropDownControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from a dropdown menu.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from a dropdown menu.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
    public struct FilterListControl: Swift.Sendable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.ListControlDisplayOptions?
        /// The ID of the FilterListControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.FilterSelectableValues?
        /// The source filter ID of the FilterListControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterListControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the FilterListControl. Choose one of the following options:
        ///
        /// * MULTI_SELECT: The user can select multiple entries from the list.
        ///
        /// * SINGLE_SELECT: The user can select a single entry from the list.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.ListControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.FilterSelectableValues? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.selectableValues = selectableValues
            self.sourceFilterId = sourceFilterId
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control from a date filter that is used to specify the relative date.
    public struct FilterRelativeDateTimeControl: Swift.Sendable {
        /// The visibility configuration of the Apply button on a FilterRelativeDateTimeControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextAreaControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
    public struct FilterSliderControl: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.SliderControlDisplayOptions?
        /// The ID of the FilterSliderControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The larger value that is displayed at the right of the slider.
        /// This member is required.
        public var maximumValue: Swift.Double
        /// The smaller value that is displayed at the left of the slider.
        /// This member is required.
        public var minimumValue: Swift.Double
        /// The source filter ID of the FilterSliderControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The number of increments that the slider bar is divided into.
        /// This member is required.
        public var stepSize: Swift.Double
        /// The title of the FilterSliderControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of the FilterSliderControl. Choose one of the following options:
        ///
        /// * SINGLE_POINT: Filter against(equals) a single data point.
        ///
        /// * RANGE: Filter data that is in a specified range.
        public var type: QuickSightClientTypes.SheetControlSliderType?

        public init(
            displayOptions: QuickSightClientTypes.SliderControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            sourceFilterId: Swift.String? = nil,
            stepSize: Swift.Double = 0.0,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlSliderType? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.sourceFilterId = sourceFilterId
            self.stepSize = stepSize
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a text box that is used to enter multiple entries.
    public struct FilterTextAreaControl: Swift.Sendable {
        /// The delimiter that is used to separate the lines in text.
        public var delimiter: Swift.String?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions?
        /// The ID of the FilterTextAreaControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextAreaControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            delimiter: Swift.String? = nil,
            displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a text box that is used to enter a single entry.
    public struct FilterTextFieldControl: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions?
        /// The ID of the FilterTextFieldControl.
        /// This member is required.
        public var filterControlId: Swift.String?
        /// The source filter ID of the FilterTextFieldControl.
        /// This member is required.
        public var sourceFilterId: Swift.String?
        /// The title of the FilterTextFieldControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions? = nil,
            filterControlId: Swift.String? = nil,
            sourceFilterId: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.filterControlId = filterControlId
            self.sourceFilterId = sourceFilterId
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// The control of a filter that is used to interact with a dashboard or an analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterControl: Swift.Sendable {
        /// A control from a filter that is scoped across more than one sheet. This represents your filter control on a sheet
        public var crossSheet: QuickSightClientTypes.FilterCrossSheetControl?
        /// A control from a date filter that is used to specify date and time.
        public var dateTimePicker: QuickSightClientTypes.FilterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public var dropdown: QuickSightClientTypes.FilterDropDownControl?
        /// A control to display a list of buttons or boxes. This is used to select either a single value or multiple values.
        public var list: QuickSightClientTypes.FilterListControl?
        /// A control from a date filter that is used to specify the relative date.
        public var relativeDateTime: QuickSightClientTypes.FilterRelativeDateTimeControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public var slider: QuickSightClientTypes.FilterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public var textArea: QuickSightClientTypes.FilterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public var textField: QuickSightClientTypes.FilterTextFieldControl?

        public init(
            crossSheet: QuickSightClientTypes.FilterCrossSheetControl? = nil,
            dateTimePicker: QuickSightClientTypes.FilterDateTimePickerControl? = nil,
            dropdown: QuickSightClientTypes.FilterDropDownControl? = nil,
            list: QuickSightClientTypes.FilterListControl? = nil,
            relativeDateTime: QuickSightClientTypes.FilterRelativeDateTimeControl? = nil,
            slider: QuickSightClientTypes.FilterSliderControl? = nil,
            textArea: QuickSightClientTypes.FilterTextAreaControl? = nil,
            textField: QuickSightClientTypes.FilterTextFieldControl? = nil
        )
        {
            self.crossSheet = crossSheet
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.relativeDateTime = relativeDateTime
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }
    }
}

extension QuickSightClientTypes {

    /// The background style configuration of a free-form layout element.
    public struct FreeFormLayoutElementBackgroundStyle: Swift.Sendable {
        /// The background color of a free-form layout element.
        public var color: Swift.String?
        /// The background visibility of a free-form layout element.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            color: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.color = color
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The background style configuration of a free-form layout element.
    public struct FreeFormLayoutElementBorderStyle: Swift.Sendable {
        /// The border color of a free-form layout element.
        public var color: Swift.String?
        /// The border visibility of a free-form layout element.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            color: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.color = color
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum LayoutElementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case filterControl
        case parameterControl
        case textBox
        case visual
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutElementType] {
            return [
                .filterControl,
                .parameterControl,
                .textBox,
                .visual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .filterControl: return "FILTER_CONTROL"
            case .parameterControl: return "PARAMETER_CONTROL"
            case .textBox: return "TEXT_BOX"
            case .visual: return "VISUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of loading animation in free-form layout.
    public struct LoadingAnimation: Swift.Sendable {
        /// The visibility configuration of LoadingAnimation.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The override configuration of the rendering rules of a sheet.
    public struct SheetElementConfigurationOverrides: Swift.Sendable {
        /// Determines whether or not the overrides are visible. Choose one of the following options:
        ///
        /// * VISIBLE
        ///
        /// * HIDDEN
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The rendering rules of a sheet that uses a free-form layout.
    public struct SheetElementRenderingRule: Swift.Sendable {
        /// The override configuration of the rendering rules of a sheet.
        /// This member is required.
        public var configurationOverrides: QuickSightClientTypes.SheetElementConfigurationOverrides?
        /// The expression of the rendering rules of a sheet.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            configurationOverrides: QuickSightClientTypes.SheetElementConfigurationOverrides? = nil,
            expression: Swift.String? = nil
        )
        {
            self.configurationOverrides = configurationOverrides
            self.expression = expression
        }
    }
}

extension QuickSightClientTypes.SheetElementRenderingRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SheetElementRenderingRule(configurationOverrides: \(Swift.String(describing: configurationOverrides)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// An element within a free-form layout.
    public struct FreeFormLayoutElement: Swift.Sendable {
        /// The background style configuration of a free-form layout element.
        public var backgroundStyle: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle?
        /// The border style configuration of a free-form layout element.
        public var borderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle?
        /// A unique identifier for an element within a free-form layout.
        /// This member is required.
        public var elementId: Swift.String?
        /// The type of element.
        /// This member is required.
        public var elementType: QuickSightClientTypes.LayoutElementType?
        /// The height of an element within a free-form layout.
        /// This member is required.
        public var height: Swift.String?
        /// The loading animation configuration of a free-form layout element.
        public var loadingAnimation: QuickSightClientTypes.LoadingAnimation?
        /// The rendering rules that determine when an element should be displayed within a free-form layout.
        public var renderingRules: [QuickSightClientTypes.SheetElementRenderingRule]?
        /// The border style configuration of a free-form layout element. This border style is used when the element is selected.
        public var selectedBorderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle?
        /// The visibility of an element within a free-form layout.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width of an element within a free-form layout.
        /// This member is required.
        public var width: Swift.String?
        /// The x-axis coordinate of the element.
        /// This member is required.
        public var xAxisLocation: Swift.String?
        /// The y-axis coordinate of the element.
        /// This member is required.
        public var yAxisLocation: Swift.String?

        public init(
            backgroundStyle: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle? = nil,
            borderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle? = nil,
            elementId: Swift.String? = nil,
            elementType: QuickSightClientTypes.LayoutElementType? = nil,
            height: Swift.String? = nil,
            loadingAnimation: QuickSightClientTypes.LoadingAnimation? = nil,
            renderingRules: [QuickSightClientTypes.SheetElementRenderingRule]? = nil,
            selectedBorderStyle: QuickSightClientTypes.FreeFormLayoutElementBorderStyle? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil,
            xAxisLocation: Swift.String? = nil,
            yAxisLocation: Swift.String? = nil
        )
        {
            self.backgroundStyle = backgroundStyle
            self.borderStyle = borderStyle
            self.elementId = elementId
            self.elementType = elementType
            self.height = height
            self.loadingAnimation = loadingAnimation
            self.renderingRules = renderingRules
            self.selectedBorderStyle = selectedBorderStyle
            self.visibility = visibility
            self.width = width
            self.xAxisLocation = xAxisLocation
            self.yAxisLocation = yAxisLocation
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a free-form layout.
    public struct FreeFormLayoutConfiguration: Swift.Sendable {
        /// Configuration options for the canvas of a free-form layout.
        public var canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions?
        /// The elements that are included in a free-form layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.FreeFormLayoutElement]?

        public init(
            canvasSizeOptions: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions? = nil,
            elements: [QuickSightClientTypes.FreeFormLayoutElement]? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }
    }
}

extension QuickSightClientTypes {

    /// An element within a grid layout.
    public struct GridLayoutElement: Swift.Sendable {
        /// The column index for the upper left corner of an element.
        public var columnIndex: Swift.Int?
        /// The width of a grid element expressed as a number of grid columns.
        /// This member is required.
        public var columnSpan: Swift.Int?
        /// A unique identifier for an element within a grid layout.
        /// This member is required.
        public var elementId: Swift.String?
        /// The type of element.
        /// This member is required.
        public var elementType: QuickSightClientTypes.LayoutElementType?
        /// The row index for the upper left corner of an element.
        public var rowIndex: Swift.Int?
        /// The height of a grid element expressed as a number of grid rows.
        /// This member is required.
        public var rowSpan: Swift.Int?

        public init(
            columnIndex: Swift.Int? = nil,
            columnSpan: Swift.Int? = nil,
            elementId: Swift.String? = nil,
            elementType: QuickSightClientTypes.LayoutElementType? = nil,
            rowIndex: Swift.Int? = nil,
            rowSpan: Swift.Int? = nil
        )
        {
            self.columnIndex = columnIndex
            self.columnSpan = columnSpan
            self.elementId = elementId
            self.elementType = elementType
            self.rowIndex = rowIndex
            self.rowSpan = rowSpan
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a grid layout. Also called a tiled layout. Visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size.
    public struct GridLayoutConfiguration: Swift.Sendable {
        /// Configuration options for the canvas of a grid layout.
        public var canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions?
        /// The elements that are included in a grid layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.GridLayoutElement]?

        public init(
            canvasSizeOptions: QuickSightClientTypes.GridLayoutCanvasSizeOptions? = nil,
            elements: [QuickSightClientTypes.GridLayoutElement]? = nil
        )
        {
            self.canvasSizeOptions = canvasSizeOptions
            self.elements = elements
        }
    }
}

extension QuickSightClientTypes {

    /// The free-form layout configuration of a section.
    public struct FreeFormSectionLayoutConfiguration: Swift.Sendable {
        /// The elements that are included in the free-form layout.
        /// This member is required.
        public var elements: [QuickSightClientTypes.FreeFormLayoutElement]?

        public init(
            elements: [QuickSightClientTypes.FreeFormLayoutElement]? = nil
        )
        {
            self.elements = elements
        }
    }
}

extension QuickSightClientTypes {

    /// The layout configuration of a section.
    public struct SectionLayoutConfiguration: Swift.Sendable {
        /// The free-form layout configuration of a section.
        /// This member is required.
        public var freeFormLayout: QuickSightClientTypes.FreeFormSectionLayoutConfiguration?

        public init(
            freeFormLayout: QuickSightClientTypes.FreeFormSectionLayoutConfiguration? = nil
        )
        {
            self.freeFormLayout = freeFormLayout
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of content in a body section.
    public struct BodySectionContent: Swift.Sendable {
        /// The layout configuration of a body section.
        public var layout: QuickSightClientTypes.SectionLayoutConfiguration?

        public init(
            layout: QuickSightClientTypes.SectionLayoutConfiguration? = nil
        )
        {
            self.layout = layout
        }
    }
}

extension QuickSightClientTypes {

    public enum SectionPageBreakStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SectionPageBreakStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a page break after a section.
    public struct SectionAfterPageBreak: Swift.Sendable {
        /// The option that enables or disables a page break at the end of a section.
        public var status: QuickSightClientTypes.SectionPageBreakStatus?

        public init(
            status: QuickSightClientTypes.SectionPageBreakStatus? = nil
        )
        {
            self.status = status
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a page break for a section.
    public struct SectionPageBreakConfiguration: Swift.Sendable {
        /// The configuration of a page break after a section.
        public var after: QuickSightClientTypes.SectionAfterPageBreak?

        public init(
            after: QuickSightClientTypes.SectionAfterPageBreak? = nil
        )
        {
            self.after = after
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration for a column that is not used in a field well.
    public struct ColumnSort: Swift.Sendable {
        /// The aggregation function that is defined in the column sort.
        public var aggregationFunction: QuickSightClientTypes.AggregationFunction?
        /// The sort direction.
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// A column of a data set.
        /// This member is required.
        public var sortBy: QuickSightClientTypes.ColumnIdentifier?

        public init(
            aggregationFunction: QuickSightClientTypes.AggregationFunction? = nil,
            direction: QuickSightClientTypes.SortDirection? = nil,
            sortBy: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.direction = direction
            self.sortBy = sortBy
        }
    }
}

extension QuickSightClientTypes {

    /// Describes the Category dataset column and constraints for the dynamic values used to repeat the contents of a section.
    public struct BodySectionDynamicCategoryDimensionConfiguration: Swift.Sendable {
        /// A column of a data set.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// Number of values to use from the column for repetition.
        public var limit: Swift.Int?
        /// Sort criteria on the column values that you use for repetition.
        public var sortByMetrics: [QuickSightClientTypes.ColumnSort]?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            limit: Swift.Int? = nil,
            sortByMetrics: [QuickSightClientTypes.ColumnSort]? = nil
        )
        {
            self.column = column
            self.limit = limit
            self.sortByMetrics = sortByMetrics
        }
    }
}

extension QuickSightClientTypes {

    /// Describes the Numeric dataset column and constraints for the dynamic values used to repeat the contents of a section.
    public struct BodySectionDynamicNumericDimensionConfiguration: Swift.Sendable {
        /// A column of a data set.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// Number of values to use from the column for repetition.
        public var limit: Swift.Int?
        /// Sort criteria on the column values that you use for repetition.
        public var sortByMetrics: [QuickSightClientTypes.ColumnSort]?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            limit: Swift.Int? = nil,
            sortByMetrics: [QuickSightClientTypes.ColumnSort]? = nil
        )
        {
            self.column = column
            self.limit = limit
            self.sortByMetrics = sortByMetrics
        }
    }
}

extension QuickSightClientTypes {

    /// Describes the dataset column and constraints for the dynamic values used to repeat the contents of a section. The dataset column is either Category or Numeric column configuration
    public struct BodySectionRepeatDimensionConfiguration: Swift.Sendable {
        /// Describes the Category dataset column and constraints around the dynamic values that will be used in repeating the section contents.
        public var dynamicCategoryDimensionConfiguration: QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration?
        /// Describes the Numeric dataset column and constraints around the dynamic values used to repeat the contents of a section.
        public var dynamicNumericDimensionConfiguration: QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration?

        public init(
            dynamicCategoryDimensionConfiguration: QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration? = nil,
            dynamicNumericDimensionConfiguration: QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration? = nil
        )
        {
            self.dynamicCategoryDimensionConfiguration = dynamicCategoryDimensionConfiguration
            self.dynamicNumericDimensionConfiguration = dynamicNumericDimensionConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The page break configuration to apply for each repeating instance.
    public struct BodySectionRepeatPageBreakConfiguration: Swift.Sendable {
        /// The configuration of a page break after a section.
        public var after: QuickSightClientTypes.SectionAfterPageBreak?

        public init(
            after: QuickSightClientTypes.SectionAfterPageBreak? = nil
        )
        {
            self.after = after
        }
    }
}

extension QuickSightClientTypes {

    /// Describes the configurations that are required to declare a section as repeating.
    public struct BodySectionRepeatConfiguration: Swift.Sendable {
        /// List of BodySectionRepeatDimensionConfiguration values that describe the dataset column and constraints for the column used to repeat the contents of a section.
        public var dimensionConfigurations: [QuickSightClientTypes.BodySectionRepeatDimensionConfiguration]?
        /// List of visuals to exclude from repetition in repeating sections. The visuals will render identically, and ignore the repeating configurations in all repeating instances.
        public var nonRepeatingVisuals: [Swift.String]?
        /// Page break configuration to apply for each repeating instance.
        public var pageBreakConfiguration: QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration?

        public init(
            dimensionConfigurations: [QuickSightClientTypes.BodySectionRepeatDimensionConfiguration]? = nil,
            nonRepeatingVisuals: [Swift.String]? = nil,
            pageBreakConfiguration: QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration? = nil
        )
        {
            self.dimensionConfigurations = dimensionConfigurations
            self.nonRepeatingVisuals = nonRepeatingVisuals
            self.pageBreakConfiguration = pageBreakConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The options that style a section.
    public struct SectionStyle: Swift.Sendable {
        /// The height of a section. Heights can only be defined for header and footer sections. The default height margin is 0.5 inches.
        public var height: Swift.String?
        /// The spacing between section content and its top, bottom, left, and right edges. There is no padding by default.
        public var padding: QuickSightClientTypes.Spacing?

        public init(
            height: Swift.String? = nil,
            padding: QuickSightClientTypes.Spacing? = nil
        )
        {
            self.height = height
            self.padding = padding
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a body section.
    public struct BodySectionConfiguration: Swift.Sendable {
        /// The configuration of content in a body section.
        /// This member is required.
        public var content: QuickSightClientTypes.BodySectionContent?
        /// The configuration of a page break for a section.
        public var pageBreakConfiguration: QuickSightClientTypes.SectionPageBreakConfiguration?
        /// Describes the configurations that are required to declare a section as repeating.
        public var repeatConfiguration: QuickSightClientTypes.BodySectionRepeatConfiguration?
        /// The unique identifier of a body section.
        /// This member is required.
        public var sectionId: Swift.String?
        /// The style options of a body section.
        public var style: QuickSightClientTypes.SectionStyle?

        public init(
            content: QuickSightClientTypes.BodySectionContent? = nil,
            pageBreakConfiguration: QuickSightClientTypes.SectionPageBreakConfiguration? = nil,
            repeatConfiguration: QuickSightClientTypes.BodySectionRepeatConfiguration? = nil,
            sectionId: Swift.String? = nil,
            style: QuickSightClientTypes.SectionStyle? = nil
        )
        {
            self.content = content
            self.pageBreakConfiguration = pageBreakConfiguration
            self.repeatConfiguration = repeatConfiguration
            self.sectionId = sectionId
            self.style = style
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a header or footer section.
    public struct HeaderFooterSectionConfiguration: Swift.Sendable {
        /// The layout configuration of the header or footer section.
        /// This member is required.
        public var layout: QuickSightClientTypes.SectionLayoutConfiguration?
        /// The unique identifier of the header or footer section.
        /// This member is required.
        public var sectionId: Swift.String?
        /// The style options of a header or footer section.
        public var style: QuickSightClientTypes.SectionStyle?

        public init(
            layout: QuickSightClientTypes.SectionLayoutConfiguration? = nil,
            sectionId: Swift.String? = nil,
            style: QuickSightClientTypes.SectionStyle? = nil
        )
        {
            self.layout = layout
            self.sectionId = sectionId
            self.style = style
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a section-based layout.
    public struct SectionBasedLayoutConfiguration: Swift.Sendable {
        /// A list of body section configurations.
        /// This member is required.
        public var bodySections: [QuickSightClientTypes.BodySectionConfiguration]?
        /// The options for the canvas of a section-based layout.
        /// This member is required.
        public var canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions?
        /// A list of footer section configurations.
        /// This member is required.
        public var footerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]?
        /// A list of header section configurations.
        /// This member is required.
        public var headerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]?

        public init(
            bodySections: [QuickSightClientTypes.BodySectionConfiguration]? = nil,
            canvasSizeOptions: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions? = nil,
            footerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil,
            headerSections: [QuickSightClientTypes.HeaderFooterSectionConfiguration]? = nil
        )
        {
            self.bodySections = bodySections
            self.canvasSizeOptions = canvasSizeOptions
            self.footerSections = footerSections
            self.headerSections = headerSections
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration that determines what the type of layout will be used on a sheet. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct LayoutConfiguration: Swift.Sendable {
        /// A free-form is optimized for a fixed width and has more control over the exact placement of layout elements.
        public var freeFormLayout: QuickSightClientTypes.FreeFormLayoutConfiguration?
        /// A type of layout that can be used on a sheet. In a grid layout, visuals snap to a grid with standard spacing and alignment. Dashboards are displayed as designed, with options to fit to screen or view at actual size. A grid layout can be configured to behave in one of two ways when the viewport is resized: FIXED or RESPONSIVE.
        public var gridLayout: QuickSightClientTypes.GridLayoutConfiguration?
        /// A section based layout organizes visuals into multiple sections and has customized header, footer and page break.
        public var sectionBasedLayout: QuickSightClientTypes.SectionBasedLayoutConfiguration?

        public init(
            freeFormLayout: QuickSightClientTypes.FreeFormLayoutConfiguration? = nil,
            gridLayout: QuickSightClientTypes.GridLayoutConfiguration? = nil,
            sectionBasedLayout: QuickSightClientTypes.SectionBasedLayoutConfiguration? = nil
        )
        {
            self.freeFormLayout = freeFormLayout
            self.gridLayout = gridLayout
            self.sectionBasedLayout = sectionBasedLayout
        }
    }
}

extension QuickSightClientTypes {

    /// A Layout defines the placement of elements within a sheet. For more information, see [Types of layout](https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html) in the Amazon QuickSight User Guide. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Layout: Swift.Sendable {
        /// The configuration that determines what the type of layout for a sheet.
        /// This member is required.
        public var configuration: QuickSightClientTypes.LayoutConfiguration?

        public init(
            configuration: QuickSightClientTypes.LayoutConfiguration? = nil
        )
        {
            self.configuration = configuration
        }
    }
}

extension QuickSightClientTypes {

    /// A control from a date parameter that specifies date and time.
    public struct ParameterDateTimePickerControl: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions?
        /// The ID of the ParameterDateTimePickerControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The name of the ParameterDateTimePickerControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterDateTimePickerControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            displayOptions: QuickSightClientTypes.DateTimePickerControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A list of selectable values that are used in a control.
    public struct ParameterSelectableValues: Swift.Sendable {
        /// The column identifier that fetches values from the data set.
        public var linkToDataSetColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The values that are used in ParameterSelectableValues.
        public var values: [Swift.String]?

        public init(
            linkToDataSetColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.linkToDataSetColumn = linkToDataSetColumn
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a dropdown list with buttons that are used to select a single value.
    public struct ParameterDropDownControl: Swift.Sendable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The visibility configuration of the Apply button on a ParameterDropDownControl.
        public var commitMode: QuickSightClientTypes.CommitMode?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions?
        /// The ID of the ParameterDropDownControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.ParameterSelectableValues?
        /// The source parameter name of the ParameterDropDownControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterDropDownControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type parameter name of the ParameterDropDownControl.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            commitMode: QuickSightClientTypes.CommitMode? = nil,
            displayOptions: QuickSightClientTypes.DropDownControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.ParameterSelectableValues? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.commitMode = commitMode
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
    public struct ParameterListControl: Swift.Sendable {
        /// The values that are displayed in a control can be configured to only show values that are valid based on what's selected in other controls.
        public var cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.ListControlDisplayOptions?
        /// The ID of the ParameterListControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// A list of selectable values that are used in a control.
        public var selectableValues: QuickSightClientTypes.ParameterSelectableValues?
        /// The source parameter name of the ParameterListControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterListControl.
        /// This member is required.
        public var title: Swift.String?
        /// The type of ParameterListControl.
        public var type: QuickSightClientTypes.SheetControlListType?

        public init(
            cascadingControlConfiguration: QuickSightClientTypes.CascadingControlConfiguration? = nil,
            displayOptions: QuickSightClientTypes.ListControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            selectableValues: QuickSightClientTypes.ParameterSelectableValues? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil,
            type: QuickSightClientTypes.SheetControlListType? = nil
        )
        {
            self.cascadingControlConfiguration = cascadingControlConfiguration
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.selectableValues = selectableValues
            self.sourceParameterName = sourceParameterName
            self.title = title
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
    public struct ParameterSliderControl: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.SliderControlDisplayOptions?
        /// The larger value that is displayed at the right of the slider.
        /// This member is required.
        public var maximumValue: Swift.Double
        /// The smaller value that is displayed at the left of the slider.
        /// This member is required.
        public var minimumValue: Swift.Double
        /// The ID of the ParameterSliderControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterSliderControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The number of increments that the slider bar is divided into.
        /// This member is required.
        public var stepSize: Swift.Double
        /// The title of the ParameterSliderControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            displayOptions: QuickSightClientTypes.SliderControlDisplayOptions? = nil,
            maximumValue: Swift.Double = 0.0,
            minimumValue: Swift.Double = 0.0,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            stepSize: Swift.Double = 0.0,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.maximumValue = maximumValue
            self.minimumValue = minimumValue
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.stepSize = stepSize
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a text box that is used to enter multiple entries.
    public struct ParameterTextAreaControl: Swift.Sendable {
        /// The delimiter that is used to separate the lines in text.
        public var delimiter: Swift.String?
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions?
        /// The ID of the ParameterTextAreaControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterTextAreaControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterTextAreaControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            delimiter: Swift.String? = nil,
            displayOptions: QuickSightClientTypes.TextAreaControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.delimiter = delimiter
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// A control to display a text box that is used to enter a single entry.
    public struct ParameterTextFieldControl: Swift.Sendable {
        /// The display options of a control.
        public var displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions?
        /// The ID of the ParameterTextFieldControl.
        /// This member is required.
        public var parameterControlId: Swift.String?
        /// The source parameter name of the ParameterTextFieldControl.
        /// This member is required.
        public var sourceParameterName: Swift.String?
        /// The title of the ParameterTextFieldControl.
        /// This member is required.
        public var title: Swift.String?

        public init(
            displayOptions: QuickSightClientTypes.TextFieldControlDisplayOptions? = nil,
            parameterControlId: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.displayOptions = displayOptions
            self.parameterControlId = parameterControlId
            self.sourceParameterName = sourceParameterName
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    /// The control of a parameter that users can interact with in a dashboard or an analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ParameterControl: Swift.Sendable {
        /// A control from a date parameter that specifies date and time.
        public var dateTimePicker: QuickSightClientTypes.ParameterDateTimePickerControl?
        /// A control to display a dropdown list with buttons that are used to select a single value.
        public var dropdown: QuickSightClientTypes.ParameterDropDownControl?
        /// A control to display a list with buttons or boxes that are used to select either a single value or multiple values.
        public var list: QuickSightClientTypes.ParameterListControl?
        /// A control to display a horizontal toggle bar. This is used to change a value by sliding the toggle.
        public var slider: QuickSightClientTypes.ParameterSliderControl?
        /// A control to display a text box that is used to enter multiple entries.
        public var textArea: QuickSightClientTypes.ParameterTextAreaControl?
        /// A control to display a text box that is used to enter a single entry.
        public var textField: QuickSightClientTypes.ParameterTextFieldControl?

        public init(
            dateTimePicker: QuickSightClientTypes.ParameterDateTimePickerControl? = nil,
            dropdown: QuickSightClientTypes.ParameterDropDownControl? = nil,
            list: QuickSightClientTypes.ParameterListControl? = nil,
            slider: QuickSightClientTypes.ParameterSliderControl? = nil,
            textArea: QuickSightClientTypes.ParameterTextAreaControl? = nil,
            textField: QuickSightClientTypes.ParameterTextFieldControl? = nil
        )
        {
            self.dateTimePicker = dateTimePicker
            self.dropdown = dropdown
            self.list = list
            self.slider = slider
            self.textArea = textArea
            self.textField = textField
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration that determines the elements and canvas size options of sheet control.
    public struct SheetControlLayoutConfiguration: Swift.Sendable {
        /// The configuration that determines the elements and canvas size options of sheet control.
        public var gridLayout: QuickSightClientTypes.GridLayoutConfiguration?

        public init(
            gridLayout: QuickSightClientTypes.GridLayoutConfiguration? = nil
        )
        {
            self.gridLayout = gridLayout
        }
    }
}

extension QuickSightClientTypes {

    /// A grid layout to define the placement of sheet control.
    public struct SheetControlLayout: Swift.Sendable {
        /// The configuration that determines the elements and canvas size options of sheet control.
        /// This member is required.
        public var configuration: QuickSightClientTypes.SheetControlLayoutConfiguration?

        public init(
            configuration: QuickSightClientTypes.SheetControlLayoutConfiguration? = nil
        )
        {
            self.configuration = configuration
        }
    }
}

extension QuickSightClientTypes {

    /// A text box.
    public struct SheetTextBox: Swift.Sendable {
        /// The content that is displayed in the text box.
        public var content: Swift.String?
        /// The unique identifier for a text box. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have text boxes that share identifiers.
        /// This member is required.
        public var sheetTextBoxId: Swift.String?

        public init(
            content: Swift.String? = nil,
            sheetTextBoxId: Swift.String? = nil
        )
        {
            self.content = content
            self.sheetTextBoxId = sheetTextBoxId
        }
    }
}

extension QuickSightClientTypes {

    public enum SelectedFieldOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allFields
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectedFieldOptions] {
            return [
                .allFields
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allFields: return "ALL_FIELDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of selected fields in theCustomActionFilterOperation. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterOperationSelectedFieldsConfiguration: Swift.Sendable {
        /// The selected columns of a dataset.
        public var selectedColumns: [QuickSightClientTypes.ColumnIdentifier]?
        /// A structure that contains the options that choose which fields are filtered in the CustomActionFilterOperation. Valid values are defined as follows:
        ///
        /// * ALL_FIELDS: Applies the filter operation to all fields.
        public var selectedFieldOptions: QuickSightClientTypes.SelectedFieldOptions?
        /// Chooses the fields that are filtered in CustomActionFilterOperation.
        public var selectedFields: [Swift.String]?

        public init(
            selectedColumns: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            selectedFieldOptions: QuickSightClientTypes.SelectedFieldOptions? = nil,
            selectedFields: [Swift.String]? = nil
        )
        {
            self.selectedColumns = selectedColumns
            self.selectedFieldOptions = selectedFieldOptions
            self.selectedFields = selectedFields
        }
    }
}

extension QuickSightClientTypes {

    public enum TargetVisualOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allVisuals
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetVisualOptions] {
            return [
                .allVisuals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allVisuals: return "ALL_VISUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of the same-sheet target visuals that you want to be filtered. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SameSheetTargetVisualConfiguration: Swift.Sendable {
        /// The options that choose the target visual in the same sheet. Valid values are defined as follows:
        ///
        /// * ALL_VISUALS: Applies the filter operation to all visuals in the same sheet.
        public var targetVisualOptions: QuickSightClientTypes.TargetVisualOptions?
        /// A list of the target visual IDs that are located in the same sheet of the analysis.
        public var targetVisuals: [Swift.String]?

        public init(
            targetVisualOptions: QuickSightClientTypes.TargetVisualOptions? = nil,
            targetVisuals: [Swift.String]? = nil
        )
        {
            self.targetVisualOptions = targetVisualOptions
            self.targetVisuals = targetVisuals
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of target visuals that you want to be filtered. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilterOperationTargetVisualsConfiguration: Swift.Sendable {
        /// The configuration of the same-sheet target visuals that you want to be filtered.
        public var sameSheetTargetVisualConfiguration: QuickSightClientTypes.SameSheetTargetVisualConfiguration?

        public init(
            sameSheetTargetVisualConfiguration: QuickSightClientTypes.SameSheetTargetVisualConfiguration? = nil
        )
        {
            self.sameSheetTargetVisualConfiguration = sameSheetTargetVisualConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The filter operation that filters data included in a visual or in an entire sheet.
    public struct CustomActionFilterOperation: Swift.Sendable {
        /// The configuration that chooses the fields to be filtered.
        /// This member is required.
        public var selectedFieldsConfiguration: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration?
        /// The configuration that chooses the target visuals to be filtered.
        /// This member is required.
        public var targetVisualsConfiguration: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration?

        public init(
            selectedFieldsConfiguration: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration? = nil,
            targetVisualsConfiguration: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration? = nil
        )
        {
            self.selectedFieldsConfiguration = selectedFieldsConfiguration
            self.targetVisualsConfiguration = targetVisualsConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The navigation configuration for CustomActionNavigationOperation.
    public struct LocalNavigationConfiguration: Swift.Sendable {
        /// The sheet that is targeted for navigation in the same analysis.
        /// This member is required.
        public var targetSheetId: Swift.String?

        public init(
            targetSheetId: Swift.String? = nil
        )
        {
            self.targetSheetId = targetSheetId
        }
    }
}

extension QuickSightClientTypes {

    /// The navigation operation that navigates between different sheets in the same analysis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CustomActionNavigationOperation: Swift.Sendable {
        /// The configuration that chooses the navigation target.
        public var localNavigationConfiguration: QuickSightClientTypes.LocalNavigationConfiguration?

        public init(
            localNavigationConfiguration: QuickSightClientTypes.LocalNavigationConfiguration? = nil
        )
        {
            self.localNavigationConfiguration = localNavigationConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The customized parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct CustomParameterValues: Swift.Sendable {
        /// A list of datetime-type parameter values.
        public var dateTimeValues: [Foundation.Date]?
        /// A list of decimal-type parameter values.
        public var decimalValues: [Swift.Double]?
        /// A list of integer-type parameter values.
        public var integerValues: [Swift.Int]?
        /// A list of string-type parameter values.
        public var stringValues: [Swift.String]?

        public init(
            dateTimeValues: [Foundation.Date]? = nil,
            decimalValues: [Swift.Double]? = nil,
            integerValues: [Swift.Int]? = nil,
            stringValues: [Swift.String]? = nil
        )
        {
            self.dateTimeValues = dateTimeValues
            self.decimalValues = decimalValues
            self.integerValues = integerValues
            self.stringValues = stringValues
        }
    }
}

extension QuickSightClientTypes.CustomParameterValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomParameterValues(dateTimeValues: \"CONTENT_REDACTED\", decimalValues: \"CONTENT_REDACTED\", integerValues: \"CONTENT_REDACTED\", stringValues: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The configuration of custom values for the destination parameter in DestinationParameterValueConfiguration.
    public struct CustomValuesConfiguration: Swift.Sendable {
        /// The customized parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var customValues: QuickSightClientTypes.CustomParameterValues?
        /// Includes the null value in custom action parameter values.
        public var includeNullValue: Swift.Bool?

        public init(
            customValues: QuickSightClientTypes.CustomParameterValues? = nil,
            includeNullValue: Swift.Bool? = nil
        )
        {
            self.customValues = customValues
            self.includeNullValue = includeNullValue
        }
    }
}

extension QuickSightClientTypes {

    public enum SelectAllValueOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allValues
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectAllValueOptions] {
            return [
                .allValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allValues: return "ALL_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of destination parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DestinationParameterValueConfiguration: Swift.Sendable {
        /// The configuration of custom values for destination parameter in DestinationParameterValueConfiguration.
        public var customValuesConfiguration: QuickSightClientTypes.CustomValuesConfiguration?
        /// The configuration that selects all options.
        public var selectAllValueOptions: QuickSightClientTypes.SelectAllValueOptions?
        /// A column of a data set.
        public var sourceColumn: QuickSightClientTypes.ColumnIdentifier?
        /// The source field ID of the destination parameter.
        public var sourceField: Swift.String?
        /// The source parameter name of the destination parameter.
        public var sourceParameterName: Swift.String?

        public init(
            customValuesConfiguration: QuickSightClientTypes.CustomValuesConfiguration? = nil,
            selectAllValueOptions: QuickSightClientTypes.SelectAllValueOptions? = nil,
            sourceColumn: QuickSightClientTypes.ColumnIdentifier? = nil,
            sourceField: Swift.String? = nil,
            sourceParameterName: Swift.String? = nil
        )
        {
            self.customValuesConfiguration = customValuesConfiguration
            self.selectAllValueOptions = selectAllValueOptions
            self.sourceColumn = sourceColumn
            self.sourceField = sourceField
            self.sourceParameterName = sourceParameterName
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of adding parameters in action.
    public struct SetParameterValueConfiguration: Swift.Sendable {
        /// The destination parameter name of the SetParameterValueConfiguration.
        /// This member is required.
        public var destinationParameterName: Swift.String?
        /// The configuration of destination parameter values. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var value: QuickSightClientTypes.DestinationParameterValueConfiguration?

        public init(
            destinationParameterName: Swift.String? = nil,
            value: QuickSightClientTypes.DestinationParameterValueConfiguration? = nil
        )
        {
            self.destinationParameterName = destinationParameterName
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The set parameter operation that sets parameters in custom action.
    public struct CustomActionSetParametersOperation: Swift.Sendable {
        /// The parameter that determines the value configuration.
        /// This member is required.
        public var parameterValueConfigurations: [QuickSightClientTypes.SetParameterValueConfiguration]?

        public init(
            parameterValueConfigurations: [QuickSightClientTypes.SetParameterValueConfiguration]? = nil
        )
        {
            self.parameterValueConfigurations = parameterValueConfigurations
        }
    }
}

extension QuickSightClientTypes {

    public enum URLTargetConfiguration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case newTab
        case newWindow
        case sameTab
        case sdkUnknown(Swift.String)

        public static var allCases: [URLTargetConfiguration] {
            return [
                .newTab,
                .newWindow,
                .sameTab
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .newTab: return "NEW_TAB"
            case .newWindow: return "NEW_WINDOW"
            case .sameTab: return "SAME_TAB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The URL operation that opens a link to another webpage.
    public struct CustomActionURLOperation: Swift.Sendable {
        /// The target of the CustomActionURLOperation. Valid values are defined as follows:
        ///
        /// * NEW_TAB: Opens the target URL in a new browser tab.
        ///
        /// * NEW_WINDOW: Opens the target URL in a new browser window.
        ///
        /// * SAME_TAB: Opens the target URL in the same browser tab.
        /// This member is required.
        public var urlTarget: QuickSightClientTypes.URLTargetConfiguration?
        /// THe URL link of the CustomActionURLOperation.
        /// This member is required.
        public var urlTemplate: Swift.String?

        public init(
            urlTarget: QuickSightClientTypes.URLTargetConfiguration? = nil,
            urlTemplate: Swift.String? = nil
        )
        {
            self.urlTarget = urlTarget
            self.urlTemplate = urlTemplate
        }
    }
}

extension QuickSightClientTypes {

    /// The operation that is defined by the custom action. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct VisualCustomActionOperation: Swift.Sendable {
        /// The filter operation that filters data included in a visual or in an entire sheet.
        public var filterOperation: QuickSightClientTypes.CustomActionFilterOperation?
        /// The navigation operation that navigates between different sheets in the same analysis.
        public var navigationOperation: QuickSightClientTypes.CustomActionNavigationOperation?
        /// The set parameter operation that sets parameters in custom action.
        public var setParametersOperation: QuickSightClientTypes.CustomActionSetParametersOperation?
        /// The URL operation that opens a link to another webpage.
        public var urlOperation: QuickSightClientTypes.CustomActionURLOperation?

        public init(
            filterOperation: QuickSightClientTypes.CustomActionFilterOperation? = nil,
            navigationOperation: QuickSightClientTypes.CustomActionNavigationOperation? = nil,
            setParametersOperation: QuickSightClientTypes.CustomActionSetParametersOperation? = nil,
            urlOperation: QuickSightClientTypes.CustomActionURLOperation? = nil
        )
        {
            self.filterOperation = filterOperation
            self.navigationOperation = navigationOperation
            self.setParametersOperation = setParametersOperation
            self.urlOperation = urlOperation
        }
    }
}

extension QuickSightClientTypes {

    public enum VisualCustomActionTrigger: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataPointClick
        case dataPointMenu
        case sdkUnknown(Swift.String)

        public static var allCases: [VisualCustomActionTrigger] {
            return [
                .dataPointClick,
                .dataPointMenu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataPointClick: return "DATA_POINT_CLICK"
            case .dataPointMenu: return "DATA_POINT_MENU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A custom action defined on a visual.
    public struct VisualCustomAction: Swift.Sendable {
        /// A list of VisualCustomActionOperations. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
        /// This member is required.
        public var actionOperations: [QuickSightClientTypes.VisualCustomActionOperation]?
        /// The ID of the VisualCustomAction.
        /// This member is required.
        public var customActionId: Swift.String?
        /// The name of the VisualCustomAction.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the VisualCustomAction.
        public var status: QuickSightClientTypes.WidgetStatus?
        /// The trigger of the VisualCustomAction. Valid values are defined as follows:
        ///
        /// * DATA_POINT_CLICK: Initiates a custom action by a left pointer click on a data point.
        ///
        /// * DATA_POINT_MENU: Initiates a custom action by right pointer click from the menu.
        /// This member is required.
        public var trigger: QuickSightClientTypes.VisualCustomActionTrigger?

        public init(
            actionOperations: [QuickSightClientTypes.VisualCustomActionOperation]? = nil,
            customActionId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil,
            trigger: QuickSightClientTypes.VisualCustomActionTrigger? = nil
        )
        {
            self.actionOperations = actionOperations
            self.customActionId = customActionId
            self.name = name
            self.status = status
            self.trigger = trigger
        }
    }
}

extension QuickSightClientTypes {

    public enum BarsArrangement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clustered
        case stacked
        case stackedPercent
        case sdkUnknown(Swift.String)

        public static var allCases: [BarsArrangement] {
            return [
                .clustered,
                .stacked,
                .stackedPercent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clustered: return "CLUSTERED"
            case .stacked: return "STACKED"
            case .stackedPercent: return "STACKED_PERCENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine how a date axis is displayed.
    public struct DateAxisOptions: Swift.Sendable {
        /// Determines whether or not missing dates are displayed.
        public var missingDateVisibility: QuickSightClientTypes.Visibility?

        public init(
            missingDateVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.missingDateVisibility = missingDateVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options that are saved for future extension.
    public struct AxisDisplayDataDrivenRange: Swift.Sendable {

        public init() { }
    }
}

extension QuickSightClientTypes {

    /// The minimum and maximum setup for an axis display range.
    public struct AxisDisplayMinMaxRange: Swift.Sendable {
        /// The maximum setup for an axis display range.
        public var maximum: Swift.Double?
        /// The minimum setup for an axis display range.
        public var minimum: Swift.Double?

        public init(
            maximum: Swift.Double? = 0.0,
            minimum: Swift.Double? = 0.0
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }
}

extension QuickSightClientTypes {

    /// The range setup of a numeric axis display range. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisDisplayRange: Swift.Sendable {
        /// The data-driven setup of an axis display range.
        public var dataDriven: QuickSightClientTypes.AxisDisplayDataDrivenRange?
        /// The minimum and maximum setup of an axis display range.
        public var minMax: QuickSightClientTypes.AxisDisplayMinMaxRange?

        public init(
            dataDriven: QuickSightClientTypes.AxisDisplayDataDrivenRange? = nil,
            minMax: QuickSightClientTypes.AxisDisplayMinMaxRange? = nil
        )
        {
            self.dataDriven = dataDriven
            self.minMax = minMax
        }
    }
}

extension QuickSightClientTypes {

    /// The liner axis scale setup. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisLinearScale: Swift.Sendable {
        /// The step count setup of a linear axis.
        public var stepCount: Swift.Int?
        /// The step size setup of a linear axis.
        public var stepSize: Swift.Double?

        public init(
            stepCount: Swift.Int? = 0,
            stepSize: Swift.Double? = 0.0
        )
        {
            self.stepCount = stepCount
            self.stepSize = stepSize
        }
    }
}

extension QuickSightClientTypes {

    /// The logarithmic axis scale setup.
    public struct AxisLogarithmicScale: Swift.Sendable {
        /// The base setup of a logarithmic axis scale.
        public var base: Swift.Double?

        public init(
            base: Swift.Double? = 0.0
        )
        {
            self.base = base
        }
    }
}

extension QuickSightClientTypes {

    /// The scale setup options for a numeric axis display. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisScale: Swift.Sendable {
        /// The linear axis scale setup.
        public var linear: QuickSightClientTypes.AxisLinearScale?
        /// The logarithmic axis scale setup.
        public var logarithmic: QuickSightClientTypes.AxisLogarithmicScale?

        public init(
            linear: QuickSightClientTypes.AxisLinearScale? = nil,
            logarithmic: QuickSightClientTypes.AxisLogarithmicScale? = nil
        )
        {
            self.linear = linear
            self.logarithmic = logarithmic
        }
    }
}

extension QuickSightClientTypes {

    /// The options for an axis with a numeric field.
    public struct NumericAxisOptions: Swift.Sendable {
        /// The range setup of a numeric axis.
        public var range: QuickSightClientTypes.AxisDisplayRange?
        /// The scale setup of a numeric axis.
        public var scale: QuickSightClientTypes.AxisScale?

        public init(
            range: QuickSightClientTypes.AxisDisplayRange? = nil,
            scale: QuickSightClientTypes.AxisScale? = nil
        )
        {
            self.range = range
            self.scale = scale
        }
    }
}

extension QuickSightClientTypes {

    /// The data options for an axis. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct AxisDataOptions: Swift.Sendable {
        /// The options for an axis with a date field.
        public var dateAxisOptions: QuickSightClientTypes.DateAxisOptions?
        /// The options for an axis with a numeric field.
        public var numericAxisOptions: QuickSightClientTypes.NumericAxisOptions?

        public init(
            dateAxisOptions: QuickSightClientTypes.DateAxisOptions? = nil,
            numericAxisOptions: QuickSightClientTypes.NumericAxisOptions? = nil
        )
        {
            self.dateAxisOptions = dateAxisOptions
            self.numericAxisOptions = numericAxisOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The percent range in the visible range.
    public struct PercentVisibleRange: Swift.Sendable {
        /// The lower bound of the range.
        public var from: Swift.Double?
        /// The top bound of the range.
        public var to: Swift.Double?

        public init(
            from: Swift.Double? = 0.0,
            to: Swift.Double? = 0.0
        )
        {
            self.from = from
            self.to = to
        }
    }
}

extension QuickSightClientTypes {

    /// The range options for the data zoom scroll bar.
    public struct VisibleRangeOptions: Swift.Sendable {
        /// The percent range in the visible range.
        public var percentRange: QuickSightClientTypes.PercentVisibleRange?

        public init(
            percentRange: QuickSightClientTypes.PercentVisibleRange? = nil
        )
        {
            self.percentRange = percentRange
        }
    }
}

extension QuickSightClientTypes {

    /// The visual display options for a data zoom scroll bar.
    public struct ScrollBarOptions: Swift.Sendable {
        /// The visibility of the data zoom scroll bar.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The visibility range for the data zoom scroll bar.
        public var visibleRange: QuickSightClientTypes.VisibleRangeOptions?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil,
            visibleRange: QuickSightClientTypes.VisibleRangeOptions? = nil
        )
        {
            self.visibility = visibility
            self.visibleRange = visibleRange
        }
    }
}

extension QuickSightClientTypes {

    /// The tick label options of an axis.
    public struct AxisTickLabelOptions: Swift.Sendable {
        /// Determines whether or not the axis ticks are visible.
        public var labelOptions: QuickSightClientTypes.LabelOptions?
        /// The rotation angle of the axis tick labels.
        public var rotationAngle: Swift.Double?

        public init(
            labelOptions: QuickSightClientTypes.LabelOptions? = nil,
            rotationAngle: Swift.Double? = 0.0
        )
        {
            self.labelOptions = labelOptions
            self.rotationAngle = rotationAngle
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for the axis label.
    public struct AxisDisplayOptions: Swift.Sendable {
        /// Determines whether or not the axis line is visible.
        public var axisLineVisibility: QuickSightClientTypes.Visibility?
        /// The offset value that determines the starting placement of the axis within a visual's bounds.
        public var axisOffset: Swift.String?
        /// The data options for an axis.
        public var dataOptions: QuickSightClientTypes.AxisDataOptions?
        /// Determines whether or not the grid line is visible.
        public var gridLineVisibility: QuickSightClientTypes.Visibility?
        /// The scroll bar options for an axis.
        public var scrollbarOptions: QuickSightClientTypes.ScrollBarOptions?
        /// The tick label options of an axis.
        public var tickLabelOptions: QuickSightClientTypes.AxisTickLabelOptions?

        public init(
            axisLineVisibility: QuickSightClientTypes.Visibility? = nil,
            axisOffset: Swift.String? = nil,
            dataOptions: QuickSightClientTypes.AxisDataOptions? = nil,
            gridLineVisibility: QuickSightClientTypes.Visibility? = nil,
            scrollbarOptions: QuickSightClientTypes.ScrollBarOptions? = nil,
            tickLabelOptions: QuickSightClientTypes.AxisTickLabelOptions? = nil
        )
        {
            self.axisLineVisibility = axisLineVisibility
            self.axisOffset = axisOffset
            self.dataOptions = dataOptions
            self.gridLineVisibility = gridLineVisibility
            self.scrollbarOptions = scrollbarOptions
            self.tickLabelOptions = tickLabelOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The reference that specifies where the axis label is applied to.
    public struct AxisLabelReferenceOptions: Swift.Sendable {
        /// The column that the axis label is targeted to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The field that the axis label is targeted to.
        /// This member is required.
        public var fieldId: Swift.String?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
        }
    }
}

extension QuickSightClientTypes {

    /// The label options for a chart axis. You must specify the field that the label is targeted to.
    public struct AxisLabelOptions: Swift.Sendable {
        /// The options that indicate which field the label belongs to.
        public var applyTo: QuickSightClientTypes.AxisLabelReferenceOptions?
        /// The text for the axis label.
        public var customLabel: Swift.String?
        /// The font configuration of the axis label.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?

        public init(
            applyTo: QuickSightClientTypes.AxisLabelReferenceOptions? = nil,
            customLabel: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil
        )
        {
            self.applyTo = applyTo
            self.customLabel = customLabel
            self.fontConfiguration = fontConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The label options for an axis on a chart.
    public struct ChartAxisLabelOptions: Swift.Sendable {
        /// The label options for a chart axis.
        public var axisLabelOptions: [QuickSightClientTypes.AxisLabelOptions]?
        /// The visibility configuration of the sort icon on a chart's axis label.
        public var sortIconVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of an axis label on a chart. Choose one of the following options:
        ///
        /// * VISIBLE: Shows the axis.
        ///
        /// * HIDDEN: Hides the axis.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            axisLabelOptions: [QuickSightClientTypes.AxisLabelOptions]? = nil,
            sortIconVisibility: QuickSightClientTypes.Visibility? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.axisLabelOptions = axisLabelOptions
            self.sortIconVisibility = sortIconVisibility
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The contribution analysis visual display for a line, pie, or bar chart.
    public struct ContributionAnalysisDefault: Swift.Sendable {
        /// The dimensions columns that are used in the contribution analysis, usually a list of ColumnIdentifiers.
        /// This member is required.
        public var contributorDimensions: [QuickSightClientTypes.ColumnIdentifier]?
        /// The measure field that is used in the contribution analysis.
        /// This member is required.
        public var measureFieldId: Swift.String?

        public init(
            contributorDimensions: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            measureFieldId: Swift.String? = nil
        )
        {
            self.contributorDimensions = contributorDimensions
            self.measureFieldId = measureFieldId
        }
    }
}

extension QuickSightClientTypes {

    /// The option that specifies individual data values for labels.
    public struct DataPathLabelType: Swift.Sendable {
        /// The field ID of the field that the data label needs to be applied to.
        public var fieldId: Swift.String?
        /// The actual value of the field that is labeled.
        public var fieldValue: Swift.String?
        /// The visibility of the data label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes.DataPathLabelType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataPathLabelType(fieldId: \(Swift.String(describing: fieldId)), visibility: \(Swift.String(describing: visibility)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The field label type.
    public struct FieldLabelType: Swift.Sendable {
        /// Indicates the field that is targeted by the field label.
        public var fieldId: Swift.String?
        /// The visibility of the field label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            fieldId: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The maximum label of a data path label.
    public struct MaximumLabelType: Swift.Sendable {
        /// The visibility of the maximum label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The minimum label of a data path label.
    public struct MinimumLabelType: Swift.Sendable {
        /// The visibility of the minimum label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The range ends label type of a data path label.
    public struct RangeEndsLabelType: Swift.Sendable {
        /// The visibility of the range ends label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the data label type. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DataLabelType: Swift.Sendable {
        /// The option that specifies individual data values for labels.
        public var dataPathLabelType: QuickSightClientTypes.DataPathLabelType?
        /// Determines the label configuration for the entire field.
        public var fieldLabelType: QuickSightClientTypes.FieldLabelType?
        /// Determines the label configuration for the maximum value in a visual.
        public var maximumLabelType: QuickSightClientTypes.MaximumLabelType?
        /// Determines the label configuration for the minimum value in a visual.
        public var minimumLabelType: QuickSightClientTypes.MinimumLabelType?
        /// Determines the label configuration for range end value in a visual.
        public var rangeEndsLabelType: QuickSightClientTypes.RangeEndsLabelType?

        public init(
            dataPathLabelType: QuickSightClientTypes.DataPathLabelType? = nil,
            fieldLabelType: QuickSightClientTypes.FieldLabelType? = nil,
            maximumLabelType: QuickSightClientTypes.MaximumLabelType? = nil,
            minimumLabelType: QuickSightClientTypes.MinimumLabelType? = nil,
            rangeEndsLabelType: QuickSightClientTypes.RangeEndsLabelType? = nil
        )
        {
            self.dataPathLabelType = dataPathLabelType
            self.fieldLabelType = fieldLabelType
            self.maximumLabelType = maximumLabelType
            self.minimumLabelType = minimumLabelType
            self.rangeEndsLabelType = rangeEndsLabelType
        }
    }
}

extension QuickSightClientTypes {

    public enum DataLabelContent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case percent
        case value
        case valueAndPercent
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelContent] {
            return [
                .percent,
                .value,
                .valueAndPercent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .percent: return "PERCENT"
            case .value: return "VALUE"
            case .valueAndPercent: return "VALUE_AND_PERCENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum DataLabelOverlap: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disableOverlap
        case enableOverlap
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelOverlap] {
            return [
                .disableOverlap,
                .enableOverlap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disableOverlap: return "DISABLE_OVERLAP"
            case .enableOverlap: return "ENABLE_OVERLAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum DataLabelPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottom
        case inside
        case `left`
        case outside
        case `right`
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLabelPosition] {
            return [
                .bottom,
                .inside,
                .left,
                .outside,
                .right,
                .top
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "BOTTOM"
            case .inside: return "INSIDE"
            case .left: return "LEFT"
            case .outside: return "OUTSIDE"
            case .right: return "RIGHT"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the data labels.
    public struct DataLabelOptions: Swift.Sendable {
        /// Determines the visibility of the category field labels.
        public var categoryLabelVisibility: QuickSightClientTypes.Visibility?
        /// The option that determines the data label type.
        public var dataLabelTypes: [QuickSightClientTypes.DataLabelType]?
        /// Determines the color of the data labels.
        public var labelColor: Swift.String?
        /// Determines the content of the data labels.
        public var labelContent: QuickSightClientTypes.DataLabelContent?
        /// Determines the font configuration of the data labels.
        public var labelFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines the visibility of the measure field labels.
        public var measureLabelVisibility: QuickSightClientTypes.Visibility?
        /// Determines whether overlap is enabled or disabled for the data labels.
        public var overlap: QuickSightClientTypes.DataLabelOverlap?
        /// Determines the position of the data labels.
        public var position: QuickSightClientTypes.DataLabelPosition?
        /// Determines the visibility of the total.
        public var totalsVisibility: QuickSightClientTypes.Visibility?
        /// Determines the visibility of the data labels.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            categoryLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            dataLabelTypes: [QuickSightClientTypes.DataLabelType]? = nil,
            labelColor: Swift.String? = nil,
            labelContent: QuickSightClientTypes.DataLabelContent? = nil,
            labelFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            measureLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            overlap: QuickSightClientTypes.DataLabelOverlap? = nil,
            position: QuickSightClientTypes.DataLabelPosition? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.dataLabelTypes = dataLabelTypes
            self.labelColor = labelColor
            self.labelContent = labelContent
            self.labelFontConfiguration = labelFontConfiguration
            self.measureLabelVisibility = measureLabelVisibility
            self.overlap = overlap
            self.position = position
            self.totalsVisibility = totalsVisibility
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The dimension type field with categorical type columns..
    public struct CategoricalDimensionField: Swift.Sendable {
        /// The column that is used in the CategoricalDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.StringFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The dimension type field with date type columns.
    public struct DateDimensionField: Swift.Sendable {
        /// The column that is used in the DateDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The date granularity of the DateDimensionField. Choose one of the following options:
        ///
        /// * YEAR
        ///
        /// * QUARTER
        ///
        /// * MONTH
        ///
        /// * WEEK
        ///
        /// * DAY
        ///
        /// * HOUR
        ///
        /// * MINUTE
        ///
        /// * SECOND
        ///
        /// * MILLISECOND
        public var dateGranularity: QuickSightClientTypes.TimeGranularity?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            dateGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.dateGranularity = dateGranularity
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The dimension type field with numerical type columns.
    public struct NumericalDimensionField: Swift.Sendable {
        /// The column that is used in the NumericalDimensionField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?
        /// The custom hierarchy ID.
        public var hierarchyId: Swift.String?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The dimension type field.
    public struct DimensionField: Swift.Sendable {
        /// The dimension type field with categorical type columns.
        public var categoricalDimensionField: QuickSightClientTypes.CategoricalDimensionField?
        /// The dimension type field with date type columns.
        public var dateDimensionField: QuickSightClientTypes.DateDimensionField?
        /// The dimension type field with numerical type columns.
        public var numericalDimensionField: QuickSightClientTypes.NumericalDimensionField?

        public init(
            categoricalDimensionField: QuickSightClientTypes.CategoricalDimensionField? = nil,
            dateDimensionField: QuickSightClientTypes.DateDimensionField? = nil,
            numericalDimensionField: QuickSightClientTypes.NumericalDimensionField? = nil
        )
        {
            self.categoricalDimensionField = categoricalDimensionField
            self.dateDimensionField = dateDimensionField
            self.numericalDimensionField = numericalDimensionField
        }
    }
}

extension QuickSightClientTypes {

    /// The table calculation measure field for pivot tables.
    public struct CalculatedMeasureField: Swift.Sendable {
        /// The expression in the table calculation.
        /// This member is required.
        public var expression: Swift.String?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?

        public init(
            expression: Swift.String? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.expression = expression
            self.fieldId = fieldId
        }
    }
}

extension QuickSightClientTypes.CalculatedMeasureField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedMeasureField(fieldId: \(Swift.String(describing: fieldId)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The measure type field with categorical type columns.
    public struct CategoricalMeasureField: Swift.Sendable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction?
        /// The column that is used in the CategoricalMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.StringFormatConfiguration?

        public init(
            aggregationFunction: QuickSightClientTypes.CategoricalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.StringFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The measure type field with date type columns.
    public struct DateMeasureField: Swift.Sendable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.DateAggregationFunction?
        /// The column that is used in the DateMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration?

        public init(
            aggregationFunction: QuickSightClientTypes.DateAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.DateTimeFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The measure type field with numerical type columns.
    public struct NumericalMeasureField: Swift.Sendable {
        /// The aggregation function of the measure field.
        public var aggregationFunction: QuickSightClientTypes.NumericalAggregationFunction?
        /// The column that is used in the NumericalMeasureField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration?

        public init(
            aggregationFunction: QuickSightClientTypes.NumericalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.NumberFormatConfiguration? = nil
        )
        {
            self.aggregationFunction = aggregationFunction
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The measure (metric) type field.
    public struct MeasureField: Swift.Sendable {
        /// The calculated measure field only used in pivot tables.
        public var calculatedMeasureField: QuickSightClientTypes.CalculatedMeasureField?
        /// The measure type field with categorical type columns.
        public var categoricalMeasureField: QuickSightClientTypes.CategoricalMeasureField?
        /// The measure type field with date type columns.
        public var dateMeasureField: QuickSightClientTypes.DateMeasureField?
        /// The measure type field with numerical type columns.
        public var numericalMeasureField: QuickSightClientTypes.NumericalMeasureField?

        public init(
            calculatedMeasureField: QuickSightClientTypes.CalculatedMeasureField? = nil,
            categoricalMeasureField: QuickSightClientTypes.CategoricalMeasureField? = nil,
            dateMeasureField: QuickSightClientTypes.DateMeasureField? = nil,
            numericalMeasureField: QuickSightClientTypes.NumericalMeasureField? = nil
        )
        {
            self.calculatedMeasureField = calculatedMeasureField
            self.categoricalMeasureField = categoricalMeasureField
            self.dateMeasureField = dateMeasureField
            self.numericalMeasureField = numericalMeasureField
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field wells of a bar chart.
    public struct BarChartAggregatedFieldWells: Swift.Sendable {
        /// The category (y-axis) field well of a bar chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The color (group/color) field well of a bar chart.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a bar chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a bar chart. Values are aggregated by category.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a BarChartVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct BarChartFieldWells: Swift.Sendable {
        /// The aggregated field wells of a bar chart.
        public var barChartAggregatedFieldWells: QuickSightClientTypes.BarChartAggregatedFieldWells?

        public init(
            barChartAggregatedFieldWells: QuickSightClientTypes.BarChartAggregatedFieldWells? = nil
        )
        {
            self.barChartAggregatedFieldWells = barChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The context menu options for a visual's interactions.
    public struct ContextMenuOption: Swift.Sendable {
        /// The availability status of the context menu options. If the value of this property is set to ENABLED, dashboard readers can interact with the context menu.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The menu options for a visual.
    public struct VisualMenuOption: Swift.Sendable {
        /// The availaiblity status of a visual's menu options.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The general visual interactions setup for visual publish options
    public struct VisualInteractionOptions: Swift.Sendable {
        /// The context menu options for a visual.
        public var contextMenuOption: QuickSightClientTypes.ContextMenuOption?
        /// The on-visual menu options for a visual.
        public var visualMenuOption: QuickSightClientTypes.VisualMenuOption?

        public init(
            contextMenuOption: QuickSightClientTypes.ContextMenuOption? = nil,
            visualMenuOption: QuickSightClientTypes.VisualMenuOption? = nil
        )
        {
            self.contextMenuOption = contextMenuOption
            self.visualMenuOption = visualMenuOption
        }
    }
}

extension QuickSightClientTypes {

    public enum LegendPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case bottom
        case `right`
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [LegendPosition] {
            return [
                .auto,
                .bottom,
                .right,
                .top
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .bottom: return "BOTTOM"
            case .right: return "RIGHT"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options for the legend setup of a visual.
    public struct LegendOptions: Swift.Sendable {
        /// The height of the legend. If this value is omitted, a default height is used when rendering.
        public var height: Swift.String?
        /// The positions for the legend. Choose one of the following options:
        ///
        /// * AUTO
        ///
        /// * RIGHT
        ///
        /// * BOTTOM
        ///
        /// * LEFT
        public var position: QuickSightClientTypes.LegendPosition?
        /// The custom title for the legend.
        public var title: QuickSightClientTypes.LabelOptions?
        /// Determines whether or not the legend is visible.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width of the legend. If this value is omitted, a default width is used when rendering.
        public var width: Swift.String?

        public init(
            height: Swift.String? = nil,
            position: QuickSightClientTypes.LegendPosition? = nil,
            title: QuickSightClientTypes.LabelOptions? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil
        )
        {
            self.height = height
            self.position = position
            self.title = title
            self.visibility = visibility
            self.width = width
        }
    }
}

extension QuickSightClientTypes {

    public enum BarChartOrientation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case horizontal
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [BarChartOrientation] {
            return [
                .horizontal,
                .vertical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .vertical: return "VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum AxisBinding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case primaryYaxis
        case secondaryYaxis
        case sdkUnknown(Swift.String)

        public static var allCases: [AxisBinding] {
            return [
                .primaryYaxis,
                .secondaryYaxis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .primaryYaxis: return "PRIMARY_YAXIS"
            case .secondaryYaxis: return "SECONDARY_YAXIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The dynamic configuration of the reference line data configuration.
    public struct ReferenceLineDynamicDataConfiguration: Swift.Sendable {
        /// The calculation that is used in the dynamic data.
        /// This member is required.
        public var calculation: QuickSightClientTypes.NumericalAggregationFunction?
        /// The column that the dynamic data targets.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The aggregation function that is used in the dynamic data.
        public var measureAggregationFunction: QuickSightClientTypes.AggregationFunction?

        public init(
            calculation: QuickSightClientTypes.NumericalAggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            measureAggregationFunction: QuickSightClientTypes.AggregationFunction? = nil
        )
        {
            self.calculation = calculation
            self.column = column
            self.measureAggregationFunction = measureAggregationFunction
        }
    }
}

extension QuickSightClientTypes {

    public enum ReferenceLineSeriesType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bar
        case line
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineSeriesType] {
            return [
                .bar,
                .line
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bar: return "BAR"
            case .line: return "LINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The static data configuration of the reference line data configuration.
    public struct ReferenceLineStaticDataConfiguration: Swift.Sendable {
        /// The double input of the static data.
        /// This member is required.
        public var value: Swift.Double

        public init(
            value: Swift.Double = 0.0
        )
        {
            self.value = value
        }
    }
}

extension QuickSightClientTypes.ReferenceLineStaticDataConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReferenceLineStaticDataConfiguration(value: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The data configuration of the reference line.
    public struct ReferenceLineDataConfiguration: Swift.Sendable {
        /// The axis binding type of the reference line. Choose one of the following options:
        ///
        /// * PrimaryY
        ///
        /// * SecondaryY
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The dynamic configuration of the reference line data configuration.
        public var dynamicConfiguration: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration?
        /// The series type of the reference line data configuration. Choose one of the following options:
        ///
        /// * BAR
        ///
        /// * LINE
        public var seriesType: QuickSightClientTypes.ReferenceLineSeriesType?
        /// The static data configuration of the reference line data configuration.
        public var staticConfiguration: QuickSightClientTypes.ReferenceLineStaticDataConfiguration?

        public init(
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            dynamicConfiguration: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration? = nil,
            seriesType: QuickSightClientTypes.ReferenceLineSeriesType? = nil,
            staticConfiguration: QuickSightClientTypes.ReferenceLineStaticDataConfiguration? = nil
        )
        {
            self.axisBinding = axisBinding
            self.dynamicConfiguration = dynamicConfiguration
            self.seriesType = seriesType
            self.staticConfiguration = staticConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a custom label on a ReferenceLine.
    public struct ReferenceLineCustomLabelConfiguration: Swift.Sendable {
        /// The string text of the custom label.
        /// This member is required.
        public var customLabel: Swift.String?

        public init(
            customLabel: Swift.String? = nil
        )
        {
            self.customLabel = customLabel
        }
    }
}

extension QuickSightClientTypes {

    public enum ReferenceLineLabelHorizontalPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case center
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineLabelHorizontalPosition] {
            return [
                .center,
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .center: return "CENTER"
            case .left: return "LEFT"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum ReferenceLineValueLabelRelativePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterCustomLabel
        case beforeCustomLabel
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineValueLabelRelativePosition] {
            return [
                .afterCustomLabel,
                .beforeCustomLabel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterCustomLabel: return "AFTER_CUSTOM_LABEL"
            case .beforeCustomLabel: return "BEFORE_CUSTOM_LABEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The value label configuration of the label in a reference line.
    public struct ReferenceLineValueLabelConfiguration: Swift.Sendable {
        /// The format configuration of the value label.
        public var formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration?
        /// The relative position of the value label. Choose one of the following options:
        ///
        /// * BEFORE_CUSTOM_LABEL
        ///
        /// * AFTER_CUSTOM_LABEL
        public var relativePosition: QuickSightClientTypes.ReferenceLineValueLabelRelativePosition?

        public init(
            formatConfiguration: QuickSightClientTypes.NumericFormatConfiguration? = nil,
            relativePosition: QuickSightClientTypes.ReferenceLineValueLabelRelativePosition? = nil
        )
        {
            self.formatConfiguration = formatConfiguration
            self.relativePosition = relativePosition
        }
    }
}

extension QuickSightClientTypes {

    public enum ReferenceLineLabelVerticalPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case above
        case below
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLineLabelVerticalPosition] {
            return [
                .above,
                .below
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .above: return "ABOVE"
            case .below: return "BELOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The label configuration of a reference line.
    public struct ReferenceLineLabelConfiguration: Swift.Sendable {
        /// The custom label configuration of the label in a reference line.
        public var customLabelConfiguration: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration?
        /// The font color configuration of the label in a reference line.
        public var fontColor: Swift.String?
        /// The font configuration of the label in a reference line.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The horizontal position configuration of the label in a reference line. Choose one of the following options:
        ///
        /// * LEFT
        ///
        /// * CENTER
        ///
        /// * RIGHT
        public var horizontalPosition: QuickSightClientTypes.ReferenceLineLabelHorizontalPosition?
        /// The value label configuration of the label in a reference line.
        public var valueLabelConfiguration: QuickSightClientTypes.ReferenceLineValueLabelConfiguration?
        /// The vertical position configuration of the label in a reference line. Choose one of the following options:
        ///
        /// * ABOVE
        ///
        /// * BELOW
        public var verticalPosition: QuickSightClientTypes.ReferenceLineLabelVerticalPosition?

        public init(
            customLabelConfiguration: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration? = nil,
            fontColor: Swift.String? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            horizontalPosition: QuickSightClientTypes.ReferenceLineLabelHorizontalPosition? = nil,
            valueLabelConfiguration: QuickSightClientTypes.ReferenceLineValueLabelConfiguration? = nil,
            verticalPosition: QuickSightClientTypes.ReferenceLineLabelVerticalPosition? = nil
        )
        {
            self.customLabelConfiguration = customLabelConfiguration
            self.fontColor = fontColor
            self.fontConfiguration = fontConfiguration
            self.horizontalPosition = horizontalPosition
            self.valueLabelConfiguration = valueLabelConfiguration
            self.verticalPosition = verticalPosition
        }
    }
}

extension QuickSightClientTypes {

    public enum ReferenceLinePatternType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceLinePatternType] {
            return [
                .dashed,
                .dotted,
                .solid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The style configuration of the reference line.
    public struct ReferenceLineStyleConfiguration: Swift.Sendable {
        /// The hex color of the reference line.
        public var color: Swift.String?
        /// The pattern type of the line style. Choose one of the following options:
        ///
        /// * SOLID
        ///
        /// * DASHED
        ///
        /// * DOTTED
        public var pattern: QuickSightClientTypes.ReferenceLinePatternType?

        public init(
            color: Swift.String? = nil,
            pattern: QuickSightClientTypes.ReferenceLinePatternType? = nil
        )
        {
            self.color = color
            self.pattern = pattern
        }
    }
}

extension QuickSightClientTypes {

    /// The reference line visual display options.
    public struct ReferenceLine: Swift.Sendable {
        /// The data configuration of the reference line.
        /// This member is required.
        public var dataConfiguration: QuickSightClientTypes.ReferenceLineDataConfiguration?
        /// The label configuration of the reference line.
        public var labelConfiguration: QuickSightClientTypes.ReferenceLineLabelConfiguration?
        /// The status of the reference line. Choose one of the following options:
        ///
        /// * ENABLE
        ///
        /// * DISABLE
        public var status: QuickSightClientTypes.WidgetStatus?
        /// The style configuration of the reference line.
        public var styleConfiguration: QuickSightClientTypes.ReferenceLineStyleConfiguration?

        public init(
            dataConfiguration: QuickSightClientTypes.ReferenceLineDataConfiguration? = nil,
            labelConfiguration: QuickSightClientTypes.ReferenceLineLabelConfiguration? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil,
            styleConfiguration: QuickSightClientTypes.ReferenceLineStyleConfiguration? = nil
        )
        {
            self.dataConfiguration = dataConfiguration
            self.labelConfiguration = labelConfiguration
            self.status = status
            self.styleConfiguration = styleConfiguration
        }
    }
}

extension QuickSightClientTypes {

    public enum PanelBorderStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [PanelBorderStyle] {
            return [
                .dashed,
                .dotted,
                .solid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum HorizontalTextAlignment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case center
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [HorizontalTextAlignment] {
            return [
                .auto,
                .center,
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .center: return "CENTER"
            case .left: return "LEFT"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the title styles for each small multiples panel.
    public struct PanelTitleOptions: Swift.Sendable {
        /// Configures the display properties of the given text.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Sets the horizontal text alignment of the title within each panel.
        public var horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment?
        /// Determines whether or not panel titles are displayed.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fontConfiguration = fontConfiguration
            self.horizontalTextAlignment = horizontalTextAlignment
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// A collection of options that configure how each panel displays in a small multiples chart.
    public struct PanelConfiguration: Swift.Sendable {
        /// Sets the background color for each panel.
        public var backgroundColor: Swift.String?
        /// Determines whether or not a background for each small multiples panel is rendered.
        public var backgroundVisibility: QuickSightClientTypes.Visibility?
        /// Sets the line color of panel borders.
        public var borderColor: Swift.String?
        /// Sets the line style of panel borders.
        public var borderStyle: QuickSightClientTypes.PanelBorderStyle?
        /// Sets the line thickness of panel borders.
        public var borderThickness: Swift.String?
        /// Determines whether or not each panel displays a border.
        public var borderVisibility: QuickSightClientTypes.Visibility?
        /// Sets the total amount of negative space to display between sibling panels.
        public var gutterSpacing: Swift.String?
        /// Determines whether or not negative space between sibling panels is rendered.
        public var gutterVisibility: QuickSightClientTypes.Visibility?
        /// Configures the title display within each small multiples panel.
        public var title: QuickSightClientTypes.PanelTitleOptions?

        public init(
            backgroundColor: Swift.String? = nil,
            backgroundVisibility: QuickSightClientTypes.Visibility? = nil,
            borderColor: Swift.String? = nil,
            borderStyle: QuickSightClientTypes.PanelBorderStyle? = nil,
            borderThickness: Swift.String? = nil,
            borderVisibility: QuickSightClientTypes.Visibility? = nil,
            gutterSpacing: Swift.String? = nil,
            gutterVisibility: QuickSightClientTypes.Visibility? = nil,
            title: QuickSightClientTypes.PanelTitleOptions? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.backgroundVisibility = backgroundVisibility
            self.borderColor = borderColor
            self.borderStyle = borderStyle
            self.borderThickness = borderThickness
            self.borderVisibility = borderVisibility
            self.gutterSpacing = gutterSpacing
            self.gutterVisibility = gutterVisibility
            self.title = title
        }
    }
}

extension QuickSightClientTypes {

    public enum SmallMultiplesAxisPlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inside
        case outside
        case sdkUnknown(Swift.String)

        public static var allCases: [SmallMultiplesAxisPlacement] {
            return [
                .inside,
                .outside
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inside: return "INSIDE"
            case .outside: return "OUTSIDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum SmallMultiplesAxisScale: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case independent
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [SmallMultiplesAxisScale] {
            return [
                .independent,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .independent: return "INDEPENDENT"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Configures the properties of a chart's axes that are used by small multiples panels.
    public struct SmallMultiplesAxisProperties: Swift.Sendable {
        /// Defines the placement of the axis. By default, axes are rendered OUTSIDE of the panels. Axes with INDEPENDENT scale are rendered INSIDE the panels.
        public var placement: QuickSightClientTypes.SmallMultiplesAxisPlacement?
        /// Determines whether scale of the axes are shared or independent. The default value is SHARED.
        public var scale: QuickSightClientTypes.SmallMultiplesAxisScale?

        public init(
            placement: QuickSightClientTypes.SmallMultiplesAxisPlacement? = nil,
            scale: QuickSightClientTypes.SmallMultiplesAxisScale? = nil
        )
        {
            self.placement = placement
            self.scale = scale
        }
    }
}

extension QuickSightClientTypes {

    /// Options that determine the layout and display options of a chart's small multiples.
    public struct SmallMultiplesOptions: Swift.Sendable {
        /// Sets the maximum number of visible columns to display in the grid of small multiples panels. The default is Auto, which automatically adjusts the columns in the grid to fit the overall layout and size of the given chart.
        public var maxVisibleColumns: Swift.Int?
        /// Sets the maximum number of visible rows to display in the grid of small multiples panels. The default value is Auto, which automatically adjusts the rows in the grid to fit the overall layout and size of the given chart.
        public var maxVisibleRows: Swift.Int?
        /// Configures the display options for each small multiples panel.
        public var panelConfiguration: QuickSightClientTypes.PanelConfiguration?
        /// The properties of a small multiples X axis.
        public var xAxis: QuickSightClientTypes.SmallMultiplesAxisProperties?
        /// The properties of a small multiples Y axis.
        public var yAxis: QuickSightClientTypes.SmallMultiplesAxisProperties?

        public init(
            maxVisibleColumns: Swift.Int? = nil,
            maxVisibleRows: Swift.Int? = nil,
            panelConfiguration: QuickSightClientTypes.PanelConfiguration? = nil,
            xAxis: QuickSightClientTypes.SmallMultiplesAxisProperties? = nil,
            yAxis: QuickSightClientTypes.SmallMultiplesAxisProperties? = nil
        )
        {
            self.maxVisibleColumns = maxVisibleColumns
            self.maxVisibleRows = maxVisibleRows
            self.panelConfiguration = panelConfiguration
            self.xAxis = xAxis
            self.yAxis = yAxis
        }
    }
}

extension QuickSightClientTypes {

    public enum OtherCategories: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case exclude
        case include
        case sdkUnknown(Swift.String)

        public static var allCases: [OtherCategories] {
            return [
                .exclude,
                .include
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .exclude: return "EXCLUDE"
            case .include: return "INCLUDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The limit configuration of the visual display for an axis.
    public struct ItemsLimitConfiguration: Swift.Sendable {
        /// The limit on how many items of a field are showed in the chart. For example, the number of slices that are displayed in a pie chart.
        public var itemsLimit: Swift.Int?
        /// The Show other of an axis in the chart. Choose one of the following options:
        ///
        /// * INCLUDE
        ///
        /// * EXCLUDE
        public var otherCategories: QuickSightClientTypes.OtherCategories?

        public init(
            itemsLimit: Swift.Int? = 0,
            otherCategories: QuickSightClientTypes.OtherCategories? = nil
        )
        {
            self.itemsLimit = itemsLimit
            self.otherCategories = otherCategories
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration for a field in a field well.
    public struct FieldSort: Swift.Sendable {
        /// The sort direction. Choose one of the following options:
        ///
        /// * ASC: Ascending
        ///
        /// * DESC: Descending
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// The sort configuration target field.
        /// This member is required.
        public var fieldId: Swift.String?

        public init(
            direction: QuickSightClientTypes.SortDirection? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.direction = direction
            self.fieldId = fieldId
        }
    }
}

extension QuickSightClientTypes {

    /// The field sort options in a chart configuration.
    public struct FieldSortOptions: Swift.Sendable {
        /// The sort configuration for a column that is not used in a field well.
        public var columnSort: QuickSightClientTypes.ColumnSort?
        /// The sort configuration for a field in a field well.
        public var fieldSort: QuickSightClientTypes.FieldSort?

        public init(
            columnSort: QuickSightClientTypes.ColumnSort? = nil,
            fieldSort: QuickSightClientTypes.FieldSort? = nil
        )
        {
            self.columnSort = columnSort
            self.fieldSort = fieldSort
        }
    }
}

extension QuickSightClientTypes {

    /// sort-configuration-description
    public struct BarChartSortConfiguration: Swift.Sendable {
        /// The limit on the number of categories displayed in a bar chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of values displayed in a bar chart.
        public var colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of color fields in a bar chart.
        public var colorSort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            colorSort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }
}

extension QuickSightClientTypes {

    public enum TooltipTarget: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bar
        case both
        case line
        case sdkUnknown(Swift.String)

        public static var allCases: [TooltipTarget] {
            return [
                .bar,
                .both,
                .line
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bar: return "BAR"
            case .both: return "BOTH"
            case .line: return "LINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The tooltip item for the columns that are not part of a field well.
    public struct ColumnTooltipItem: Swift.Sendable {
        /// The aggregation function of the column tooltip item.
        public var aggregation: QuickSightClientTypes.AggregationFunction?
        /// The target column of the tooltip item.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The label of the tooltip item.
        public var label: Swift.String?
        /// Determines the target of the column tooltip item in a combo chart visual.
        public var tooltipTarget: QuickSightClientTypes.TooltipTarget?
        /// The visibility of the tooltip item.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            aggregation: QuickSightClientTypes.AggregationFunction? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            label: Swift.String? = nil,
            tooltipTarget: QuickSightClientTypes.TooltipTarget? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.aggregation = aggregation
            self.column = column
            self.label = label
            self.tooltipTarget = tooltipTarget
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The tooltip item for the fields.
    public struct FieldTooltipItem: Swift.Sendable {
        /// The unique ID of the field that is targeted by the tooltip.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The label of the tooltip item.
        public var label: Swift.String?
        /// Determines the target of the field tooltip item in a combo chart visual.
        public var tooltipTarget: QuickSightClientTypes.TooltipTarget?
        /// The visibility of the tooltip item.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            fieldId: Swift.String? = nil,
            label: Swift.String? = nil,
            tooltipTarget: QuickSightClientTypes.TooltipTarget? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldId = fieldId
            self.label = label
            self.tooltipTarget = tooltipTarget
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The tooltip. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TooltipItem: Swift.Sendable {
        /// The tooltip item for the columns that are not part of a field well.
        public var columnTooltipItem: QuickSightClientTypes.ColumnTooltipItem?
        /// The tooltip item for the fields.
        public var fieldTooltipItem: QuickSightClientTypes.FieldTooltipItem?

        public init(
            columnTooltipItem: QuickSightClientTypes.ColumnTooltipItem? = nil,
            fieldTooltipItem: QuickSightClientTypes.FieldTooltipItem? = nil
        )
        {
            self.columnTooltipItem = columnTooltipItem
            self.fieldTooltipItem = fieldTooltipItem
        }
    }
}

extension QuickSightClientTypes {

    public enum TooltipTitleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case primaryValue
        case sdkUnknown(Swift.String)

        public static var allCases: [TooltipTitleType] {
            return [
                .none,
                .primaryValue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .primaryValue: return "PRIMARY_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The setup for the detailed tooltip.
    public struct FieldBasedTooltip: Swift.Sendable {
        /// The visibility of Show aggregations.
        public var aggregationVisibility: QuickSightClientTypes.Visibility?
        /// The fields configuration in the tooltip.
        public var tooltipFields: [QuickSightClientTypes.TooltipItem]?
        /// The type for the >tooltip title. Choose one of the following options:
        ///
        /// * NONE: Doesn't use the primary value as the title.
        ///
        /// * PRIMARY_VALUE: Uses primary value as the title.
        public var tooltipTitleType: QuickSightClientTypes.TooltipTitleType?

        public init(
            aggregationVisibility: QuickSightClientTypes.Visibility? = nil,
            tooltipFields: [QuickSightClientTypes.TooltipItem]? = nil,
            tooltipTitleType: QuickSightClientTypes.TooltipTitleType? = nil
        )
        {
            self.aggregationVisibility = aggregationVisibility
            self.tooltipFields = tooltipFields
            self.tooltipTitleType = tooltipTitleType
        }
    }
}

extension QuickSightClientTypes {

    public enum SelectedTooltipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case detailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SelectedTooltipType] {
            return [
                .basic,
                .detailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .detailed: return "DETAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for the visual tooltip.
    public struct TooltipOptions: Swift.Sendable {
        /// The setup for the detailed tooltip. The tooltip setup is always saved. The display type is decided based on the tooltip type.
        public var fieldBasedTooltip: QuickSightClientTypes.FieldBasedTooltip?
        /// The selected type for the tooltip. Choose one of the following options:
        ///
        /// * BASIC: A basic tooltip.
        ///
        /// * DETAILED: A detailed tooltip.
        public var selectedTooltipType: QuickSightClientTypes.SelectedTooltipType?
        /// Determines whether or not the tooltip is visible.
        public var tooltipVisibility: QuickSightClientTypes.Visibility?

        public init(
            fieldBasedTooltip: QuickSightClientTypes.FieldBasedTooltip? = nil,
            selectedTooltipType: QuickSightClientTypes.SelectedTooltipType? = nil,
            tooltipVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.fieldBasedTooltip = fieldBasedTooltip
            self.selectedTooltipType = selectedTooltipType
            self.tooltipVisibility = tooltipVisibility
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableDataPathType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case countMetricColumn
        case emptyColumnHeader
        case hierarchyRowsLayoutColumn
        case multipleRowMetricsColumn
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableDataPathType] {
            return [
                .countMetricColumn,
                .emptyColumnHeader,
                .hierarchyRowsLayoutColumn,
                .multipleRowMetricsColumn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .countMetricColumn: return "COUNT_METRIC_COLUMN"
            case .emptyColumnHeader: return "EMPTY_COLUMN_HEADER"
            case .hierarchyRowsLayoutColumn: return "HIERARCHY_ROWS_LAYOUT_COLUMN"
            case .multipleRowMetricsColumn: return "MULTIPLE_ROW_METRICS_COLUMN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The type of the data path value.
    public struct DataPathType: Swift.Sendable {
        /// The type of data path value utilized in a pivot table. Choose one of the following options:
        ///
        /// * HIERARCHY_ROWS_LAYOUT_COLUMN - The type of data path for the rows layout column, when RowsLayout is set to HIERARCHY.
        ///
        /// * MULTIPLE_ROW_METRICS_COLUMN - The type of data path for the metric column when the row is set to Metric Placement.
        ///
        /// * EMPTY_COLUMN_HEADER - The type of data path for the column with empty column header, when there is no field in ColumnsFieldWell and the row is set to Metric Placement.
        ///
        /// * COUNT_METRIC_COLUMN - The type of data path for the column with COUNT as the metric, when there is no field in the ValuesFieldWell.
        public var pivotTableDataPathType: QuickSightClientTypes.PivotTableDataPathType?

        public init(
            pivotTableDataPathType: QuickSightClientTypes.PivotTableDataPathType? = nil
        )
        {
            self.pivotTableDataPathType = pivotTableDataPathType
        }
    }
}

extension QuickSightClientTypes {

    /// The data path that needs to be sorted.
    public struct DataPathValue: Swift.Sendable {
        /// The type configuration of the field.
        public var dataPathType: QuickSightClientTypes.DataPathType?
        /// The field ID of the field that needs to be sorted.
        public var fieldId: Swift.String?
        /// The actual value of the field that needs to be sorted.
        public var fieldValue: Swift.String?

        public init(
            dataPathType: QuickSightClientTypes.DataPathType? = nil,
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil
        )
        {
            self.dataPathType = dataPathType
            self.fieldId = fieldId
            self.fieldValue = fieldValue
        }
    }
}

extension QuickSightClientTypes.DataPathValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataPathValue(dataPathType: \(Swift.String(describing: dataPathType)), fieldId: \(Swift.String(describing: fieldId)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The color map that determines the color options for a particular element.
    public struct DataPathColor: Swift.Sendable {
        /// The color that needs to be applied to the element.
        /// This member is required.
        public var color: Swift.String?
        /// The element that the color needs to be applied to.
        /// This member is required.
        public var element: QuickSightClientTypes.DataPathValue?
        /// The time granularity of the field that the color needs to be applied to.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            color: Swift.String? = nil,
            element: QuickSightClientTypes.DataPathValue? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.color = color
            self.element = element
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// The visual display options for the visual palette.
    public struct VisualPalette: Swift.Sendable {
        /// The chart color options for the visual palette.
        public var chartColor: Swift.String?
        /// The color map options for the visual palette.
        public var colorMap: [QuickSightClientTypes.DataPathColor]?

        public init(
            chartColor: Swift.String? = nil,
            colorMap: [QuickSightClientTypes.DataPathColor]? = nil
        )
        {
            self.chartColor = chartColor
            self.colorMap = colorMap
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a BarChartVisual.
    public struct BarChartConfiguration: Swift.Sendable {
        /// Determines the arrangement of the bars. The orientation and arrangement of bars determine the type of bar that is used in the visual.
        public var barsArrangement: QuickSightClientTypes.BarsArrangement?
        /// The label display options (grid line, range, scale, axis step) for bar chart category.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a color that is used in a bar chart.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.BarChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The orientation of the bars in a bar chart visual. There are two valid values in this structure:
        ///
        /// * HORIZONTAL: Used for charts that have horizontal bars. Visuals that use this value are horizontal bar charts, horizontal stacked bar charts, and horizontal stacked 100% bar charts.
        ///
        /// * VERTICAL: Used for charts that have vertical bars. Visuals that use this value are vertical bar charts, vertical stacked bar charts, and vertical stacked 100% bar charts.
        public var orientation: QuickSightClientTypes.BarChartOrientation?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a BarChartVisual.
        public var sortConfiguration: QuickSightClientTypes.BarChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label display options (grid line, range, scale, axis step) for a bar chart value.
        public var valueAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) for a bar chart value.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            barsArrangement: QuickSightClientTypes.BarsArrangement? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.BarChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            orientation: QuickSightClientTypes.BarChartOrientation? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.BarChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.orientation = orientation
            self.referenceLines = referenceLines
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueAxis = valueAxis
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// The category drill down filter.
    public struct CategoryDrillDownFilter: Swift.Sendable {
        /// A list of the string inputs that are the values of the category drill down filter.
        /// This member is required.
        public var categoryValues: [Swift.String]?
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?

        public init(
            categoryValues: [Swift.String]? = nil,
            column: QuickSightClientTypes.ColumnIdentifier? = nil
        )
        {
            self.categoryValues = categoryValues
            self.column = column
        }
    }
}

extension QuickSightClientTypes {

    /// The numeric equality type drill down filter.
    public struct NumericEqualityDrillDownFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The value of the double input numeric drill down filter.
        /// This member is required.
        public var value: Swift.Double

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.column = column
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The time range drill down filter.
    public struct TimeRangeDrillDownFilter: Swift.Sendable {
        /// The column that the filter is applied to.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The maximum value for the filter value range.
        /// This member is required.
        public var rangeMaximum: Foundation.Date?
        /// The minimum value for the filter value range.
        /// This member is required.
        public var rangeMinimum: Foundation.Date?
        /// The level of time precision that is used to aggregate DateTime values.
        /// This member is required.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            rangeMaximum: Foundation.Date? = nil,
            rangeMinimum: Foundation.Date? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.column = column
            self.rangeMaximum = rangeMaximum
            self.rangeMinimum = rangeMinimum
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// The drill down filter for the column hierarchies. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct DrillDownFilter: Swift.Sendable {
        /// The category type drill down filter. This filter is used for string type columns.
        public var categoryFilter: QuickSightClientTypes.CategoryDrillDownFilter?
        /// The numeric equality type drill down filter. This filter is used for number type columns.
        public var numericEqualityFilter: QuickSightClientTypes.NumericEqualityDrillDownFilter?
        /// The time range drill down filter. This filter is used for date time columns.
        public var timeRangeFilter: QuickSightClientTypes.TimeRangeDrillDownFilter?

        public init(
            categoryFilter: QuickSightClientTypes.CategoryDrillDownFilter? = nil,
            numericEqualityFilter: QuickSightClientTypes.NumericEqualityDrillDownFilter? = nil,
            timeRangeFilter: QuickSightClientTypes.TimeRangeDrillDownFilter? = nil
        )
        {
            self.categoryFilter = categoryFilter
            self.numericEqualityFilter = numericEqualityFilter
            self.timeRangeFilter = timeRangeFilter
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the hierarchy of any DateTime fields.
    public struct DateTimeHierarchy: Swift.Sendable {
        /// The option that determines the drill down filters for the DateTime hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the DateTime hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init(
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
    public struct ExplicitHierarchy: Swift.Sendable {
        /// The list of columns that define the explicit hierarchy.
        /// This member is required.
        public var columns: [QuickSightClientTypes.ColumnIdentifier]?
        /// The option that determines the drill down filters for the explicit hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the explicit hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init(
            columns: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
    public struct PredefinedHierarchy: Swift.Sendable {
        /// The list of columns that define the predefined hierarchy.
        /// This member is required.
        public var columns: [QuickSightClientTypes.ColumnIdentifier]?
        /// The option that determines the drill down filters for the predefined hierarchy.
        public var drillDownFilters: [QuickSightClientTypes.DrillDownFilter]?
        /// The hierarchy ID of the predefined hierarchy.
        /// This member is required.
        public var hierarchyId: Swift.String?

        public init(
            columns: [QuickSightClientTypes.ColumnIdentifier]? = nil,
            drillDownFilters: [QuickSightClientTypes.DrillDownFilter]? = nil,
            hierarchyId: Swift.String? = nil
        )
        {
            self.columns = columns
            self.drillDownFilters = drillDownFilters
            self.hierarchyId = hierarchyId
        }
    }
}

extension QuickSightClientTypes {

    /// The option that determines the hierarchy of the fields for a visual element.
    public struct ColumnHierarchy: Swift.Sendable {
        /// The option that determines the hierarchy of any DateTime fields.
        public var dateTimeHierarchy: QuickSightClientTypes.DateTimeHierarchy?
        /// The option that determines the hierarchy of the fields that are built within a visual's field wells. These fields can't be duplicated to other visuals.
        public var explicitHierarchy: QuickSightClientTypes.ExplicitHierarchy?
        /// The option that determines the hierarchy of the fields that are defined during data preparation. These fields are available to use in any analysis that uses the data source.
        public var predefinedHierarchy: QuickSightClientTypes.PredefinedHierarchy?

        public init(
            dateTimeHierarchy: QuickSightClientTypes.DateTimeHierarchy? = nil,
            explicitHierarchy: QuickSightClientTypes.ExplicitHierarchy? = nil,
            predefinedHierarchy: QuickSightClientTypes.PredefinedHierarchy? = nil
        )
        {
            self.dateTimeHierarchy = dateTimeHierarchy
            self.explicitHierarchy = explicitHierarchy
            self.predefinedHierarchy = predefinedHierarchy
        }
    }
}

extension QuickSightClientTypes {

    /// The text format for a subtitle. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct LongFormatText: Swift.Sendable {
        /// Plain text format.
        public var plainText: Swift.String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public var richText: Swift.String?

        public init(
            plainText: Swift.String? = nil,
            richText: Swift.String? = nil
        )
        {
            self.plainText = plainText
            self.richText = richText
        }
    }
}

extension QuickSightClientTypes {

    /// The subtitle label options for a visual.
    public struct VisualSubtitleLabelOptions: Swift.Sendable {
        /// The long text format of the subtitle label, such as plain text or rich text.
        public var formatText: QuickSightClientTypes.LongFormatText?
        /// The visibility of the subtitle label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            formatText: QuickSightClientTypes.LongFormatText? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.formatText = formatText
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The text format for the title. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ShortFormatText: Swift.Sendable {
        /// Plain text format.
        public var plainText: Swift.String?
        /// Rich text. Examples of rich text include bold, underline, and italics.
        public var richText: Swift.String?

        public init(
            plainText: Swift.String? = nil,
            richText: Swift.String? = nil
        )
        {
            self.plainText = plainText
            self.richText = richText
        }
    }
}

extension QuickSightClientTypes {

    /// The title label options for a visual.
    public struct VisualTitleLabelOptions: Swift.Sendable {
        /// The short text format of the title label, such as plain text or rich text.
        public var formatText: QuickSightClientTypes.ShortFormatText?
        /// The visibility of the title label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            formatText: QuickSightClientTypes.ShortFormatText? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.formatText = formatText
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// A bar chart. The BarChartVisual structure describes a visual that is a member of the bar chart family. The following charts can be described using this structure:
    ///
    /// * Horizontal bar chart
    ///
    /// * Vertical bar chart
    ///
    /// * Horizontal stacked bar chart
    ///
    /// * Vertical stacked bar chart
    ///
    /// * Horizontal stacked 100% bar chart
    ///
    /// * Vertical stacked 100% bar chart
    ///
    ///
    /// For more information, see [Using bar charts](https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html) in the Amazon QuickSight User Guide.
    public struct BarChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.BarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.BarChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum BoxPlotFillStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case solid
        case transparent
        case sdkUnknown(Swift.String)

        public static var allCases: [BoxPlotFillStyle] {
            return [
                .solid,
                .transparent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .solid: return "SOLID"
            case .transparent: return "TRANSPARENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The style options of the box plot.
    public struct BoxPlotStyleOptions: Swift.Sendable {
        /// The fill styles (solid, transparent) of the box plot.
        public var fillStyle: QuickSightClientTypes.BoxPlotFillStyle?

        public init(
            fillStyle: QuickSightClientTypes.BoxPlotFillStyle? = nil
        )
        {
            self.fillStyle = fillStyle
        }
    }
}

extension QuickSightClientTypes {

    /// The options of a box plot visual.
    public struct BoxPlotOptions: Swift.Sendable {
        /// Determines the visibility of all data points of the box plot.
        public var allDataPointsVisibility: QuickSightClientTypes.Visibility?
        /// Determines the visibility of the outlier in a box plot.
        public var outlierVisibility: QuickSightClientTypes.Visibility?
        /// The style options of the box plot.
        public var styleOptions: QuickSightClientTypes.BoxPlotStyleOptions?

        public init(
            allDataPointsVisibility: QuickSightClientTypes.Visibility? = nil,
            outlierVisibility: QuickSightClientTypes.Visibility? = nil,
            styleOptions: QuickSightClientTypes.BoxPlotStyleOptions? = nil
        )
        {
            self.allDataPointsVisibility = allDataPointsVisibility
            self.outlierVisibility = outlierVisibility
            self.styleOptions = styleOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well for a box plot.
    public struct BoxPlotAggregatedFieldWells: Swift.Sendable {
        /// The group by field well of a box plot chart. Values are grouped based on group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The value field well of a box plot chart. Values are aggregated based on group by fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a BoxPlotVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct BoxPlotFieldWells: Swift.Sendable {
        /// The aggregated field wells of a box plot.
        public var boxPlotAggregatedFieldWells: QuickSightClientTypes.BoxPlotAggregatedFieldWells?

        public init(
            boxPlotAggregatedFieldWells: QuickSightClientTypes.BoxPlotAggregatedFieldWells? = nil
        )
        {
            self.boxPlotAggregatedFieldWells = boxPlotAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The pagination configuration for a table visual or boxplot.
    public struct PaginationConfiguration: Swift.Sendable {
        /// Indicates the page number.
        /// This member is required.
        public var pageNumber: Swift.Int?
        /// Indicates how many items render in one page.
        /// This member is required.
        public var pageSize: Swift.Int?

        public init(
            pageNumber: Swift.Int? = nil,
            pageSize: Swift.Int? = 0
        )
        {
            self.pageNumber = pageNumber
            self.pageSize = pageSize
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a BoxPlotVisual.
    public struct BoxPlotSortConfiguration: Swift.Sendable {
        /// The sort configuration of a group by fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The pagination configuration of a table visual or box plot.
        public var paginationConfiguration: QuickSightClientTypes.PaginationConfiguration?

        public init(
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            paginationConfiguration: QuickSightClientTypes.PaginationConfiguration? = nil
        )
        {
            self.categorySort = categorySort
            self.paginationConfiguration = paginationConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a BoxPlotVisual.
    public struct BoxPlotChartConfiguration: Swift.Sendable {
        /// The box plot chart options for a box plot visual
        public var boxPlotOptions: QuickSightClientTypes.BoxPlotOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort Icon visibility) of a box plot category.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.BoxPlotFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The options for the legend setup of a visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label display options (grid line, range, scale, axis step) of a box plot category.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility and sort icon visibility) of a box plot value.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The sort configuration of a BoxPlotVisual.
        public var sortConfiguration: QuickSightClientTypes.BoxPlotSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            boxPlotOptions: QuickSightClientTypes.BoxPlotOptions? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.BoxPlotFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            sortConfiguration: QuickSightClientTypes.BoxPlotSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.boxPlotOptions = boxPlotOptions
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// A box plot. For more information, see [Using box plots](https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html) in the Amazon QuickSight User Guide.
    public struct BoxPlotVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.BoxPlotChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.BoxPlotChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field wells of a combo chart.
    public struct ComboChartAggregatedFieldWells: Swift.Sendable {
        /// The aggregated BarValues field well of a combo chart.
        public var barValues: [QuickSightClientTypes.MeasureField]?
        /// The aggregated category field wells of a combo chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The aggregated colors field well of a combo chart.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The aggregated LineValues field well of a combo chart.
        public var lineValues: [QuickSightClientTypes.MeasureField]?

        public init(
            barValues: [QuickSightClientTypes.MeasureField]? = nil,
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            lineValues: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.barValues = barValues
            self.category = category
            self.colors = colors
            self.lineValues = lineValues
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of the visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ComboChartFieldWells: Swift.Sendable {
        /// The aggregated field wells of a combo chart. Combo charts only have aggregated field wells. Columns in a combo chart are aggregated by category.
        public var comboChartAggregatedFieldWells: QuickSightClientTypes.ComboChartAggregatedFieldWells?

        public init(
            comboChartAggregatedFieldWells: QuickSightClientTypes.ComboChartAggregatedFieldWells? = nil
        )
        {
            self.comboChartAggregatedFieldWells = comboChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    public enum SingleYAxisOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case primaryYAxis
        case sdkUnknown(Swift.String)

        public static var allCases: [SingleYAxisOption] {
            return [
                .primaryYAxis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .primaryYAxis: return "PRIMARY_Y_AXIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that are available for a single Y axis in a chart.
    public struct YAxisOptions: Swift.Sendable {
        /// The Y axis type to be used in the chart. If you choose PRIMARY_Y_AXIS, the primary Y Axis is located on the leftmost vertical axis of the chart.
        /// This member is required.
        public var yAxis: QuickSightClientTypes.SingleYAxisOption?

        public init(
            yAxis: QuickSightClientTypes.SingleYAxisOption? = nil
        )
        {
            self.yAxis = yAxis
        }
    }
}

extension QuickSightClientTypes {

    /// The settings of a chart's single axis configuration.
    public struct SingleAxisOptions: Swift.Sendable {
        /// The Y axis options of a single axis configuration.
        public var yAxisOptions: QuickSightClientTypes.YAxisOptions?

        public init(
            yAxisOptions: QuickSightClientTypes.YAxisOptions? = nil
        )
        {
            self.yAxisOptions = yAxisOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a ComboChartVisual.
    public struct ComboChartSortConfiguration: Swift.Sendable {
        /// The item limit configuration for the category field well of a combo chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category field well in a combo chart.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The item limit configuration of the color field well in a combo chart.
        public var colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the color field well in a combo chart.
        public var colorSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            colorSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a ComboChartVisual.
    public struct ComboChartConfiguration: Swift.Sendable {
        /// The options that determine if visual data labels are displayed. The data label options for a bar in a combo chart.
        public var barDataLabels: QuickSightClientTypes.DataLabelOptions?
        /// Determines the bar arrangement in a combo chart. The following are valid values in this structure:
        ///
        /// * CLUSTERED: For clustered bar combo charts.
        ///
        /// * STACKED: For stacked bar combo charts.
        ///
        /// * STACKED_PERCENT: Do not use. If you use this value, the operation returns a validation error.
        public var barsArrangement: QuickSightClientTypes.BarsArrangement?
        /// The category axis of a combo chart.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart category (group/color) field well.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's color field well.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.ComboChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The options that determine if visual data labels are displayed. The data label options for a line in a combo chart.
        public var lineDataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of a combo chart's primary y-axis (bar) field well.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's primary y-axis (bar) field well.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference line setup of the visual.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The label display options (grid line, range, scale, axis step) of a combo chart's secondary y-axis (line) field well.
        public var secondaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of a combo chart's secondary y-axis(line) field well.
        public var secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The settings of a chart's single axis configuration.
        public var singleAxisOptions: QuickSightClientTypes.SingleAxisOptions?
        /// The sort configuration of a ComboChartVisual.
        public var sortConfiguration: QuickSightClientTypes.ComboChartSortConfiguration?
        /// The legend display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            barDataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            barsArrangement: QuickSightClientTypes.BarsArrangement? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.ComboChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            lineDataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            secondaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            singleAxisOptions: QuickSightClientTypes.SingleAxisOptions? = nil,
            sortConfiguration: QuickSightClientTypes.ComboChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.barDataLabels = barDataLabels
            self.barsArrangement = barsArrangement
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.lineDataLabels = lineDataLabels
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.singleAxisOptions = singleAxisOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// A combo chart. The ComboChartVisual includes stacked bar combo charts and clustered bar combo charts For more information, see [Using combo charts](https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html) in the Amazon QuickSight User Guide.
    public struct ComboChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.ComboChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.ComboChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum CustomContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case image
        case otherEmbeddedContent
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomContentType] {
            return [
                .image,
                .otherEmbeddedContent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .image: return "IMAGE"
            case .otherEmbeddedContent: return "OTHER_EMBEDDED_CONTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum CustomContentImageScalingConfiguration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doNotScale
        case fitToHeight
        case fitToWidth
        case scaleToVisual
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomContentImageScalingConfiguration] {
            return [
                .doNotScale,
                .fitToHeight,
                .fitToWidth,
                .scaleToVisual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doNotScale: return "DO_NOT_SCALE"
            case .fitToHeight: return "FIT_TO_HEIGHT"
            case .fitToWidth: return "FIT_TO_WIDTH"
            case .scaleToVisual: return "SCALE_TO_VISUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a CustomContentVisual.
    public struct CustomContentConfiguration: Swift.Sendable {
        /// The content type of the custom content visual. You can use this to have the visual render as an image.
        public var contentType: QuickSightClientTypes.CustomContentType?
        /// The input URL that links to the custom content that you want in the custom visual.
        public var contentUrl: Swift.String?
        /// The sizing options for the size of the custom content visual. This structure is required when the ContentType of the visual is 'IMAGE'.
        public var imageScaling: QuickSightClientTypes.CustomContentImageScalingConfiguration?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?

        public init(
            contentType: QuickSightClientTypes.CustomContentType? = nil,
            contentUrl: Swift.String? = nil,
            imageScaling: QuickSightClientTypes.CustomContentImageScalingConfiguration? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil
        )
        {
            self.contentType = contentType
            self.contentUrl = contentUrl
            self.imageScaling = imageScaling
            self.interactions = interactions
        }
    }
}

extension QuickSightClientTypes {

    /// A visual that contains custom content. For more information, see [Using custom visual content](https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html) in the Amazon QuickSight User Guide.
    public struct CustomContentVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a CustomContentVisual.
        public var chartConfiguration: QuickSightClientTypes.CustomContentConfiguration?
        /// The dataset that is used to create the custom content visual. You can't create a visual without a dataset.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.CustomContentConfiguration? = nil,
            dataSetIdentifier: Swift.String? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.dataSetIdentifier = dataSetIdentifier
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// An empty visual. Empty visuals are used in layouts but have not been configured to show any data. A new visual created in the Amazon QuickSight console is considered an EmptyVisual until a visual type is selected.
    public struct EmptyVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The data set that is used in the empty visual. Every visual requires a dataset to render.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            dataSetIdentifier: Swift.String? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well of the filled map.
    public struct FilledMapAggregatedFieldWells: Swift.Sendable {
        /// The aggregated location field well of the filled map. Values are grouped by location fields.
        public var geospatial: [QuickSightClientTypes.DimensionField]?
        /// The aggregated color field well of a filled map. Values are aggregated based on location fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            geospatial: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.geospatial = geospatial
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a FilledMapVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FilledMapFieldWells: Swift.Sendable {
        /// The aggregated field well of the filled map.
        public var filledMapAggregatedFieldWells: QuickSightClientTypes.FilledMapAggregatedFieldWells?

        public init(
            filledMapAggregatedFieldWells: QuickSightClientTypes.FilledMapAggregatedFieldWells? = nil
        )
        {
            self.filledMapAggregatedFieldWells = filledMapAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    public enum BaseMapStyleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case darkGray
        case imagery
        case lightGray
        case street
        case sdkUnknown(Swift.String)

        public static var allCases: [BaseMapStyleType] {
            return [
                .darkGray,
                .imagery,
                .lightGray,
                .street
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .darkGray: return "DARK_GRAY"
            case .imagery: return "IMAGERY"
            case .lightGray: return "LIGHT_GRAY"
            case .street: return "STREET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The map style options of the geospatial map.
    public struct GeospatialMapStyleOptions: Swift.Sendable {
        /// The base map style of the geospatial map.
        public var baseMapStyle: QuickSightClientTypes.BaseMapStyleType?

        public init(
            baseMapStyle: QuickSightClientTypes.BaseMapStyleType? = nil
        )
        {
            self.baseMapStyle = baseMapStyle
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a FilledMapVisual.
    public struct FilledMapSortConfiguration: Swift.Sendable {
        /// The sort configuration of the location fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categorySort = categorySort
        }
    }
}

extension QuickSightClientTypes {

    /// The bound options (north, south, west, east) of the geospatial window options.
    public struct GeospatialCoordinateBounds: Swift.Sendable {
        /// The longitude of the east bound of the geospatial coordinate bounds.
        /// This member is required.
        public var east: Swift.Double?
        /// The latitude of the north bound of the geospatial coordinate bounds.
        /// This member is required.
        public var north: Swift.Double?
        /// The latitude of the south bound of the geospatial coordinate bounds.
        /// This member is required.
        public var south: Swift.Double?
        /// The longitude of the west bound of the geospatial coordinate bounds.
        /// This member is required.
        public var west: Swift.Double?

        public init(
            east: Swift.Double? = nil,
            north: Swift.Double? = nil,
            south: Swift.Double? = nil,
            west: Swift.Double? = nil
        )
        {
            self.east = east
            self.north = north
            self.south = south
            self.west = west
        }
    }
}

extension QuickSightClientTypes {

    public enum MapZoomMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [MapZoomMode] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The window options of the geospatial map visual.
    public struct GeospatialWindowOptions: Swift.Sendable {
        /// The bounds options (north, south, west, east) of the geospatial window options.
        public var bounds: QuickSightClientTypes.GeospatialCoordinateBounds?
        /// The map zoom modes (manual, auto) of the geospatial window options.
        public var mapZoomMode: QuickSightClientTypes.MapZoomMode?

        public init(
            bounds: QuickSightClientTypes.GeospatialCoordinateBounds? = nil,
            mapZoomMode: QuickSightClientTypes.MapZoomMode? = nil
        )
        {
            self.bounds = bounds
            self.mapZoomMode = mapZoomMode
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a FilledMapVisual.
    public struct FilledMapConfiguration: Swift.Sendable {
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.FilledMapFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The map style options of the filled map visual.
        public var mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions?
        /// The sort configuration of a FilledMapVisual.
        public var sortConfiguration: QuickSightClientTypes.FilledMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The window options of the filled map visual.
        public var windowOptions: QuickSightClientTypes.GeospatialWindowOptions?

        public init(
            fieldWells: QuickSightClientTypes.FilledMapFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions? = nil,
            sortConfiguration: QuickSightClientTypes.FilledMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            windowOptions: QuickSightClientTypes.GeospatialWindowOptions? = nil
        )
        {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.windowOptions = windowOptions
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the gradient stop configuration.
    public struct GradientStop: Swift.Sendable {
        /// Determines the color.
        public var color: Swift.String?
        /// Determines the data value.
        public var dataValue: Swift.Double?
        /// Determines gradient offset value.
        /// This member is required.
        public var gradientOffset: Swift.Double

        public init(
            color: Swift.String? = nil,
            dataValue: Swift.Double? = 0.0,
            gradientOffset: Swift.Double = 0.0
        )
        {
            self.color = color
            self.dataValue = dataValue
            self.gradientOffset = gradientOffset
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the gradient color settings.
    public struct GradientColor: Swift.Sendable {
        /// The list of gradient color stops.
        public var stops: [QuickSightClientTypes.GradientStop]?

        public init(
            stops: [QuickSightClientTypes.GradientStop]? = nil
        )
        {
            self.stops = stops
        }
    }
}

extension QuickSightClientTypes {

    /// Formatting configuration for gradient color.
    public struct ConditionalFormattingGradientColor: Swift.Sendable {
        /// Determines the color.
        /// This member is required.
        public var color: QuickSightClientTypes.GradientColor?
        /// The expression that determines the formatting configuration for gradient color.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            color: QuickSightClientTypes.GradientColor? = nil,
            expression: Swift.String? = nil
        )
        {
            self.color = color
            self.expression = expression
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingGradientColor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingGradientColor(color: \(Swift.String(describing: color)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// Formatting configuration for solid color.
    public struct ConditionalFormattingSolidColor: Swift.Sendable {
        /// Determines the color.
        public var color: Swift.String?
        /// The expression that determines the formatting configuration for solid color.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            color: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.color = color
            self.expression = expression
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingSolidColor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingSolidColor(color: \(Swift.String(describing: color)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The formatting configuration for the color.
    public struct ConditionalFormattingColor: Swift.Sendable {
        /// Formatting configuration for gradient color.
        public var gradient: QuickSightClientTypes.ConditionalFormattingGradientColor?
        /// Formatting configuration for solid color.
        public var solid: QuickSightClientTypes.ConditionalFormattingSolidColor?

        public init(
            gradient: QuickSightClientTypes.ConditionalFormattingGradientColor? = nil,
            solid: QuickSightClientTypes.ConditionalFormattingSolidColor? = nil
        )
        {
            self.gradient = gradient
            self.solid = solid
        }
    }
}

extension QuickSightClientTypes {

    /// The shape conditional formatting of a filled map visual.
    public struct ShapeConditionalFormat: Swift.Sendable {
        /// The conditional formatting for the shape background color of a filled map visual.
        /// This member is required.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting that determines the shape of the filled map.
    public struct FilledMapShapeConditionalFormatting: Swift.Sendable {
        /// The field ID of the filled map shape.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The conditional formatting that determines the background color of a filled map's shape.
        public var format: QuickSightClientTypes.ShapeConditionalFormat?

        public init(
            fieldId: Swift.String? = nil,
            format: QuickSightClientTypes.ShapeConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.format = format
        }
    }
}

extension QuickSightClientTypes {

    /// Conditional formatting options of a FilledMapVisual.
    public struct FilledMapConditionalFormattingOption: Swift.Sendable {
        /// The conditional formatting that determines the shape of the filled map.
        /// This member is required.
        public var shape: QuickSightClientTypes.FilledMapShapeConditionalFormatting?

        public init(
            shape: QuickSightClientTypes.FilledMapShapeConditionalFormatting? = nil
        )
        {
            self.shape = shape
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting of a FilledMapVisual.
    public struct FilledMapConditionalFormatting: Swift.Sendable {
        /// Conditional formatting options of a FilledMapVisual.
        /// This member is required.
        public var conditionalFormattingOptions: [QuickSightClientTypes.FilledMapConditionalFormattingOption]?

        public init(
            conditionalFormattingOptions: [QuickSightClientTypes.FilledMapConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A filled map. For more information, see [Creating filled maps](https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html) in the Amazon QuickSight User Guide.
    public struct FilledMapVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.FilledMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The conditional formatting of a FilledMapVisual.
        public var conditionalFormatting: QuickSightClientTypes.FilledMapConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.FilledMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            conditionalFormatting: QuickSightClientTypes.FilledMapConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum FunnelChartMeasureDataLabelStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case percentageByFirstStage
        case percentageByPreviousStage
        case valueAndPercentageByFirstStage
        case valueAndPercentageByPreviousStage
        case valueOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [FunnelChartMeasureDataLabelStyle] {
            return [
                .percentageByFirstStage,
                .percentageByPreviousStage,
                .valueAndPercentageByFirstStage,
                .valueAndPercentageByPreviousStage,
                .valueOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .percentageByFirstStage: return "PERCENTAGE_BY_FIRST_STAGE"
            case .percentageByPreviousStage: return "PERCENTAGE_BY_PREVIOUS_STAGE"
            case .valueAndPercentageByFirstStage: return "VALUE_AND_PERCENTAGE_BY_FIRST_STAGE"
            case .valueAndPercentageByPreviousStage: return "VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE"
            case .valueOnly: return "VALUE_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the data labels.
    public struct FunnelChartDataLabelOptions: Swift.Sendable {
        /// The visibility of the category labels within the data labels.
        public var categoryLabelVisibility: QuickSightClientTypes.Visibility?
        /// The color of the data label text.
        public var labelColor: Swift.String?
        /// The font configuration for the data labels. Only the FontSize attribute of the font configuration is used for data labels.
        public var labelFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// Determines the style of the metric labels.
        public var measureDataLabelStyle: QuickSightClientTypes.FunnelChartMeasureDataLabelStyle?
        /// The visibility of the measure labels within the data labels.
        public var measureLabelVisibility: QuickSightClientTypes.Visibility?
        /// Determines the positioning of the data label relative to a section of the funnel.
        public var position: QuickSightClientTypes.DataLabelPosition?
        /// The visibility option that determines if data labels are displayed.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            categoryLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            labelColor: Swift.String? = nil,
            labelFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            measureDataLabelStyle: QuickSightClientTypes.FunnelChartMeasureDataLabelStyle? = nil,
            measureLabelVisibility: QuickSightClientTypes.Visibility? = nil,
            position: QuickSightClientTypes.DataLabelPosition? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.categoryLabelVisibility = categoryLabelVisibility
            self.labelColor = labelColor
            self.labelFontConfiguration = labelFontConfiguration
            self.measureDataLabelStyle = measureDataLabelStyle
            self.measureLabelVisibility = measureLabelVisibility
            self.position = position
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a FunnelChartVisual.
    public struct FunnelChartAggregatedFieldWells: Swift.Sendable {
        /// The category field wells of a funnel chart. Values are grouped by category fields.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a funnel chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a FunnelChartVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct FunnelChartFieldWells: Swift.Sendable {
        /// The field well configuration of a FunnelChartVisual.
        public var funnelChartAggregatedFieldWells: QuickSightClientTypes.FunnelChartAggregatedFieldWells?

        public init(
            funnelChartAggregatedFieldWells: QuickSightClientTypes.FunnelChartAggregatedFieldWells? = nil
        )
        {
            self.funnelChartAggregatedFieldWells = funnelChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a FunnelChartVisual.
    public struct FunnelChartSortConfiguration: Swift.Sendable {
        /// The limit on the number of categories displayed.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a FunnelChartVisual.
    public struct FunnelChartConfiguration: Swift.Sendable {
        /// The label options of the categories that are displayed in a FunnelChartVisual.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine the presentation of the data labels.
        public var dataLabelOptions: QuickSightClientTypes.FunnelChartDataLabelOptions?
        /// The field well configuration of a FunnelChartVisual.
        public var fieldWells: QuickSightClientTypes.FunnelChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The sort configuration of a FunnelChartVisual.
        public var sortConfiguration: QuickSightClientTypes.FunnelChartSortConfiguration?
        /// The tooltip configuration of a FunnelChartVisual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label options for the values that are displayed in a FunnelChartVisual.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The visual palette configuration of a FunnelChartVisual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            dataLabelOptions: QuickSightClientTypes.FunnelChartDataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.FunnelChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            sortConfiguration: QuickSightClientTypes.FunnelChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.dataLabelOptions = dataLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// A funnel chart. For more information, see [Using funnel charts](https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html) in the Amazon QuickSight User Guide.
    public struct FunnelChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a FunnelChartVisual.
        public var chartConfiguration: QuickSightClientTypes.FunnelChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.FunnelChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The color configuration of a GaugeChartVisual.
    public struct GaugeChartColorConfiguration: Swift.Sendable {
        /// The background color configuration of a GaugeChartVisual.
        public var backgroundColor: Swift.String?
        /// The foreground color configuration of a GaugeChartVisual.
        public var foregroundColor: Swift.String?

        public init(
            backgroundColor: Swift.String? = nil,
            foregroundColor: Swift.String? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.foregroundColor = foregroundColor
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a GaugeChartVisual.
    public struct GaugeChartFieldWells: Swift.Sendable {
        /// The target value field wells of a GaugeChartVisual.
        public var targetValues: [QuickSightClientTypes.MeasureField]?
        /// The value field wells of a GaugeChartVisual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            targetValues: [QuickSightClientTypes.MeasureField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.targetValues = targetValues
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    public enum ArcThicknessOptions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case medium
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [ArcThicknessOptions] {
            return [
                .large,
                .medium,
                .small
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The arc configuration of a GaugeChartVisual.
    public struct ArcConfiguration: Swift.Sendable {
        /// The option that determines the arc angle of a GaugeChartVisual.
        public var arcAngle: Swift.Double?
        /// The options that determine the arc thickness of a GaugeChartVisual.
        public var arcThickness: QuickSightClientTypes.ArcThicknessOptions?

        public init(
            arcAngle: Swift.Double? = 0.0,
            arcThickness: QuickSightClientTypes.ArcThicknessOptions? = nil
        )
        {
            self.arcAngle = arcAngle
            self.arcThickness = arcThickness
        }
    }
}

extension QuickSightClientTypes {

    /// The arc axis range of a GaugeChartVisual.
    public struct ArcAxisDisplayRange: Swift.Sendable {
        /// The maximum value of the arc axis range.
        public var max: Swift.Double?
        /// The minimum value of the arc axis range.
        public var min: Swift.Double?

        public init(
            max: Swift.Double? = 0.0,
            min: Swift.Double? = 0.0
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension QuickSightClientTypes {

    /// The arc axis configuration of a GaugeChartVisual.
    public struct ArcAxisConfiguration: Swift.Sendable {
        /// The arc axis range of a GaugeChartVisual.
        public var range: QuickSightClientTypes.ArcAxisDisplayRange?
        /// The reserved range of the arc axis.
        public var reserveRange: Swift.Int

        public init(
            range: QuickSightClientTypes.ArcAxisDisplayRange? = nil,
            reserveRange: Swift.Int = 0
        )
        {
            self.range = range
            self.reserveRange = reserveRange
        }
    }
}

extension QuickSightClientTypes {

    /// The format of the comparison. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ComparisonFormatConfiguration: Swift.Sendable {
        /// The number display format.
        public var numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration?
        /// The percentage display format.
        public var percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration?

        public init(
            numberDisplayFormatConfiguration: QuickSightClientTypes.NumberDisplayFormatConfiguration? = nil,
            percentageDisplayFormatConfiguration: QuickSightClientTypes.PercentageDisplayFormatConfiguration? = nil
        )
        {
            self.numberDisplayFormatConfiguration = numberDisplayFormatConfiguration
            self.percentageDisplayFormatConfiguration = percentageDisplayFormatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    public enum ComparisonMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case difference
        case percent
        case percentDifference
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonMethod] {
            return [
                .difference,
                .percent,
                .percentDifference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .difference: return "DIFFERENCE"
            case .percent: return "PERCENT"
            case .percentDifference: return "PERCENT_DIFFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The comparison display configuration of a KPI or gauge chart.
    public struct ComparisonConfiguration: Swift.Sendable {
        /// The format of the comparison.
        public var comparisonFormat: QuickSightClientTypes.ComparisonFormatConfiguration?
        /// The method of the comparison. Choose from the following options:
        ///
        /// * DIFFERENCE
        ///
        /// * PERCENT_DIFFERENCE
        ///
        /// * PERCENT
        public var comparisonMethod: QuickSightClientTypes.ComparisonMethod?

        public init(
            comparisonFormat: QuickSightClientTypes.ComparisonFormatConfiguration? = nil,
            comparisonMethod: QuickSightClientTypes.ComparisonMethod? = nil
        )
        {
            self.comparisonFormat = comparisonFormat
            self.comparisonMethod = comparisonMethod
        }
    }
}

extension QuickSightClientTypes {

    public enum PrimaryValueDisplayType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actual
        case comparison
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [PrimaryValueDisplayType] {
            return [
                .actual,
                .comparison,
                .hidden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .comparison: return "COMPARISON"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the GaugeChartVisual.
    public struct GaugeChartOptions: Swift.Sendable {
        /// The arc configuration of a GaugeChartVisual.
        public var arc: QuickSightClientTypes.ArcConfiguration?
        /// The arc axis configuration of a GaugeChartVisual.
        public var arcAxis: QuickSightClientTypes.ArcAxisConfiguration?
        /// The comparison configuration of a GaugeChartVisual.
        public var comparison: QuickSightClientTypes.ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public var primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public var primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?

        public init(
            arc: QuickSightClientTypes.ArcConfiguration? = nil,
            arcAxis: QuickSightClientTypes.ArcAxisConfiguration? = nil,
            comparison: QuickSightClientTypes.ComparisonConfiguration? = nil,
            primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType? = nil,
            primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil
        )
        {
            self.arc = arc
            self.arcAxis = arcAxis
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a GaugeChartVisual.
    public struct GaugeChartConfiguration: Swift.Sendable {
        /// The color configuration of a GaugeChartVisual.
        public var colorConfiguration: QuickSightClientTypes.GaugeChartColorConfiguration?
        /// The data label configuration of a GaugeChartVisual.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a GaugeChartVisual.
        public var fieldWells: QuickSightClientTypes.GaugeChartFieldWells?
        /// The options that determine the presentation of the GaugeChartVisual.
        public var gaugeChartOptions: QuickSightClientTypes.GaugeChartOptions?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The tooltip configuration of a GaugeChartVisual.
        public var tooltipOptions: QuickSightClientTypes.TooltipOptions?
        /// The visual palette configuration of a GaugeChartVisual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            colorConfiguration: QuickSightClientTypes.GaugeChartColorConfiguration? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.GaugeChartFieldWells? = nil,
            gaugeChartOptions: QuickSightClientTypes.GaugeChartOptions? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            tooltipOptions: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.colorConfiguration = colorConfiguration
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.gaugeChartOptions = gaugeChartOptions
            self.interactions = interactions
            self.tooltipOptions = tooltipOptions
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the arc of a GaugeChartVisual.
    public struct GaugeChartArcConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the arc foreground color.
        public var foregroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            foregroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.foregroundColor = foregroundColor
        }
    }
}

extension QuickSightClientTypes {

    public enum ConditionalFormattingIconDisplayOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iconOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionalFormattingIconDisplayOption] {
            return [
                .iconOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iconOnly: return "ICON_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the icon display configuration.
    public struct ConditionalFormattingIconDisplayConfiguration: Swift.Sendable {
        /// Determines the icon display configuration.
        public var iconDisplayOption: QuickSightClientTypes.ConditionalFormattingIconDisplayOption?

        public init(
            iconDisplayOption: QuickSightClientTypes.ConditionalFormattingIconDisplayOption? = nil
        )
        {
            self.iconDisplayOption = iconDisplayOption
        }
    }
}

extension QuickSightClientTypes {

    public enum Icon: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arrowDown
        case arrowDownLeft
        case arrowDownRight
        case arrowLeft
        case arrowRight
        case arrowUp
        case arrowUpLeft
        case arrowUpRight
        case caretDown
        case caretUp
        case checkmark
        case circle
        case faceDown
        case faceFlat
        case faceUp
        case flag
        case minus
        case oneBar
        case plus
        case square
        case threeBar
        case thumbsDown
        case thumbsUp
        case triangle
        case twoBar
        case x
        case sdkUnknown(Swift.String)

        public static var allCases: [Icon] {
            return [
                .arrowDown,
                .arrowDownLeft,
                .arrowDownRight,
                .arrowLeft,
                .arrowRight,
                .arrowUp,
                .arrowUpLeft,
                .arrowUpRight,
                .caretDown,
                .caretUp,
                .checkmark,
                .circle,
                .faceDown,
                .faceFlat,
                .faceUp,
                .flag,
                .minus,
                .oneBar,
                .plus,
                .square,
                .threeBar,
                .thumbsDown,
                .thumbsUp,
                .triangle,
                .twoBar,
                .x
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arrowDown: return "ARROW_DOWN"
            case .arrowDownLeft: return "ARROW_DOWN_LEFT"
            case .arrowDownRight: return "ARROW_DOWN_RIGHT"
            case .arrowLeft: return "ARROW_LEFT"
            case .arrowRight: return "ARROW_RIGHT"
            case .arrowUp: return "ARROW_UP"
            case .arrowUpLeft: return "ARROW_UP_LEFT"
            case .arrowUpRight: return "ARROW_UP_RIGHT"
            case .caretDown: return "CARET_DOWN"
            case .caretUp: return "CARET_UP"
            case .checkmark: return "CHECKMARK"
            case .circle: return "CIRCLE"
            case .faceDown: return "FACE_DOWN"
            case .faceFlat: return "FACE_FLAT"
            case .faceUp: return "FACE_UP"
            case .flag: return "FLAG"
            case .minus: return "MINUS"
            case .oneBar: return "ONE_BAR"
            case .plus: return "PLUS"
            case .square: return "SQUARE"
            case .threeBar: return "THREE_BAR"
            case .thumbsDown: return "THUMBS_DOWN"
            case .thumbsUp: return "THUMBS_UP"
            case .triangle: return "TRIANGLE"
            case .twoBar: return "TWO_BAR"
            case .x: return "X"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Custom icon options for an icon set.
    public struct ConditionalFormattingCustomIconOptions: Swift.Sendable {
        /// Determines the type of icon.
        public var icon: QuickSightClientTypes.Icon?
        /// Determines the Unicode icon type.
        public var unicodeIcon: Swift.String?

        public init(
            icon: QuickSightClientTypes.Icon? = nil,
            unicodeIcon: Swift.String? = nil
        )
        {
            self.icon = icon
            self.unicodeIcon = unicodeIcon
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the custom condition for an icon set.
    public struct ConditionalFormattingCustomIconCondition: Swift.Sendable {
        /// Determines the color of the icon.
        public var color: Swift.String?
        /// Determines the icon display configuration.
        public var displayConfiguration: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration?
        /// The expression that determines the condition of the icon set.
        /// This member is required.
        public var expression: Swift.String?
        /// Custom icon options for an icon set.
        /// This member is required.
        public var iconOptions: QuickSightClientTypes.ConditionalFormattingCustomIconOptions?

        public init(
            color: Swift.String? = nil,
            displayConfiguration: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration? = nil,
            expression: Swift.String? = nil,
            iconOptions: QuickSightClientTypes.ConditionalFormattingCustomIconOptions? = nil
        )
        {
            self.color = color
            self.displayConfiguration = displayConfiguration
            self.expression = expression
            self.iconOptions = iconOptions
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingCustomIconCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingCustomIconCondition(color: \(Swift.String(describing: color)), displayConfiguration: \(Swift.String(describing: displayConfiguration)), iconOptions: \(Swift.String(describing: iconOptions)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum ConditionalFormattingIconSetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bars
        case caretUpMinusDown
        case checkX
        case flags
        case fourColorArrow
        case fourGrayArrow
        case plusMinus
        case threeCircle
        case threeColorArrow
        case threeGrayArrow
        case threeShape
        case sdkUnknown(Swift.String)

        public static var allCases: [ConditionalFormattingIconSetType] {
            return [
                .bars,
                .caretUpMinusDown,
                .checkX,
                .flags,
                .fourColorArrow,
                .fourGrayArrow,
                .plusMinus,
                .threeCircle,
                .threeColorArrow,
                .threeGrayArrow,
                .threeShape
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bars: return "BARS"
            case .caretUpMinusDown: return "CARET_UP_MINUS_DOWN"
            case .checkX: return "CHECK_X"
            case .flags: return "FLAGS"
            case .fourColorArrow: return "FOUR_COLOR_ARROW"
            case .fourGrayArrow: return "FOUR_GRAY_ARROW"
            case .plusMinus: return "PLUS_MINUS"
            case .threeCircle: return "THREE_CIRCLE"
            case .threeColorArrow: return "THREE_COLOR_ARROW"
            case .threeGrayArrow: return "THREE_GRAY_ARROW"
            case .threeShape: return "THREE_SHAPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Formatting configuration for icon set.
    public struct ConditionalFormattingIconSet: Swift.Sendable {
        /// The expression that determines the formatting configuration for the icon set.
        /// This member is required.
        public var expression: Swift.String?
        /// Determines the icon set type.
        public var iconSetType: QuickSightClientTypes.ConditionalFormattingIconSetType?

        public init(
            expression: Swift.String? = nil,
            iconSetType: QuickSightClientTypes.ConditionalFormattingIconSetType? = nil
        )
        {
            self.expression = expression
            self.iconSetType = iconSetType
        }
    }
}

extension QuickSightClientTypes.ConditionalFormattingIconSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionalFormattingIconSet(iconSetType: \(Swift.String(describing: iconSetType)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The formatting configuration for the icon.
    public struct ConditionalFormattingIcon: Swift.Sendable {
        /// Determines the custom condition for an icon set.
        public var customCondition: QuickSightClientTypes.ConditionalFormattingCustomIconCondition?
        /// Formatting configuration for icon set.
        public var iconSet: QuickSightClientTypes.ConditionalFormattingIconSet?

        public init(
            customCondition: QuickSightClientTypes.ConditionalFormattingCustomIconCondition? = nil,
            iconSet: QuickSightClientTypes.ConditionalFormattingIconSet? = nil
        )
        {
            self.customCondition = customCondition
            self.iconSet = iconSet
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the primary value of a GaugeChartVisual.
    public struct GaugeChartPrimaryValueConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the primary value icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the primary value text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// Conditional formatting options of a GaugeChartVisual.
    public struct GaugeChartConditionalFormattingOption: Swift.Sendable {
        /// The options that determine the presentation of the arc of a GaugeChartVisual.
        public var arc: QuickSightClientTypes.GaugeChartArcConditionalFormatting?
        /// The conditional formatting for the primary value of a GaugeChartVisual.
        public var primaryValue: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting?

        public init(
            arc: QuickSightClientTypes.GaugeChartArcConditionalFormatting? = nil,
            primaryValue: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting? = nil
        )
        {
            self.arc = arc
            self.primaryValue = primaryValue
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting of a GaugeChartVisual.
    public struct GaugeChartConditionalFormatting: Swift.Sendable {
        /// Conditional formatting options of a GaugeChartVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.GaugeChartConditionalFormattingOption]?

        public init(
            conditionalFormattingOptions: [QuickSightClientTypes.GaugeChartConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A gauge chart. For more information, see [Using gauge charts](https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html) in the Amazon QuickSight User Guide.
    public struct GaugeChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a GaugeChartVisual.
        public var chartConfiguration: QuickSightClientTypes.GaugeChartConfiguration?
        /// The conditional formatting of a GaugeChartVisual.
        public var conditionalFormatting: QuickSightClientTypes.GaugeChartConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.GaugeChartConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.GaugeChartConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field wells for a geospatial map.
    public struct GeospatialMapAggregatedFieldWells: Swift.Sendable {
        /// The color field wells of a geospatial map.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The geospatial field wells of a geospatial map. Values are grouped by geospatial fields.
        public var geospatial: [QuickSightClientTypes.DimensionField]?
        /// The size field wells of a geospatial map. Values are aggregated based on geospatial fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            geospatial: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.colors = colors
            self.geospatial = geospatial
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a GeospatialMapVisual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct GeospatialMapFieldWells: Swift.Sendable {
        /// The aggregated field well for a geospatial map.
        public var geospatialMapAggregatedFieldWells: QuickSightClientTypes.GeospatialMapAggregatedFieldWells?

        public init(
            geospatialMapAggregatedFieldWells: QuickSightClientTypes.GeospatialMapAggregatedFieldWells? = nil
        )
        {
            self.geospatialMapAggregatedFieldWells = geospatialMapAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The simple cluster marker of the cluster marker.
    public struct SimpleClusterMarker: Swift.Sendable {
        /// The color of the simple cluster marker.
        public var color: Swift.String?

        public init(
            color: Swift.String? = nil
        )
        {
            self.color = color
        }
    }
}

extension QuickSightClientTypes {

    /// The cluster marker that is a part of the cluster marker configuration.
    public struct ClusterMarker: Swift.Sendable {
        /// The simple cluster marker of the cluster marker.
        public var simpleClusterMarker: QuickSightClientTypes.SimpleClusterMarker?

        public init(
            simpleClusterMarker: QuickSightClientTypes.SimpleClusterMarker? = nil
        )
        {
            self.simpleClusterMarker = simpleClusterMarker
        }
    }
}

extension QuickSightClientTypes {

    /// The cluster marker configuration of the geospatial map selected point style.
    public struct ClusterMarkerConfiguration: Swift.Sendable {
        /// The cluster marker that is a part of the cluster marker configuration.
        public var clusterMarker: QuickSightClientTypes.ClusterMarker?

        public init(
            clusterMarker: QuickSightClientTypes.ClusterMarker? = nil
        )
        {
            self.clusterMarker = clusterMarker
        }
    }
}

extension QuickSightClientTypes {

    /// The color to be used in the heatmap point style.
    public struct GeospatialHeatmapDataColor: Swift.Sendable {
        /// The hex color to be used in the heatmap point style.
        /// This member is required.
        public var color: Swift.String?

        public init(
            color: Swift.String? = nil
        )
        {
            self.color = color
        }
    }
}

extension QuickSightClientTypes {

    /// The color scale specification for the heatmap point style.
    public struct GeospatialHeatmapColorScale: Swift.Sendable {
        /// The list of colors to be used in heatmap point style.
        public var colors: [QuickSightClientTypes.GeospatialHeatmapDataColor]?

        public init(
            colors: [QuickSightClientTypes.GeospatialHeatmapDataColor]? = nil
        )
        {
            self.colors = colors
        }
    }
}

extension QuickSightClientTypes {

    /// The heatmap configuration of the geospatial point style.
    public struct GeospatialHeatmapConfiguration: Swift.Sendable {
        /// The color scale specification for the heatmap point style.
        public var heatmapColor: QuickSightClientTypes.GeospatialHeatmapColorScale?

        public init(
            heatmapColor: QuickSightClientTypes.GeospatialHeatmapColorScale? = nil
        )
        {
            self.heatmapColor = heatmapColor
        }
    }
}

extension QuickSightClientTypes {

    public enum GeospatialSelectedPointStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cluster
        case heatmap
        case point
        case sdkUnknown(Swift.String)

        public static var allCases: [GeospatialSelectedPointStyle] {
            return [
                .cluster,
                .heatmap,
                .point
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cluster: return "CLUSTER"
            case .heatmap: return "HEATMAP"
            case .point: return "POINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The point style of the geospatial map.
    public struct GeospatialPointStyleOptions: Swift.Sendable {
        /// The cluster marker configuration of the geospatial point style.
        public var clusterMarkerConfiguration: QuickSightClientTypes.ClusterMarkerConfiguration?
        /// The heatmap configuration of the geospatial point style.
        public var heatmapConfiguration: QuickSightClientTypes.GeospatialHeatmapConfiguration?
        /// The selected point styles (point, cluster) of the geospatial map.
        public var selectedPointStyle: QuickSightClientTypes.GeospatialSelectedPointStyle?

        public init(
            clusterMarkerConfiguration: QuickSightClientTypes.ClusterMarkerConfiguration? = nil,
            heatmapConfiguration: QuickSightClientTypes.GeospatialHeatmapConfiguration? = nil,
            selectedPointStyle: QuickSightClientTypes.GeospatialSelectedPointStyle? = nil
        )
        {
            self.clusterMarkerConfiguration = clusterMarkerConfiguration
            self.heatmapConfiguration = heatmapConfiguration
            self.selectedPointStyle = selectedPointStyle
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a GeospatialMapVisual.
    public struct GeospatialMapConfiguration: Swift.Sendable {
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.GeospatialMapFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The map style options of the geospatial map.
        public var mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions?
        /// The point style options of the geospatial map.
        public var pointStyleOptions: QuickSightClientTypes.GeospatialPointStyleOptions?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The visual display options for the visual palette.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The window options of the geospatial map.
        public var windowOptions: QuickSightClientTypes.GeospatialWindowOptions?

        public init(
            fieldWells: QuickSightClientTypes.GeospatialMapFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            mapStyleOptions: QuickSightClientTypes.GeospatialMapStyleOptions? = nil,
            pointStyleOptions: QuickSightClientTypes.GeospatialPointStyleOptions? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            windowOptions: QuickSightClientTypes.GeospatialWindowOptions? = nil
        )
        {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.mapStyleOptions = mapStyleOptions
            self.pointStyleOptions = pointStyleOptions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.windowOptions = windowOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A geospatial map or a points on map visual. For more information, see [Creating point maps](https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html) in the Amazon QuickSight User Guide.
    public struct GeospatialMapVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.GeospatialMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.GeospatialMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum ColorFillType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case discrete
        case gradient
        case sdkUnknown(Swift.String)

        public static var allCases: [ColorFillType] {
            return [
                .discrete,
                .gradient
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .discrete: return "DISCRETE"
            case .gradient: return "GRADIENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the color that is applied to a particular data value.
    public struct DataColor: Swift.Sendable {
        /// The color that is applied to the data value.
        public var color: Swift.String?
        /// The data value that the color is applied to.
        public var dataValue: Swift.Double?

        public init(
            color: Swift.String? = nil,
            dataValue: Swift.Double? = 0.0
        )
        {
            self.color = color
            self.dataValue = dataValue
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the color scale that is applied to the visual.
    public struct ColorScale: Swift.Sendable {
        /// Determines the color fill type.
        /// This member is required.
        public var colorFillType: QuickSightClientTypes.ColorFillType?
        /// Determines the list of colors that are applied to the visual.
        /// This member is required.
        public var colors: [QuickSightClientTypes.DataColor]?
        /// Determines the color that is applied to null values.
        public var nullValueColor: QuickSightClientTypes.DataColor?

        public init(
            colorFillType: QuickSightClientTypes.ColorFillType? = nil,
            colors: [QuickSightClientTypes.DataColor]? = nil,
            nullValueColor: QuickSightClientTypes.DataColor? = nil
        )
        {
            self.colorFillType = colorFillType
            self.colors = colors
            self.nullValueColor = nullValueColor
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field wells of a heat map.
    public struct HeatMapAggregatedFieldWells: Swift.Sendable {
        /// The columns field well of a heat map.
        public var columns: [QuickSightClientTypes.DimensionField]?
        /// The rows field well of a heat map.
        public var rows: [QuickSightClientTypes.DimensionField]?
        /// The values field well of a heat map.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            columns: [QuickSightClientTypes.DimensionField]? = nil,
            rows: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.columns = columns
            self.rows = rows
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a heat map. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct HeatMapFieldWells: Swift.Sendable {
        /// The aggregated field wells of a heat map.
        public var heatMapAggregatedFieldWells: QuickSightClientTypes.HeatMapAggregatedFieldWells?

        public init(
            heatMapAggregatedFieldWells: QuickSightClientTypes.HeatMapAggregatedFieldWells? = nil
        )
        {
            self.heatMapAggregatedFieldWells = heatMapAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a heat map.
    public struct HeatMapSortConfiguration: Swift.Sendable {
        /// The limit on the number of columns that are displayed in a heat map.
        public var heatMapColumnItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The column sort configuration for heat map for columns that aren't a part of a field well.
        public var heatMapColumnSort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of rows that are displayed in a heat map.
        public var heatMapRowItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The field sort configuration of the rows fields.
        public var heatMapRowSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            heatMapColumnItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            heatMapColumnSort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            heatMapRowItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            heatMapRowSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.heatMapColumnItemsLimitConfiguration = heatMapColumnItemsLimitConfiguration
            self.heatMapColumnSort = heatMapColumnSort
            self.heatMapRowItemsLimitConfiguration = heatMapRowItemsLimitConfiguration
            self.heatMapRowSort = heatMapRowSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a heat map.
    public struct HeatMapConfiguration: Swift.Sendable {
        /// The color options (gradient color, point of divergence) in a heat map.
        public var colorScale: QuickSightClientTypes.ColorScale?
        /// The label options of the column that is displayed in a heat map.
        public var columnLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.HeatMapFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label options of the row that is displayed in a heat map.
        public var rowLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a heat map.
        public var sortConfiguration: QuickSightClientTypes.HeatMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?

        public init(
            colorScale: QuickSightClientTypes.ColorScale? = nil,
            columnLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.HeatMapFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            rowLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.HeatMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil
        )
        {
            self.colorScale = colorScale
            self.columnLabelOptions = columnLabelOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.rowLabelOptions = rowLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }
    }
}

extension QuickSightClientTypes {

    /// A heat map. For more information, see [Using heat maps](https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html) in the Amazon QuickSight User Guide.
    public struct HeatMapVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a heat map.
        public var chartConfiguration: QuickSightClientTypes.HeatMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.HeatMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the bin count of a histogram.
    public struct BinCountOptions: Swift.Sendable {
        /// The options that determine the bin count value.
        public var value: Swift.Int?

        public init(
            value: Swift.Int? = nil
        )
        {
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the bin width of a histogram.
    public struct BinWidthOptions: Swift.Sendable {
        /// The options that determine the bin count limit.
        public var binCountLimit: Swift.Int?
        /// The options that determine the bin width value.
        public var value: Swift.Double?

        public init(
            binCountLimit: Swift.Int? = nil,
            value: Swift.Double? = nil
        )
        {
            self.binCountLimit = binCountLimit
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    public enum HistogramBinType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binCount
        case binWidth
        case sdkUnknown(Swift.String)

        public static var allCases: [HistogramBinType] {
            return [
                .binCount,
                .binWidth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binCount: return "BIN_COUNT"
            case .binWidth: return "BIN_WIDTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of histogram bins.
    public struct HistogramBinOptions: Swift.Sendable {
        /// The options that determine the bin count of a histogram.
        public var binCount: QuickSightClientTypes.BinCountOptions?
        /// The options that determine the bin width of a histogram.
        public var binWidth: QuickSightClientTypes.BinWidthOptions?
        /// The options that determine the selected bin type.
        public var selectedBinType: QuickSightClientTypes.HistogramBinType?
        /// The options that determine the bin start value.
        public var startValue: Swift.Double?

        public init(
            binCount: QuickSightClientTypes.BinCountOptions? = nil,
            binWidth: QuickSightClientTypes.BinWidthOptions? = nil,
            selectedBinType: QuickSightClientTypes.HistogramBinType? = nil,
            startValue: Swift.Double? = 0.0
        )
        {
            self.binCount = binCount
            self.binWidth = binWidth
            self.selectedBinType = selectedBinType
            self.startValue = startValue
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a histogram.
    public struct HistogramAggregatedFieldWells: Swift.Sendable {
        /// The value field wells of a histogram. Values are aggregated by COUNT or DISTINCT_COUNT.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a histogram.
    public struct HistogramFieldWells: Swift.Sendable {
        /// The field well configuration of a histogram.
        public var histogramAggregatedFieldWells: QuickSightClientTypes.HistogramAggregatedFieldWells?

        public init(
            histogramAggregatedFieldWells: QuickSightClientTypes.HistogramAggregatedFieldWells? = nil
        )
        {
            self.histogramAggregatedFieldWells = histogramAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a HistogramVisual.
    public struct HistogramConfiguration: Swift.Sendable {
        /// The options that determine the presentation of histogram bins.
        public var binOptions: QuickSightClientTypes.HistogramBinOptions?
        /// The data label configuration of a histogram.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a histogram.
        public var fieldWells: QuickSightClientTypes.HistogramFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The tooltip configuration of a histogram.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The visual palette configuration of a histogram.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The options that determine the presentation of the y-axis.
        public var yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?

        public init(
            binOptions: QuickSightClientTypes.HistogramBinOptions? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.HistogramFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil
        )
        {
            self.binOptions = binOptions
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A histogram. For more information, see [Using histograms](https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html) in the Amazon QuickSight User Guide.
    public struct HistogramVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration for a HistogramVisual.
        public var chartConfiguration: QuickSightClientTypes.HistogramConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.HistogramConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum ForecastComputationSeasonality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [ForecastComputationSeasonality] {
            return [
                .automatic,
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The forecast computation configuration.
    public struct ForecastComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The custom seasonality value setup of a forecast computation.
        public var customSeasonalityValue: Swift.Int?
        /// The lower boundary setup of a forecast computation.
        public var lowerBoundary: Swift.Double?
        /// The name of a computation.
        public var name: Swift.String?
        /// The periods backward setup of a forecast computation.
        public var periodsBackward: Swift.Int?
        /// The periods forward setup of a forecast computation.
        public var periodsForward: Swift.Int?
        /// The prediction interval setup of a forecast computation.
        public var predictionInterval: Swift.Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:
        ///
        /// * AUTOMATIC
        ///
        /// * CUSTOM: Checks the custom seasonality value.
        public var seasonality: QuickSightClientTypes.ForecastComputationSeasonality?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The upper boundary setup of a forecast computation.
        public var upperBoundary: Swift.Double?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            customSeasonalityValue: Swift.Int? = nil,
            lowerBoundary: Swift.Double? = 0.0,
            name: Swift.String? = nil,
            periodsBackward: Swift.Int? = nil,
            periodsForward: Swift.Int? = nil,
            predictionInterval: Swift.Int? = nil,
            seasonality: QuickSightClientTypes.ForecastComputationSeasonality? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            upperBoundary: Swift.Double? = 0.0,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.customSeasonalityValue = customSeasonalityValue
            self.lowerBoundary = lowerBoundary
            self.name = name
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.time = time
            self.upperBoundary = upperBoundary
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The growth rate computation configuration.
    public struct GrowthRateComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The period size setup of a growth rate computation.
        public var periodSize: Swift.Int?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            periodSize: Swift.Int? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.periodSize = periodSize
            self.time = time
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    public enum MaximumMinimumComputationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case maximum
        case minimum
        case sdkUnknown(Swift.String)

        public static var allCases: [MaximumMinimumComputationType] {
            return [
                .maximum,
                .minimum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The maximum and minimum computation configuration.
    public struct MaximumMinimumComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The type of computation. Choose one of the following options:
        ///
        /// * MAXIMUM: A maximum computation.
        ///
        /// * MINIMUM: A minimum computation.
        /// This member is required.
        public var type: QuickSightClientTypes.MaximumMinimumComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            type: QuickSightClientTypes.MaximumMinimumComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.type = type
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The metric comparison computation configuration.
    public struct MetricComparisonComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The field that is used in a metric comparison from value setup.
        public var fromValue: QuickSightClientTypes.MeasureField?
        /// The name of a computation.
        public var name: Swift.String?
        /// The field that is used in a metric comparison to value setup.
        public var targetValue: QuickSightClientTypes.MeasureField?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?

        public init(
            computationId: Swift.String? = nil,
            fromValue: QuickSightClientTypes.MeasureField? = nil,
            name: Swift.String? = nil,
            targetValue: QuickSightClientTypes.MeasureField? = nil,
            time: QuickSightClientTypes.DimensionField? = nil
        )
        {
            self.computationId = computationId
            self.fromValue = fromValue
            self.name = name
            self.targetValue = targetValue
            self.time = time
        }
    }
}

extension QuickSightClientTypes {

    /// The period over period computation configuration.
    public struct PeriodOverPeriodComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.time = time
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The period to date computation configuration.
    public struct PeriodToDateComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The time granularity setup of period to date computation. Choose from the following options:
        ///
        /// * YEAR: Year to date.
        ///
        /// * MONTH: Month to date.
        public var periodTimeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            periodTimeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.periodTimeGranularity = periodTimeGranularity
            self.time = time
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    public enum TopBottomSortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absoluteDifference
        case percentDifference
        case sdkUnknown(Swift.String)

        public static var allCases: [TopBottomSortOrder] {
            return [
                .absoluteDifference,
                .percentDifference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absoluteDifference: return "ABSOLUTE_DIFFERENCE"
            case .percentDifference: return "PERCENT_DIFFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TopBottomComputationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottom
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [TopBottomComputationType] {
            return [
                .bottom,
                .top
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "BOTTOM"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The top movers and bottom movers computation setup.
    public struct TopBottomMoversComputation: Swift.Sendable {
        /// The category field that is used in a computation.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The mover size setup of the top and bottom movers computation.
        public var moverSize: Swift.Int?
        /// The name of a computation.
        public var name: Swift.String?
        /// The sort order setup of the top and bottom movers computation.
        public var sortOrder: QuickSightClientTypes.TopBottomSortOrder?
        /// The time field that is used in a computation.
        public var time: QuickSightClientTypes.DimensionField?
        /// The computation type. Choose from the following options:
        ///
        /// * TOP: Top movers computation.
        ///
        /// * BOTTOM: Bottom movers computation.
        /// This member is required.
        public var type: QuickSightClientTypes.TopBottomComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            moverSize: Swift.Int? = nil,
            name: Swift.String? = nil,
            sortOrder: QuickSightClientTypes.TopBottomSortOrder? = nil,
            time: QuickSightClientTypes.DimensionField? = nil,
            type: QuickSightClientTypes.TopBottomComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.moverSize = moverSize
            self.name = name
            self.sortOrder = sortOrder
            self.time = time
            self.type = type
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The top ranked and bottom ranked computation configuration.
    public struct TopBottomRankedComputation: Swift.Sendable {
        /// The category field that is used in a computation.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The result size of a top and bottom ranked computation.
        public var resultSize: Swift.Int?
        /// The computation type. Choose one of the following options:
        ///
        /// * TOP: A top ranked computation.
        ///
        /// * BOTTOM: A bottom ranked computation.
        /// This member is required.
        public var type: QuickSightClientTypes.TopBottomComputationType?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            resultSize: Swift.Int? = nil,
            type: QuickSightClientTypes.TopBottomComputationType? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.name = name
            self.resultSize = resultSize
            self.type = type
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The total aggregation computation configuration.
    public struct TotalAggregationComputation: Swift.Sendable {
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?
        /// The value field that is used in a computation.
        public var value: QuickSightClientTypes.MeasureField?

        public init(
            computationId: Swift.String? = nil,
            name: Swift.String? = nil,
            value: QuickSightClientTypes.MeasureField? = nil
        )
        {
            self.computationId = computationId
            self.name = name
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The unique values computation configuration.
    public struct UniqueValuesComputation: Swift.Sendable {
        /// The category field that is used in a computation.
        public var category: QuickSightClientTypes.DimensionField?
        /// The ID for a computation.
        /// This member is required.
        public var computationId: Swift.String?
        /// The name of a computation.
        public var name: Swift.String?

        public init(
            category: QuickSightClientTypes.DimensionField? = nil,
            computationId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.category = category
            self.computationId = computationId
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// The computation union that is used in an insight visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Computation: Swift.Sendable {
        /// The forecast computation configuration.
        public var forecast: QuickSightClientTypes.ForecastComputation?
        /// The growth rate computation configuration.
        public var growthRate: QuickSightClientTypes.GrowthRateComputation?
        /// The maximum and minimum computation configuration.
        public var maximumMinimum: QuickSightClientTypes.MaximumMinimumComputation?
        /// The metric comparison computation configuration.
        public var metricComparison: QuickSightClientTypes.MetricComparisonComputation?
        /// The period over period computation configuration.
        public var periodOverPeriod: QuickSightClientTypes.PeriodOverPeriodComputation?
        /// The period to DataSetIdentifier computation configuration.
        public var periodToDate: QuickSightClientTypes.PeriodToDateComputation?
        /// The top movers and bottom movers computation configuration.
        public var topBottomMovers: QuickSightClientTypes.TopBottomMoversComputation?
        /// The top ranked and bottom ranked computation configuration.
        public var topBottomRanked: QuickSightClientTypes.TopBottomRankedComputation?
        /// The total aggregation computation configuration.
        public var totalAggregation: QuickSightClientTypes.TotalAggregationComputation?
        /// The unique values computation configuration.
        public var uniqueValues: QuickSightClientTypes.UniqueValuesComputation?

        public init(
            forecast: QuickSightClientTypes.ForecastComputation? = nil,
            growthRate: QuickSightClientTypes.GrowthRateComputation? = nil,
            maximumMinimum: QuickSightClientTypes.MaximumMinimumComputation? = nil,
            metricComparison: QuickSightClientTypes.MetricComparisonComputation? = nil,
            periodOverPeriod: QuickSightClientTypes.PeriodOverPeriodComputation? = nil,
            periodToDate: QuickSightClientTypes.PeriodToDateComputation? = nil,
            topBottomMovers: QuickSightClientTypes.TopBottomMoversComputation? = nil,
            topBottomRanked: QuickSightClientTypes.TopBottomRankedComputation? = nil,
            totalAggregation: QuickSightClientTypes.TotalAggregationComputation? = nil,
            uniqueValues: QuickSightClientTypes.UniqueValuesComputation? = nil
        )
        {
            self.forecast = forecast
            self.growthRate = growthRate
            self.maximumMinimum = maximumMinimum
            self.metricComparison = metricComparison
            self.periodOverPeriod = periodOverPeriod
            self.periodToDate = periodToDate
            self.topBottomMovers = topBottomMovers
            self.topBottomRanked = topBottomRanked
            self.totalAggregation = totalAggregation
            self.uniqueValues = uniqueValues
        }
    }
}

extension QuickSightClientTypes {

    /// The custom narrative options.
    public struct CustomNarrativeOptions: Swift.Sendable {
        /// The string input of custom narrative.
        /// This member is required.
        public var narrative: Swift.String?

        public init(
            narrative: Swift.String? = nil
        )
        {
            self.narrative = narrative
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of an insight visual.
    public struct InsightConfiguration: Swift.Sendable {
        /// The computations configurations of the insight visual
        public var computations: [QuickSightClientTypes.Computation]?
        /// The custom narrative of the insight visual.
        public var customNarrative: QuickSightClientTypes.CustomNarrativeOptions?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?

        public init(
            computations: [QuickSightClientTypes.Computation]? = nil,
            customNarrative: QuickSightClientTypes.CustomNarrativeOptions? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil
        )
        {
            self.computations = computations
            self.customNarrative = customNarrative
            self.interactions = interactions
        }
    }
}

extension QuickSightClientTypes {

    /// An insight visual. For more information, see [Working with insights](https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html) in the Amazon QuickSight User Guide.
    public struct InsightVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The dataset that is used in the insight visual.
        /// This member is required.
        public var dataSetIdentifier: Swift.String?
        /// The configuration of an insight visual.
        public var insightConfiguration: QuickSightClientTypes.InsightConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            dataSetIdentifier: Swift.String? = nil,
            insightConfiguration: QuickSightClientTypes.InsightConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.dataSetIdentifier = dataSetIdentifier
            self.insightConfiguration = insightConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a KPI visual.
    public struct KPIFieldWells: Swift.Sendable {
        /// The target value field wells of a KPI visual.
        public var targetValues: [QuickSightClientTypes.MeasureField]?
        /// The trend group field wells of a KPI visual.
        public var trendGroups: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a KPI visual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            targetValues: [QuickSightClientTypes.MeasureField]? = nil,
            trendGroups: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.targetValues = targetValues
            self.trendGroups = trendGroups
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the progress bar of a KPI visual.
    public struct ProgressBarOptions: Swift.Sendable {
        /// The visibility of the progress bar.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of the secondary value of a KPI visual.
    public struct SecondaryValueOptions: Swift.Sendable {
        /// Determines the visibility of the secondary value.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum KPISparklineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case area
        case line
        case sdkUnknown(Swift.String)

        public static var allCases: [KPISparklineType] {
            return [
                .area,
                .line
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .area: return "AREA"
            case .line: return "LINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the visibility, color, type, and tooltip visibility of the sparkline of a KPI visual.
    public struct KPISparklineOptions: Swift.Sendable {
        /// The color of the sparkline.
        public var color: Swift.String?
        /// The tooltip visibility of the sparkline.
        public var tooltipVisibility: QuickSightClientTypes.Visibility?
        /// The type of the sparkline.
        /// This member is required.
        public var type: QuickSightClientTypes.KPISparklineType?
        /// The visibility of the sparkline.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            color: Swift.String? = nil,
            tooltipVisibility: QuickSightClientTypes.Visibility? = nil,
            type: QuickSightClientTypes.KPISparklineType? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.color = color
            self.tooltipVisibility = tooltipVisibility
            self.type = type
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of trend arrows in a KPI visual.
    public struct TrendArrowOptions: Swift.Sendable {
        /// The visibility of the trend arrows.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum KPIVisualStandardLayoutType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case classic
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [KPIVisualStandardLayoutType] {
            return [
                .classic,
                .vertical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .classic: return "CLASSIC"
            case .vertical: return "VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The standard layout of the KPI visual.
    public struct KPIVisualStandardLayout: Swift.Sendable {
        /// The standard layout type.
        /// This member is required.
        public var type: QuickSightClientTypes.KPIVisualStandardLayoutType?

        public init(
            type: QuickSightClientTypes.KPIVisualStandardLayoutType? = nil
        )
        {
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the layout a KPI visual.
    public struct KPIVisualLayoutOptions: Swift.Sendable {
        /// The standard layout of the KPI visual.
        public var standardLayout: QuickSightClientTypes.KPIVisualStandardLayout?

        public init(
            standardLayout: QuickSightClientTypes.KPIVisualStandardLayout? = nil
        )
        {
            self.standardLayout = standardLayout
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of a KPI visual.
    public struct KPIOptions: Swift.Sendable {
        /// The comparison configuration of a KPI visual.
        public var comparison: QuickSightClientTypes.ComparisonConfiguration?
        /// The options that determine the primary value display type.
        public var primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType?
        /// The options that determine the primary value font configuration.
        public var primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The options that determine the presentation of the progress bar of a KPI visual.
        public var progressBar: QuickSightClientTypes.ProgressBarOptions?
        /// The options that determine the presentation of the secondary value of a KPI visual.
        public var secondaryValue: QuickSightClientTypes.SecondaryValueOptions?
        /// The options that determine the secondary value font configuration.
        public var secondaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The options that determine the visibility, color, type, and tooltip visibility of the sparkline of a KPI visual.
        public var sparkline: QuickSightClientTypes.KPISparklineOptions?
        /// The options that determine the presentation of trend arrows in a KPI visual.
        public var trendArrows: QuickSightClientTypes.TrendArrowOptions?
        /// The options that determine the layout a KPI visual.
        public var visualLayoutOptions: QuickSightClientTypes.KPIVisualLayoutOptions?

        public init(
            comparison: QuickSightClientTypes.ComparisonConfiguration? = nil,
            primaryValueDisplayType: QuickSightClientTypes.PrimaryValueDisplayType? = nil,
            primaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            progressBar: QuickSightClientTypes.ProgressBarOptions? = nil,
            secondaryValue: QuickSightClientTypes.SecondaryValueOptions? = nil,
            secondaryValueFontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            sparkline: QuickSightClientTypes.KPISparklineOptions? = nil,
            trendArrows: QuickSightClientTypes.TrendArrowOptions? = nil,
            visualLayoutOptions: QuickSightClientTypes.KPIVisualLayoutOptions? = nil
        )
        {
            self.comparison = comparison
            self.primaryValueDisplayType = primaryValueDisplayType
            self.primaryValueFontConfiguration = primaryValueFontConfiguration
            self.progressBar = progressBar
            self.secondaryValue = secondaryValue
            self.secondaryValueFontConfiguration = secondaryValueFontConfiguration
            self.sparkline = sparkline
            self.trendArrows = trendArrows
            self.visualLayoutOptions = visualLayoutOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a KPI visual.
    public struct KPISortConfiguration: Swift.Sendable {
        /// The sort configuration of the trend group fields.
        public var trendGroupSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            trendGroupSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.trendGroupSort = trendGroupSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a KPI visual.
    public struct KPIConfiguration: Swift.Sendable {
        /// The field well configuration of a KPI visual.
        public var fieldWells: QuickSightClientTypes.KPIFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The options that determine the presentation of a KPI visual.
        public var kpiOptions: QuickSightClientTypes.KPIOptions?
        /// The sort configuration of a KPI visual.
        public var sortConfiguration: QuickSightClientTypes.KPISortConfiguration?

        public init(
            fieldWells: QuickSightClientTypes.KPIFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            kpiOptions: QuickSightClientTypes.KPIOptions? = nil,
            sortConfiguration: QuickSightClientTypes.KPISortConfiguration? = nil
        )
        {
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.kpiOptions = kpiOptions
            self.sortConfiguration = sortConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the actual value of a KPI visual.
    public struct KPIActualValueConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the actual value's icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the actual value's text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the comparison value of a KPI visual.
    public struct KPIComparisonValueConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the comparison value's icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the comparison value's text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the primary value of a KPI visual.
    public struct KPIPrimaryValueConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the primary value's icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting of the primary value's text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.icon = icon
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the progress bar of a KPI visual.
    public struct KPIProgressBarConditionalFormatting: Swift.Sendable {
        /// The conditional formatting of the progress bar's foreground color.
        public var foregroundColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            foregroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.foregroundColor = foregroundColor
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting options of a KPI visual.
    public struct KPIConditionalFormattingOption: Swift.Sendable {
        /// The conditional formatting for the actual value of a KPI visual.
        public var actualValue: QuickSightClientTypes.KPIActualValueConditionalFormatting?
        /// The conditional formatting for the comparison value of a KPI visual.
        public var comparisonValue: QuickSightClientTypes.KPIComparisonValueConditionalFormatting?
        /// The conditional formatting for the primary value of a KPI visual.
        public var primaryValue: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting?
        /// The conditional formatting for the progress bar of a KPI visual.
        public var progressBar: QuickSightClientTypes.KPIProgressBarConditionalFormatting?

        public init(
            actualValue: QuickSightClientTypes.KPIActualValueConditionalFormatting? = nil,
            comparisonValue: QuickSightClientTypes.KPIComparisonValueConditionalFormatting? = nil,
            primaryValue: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting? = nil,
            progressBar: QuickSightClientTypes.KPIProgressBarConditionalFormatting? = nil
        )
        {
            self.actualValue = actualValue
            self.comparisonValue = comparisonValue
            self.primaryValue = primaryValue
            self.progressBar = progressBar
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting of a KPI visual.
    public struct KPIConditionalFormatting: Swift.Sendable {
        /// The conditional formatting options of a KPI visual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.KPIConditionalFormattingOption]?

        public init(
            conditionalFormattingOptions: [QuickSightClientTypes.KPIConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A key performance indicator (KPI). For more information, see [Using KPIs](https://docs.aws.amazon.com/quicksight/latest/user/kpi.html) in the Amazon QuickSight User Guide.
    public struct KPIVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a KPI visual.
        public var chartConfiguration: QuickSightClientTypes.KPIConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The conditional formatting of a KPI visual.
        public var conditionalFormatting: QuickSightClientTypes.KPIConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.KPIConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            conditionalFormatting: QuickSightClientTypes.KPIConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum LineInterpolation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linear
        case smooth
        case stepped
        case sdkUnknown(Swift.String)

        public static var allCases: [LineInterpolation] {
            return [
                .linear,
                .smooth,
                .stepped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case .smooth: return "SMOOTH"
            case .stepped: return "STEPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum LineChartLineStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dashed
        case dotted
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartLineStyle] {
            return [
                .dashed,
                .dotted,
                .solid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dashed: return "DASHED"
            case .dotted: return "DOTTED"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Line styles options for a line series in LineChartVisual.
    public struct LineChartLineStyleSettings: Swift.Sendable {
        /// Interpolation style for line series.
        ///
        /// * LINEAR: Show as default, linear style.
        ///
        /// * SMOOTH: Show as a smooth curve.
        ///
        /// * STEPPED: Show steps in line.
        public var lineInterpolation: QuickSightClientTypes.LineInterpolation?
        /// Line style for line series.
        ///
        /// * SOLID: Show as a solid line.
        ///
        /// * DOTTED: Show as a dotted line.
        ///
        /// * DASHED: Show as a dashed line.
        public var lineStyle: QuickSightClientTypes.LineChartLineStyle?
        /// Configuration option that determines whether to show the line for the series.
        public var lineVisibility: QuickSightClientTypes.Visibility?
        /// Width that determines the line thickness.
        public var lineWidth: Swift.String?

        public init(
            lineInterpolation: QuickSightClientTypes.LineInterpolation? = nil,
            lineStyle: QuickSightClientTypes.LineChartLineStyle? = nil,
            lineVisibility: QuickSightClientTypes.Visibility? = nil,
            lineWidth: Swift.String? = nil
        )
        {
            self.lineInterpolation = lineInterpolation
            self.lineStyle = lineStyle
            self.lineVisibility = lineVisibility
            self.lineWidth = lineWidth
        }
    }
}

extension QuickSightClientTypes {

    public enum LineChartMarkerShape: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case circle
        case diamond
        case roundedSquare
        case square
        case triangle
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartMarkerShape] {
            return [
                .circle,
                .diamond,
                .roundedSquare,
                .square,
                .triangle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .circle: return "CIRCLE"
            case .diamond: return "DIAMOND"
            case .roundedSquare: return "ROUNDED_SQUARE"
            case .square: return "SQUARE"
            case .triangle: return "TRIANGLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Marker styles options for a line series in LineChartVisual.
    public struct LineChartMarkerStyleSettings: Swift.Sendable {
        /// Color of marker in the series.
        public var markerColor: Swift.String?
        /// Shape option for markers in the series.
        ///
        /// * CIRCLE: Show marker as a circle.
        ///
        /// * TRIANGLE: Show marker as a triangle.
        ///
        /// * SQUARE: Show marker as a square.
        ///
        /// * DIAMOND: Show marker as a diamond.
        ///
        /// * ROUNDED_SQUARE: Show marker as a rounded square.
        public var markerShape: QuickSightClientTypes.LineChartMarkerShape?
        /// Size of marker in the series.
        public var markerSize: Swift.String?
        /// Configuration option that determines whether to show the markers in the series.
        public var markerVisibility: QuickSightClientTypes.Visibility?

        public init(
            markerColor: Swift.String? = nil,
            markerShape: QuickSightClientTypes.LineChartMarkerShape? = nil,
            markerSize: Swift.String? = nil,
            markerVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.markerColor = markerColor
            self.markerShape = markerShape
            self.markerSize = markerSize
            self.markerVisibility = markerVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the default presentation of all line series in LineChartVisual.
    public struct LineChartDefaultSeriesSettings: Swift.Sendable {
        /// The axis to which you are binding all line series to.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// Line styles options for all line series in the visual.
        public var lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings?
        /// Marker styles options for all line series in the visual.
        public var markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings?

        public init(
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings? = nil,
            markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a line chart.
    public struct LineChartAggregatedFieldWells: Swift.Sendable {
        /// The category field wells of a line chart. Values are grouped by category fields.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The color field wells of a line chart. Values are grouped by category fields.
        public var colors: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a line chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a line chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            colors: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.colors = colors
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a line chart.
    public struct LineChartFieldWells: Swift.Sendable {
        /// The field well configuration of a line chart.
        public var lineChartAggregatedFieldWells: QuickSightClientTypes.LineChartAggregatedFieldWells?

        public init(
            lineChartAggregatedFieldWells: QuickSightClientTypes.LineChartAggregatedFieldWells? = nil
        )
        {
            self.lineChartAggregatedFieldWells = lineChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The forecast properties setup of a forecast in the line chart.
    public struct TimeBasedForecastProperties: Swift.Sendable {
        /// The lower boundary setup of a forecast computation.
        public var lowerBoundary: Swift.Double?
        /// The periods backward setup of a forecast computation.
        public var periodsBackward: Swift.Int?
        /// The periods forward setup of a forecast computation.
        public var periodsForward: Swift.Int?
        /// The prediction interval setup of a forecast computation.
        public var predictionInterval: Swift.Int?
        /// The seasonality setup of a forecast computation. Choose one of the following options:
        ///
        /// * NULL: The input is set to NULL.
        ///
        /// * NON_NULL: The input is set to a custom value.
        public var seasonality: Swift.Int?
        /// The upper boundary setup of a forecast computation.
        public var upperBoundary: Swift.Double?

        public init(
            lowerBoundary: Swift.Double? = 0.0,
            periodsBackward: Swift.Int? = nil,
            periodsForward: Swift.Int? = nil,
            predictionInterval: Swift.Int? = nil,
            seasonality: Swift.Int? = nil,
            upperBoundary: Swift.Double? = 0.0
        )
        {
            self.lowerBoundary = lowerBoundary
            self.periodsBackward = periodsBackward
            self.periodsForward = periodsForward
            self.predictionInterval = predictionInterval
            self.seasonality = seasonality
            self.upperBoundary = upperBoundary
        }
    }
}

extension QuickSightClientTypes {

    /// Provides the forecast to meet the target for a particular date.
    public struct WhatIfPointScenario: Swift.Sendable {
        /// The date that you need the forecast results for.
        /// This member is required.
        public var date: Foundation.Date?
        /// The target value that you want to meet for the provided date.
        /// This member is required.
        public var value: Swift.Double

        public init(
            date: Foundation.Date? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.date = date
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// Provides the forecast to meet the target for a particular date range.
    public struct WhatIfRangeScenario: Swift.Sendable {
        /// The end date in the date range that you need the forecast results for.
        /// This member is required.
        public var endDate: Foundation.Date?
        /// The start date in the date range that you need the forecast results for.
        /// This member is required.
        public var startDate: Foundation.Date?
        /// The target value that you want to meet for the provided date range.
        /// This member is required.
        public var value: Swift.Double

        public init(
            endDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil,
            value: Swift.Double = 0.0
        )
        {
            self.endDate = endDate
            self.startDate = startDate
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The forecast scenario of a forecast in the line chart.
    public struct ForecastScenario: Swift.Sendable {
        /// The what-if analysis forecast setup with the target date.
        public var whatIfPointScenario: QuickSightClientTypes.WhatIfPointScenario?
        /// The what-if analysis forecast setup with the date range.
        public var whatIfRangeScenario: QuickSightClientTypes.WhatIfRangeScenario?

        public init(
            whatIfPointScenario: QuickSightClientTypes.WhatIfPointScenario? = nil,
            whatIfRangeScenario: QuickSightClientTypes.WhatIfRangeScenario? = nil
        )
        {
            self.whatIfPointScenario = whatIfPointScenario
            self.whatIfRangeScenario = whatIfRangeScenario
        }
    }
}

extension QuickSightClientTypes {

    /// The forecast configuration that is used in a line chart's display properties.
    public struct ForecastConfiguration: Swift.Sendable {
        /// The forecast properties setup of a forecast in the line chart.
        public var forecastProperties: QuickSightClientTypes.TimeBasedForecastProperties?
        /// The forecast scenario of a forecast in the line chart.
        public var scenario: QuickSightClientTypes.ForecastScenario?

        public init(
            forecastProperties: QuickSightClientTypes.TimeBasedForecastProperties? = nil,
            scenario: QuickSightClientTypes.ForecastScenario? = nil
        )
        {
            self.forecastProperties = forecastProperties
            self.scenario = scenario
        }
    }
}

extension QuickSightClientTypes {

    public enum MissingDataTreatmentOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interpolate
        case showAsBlank
        case showAsZero
        case sdkUnknown(Swift.String)

        public static var allCases: [MissingDataTreatmentOption] {
            return [
                .interpolate,
                .showAsBlank,
                .showAsZero
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interpolate: return "INTERPOLATE"
            case .showAsBlank: return "SHOW_AS_BLANK"
            case .showAsZero: return "SHOW_AS_ZERO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration options that determine how missing data is treated during the rendering of a line chart.
    public struct MissingDataConfiguration: Swift.Sendable {
        /// The treatment option that determines how missing data should be rendered. Choose from the following options:
        ///
        /// * INTERPOLATE: Interpolate missing values between the prior and the next known value.
        ///
        /// * SHOW_AS_ZERO: Show missing values as the value 0.
        ///
        /// * SHOW_AS_BLANK: Display a blank space when rendering missing data.
        public var treatmentOption: QuickSightClientTypes.MissingDataTreatmentOption?

        public init(
            treatmentOption: QuickSightClientTypes.MissingDataTreatmentOption? = nil
        )
        {
            self.treatmentOption = treatmentOption
        }
    }
}

extension QuickSightClientTypes {

    /// The series axis configuration of a line chart.
    public struct LineSeriesAxisDisplayOptions: Swift.Sendable {
        /// The options that determine the presentation of the line series axis.
        public var axisOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The configuration options that determine how missing data is treated during the rendering of a line chart.
        public var missingDataConfigurations: [QuickSightClientTypes.MissingDataConfiguration]?

        public init(
            axisOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            missingDataConfigurations: [QuickSightClientTypes.MissingDataConfiguration]? = nil
        )
        {
            self.axisOptions = axisOptions
            self.missingDataConfigurations = missingDataConfigurations
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of a line series in the visual
    public struct LineChartSeriesSettings: Swift.Sendable {
        /// Line styles options for a line series in LineChartVisual.
        public var lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings?
        /// Marker styles options for a line series in LineChartVisual.
        public var markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings?

        public init(
            lineStyleSettings: QuickSightClientTypes.LineChartLineStyleSettings? = nil,
            markerStyleSettings: QuickSightClientTypes.LineChartMarkerStyleSettings? = nil
        )
        {
            self.lineStyleSettings = lineStyleSettings
            self.markerStyleSettings = markerStyleSettings
        }
    }
}

extension QuickSightClientTypes {

    /// The data field series item configuration of a line chart.
    public struct DataFieldSeriesItem: Swift.Sendable {
        /// The axis that you are binding the field to.
        /// This member is required.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The field ID of the field that you are setting the axis binding to.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The field value of the field that you are setting the axis binding to.
        public var fieldValue: Swift.String?
        /// The options that determine the presentation of line series associated to the field.
        public var settings: QuickSightClientTypes.LineChartSeriesSettings?

        public init(
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            fieldId: Swift.String? = nil,
            fieldValue: Swift.String? = nil,
            settings: QuickSightClientTypes.LineChartSeriesSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.fieldValue = fieldValue
            self.settings = settings
        }
    }
}

extension QuickSightClientTypes.DataFieldSeriesItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataFieldSeriesItem(axisBinding: \(Swift.String(describing: axisBinding)), fieldId: \(Swift.String(describing: fieldId)), settings: \(Swift.String(describing: settings)), fieldValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The field series item configuration of a line chart.
    public struct FieldSeriesItem: Swift.Sendable {
        /// The axis that you are binding the field to.
        /// This member is required.
        public var axisBinding: QuickSightClientTypes.AxisBinding?
        /// The field ID of the field for which you are setting the axis binding.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The options that determine the presentation of line series associated to the field.
        public var settings: QuickSightClientTypes.LineChartSeriesSettings?

        public init(
            axisBinding: QuickSightClientTypes.AxisBinding? = nil,
            fieldId: Swift.String? = nil,
            settings: QuickSightClientTypes.LineChartSeriesSettings? = nil
        )
        {
            self.axisBinding = axisBinding
            self.fieldId = fieldId
            self.settings = settings
        }
    }
}

extension QuickSightClientTypes {

    /// The series item configuration of a line chart. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct SeriesItem: Swift.Sendable {
        /// The data field series item configuration of a line chart.
        public var dataFieldSeriesItem: QuickSightClientTypes.DataFieldSeriesItem?
        /// The field series item configuration of a line chart.
        public var fieldSeriesItem: QuickSightClientTypes.FieldSeriesItem?

        public init(
            dataFieldSeriesItem: QuickSightClientTypes.DataFieldSeriesItem? = nil,
            fieldSeriesItem: QuickSightClientTypes.FieldSeriesItem? = nil
        )
        {
            self.dataFieldSeriesItem = dataFieldSeriesItem
            self.fieldSeriesItem = fieldSeriesItem
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a line chart.
    public struct LineChartSortConfiguration: Swift.Sendable {
        /// The limit on the number of categories that are displayed in a line chart.
        public var categoryItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of lines that are displayed in a line chart.
        public var colorItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimitConfiguration = categoryItemsLimitConfiguration
            self.categorySort = categorySort
            self.colorItemsLimitConfiguration = colorItemsLimitConfiguration
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }
}

extension QuickSightClientTypes {

    public enum LineChartType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case area
        case line
        case stackedArea
        case sdkUnknown(Swift.String)

        public static var allCases: [LineChartType] {
            return [
                .area,
                .line,
                .stackedArea
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .area: return "AREA"
            case .line: return "LINE"
            case .stackedArea: return "STACKED_AREA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a line chart.
    public struct LineChartConfiguration: Swift.Sendable {
        /// The default configuration of a line chart's contribution analysis.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The data label configuration of a line chart.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The options that determine the default presentation of all line series in LineChartVisual.
        public var defaultSeriesSettings: QuickSightClientTypes.LineChartDefaultSeriesSettings?
        /// The field well configuration of a line chart.
        public var fieldWells: QuickSightClientTypes.LineChartFieldWells?
        /// The forecast configuration of a line chart.
        public var forecastConfigurations: [QuickSightClientTypes.ForecastConfiguration]?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend configuration of a line chart.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The series axis configuration of a line chart.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The reference lines configuration of a line chart.
        public var referenceLines: [QuickSightClientTypes.ReferenceLine]?
        /// The series axis configuration of a line chart.
        public var secondaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions?
        /// The options that determine the presentation of the secondary y-axis label.
        public var secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The series item configuration of a line chart.
        public var series: [QuickSightClientTypes.SeriesItem]?
        /// The settings of a chart's single axis configuration.
        public var singleAxisOptions: QuickSightClientTypes.SingleAxisOptions?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a line chart.
        public var sortConfiguration: QuickSightClientTypes.LineChartSortConfiguration?
        /// The tooltip configuration of a line chart.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// Determines the type of the line chart.
        public var type: QuickSightClientTypes.LineChartType?
        /// The visual palette configuration of a line chart.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of the x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the x-axis label.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?

        public init(
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            defaultSeriesSettings: QuickSightClientTypes.LineChartDefaultSeriesSettings? = nil,
            fieldWells: QuickSightClientTypes.LineChartFieldWells? = nil,
            forecastConfigurations: [QuickSightClientTypes.ForecastConfiguration]? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            referenceLines: [QuickSightClientTypes.ReferenceLine]? = nil,
            secondaryYAxisDisplayOptions: QuickSightClientTypes.LineSeriesAxisDisplayOptions? = nil,
            secondaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            series: [QuickSightClientTypes.SeriesItem]? = nil,
            singleAxisOptions: QuickSightClientTypes.SingleAxisOptions? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.LineChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            type: QuickSightClientTypes.LineChartType? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil
        )
        {
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.defaultSeriesSettings = defaultSeriesSettings
            self.fieldWells = fieldWells
            self.forecastConfigurations = forecastConfigurations
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.referenceLines = referenceLines
            self.secondaryYAxisDisplayOptions = secondaryYAxisDisplayOptions
            self.secondaryYAxisLabelOptions = secondaryYAxisLabelOptions
            self.series = series
            self.singleAxisOptions = singleAxisOptions
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.type = type
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A line chart. For more information, see [Using line charts](https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html) in the Amazon QuickSight User Guide.
    public struct LineChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a line chart.
        public var chartConfiguration: QuickSightClientTypes.LineChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.LineChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum ArcThickness: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case medium
        case small
        case whole
        case sdkUnknown(Swift.String)

        public static var allCases: [ArcThickness] {
            return [
                .large,
                .medium,
                .small,
                .whole
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .small: return "SMALL"
            case .whole: return "WHOLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the arc thickness of a GaugeChartVisual.
    public struct ArcOptions: Swift.Sendable {
        /// The arc thickness of a GaugeChartVisual.
        public var arcThickness: QuickSightClientTypes.ArcThickness?

        public init(
            arcThickness: QuickSightClientTypes.ArcThickness? = nil
        )
        {
            self.arcThickness = arcThickness
        }
    }
}

extension QuickSightClientTypes {

    /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
    public struct DonutCenterOptions: Swift.Sendable {
        /// Determines the visibility of the label in a donut chart. In the Amazon QuickSight console, this option is called 'Show total'.
        public var labelVisibility: QuickSightClientTypes.Visibility?

        public init(
            labelVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.labelVisibility = labelVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// The options for configuring a donut chart or pie chart.
    public struct DonutOptions: Swift.Sendable {
        /// The option for define the arc of the chart shape. Valid values are as follows:
        ///
        /// * WHOLE - A pie chart
        ///
        /// * SMALL- A small-sized donut chart
        ///
        /// * MEDIUM- A medium-sized donut chart
        ///
        /// * LARGE- A large-sized donut chart
        public var arcOptions: QuickSightClientTypes.ArcOptions?
        /// The label options of the label that is displayed in the center of a donut chart. This option isn't available for pie charts.
        public var donutCenterOptions: QuickSightClientTypes.DonutCenterOptions?

        public init(
            arcOptions: QuickSightClientTypes.ArcOptions? = nil,
            donutCenterOptions: QuickSightClientTypes.DonutCenterOptions? = nil
        )
        {
            self.arcOptions = arcOptions
            self.donutCenterOptions = donutCenterOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a pie chart.
    public struct PieChartAggregatedFieldWells: Swift.Sendable {
        /// The category (group/color) field wells of a pie chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The small multiples field well of a pie chart.
        public var smallMultiples: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a pie chart. Values are aggregated based on categories.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            smallMultiples: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.smallMultiples = smallMultiples
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a pie chart. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct PieChartFieldWells: Swift.Sendable {
        /// The field well configuration of a pie chart.
        public var pieChartAggregatedFieldWells: QuickSightClientTypes.PieChartAggregatedFieldWells?

        public init(
            pieChartAggregatedFieldWells: QuickSightClientTypes.PieChartAggregatedFieldWells? = nil
        )
        {
            self.pieChartAggregatedFieldWells = pieChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a pie chart.
    public struct PieChartSortConfiguration: Swift.Sendable {
        /// The limit on the number of categories that are displayed in a pie chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The limit on the number of small multiples panels that are displayed.
        public var smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the small multiples field.
        public var smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            smallMultiplesLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            smallMultiplesSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.smallMultiplesLimitConfiguration = smallMultiplesLimitConfiguration
            self.smallMultiplesSort = smallMultiplesSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a pie chart.
    public struct PieChartConfiguration: Swift.Sendable {
        /// The label options of the group/color that is displayed in a pie chart.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The contribution analysis (anomaly configuration) setup of the visual.
        public var contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The options that determine the shape of the chart. This option determines whether the chart is a pie chart or a donut chart.
        public var donutOptions: QuickSightClientTypes.DonutOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.PieChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The small multiples setup for the visual.
        public var smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions?
        /// The sort configuration of a pie chart.
        public var sortConfiguration: QuickSightClientTypes.PieChartSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The label options for the value that is displayed in a pie chart.
        public var valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            contributionAnalysisDefaults: [QuickSightClientTypes.ContributionAnalysisDefault]? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            donutOptions: QuickSightClientTypes.DonutOptions? = nil,
            fieldWells: QuickSightClientTypes.PieChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            smallMultiplesOptions: QuickSightClientTypes.SmallMultiplesOptions? = nil,
            sortConfiguration: QuickSightClientTypes.PieChartSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            valueLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.contributionAnalysisDefaults = contributionAnalysisDefaults
            self.dataLabels = dataLabels
            self.donutOptions = donutOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.smallMultiplesOptions = smallMultiplesOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.valueLabelOptions = valueLabelOptions
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// A pie or donut chart. The PieChartVisual structure describes a visual that is a member of the pie chart family. The following charts can be described by using this structure:
    ///
    /// * Pie charts
    ///
    /// * Donut charts
    ///
    ///
    /// For more information, see [Using pie charts](https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html) in the Amazon QuickSight User Guide. For more information, see [Using donut charts](https://docs.aws.amazon.com/quicksight/latest/user/donut-chart.html) in the Amazon QuickSight User Guide.
    public struct PieChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a pie chart.
        public var chartConfiguration: QuickSightClientTypes.PieChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.PieChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableFieldCollapseState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collapsed
        case expanded
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableFieldCollapseState] {
            return [
                .collapsed,
                .expanded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collapsed: return "COLLAPSED"
            case .expanded: return "EXPANDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The target of a pivot table field collapse state.
    public struct PivotTableFieldCollapseStateTarget: Swift.Sendable {
        /// The data path of the pivot table's header. Used to set the collapse state.
        public var fieldDataPathValues: [QuickSightClientTypes.DataPathValue]?
        /// The field ID of the pivot table that the collapse state needs to be set to.
        public var fieldId: Swift.String?

        public init(
            fieldDataPathValues: [QuickSightClientTypes.DataPathValue]? = nil,
            fieldId: Swift.String? = nil
        )
        {
            self.fieldDataPathValues = fieldDataPathValues
            self.fieldId = fieldId
        }
    }
}

extension QuickSightClientTypes {

    /// The collapse state options for the pivot table field options.
    public struct PivotTableFieldCollapseStateOption: Swift.Sendable {
        /// The state of the field target of a pivot table. Choose one of the following options:
        ///
        /// * COLLAPSED
        ///
        /// * EXPANDED
        public var state: QuickSightClientTypes.PivotTableFieldCollapseState?
        /// A tagged-union object that sets the collapse state.
        /// This member is required.
        public var target: QuickSightClientTypes.PivotTableFieldCollapseStateTarget?

        public init(
            state: QuickSightClientTypes.PivotTableFieldCollapseState? = nil,
            target: QuickSightClientTypes.PivotTableFieldCollapseStateTarget? = nil
        )
        {
            self.state = state
            self.target = target
        }
    }
}

extension QuickSightClientTypes {

    /// The data path options for the pivot table field options.
    public struct PivotTableDataPathOption: Swift.Sendable {
        /// The list of data path values for the data path options.
        /// This member is required.
        public var dataPathList: [QuickSightClientTypes.DataPathValue]?
        /// The width of the data path option.
        public var width: Swift.String?

        public init(
            dataPathList: [QuickSightClientTypes.DataPathValue]? = nil,
            width: Swift.String? = nil
        )
        {
            self.dataPathList = dataPathList
            self.width = width
        }
    }
}

extension QuickSightClientTypes {

    /// The selected field options for the pivot table field options.
    public struct PivotTableFieldOption: Swift.Sendable {
        /// The custom label of the pivot table field.
        public var customLabel: Swift.String?
        /// The field ID of the pivot table field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The visibility of the pivot table field.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            customLabel: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The field options for a pivot table visual.
    public struct PivotTableFieldOptions: Swift.Sendable {
        /// The collapse state options for the pivot table field options.
        public var collapseStateOptions: [QuickSightClientTypes.PivotTableFieldCollapseStateOption]?
        /// The data path options for the pivot table field options.
        public var dataPathOptions: [QuickSightClientTypes.PivotTableDataPathOption]?
        /// The selected field options for the pivot table field options.
        public var selectedFieldOptions: [QuickSightClientTypes.PivotTableFieldOption]?

        public init(
            collapseStateOptions: [QuickSightClientTypes.PivotTableFieldCollapseStateOption]? = nil,
            dataPathOptions: [QuickSightClientTypes.PivotTableDataPathOption]? = nil,
            selectedFieldOptions: [QuickSightClientTypes.PivotTableFieldOption]? = nil
        )
        {
            self.collapseStateOptions = collapseStateOptions
            self.dataPathOptions = dataPathOptions
            self.selectedFieldOptions = selectedFieldOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well for the pivot table.
    public struct PivotTableAggregatedFieldWells: Swift.Sendable {
        /// The columns field well for a pivot table. Values are grouped by columns fields.
        public var columns: [QuickSightClientTypes.DimensionField]?
        /// The rows field well for a pivot table. Values are grouped by rows fields.
        public var rows: [QuickSightClientTypes.DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on rows and columns fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            columns: [QuickSightClientTypes.DimensionField]? = nil,
            rows: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.columns = columns
            self.rows = rows
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells for a pivot table visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct PivotTableFieldWells: Swift.Sendable {
        /// The aggregated field well for the pivot table.
        public var pivotTableAggregatedFieldWells: QuickSightClientTypes.PivotTableAggregatedFieldWells?

        public init(
            pivotTableAggregatedFieldWells: QuickSightClientTypes.PivotTableAggregatedFieldWells? = nil
        )
        {
            self.pivotTableAggregatedFieldWells = pivotTableAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The paginated report options for a pivot table visual.
    public struct PivotTablePaginatedReportOptions: Swift.Sendable {
        /// The visibility of the repeating header rows on each page.
        public var overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of the printing table overflow across pages.
        public var verticalOverflowVisibility: QuickSightClientTypes.Visibility?

        public init(
            overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility? = nil,
            verticalOverflowVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// Allows data paths to be sorted by a specific data value.
    public struct DataPathSort: Swift.Sendable {
        /// Determines the sort direction.
        /// This member is required.
        public var direction: QuickSightClientTypes.SortDirection?
        /// The list of data paths that need to be sorted.
        /// This member is required.
        public var sortPaths: [QuickSightClientTypes.DataPathValue]?

        public init(
            direction: QuickSightClientTypes.SortDirection? = nil,
            sortPaths: [QuickSightClientTypes.DataPathValue]? = nil
        )
        {
            self.direction = direction
            self.sortPaths = sortPaths
        }
    }
}

extension QuickSightClientTypes {

    /// The sort by field for the field sort options.
    public struct PivotTableSortBy: Swift.Sendable {
        /// The column sort (field id, direction) for the pivot table sort by options.
        public var column: QuickSightClientTypes.ColumnSort?
        /// The data path sort (data path value, direction) for the pivot table sort by options.
        public var dataPath: QuickSightClientTypes.DataPathSort?
        /// The field sort (field id, direction) for the pivot table sort by options.
        public var field: QuickSightClientTypes.FieldSort?

        public init(
            column: QuickSightClientTypes.ColumnSort? = nil,
            dataPath: QuickSightClientTypes.DataPathSort? = nil,
            field: QuickSightClientTypes.FieldSort? = nil
        )
        {
            self.column = column
            self.dataPath = dataPath
            self.field = field
        }
    }
}

extension QuickSightClientTypes {

    /// The field sort options for a pivot table sort configuration.
    public struct PivotFieldSortOptions: Swift.Sendable {
        /// The field ID for the field sort options.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The sort by field for the field sort options.
        /// This member is required.
        public var sortBy: QuickSightClientTypes.PivotTableSortBy?

        public init(
            fieldId: Swift.String? = nil,
            sortBy: QuickSightClientTypes.PivotTableSortBy? = nil
        )
        {
            self.fieldId = fieldId
            self.sortBy = sortBy
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration for a PivotTableVisual.
    public struct PivotTableSortConfiguration: Swift.Sendable {
        /// The field sort options for a pivot table sort configuration.
        public var fieldSortOptions: [QuickSightClientTypes.PivotFieldSortOptions]?

        public init(
            fieldSortOptions: [QuickSightClientTypes.PivotFieldSortOptions]? = nil
        )
        {
            self.fieldSortOptions = fieldSortOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum TableBorderStyle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case solid
        case sdkUnknown(Swift.String)

        public static var allCases: [TableBorderStyle] {
            return [
                .none,
                .solid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .solid: return "SOLID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The border options for a table border.
    public struct TableBorderOptions: Swift.Sendable {
        /// The color of a table border.
        public var color: Swift.String?
        /// The style (none, solid) of a table border.
        public var style: QuickSightClientTypes.TableBorderStyle?
        /// The thickness of a table border.
        public var thickness: Swift.Int?

        public init(
            color: Swift.String? = nil,
            style: QuickSightClientTypes.TableBorderStyle? = nil,
            thickness: Swift.Int? = nil
        )
        {
            self.color = color
            self.style = style
            self.thickness = thickness
        }
    }
}

extension QuickSightClientTypes {

    /// The side border options for a table.
    public struct TableSideBorderOptions: Swift.Sendable {
        /// The table border options of the bottom border.
        public var bottom: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the inner horizontal border.
        public var innerHorizontal: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the inner vertical border.
        public var innerVertical: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the left border.
        public var `left`: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the right border.
        public var `right`: QuickSightClientTypes.TableBorderOptions?
        /// The table border options of the top border.
        public var top: QuickSightClientTypes.TableBorderOptions?

        public init(
            bottom: QuickSightClientTypes.TableBorderOptions? = nil,
            innerHorizontal: QuickSightClientTypes.TableBorderOptions? = nil,
            innerVertical: QuickSightClientTypes.TableBorderOptions? = nil,
            `left`: QuickSightClientTypes.TableBorderOptions? = nil,
            `right`: QuickSightClientTypes.TableBorderOptions? = nil,
            top: QuickSightClientTypes.TableBorderOptions? = nil
        )
        {
            self.bottom = bottom
            self.innerHorizontal = innerHorizontal
            self.innerVertical = innerVertical
            self.`left` = `left`
            self.`right` = `right`
            self.top = top
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the border options for a table visual.
    public struct GlobalTableBorderOptions: Swift.Sendable {
        /// Determines the options for side specific border.
        public var sideSpecificBorder: QuickSightClientTypes.TableSideBorderOptions?
        /// Determines the options for uniform border.
        public var uniformBorder: QuickSightClientTypes.TableBorderOptions?

        public init(
            sideSpecificBorder: QuickSightClientTypes.TableSideBorderOptions? = nil,
            uniformBorder: QuickSightClientTypes.TableBorderOptions? = nil
        )
        {
            self.sideSpecificBorder = sideSpecificBorder
            self.uniformBorder = uniformBorder
        }
    }
}

extension QuickSightClientTypes {

    public enum TextWrap: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case wrap
        case sdkUnknown(Swift.String)

        public static var allCases: [TextWrap] {
            return [
                .none,
                .wrap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .wrap: return "WRAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum VerticalTextAlignment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case bottom
        case middle
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [VerticalTextAlignment] {
            return [
                .auto,
                .bottom,
                .middle,
                .top
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .bottom: return "BOTTOM"
            case .middle: return "MIDDLE"
            case .top: return "TOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The table cell style for a cell in pivot table or table visual.
    public struct TableCellStyle: Swift.Sendable {
        /// The background color for the table cells.
        public var backgroundColor: Swift.String?
        /// The borders for the table cells.
        public var border: QuickSightClientTypes.GlobalTableBorderOptions?
        /// The font configuration of the table cells.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The height color for the table cells.
        public var height: Swift.Int?
        /// The horizontal text alignment (left, center, right, auto) for the table cells.
        public var horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment?
        /// The text wrap (none, wrap) for the table cells.
        public var textWrap: QuickSightClientTypes.TextWrap?
        /// The vertical text alignment (top, middle, bottom) for the table cells.
        public var verticalTextAlignment: QuickSightClientTypes.VerticalTextAlignment?
        /// The visibility of the table cells.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            backgroundColor: Swift.String? = nil,
            border: QuickSightClientTypes.GlobalTableBorderOptions? = nil,
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            height: Swift.Int? = nil,
            horizontalTextAlignment: QuickSightClientTypes.HorizontalTextAlignment? = nil,
            textWrap: QuickSightClientTypes.TextWrap? = nil,
            verticalTextAlignment: QuickSightClientTypes.VerticalTextAlignment? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.border = border
            self.fontConfiguration = fontConfiguration
            self.height = height
            self.horizontalTextAlignment = horizontalTextAlignment
            self.textWrap = textWrap
            self.verticalTextAlignment = verticalTextAlignment
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableMetricPlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case column
        case row
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableMetricPlacement] {
            return [
                .column,
                .row
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .column: return "COLUMN"
            case .row: return "ROW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the row alternate color options.
    public struct RowAlternateColorOptions: Swift.Sendable {
        /// Determines the list of row alternate colors.
        public var rowAlternateColors: [Swift.String]?
        /// Determines the widget status.
        public var status: QuickSightClientTypes.WidgetStatus?
        /// The primary background color options for alternate rows.
        public var usePrimaryBackgroundColor: QuickSightClientTypes.WidgetStatus?

        public init(
            rowAlternateColors: [Swift.String]? = nil,
            status: QuickSightClientTypes.WidgetStatus? = nil,
            usePrimaryBackgroundColor: QuickSightClientTypes.WidgetStatus? = nil
        )
        {
            self.rowAlternateColors = rowAlternateColors
            self.status = status
            self.usePrimaryBackgroundColor = usePrimaryBackgroundColor
        }
    }
}

extension QuickSightClientTypes {

    /// The options for the label thta is located above the row headers. This option is only applicable when RowsLayout is set to HIERARCHY.
    public struct PivotTableRowsLabelOptions: Swift.Sendable {
        /// The custom label string for the rows label.
        public var customLabel: Swift.String?
        /// The visibility of the rows label.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            customLabel: Swift.String? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableRowsLayout: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hierarchy
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableRowsLayout] {
            return [
                .hierarchy,
                .tabular
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hierarchy: return "HIERARCHY"
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The table options for a pivot table visual.
    public struct PivotTableOptions: Swift.Sendable {
        /// The table cell style of cells.
        public var cellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility setting of a pivot table's collapsed row dimension fields. If the value of this structure is HIDDEN, all collapsed columns in a pivot table are automatically hidden. The default value is VISIBLE.
        public var collapsedRowDimensionsVisibility: QuickSightClientTypes.Visibility?
        /// The table cell style of the column header.
        public var columnHeaderStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility of the column names.
        public var columnNamesVisibility: QuickSightClientTypes.Visibility?
        /// The default cell width of the pivot table.
        public var defaultCellWidth: Swift.String?
        /// The metric placement (row, column) options.
        public var metricPlacement: QuickSightClientTypes.PivotTableMetricPlacement?
        /// The row alternate color options (widget status, row alternate colors).
        public var rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions?
        /// The table cell style of row field names.
        public var rowFieldNamesStyle: QuickSightClientTypes.TableCellStyle?
        /// The table cell style of the row headers.
        public var rowHeaderStyle: QuickSightClientTypes.TableCellStyle?
        /// The options for the label that is located above the row headers. This option is only applicable when RowsLayout is set to HIERARCHY.
        public var rowsLabelOptions: QuickSightClientTypes.PivotTableRowsLabelOptions?
        /// The layout for the row dimension headers of a pivot table. Choose one of the following options.
        ///
        /// * TABULAR: (Default) Each row field is displayed in a separate column.
        ///
        /// * HIERARCHY: All row fields are displayed in a single column. Indentation is used to differentiate row headers of different fields.
        public var rowsLayout: QuickSightClientTypes.PivotTableRowsLayout?
        /// The visibility of the single metric options.
        public var singleMetricVisibility: QuickSightClientTypes.Visibility?
        /// Determines the visibility of the pivot table.
        public var toggleButtonsVisibility: QuickSightClientTypes.Visibility?

        public init(
            cellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            collapsedRowDimensionsVisibility: QuickSightClientTypes.Visibility? = nil,
            columnHeaderStyle: QuickSightClientTypes.TableCellStyle? = nil,
            columnNamesVisibility: QuickSightClientTypes.Visibility? = nil,
            defaultCellWidth: Swift.String? = nil,
            metricPlacement: QuickSightClientTypes.PivotTableMetricPlacement? = nil,
            rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions? = nil,
            rowFieldNamesStyle: QuickSightClientTypes.TableCellStyle? = nil,
            rowHeaderStyle: QuickSightClientTypes.TableCellStyle? = nil,
            rowsLabelOptions: QuickSightClientTypes.PivotTableRowsLabelOptions? = nil,
            rowsLayout: QuickSightClientTypes.PivotTableRowsLayout? = nil,
            singleMetricVisibility: QuickSightClientTypes.Visibility? = nil,
            toggleButtonsVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.cellStyle = cellStyle
            self.collapsedRowDimensionsVisibility = collapsedRowDimensionsVisibility
            self.columnHeaderStyle = columnHeaderStyle
            self.columnNamesVisibility = columnNamesVisibility
            self.defaultCellWidth = defaultCellWidth
            self.metricPlacement = metricPlacement
            self.rowAlternateColorOptions = rowAlternateColorOptions
            self.rowFieldNamesStyle = rowFieldNamesStyle
            self.rowHeaderStyle = rowHeaderStyle
            self.rowsLabelOptions = rowsLabelOptions
            self.rowsLayout = rowsLayout
            self.singleMetricVisibility = singleMetricVisibility
            self.toggleButtonsVisibility = toggleButtonsVisibility
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableSubtotalLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case custom
        case last
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableSubtotalLevel] {
            return [
                .all,
                .custom,
                .last
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .last: return "LAST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The optional configuration of subtotals cells.
    public struct PivotTableFieldSubtotalOptions: Swift.Sendable {
        /// The field ID of the subtotal options.
        public var fieldId: Swift.String?

        public init(
            fieldId: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
        }
    }
}

extension QuickSightClientTypes {

    public enum StyledCellType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case metricHeader
        case total
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [StyledCellType] {
            return [
                .metricHeader,
                .total,
                .value
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .metricHeader: return "METRIC_HEADER"
            case .total: return "TOTAL"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The table style target.
    public struct TableStyleTarget: Swift.Sendable {
        /// The cell type of the table style target.
        /// This member is required.
        public var cellType: QuickSightClientTypes.StyledCellType?

        public init(
            cellType: QuickSightClientTypes.StyledCellType? = nil
        )
        {
            self.cellType = cellType
        }
    }
}

extension QuickSightClientTypes {

    /// The subtotal options.
    public struct SubtotalOptions: Swift.Sendable {
        /// The custom label string for the subtotal cells.
        public var customLabel: Swift.String?
        /// The field level (all, custom, last) for the subtotal cells.
        public var fieldLevel: QuickSightClientTypes.PivotTableSubtotalLevel?
        /// The optional configuration of subtotal cells.
        public var fieldLevelOptions: [QuickSightClientTypes.PivotTableFieldSubtotalOptions]?
        /// The cell styling options for the subtotals of header cells.
        public var metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The style targets options for subtotals.
        public var styleTargets: [QuickSightClientTypes.TableStyleTarget]?
        /// The cell styling options for the subtotal cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the subtotal cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?
        /// The cell styling options for the subtotals of value cells.
        public var valueCellStyle: QuickSightClientTypes.TableCellStyle?

        public init(
            customLabel: Swift.String? = nil,
            fieldLevel: QuickSightClientTypes.PivotTableSubtotalLevel? = nil,
            fieldLevelOptions: [QuickSightClientTypes.PivotTableFieldSubtotalOptions]? = nil,
            metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            styleTargets: [QuickSightClientTypes.TableStyleTarget]? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil,
            valueCellStyle: QuickSightClientTypes.TableCellStyle? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldLevel = fieldLevel
            self.fieldLevelOptions = fieldLevelOptions
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.styleTargets = styleTargets
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }
    }
}

extension QuickSightClientTypes {

    public enum TableTotalsPlacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case end
        case start
        case sdkUnknown(Swift.String)

        public static var allCases: [TableTotalsPlacement] {
            return [
                .auto,
                .end,
                .start
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .end: return "END"
            case .start: return "START"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TableTotalsScrollStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pinned
        case scrolled
        case sdkUnknown(Swift.String)

        public static var allCases: [TableTotalsScrollStatus] {
            return [
                .pinned,
                .scrolled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pinned: return "PINNED"
            case .scrolled: return "SCROLLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum SimpleTotalAggregationFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case `default`
        case max
        case min
        case `none`
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [SimpleTotalAggregationFunction] {
            return [
                .average,
                .default,
                .max,
                .min,
                .none,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .default: return "DEFAULT"
            case .max: return "MAX"
            case .min: return "MIN"
            case .none: return "NONE"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An aggregation function that aggregates the total values of a measure.
    public struct TotalAggregationFunction: Swift.Sendable {
        /// A built in aggregation function for total values.
        public var simpleTotalAggregationFunction: QuickSightClientTypes.SimpleTotalAggregationFunction?

        public init(
            simpleTotalAggregationFunction: QuickSightClientTypes.SimpleTotalAggregationFunction? = nil
        )
        {
            self.simpleTotalAggregationFunction = simpleTotalAggregationFunction
        }
    }
}

extension QuickSightClientTypes {

    /// The total aggregation settings map of a field id.
    public struct TotalAggregationOption: Swift.Sendable {
        /// The field id that's associated with the total aggregation option.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The total aggregation function that you want to set for a specified field id.
        /// This member is required.
        public var totalAggregationFunction: QuickSightClientTypes.TotalAggregationFunction?

        public init(
            fieldId: Swift.String? = nil,
            totalAggregationFunction: QuickSightClientTypes.TotalAggregationFunction? = nil
        )
        {
            self.fieldId = fieldId
            self.totalAggregationFunction = totalAggregationFunction
        }
    }
}

extension QuickSightClientTypes {

    /// The optional configuration of totals cells in a PivotTableVisual.
    public struct PivotTotalOptions: Swift.Sendable {
        /// The custom label string for the total cells.
        public var customLabel: Swift.String?
        /// The cell styling options for the total of header cells.
        public var metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The placement (start, end) for the total cells.
        public var placement: QuickSightClientTypes.TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public var scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus?
        /// The total aggregation options for each value field.
        public var totalAggregationOptions: [QuickSightClientTypes.TotalAggregationOption]?
        /// The cell styling options for the total cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the total cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?
        /// The cell styling options for the totals of value cells.
        public var valueCellStyle: QuickSightClientTypes.TableCellStyle?

        public init(
            customLabel: Swift.String? = nil,
            metricHeaderCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            placement: QuickSightClientTypes.TableTotalsPlacement? = nil,
            scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus? = nil,
            totalAggregationOptions: [QuickSightClientTypes.TotalAggregationOption]? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil,
            valueCellStyle: QuickSightClientTypes.TableCellStyle? = nil
        )
        {
            self.customLabel = customLabel
            self.metricHeaderCellStyle = metricHeaderCellStyle
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalAggregationOptions = totalAggregationOptions
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
            self.valueCellStyle = valueCellStyle
        }
    }
}

extension QuickSightClientTypes {

    /// The total options for a pivot table visual.
    public struct PivotTableTotalOptions: Swift.Sendable {
        /// The column subtotal options.
        public var columnSubtotalOptions: QuickSightClientTypes.SubtotalOptions?
        /// The column total options.
        public var columnTotalOptions: QuickSightClientTypes.PivotTotalOptions?
        /// The row subtotal options.
        public var rowSubtotalOptions: QuickSightClientTypes.SubtotalOptions?
        /// The row total options.
        public var rowTotalOptions: QuickSightClientTypes.PivotTotalOptions?

        public init(
            columnSubtotalOptions: QuickSightClientTypes.SubtotalOptions? = nil,
            columnTotalOptions: QuickSightClientTypes.PivotTotalOptions? = nil,
            rowSubtotalOptions: QuickSightClientTypes.SubtotalOptions? = nil,
            rowTotalOptions: QuickSightClientTypes.PivotTotalOptions? = nil
        )
        {
            self.columnSubtotalOptions = columnSubtotalOptions
            self.columnTotalOptions = columnTotalOptions
            self.rowSubtotalOptions = rowSubtotalOptions
            self.rowTotalOptions = rowTotalOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a PivotTableVisual.
    public struct PivotTableConfiguration: Swift.Sendable {
        /// The field options for a pivot table visual.
        public var fieldOptions: QuickSightClientTypes.PivotTableFieldOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.PivotTableFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The paginated report options for a pivot table visual.
        public var paginatedReportOptions: QuickSightClientTypes.PivotTablePaginatedReportOptions?
        /// The sort configuration for a PivotTableVisual.
        public var sortConfiguration: QuickSightClientTypes.PivotTableSortConfiguration?
        /// The table options for a pivot table visual.
        public var tableOptions: QuickSightClientTypes.PivotTableOptions?
        /// The total options for a pivot table visual.
        public var totalOptions: QuickSightClientTypes.PivotTableTotalOptions?

        public init(
            fieldOptions: QuickSightClientTypes.PivotTableFieldOptions? = nil,
            fieldWells: QuickSightClientTypes.PivotTableFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            paginatedReportOptions: QuickSightClientTypes.PivotTablePaginatedReportOptions? = nil,
            sortConfiguration: QuickSightClientTypes.PivotTableSortConfiguration? = nil,
            tableOptions: QuickSightClientTypes.PivotTableOptions? = nil,
            totalOptions: QuickSightClientTypes.PivotTableTotalOptions? = nil
        )
        {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum PivotTableConditionalFormattingScopeRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case field
        case fieldTotal
        case grandTotal
        case sdkUnknown(Swift.String)

        public static var allCases: [PivotTableConditionalFormattingScopeRole] {
            return [
                .field,
                .fieldTotal,
                .grandTotal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .field: return "FIELD"
            case .fieldTotal: return "FIELD_TOTAL"
            case .grandTotal: return "GRAND_TOTAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The scope of the cell for conditional formatting.
    public struct PivotTableConditionalFormattingScope: Swift.Sendable {
        /// The role (field, field total, grand total) of the cell for conditional formatting.
        public var role: QuickSightClientTypes.PivotTableConditionalFormattingScopeRole?

        public init(
            role: QuickSightClientTypes.PivotTableConditionalFormattingScopeRole? = nil
        )
        {
            self.role = role
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for the text.
    public struct TextConditionalFormat: Swift.Sendable {
        /// The conditional formatting for the text background color.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?
        /// The conditional formatting for the icon.
        public var icon: QuickSightClientTypes.ConditionalFormattingIcon?
        /// The conditional formatting for the text color.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil,
            icon: QuickSightClientTypes.ConditionalFormattingIcon? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.icon = icon
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// The cell conditional formatting option for a pivot table.
    public struct PivotTableCellConditionalFormatting: Swift.Sendable {
        /// The field ID of the cell for conditional formatting.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The scope of the cell for conditional formatting.
        public var scope: QuickSightClientTypes.PivotTableConditionalFormattingScope?
        /// A list of cell scopes for conditional formatting.
        public var scopes: [QuickSightClientTypes.PivotTableConditionalFormattingScope]?
        /// The text format of the cell for conditional formatting.
        public var textFormat: QuickSightClientTypes.TextConditionalFormat?

        public init(
            fieldId: Swift.String? = nil,
            scope: QuickSightClientTypes.PivotTableConditionalFormattingScope? = nil,
            scopes: [QuickSightClientTypes.PivotTableConditionalFormattingScope]? = nil,
            textFormat: QuickSightClientTypes.TextConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.scope = scope
            self.scopes = scopes
            self.textFormat = textFormat
        }
    }
}

extension QuickSightClientTypes {

    /// Conditional formatting options for a PivotTableVisual.
    public struct PivotTableConditionalFormattingOption: Swift.Sendable {
        /// The cell conditional formatting option for a pivot table.
        public var cell: QuickSightClientTypes.PivotTableCellConditionalFormatting?

        public init(
            cell: QuickSightClientTypes.PivotTableCellConditionalFormatting? = nil
        )
        {
            self.cell = cell
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for a PivotTableVisual.
    public struct PivotTableConditionalFormatting: Swift.Sendable {
        /// Conditional formatting options for a PivotTableVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.PivotTableConditionalFormattingOption]?

        public init(
            conditionalFormattingOptions: [QuickSightClientTypes.PivotTableConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A pivot table. For more information, see [Using pivot tables](https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html) in the Amazon QuickSight User Guide.
    public struct PivotTableVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.PivotTableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public var conditionalFormatting: QuickSightClientTypes.PivotTableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.PivotTableConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.PivotTableConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    public enum RadarChartAxesRangeScale: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case independent
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [RadarChartAxesRangeScale] {
            return [
                .auto,
                .independent,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .independent: return "INDEPENDENT"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The configured style settings of a radar chart.
    public struct RadarChartAreaStyleSettings: Swift.Sendable {
        /// The visibility settings of a radar chart.
        public var visibility: QuickSightClientTypes.Visibility?

        public init(
            visibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.visibility = visibility
        }
    }
}

extension QuickSightClientTypes {

    /// The series settings of a radar chart.
    public struct RadarChartSeriesSettings: Swift.Sendable {
        /// The area style settings of a radar chart.
        public var areaStyleSettings: QuickSightClientTypes.RadarChartAreaStyleSettings?

        public init(
            areaStyleSettings: QuickSightClientTypes.RadarChartAreaStyleSettings? = nil
        )
        {
            self.areaStyleSettings = areaStyleSettings
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well configuration of a RadarChartVisual.
    public struct RadarChartAggregatedFieldWells: Swift.Sendable {
        /// The aggregated field well categories of a radar chart.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The color that are assigned to the aggregated field wells of a radar chart.
        public var color: [QuickSightClientTypes.DimensionField]?
        /// The values that are assigned to the aggregated field wells of a radar chart.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            color: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.color = color
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a radar chart visual.
    public struct RadarChartFieldWells: Swift.Sendable {
        /// The aggregated field wells of a radar chart visual.
        public var radarChartAggregatedFieldWells: QuickSightClientTypes.RadarChartAggregatedFieldWells?

        public init(
            radarChartAggregatedFieldWells: QuickSightClientTypes.RadarChartAggregatedFieldWells? = nil
        )
        {
            self.radarChartAggregatedFieldWells = radarChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    public enum RadarChartShape: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case circle
        case polygon
        case sdkUnknown(Swift.String)

        public static var allCases: [RadarChartShape] {
            return [
                .circle,
                .polygon
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .circle: return "CIRCLE"
            case .polygon: return "POLYGON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a RadarChartVisual.
    public struct RadarChartSortConfiguration: Swift.Sendable {
        /// The category items limit for a radar chart.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The category sort options of a radar chart.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?
        /// The color items limit of a radar chart.
        public var colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The color sort configuration of a radar chart.
        public var colorSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil,
            colorItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            colorSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
            self.colorItemsLimit = colorItemsLimit
            self.colorSort = colorSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a RadarChartVisual.
    public struct RadarChartConfiguration: Swift.Sendable {
        /// Determines the visibility of the colors of alternatign bands in a radar chart.
        public var alternateBandColorsVisibility: QuickSightClientTypes.Visibility?
        /// The color of the even-numbered alternate bands of a radar chart.
        public var alternateBandEvenColor: Swift.String?
        /// The color of the odd-numbered alternate bands of a radar chart.
        public var alternateBandOddColor: Swift.String?
        /// The axis behavior options of a radar chart.
        public var axesRangeScale: QuickSightClientTypes.RadarChartAxesRangeScale?
        /// The base sreies settings of a radar chart.
        public var baseSeriesSettings: QuickSightClientTypes.RadarChartSeriesSettings?
        /// The category axis of a radar chart.
        public var categoryAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The category label options of a radar chart.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The color axis of a radar chart.
        public var colorAxis: QuickSightClientTypes.AxisDisplayOptions?
        /// The color label options of a radar chart.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field well configuration of a RadarChartVisual.
        public var fieldWells: QuickSightClientTypes.RadarChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The shape of the radar chart.
        public var shape: QuickSightClientTypes.RadarChartShape?
        /// The sort configuration of a RadarChartVisual.
        public var sortConfiguration: QuickSightClientTypes.RadarChartSortConfiguration?
        /// The start angle of a radar chart's axis.
        public var startAngle: Swift.Double?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?

        public init(
            alternateBandColorsVisibility: QuickSightClientTypes.Visibility? = nil,
            alternateBandEvenColor: Swift.String? = nil,
            alternateBandOddColor: Swift.String? = nil,
            axesRangeScale: QuickSightClientTypes.RadarChartAxesRangeScale? = nil,
            baseSeriesSettings: QuickSightClientTypes.RadarChartSeriesSettings? = nil,
            categoryAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorAxis: QuickSightClientTypes.AxisDisplayOptions? = nil,
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.RadarChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            shape: QuickSightClientTypes.RadarChartShape? = nil,
            sortConfiguration: QuickSightClientTypes.RadarChartSortConfiguration? = nil,
            startAngle: Swift.Double? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil
        )
        {
            self.alternateBandColorsVisibility = alternateBandColorsVisibility
            self.alternateBandEvenColor = alternateBandEvenColor
            self.alternateBandOddColor = alternateBandOddColor
            self.axesRangeScale = axesRangeScale
            self.baseSeriesSettings = baseSeriesSettings
            self.categoryAxis = categoryAxis
            self.categoryLabelOptions = categoryLabelOptions
            self.colorAxis = colorAxis
            self.colorLabelOptions = colorLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.shape = shape
            self.sortConfiguration = sortConfiguration
            self.startAngle = startAngle
            self.visualPalette = visualPalette
        }
    }
}

extension QuickSightClientTypes {

    /// A radar chart visual.
    public struct RadarChartVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.RadarChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.RadarChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a sankey diagram.
    public struct SankeyDiagramAggregatedFieldWells: Swift.Sendable {
        /// The destination field wells of a sankey diagram.
        public var destination: [QuickSightClientTypes.DimensionField]?
        /// The source field wells of a sankey diagram.
        public var source: [QuickSightClientTypes.DimensionField]?
        /// The weight field wells of a sankey diagram.
        public var weight: [QuickSightClientTypes.MeasureField]?

        public init(
            destination: [QuickSightClientTypes.DimensionField]? = nil,
            source: [QuickSightClientTypes.DimensionField]? = nil,
            weight: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.destination = destination
            self.source = source
            self.weight = weight
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a sankey diagram.
    public struct SankeyDiagramFieldWells: Swift.Sendable {
        /// The field well configuration of a sankey diagram.
        public var sankeyDiagramAggregatedFieldWells: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells?

        public init(
            sankeyDiagramAggregatedFieldWells: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells? = nil
        )
        {
            self.sankeyDiagramAggregatedFieldWells = sankeyDiagramAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a sankey diagram.
    public struct SankeyDiagramSortConfiguration: Swift.Sendable {
        /// The limit on the number of destination nodes that are displayed in a sankey diagram.
        public var destinationItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The limit on the number of source nodes that are displayed in a sankey diagram.
        public var sourceItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the weight fields.
        public var weightSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            destinationItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            sourceItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            weightSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.destinationItemsLimit = destinationItemsLimit
            self.sourceItemsLimit = sourceItemsLimit
            self.weightSort = weightSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a sankey diagram.
    public struct SankeyDiagramChartConfiguration: Swift.Sendable {
        /// The data label configuration of a sankey diagram.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a sankey diagram.
        public var fieldWells: QuickSightClientTypes.SankeyDiagramFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The sort configuration of a sankey diagram.
        public var sortConfiguration: QuickSightClientTypes.SankeyDiagramSortConfiguration?

        public init(
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.SankeyDiagramFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            sortConfiguration: QuickSightClientTypes.SankeyDiagramSortConfiguration? = nil
        )
        {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// A sankey diagram. For more information, see [Using Sankey diagrams](https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html) in the Amazon QuickSight User Guide.
    public struct SankeyDiagramVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration of a sankey diagram.
        public var chartConfiguration: QuickSightClientTypes.SankeyDiagramChartConfiguration?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.SankeyDiagramChartConfiguration? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well of a scatter plot.
    public struct ScatterPlotCategoricallyAggregatedFieldWells: Swift.Sendable {
        /// The category field well of a scatter plot.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The label field well of a scatter plot.
        public var label: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a scatter plot.
        public var size: [QuickSightClientTypes.MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is aggregated by category.
        public var xAxis: [QuickSightClientTypes.MeasureField]?
        /// The y-axis field well of a scatter plot. The y-axis is aggregated by category.
        public var yAxis: [QuickSightClientTypes.MeasureField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            label: [QuickSightClientTypes.DimensionField]? = nil,
            size: [QuickSightClientTypes.MeasureField]? = nil,
            xAxis: [QuickSightClientTypes.MeasureField]? = nil,
            yAxis: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.category = category
            self.label = label
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }
    }
}

extension QuickSightClientTypes {

    /// The unaggregated field wells of a scatter plot.
    public struct ScatterPlotUnaggregatedFieldWells: Swift.Sendable {
        /// The category field well of a scatter plot.
        public var category: [QuickSightClientTypes.DimensionField]?
        /// The label field well of a scatter plot.
        public var label: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a scatter plot.
        public var size: [QuickSightClientTypes.MeasureField]?
        /// The x-axis field well of a scatter plot. The x-axis is a dimension field and cannot be aggregated.
        public var xAxis: [QuickSightClientTypes.DimensionField]?
        /// The y-axis field well of a scatter plot. The y-axis is a dimension field and cannot be aggregated.
        public var yAxis: [QuickSightClientTypes.DimensionField]?

        public init(
            category: [QuickSightClientTypes.DimensionField]? = nil,
            label: [QuickSightClientTypes.DimensionField]? = nil,
            size: [QuickSightClientTypes.MeasureField]? = nil,
            xAxis: [QuickSightClientTypes.DimensionField]? = nil,
            yAxis: [QuickSightClientTypes.DimensionField]? = nil
        )
        {
            self.category = category
            self.label = label
            self.size = size
            self.xAxis = xAxis
            self.yAxis = yAxis
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a scatter plot. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct ScatterPlotFieldWells: Swift.Sendable {
        /// The aggregated field wells of a scatter plot. The x and y-axes of scatter plots with aggregated field wells are aggregated by category, label, or both.
        public var scatterPlotCategoricallyAggregatedFieldWells: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells?
        /// The unaggregated field wells of a scatter plot. The x and y-axes of these scatter plots are unaggregated.
        public var scatterPlotUnaggregatedFieldWells: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells?

        public init(
            scatterPlotCategoricallyAggregatedFieldWells: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells? = nil,
            scatterPlotUnaggregatedFieldWells: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells? = nil
        )
        {
            self.scatterPlotCategoricallyAggregatedFieldWells = scatterPlotCategoricallyAggregatedFieldWells
            self.scatterPlotUnaggregatedFieldWells = scatterPlotUnaggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a scatter plot.
    public struct ScatterPlotSortConfiguration: Swift.Sendable {
        /// The limit configuration of the visual display for an axis.
        public var scatterPlotLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?

        public init(
            scatterPlotLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil
        )
        {
            self.scatterPlotLimitConfiguration = scatterPlotLimitConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a scatter plot.
    public struct ScatterPlotConfiguration: Swift.Sendable {
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.ScatterPlotFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The sort configuration of a scatter plot.
        public var sortConfiguration: QuickSightClientTypes.ScatterPlotSortConfiguration?
        /// The legend display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?
        /// The palette (chart color) display setup of the visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's x-axis.
        public var xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's x-axis.
        public var xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The label display options (grid line, range, scale, and axis step) of the scatter plot's y-axis.
        public var yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The label options (label text, label visibility, and sort icon visibility) of the scatter plot's y-axis.
        public var yAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?

        public init(
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.ScatterPlotFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            sortConfiguration: QuickSightClientTypes.ScatterPlotSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            xAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            xAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            yAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            yAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil
        )
        {
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
            self.visualPalette = visualPalette
            self.xAxisDisplayOptions = xAxisDisplayOptions
            self.xAxisLabelOptions = xAxisLabelOptions
            self.yAxisDisplayOptions = yAxisDisplayOptions
            self.yAxisLabelOptions = yAxisLabelOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A scatter plot. For more information, see [Using scatter plots](https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html) in the Amazon QuickSight User Guide.
    public struct ScatterPlotVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.ScatterPlotConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.ScatterPlotConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The settings for the pinned columns of a table visual.
    public struct TablePinnedFieldOptions: Swift.Sendable {
        /// A list of columns to be pinned to the left of a table visual.
        public var pinnedLeftFields: [Swift.String]?

        public init(
            pinnedLeftFields: [Swift.String]? = nil
        )
        {
            self.pinnedLeftFields = pinnedLeftFields
        }
    }
}

extension QuickSightClientTypes {

    public enum TableCellImageScalingConfiguration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doNotScale
        case fitToCellHeight
        case fitToCellWidth
        case sdkUnknown(Swift.String)

        public static var allCases: [TableCellImageScalingConfiguration] {
            return [
                .doNotScale,
                .fitToCellHeight,
                .fitToCellWidth
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doNotScale: return "DO_NOT_SCALE"
            case .fitToCellHeight: return "FIT_TO_CELL_HEIGHT"
            case .fitToCellWidth: return "FIT_TO_CELL_WIDTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The sizing options for the table image configuration.
    public struct TableCellImageSizingConfiguration: Swift.Sendable {
        /// The cell scaling configuration of the sizing options for the table image configuration.
        public var tableCellImageScalingConfiguration: QuickSightClientTypes.TableCellImageScalingConfiguration?

        public init(
            tableCellImageScalingConfiguration: QuickSightClientTypes.TableCellImageScalingConfiguration? = nil
        )
        {
            self.tableCellImageScalingConfiguration = tableCellImageScalingConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The image configuration of a table field URL.
    public struct TableFieldImageConfiguration: Swift.Sendable {
        /// The sizing options for the table image configuration.
        public var sizingOptions: QuickSightClientTypes.TableCellImageSizingConfiguration?

        public init(
            sizingOptions: QuickSightClientTypes.TableCellImageSizingConfiguration? = nil
        )
        {
            self.sizingOptions = sizingOptions
        }
    }
}

extension QuickSightClientTypes {

    public enum TableFieldIconSetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case link
        case sdkUnknown(Swift.String)

        public static var allCases: [TableFieldIconSetType] {
            return [
                .link
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .link: return "LINK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The custom icon content for the table link content configuration.
    public struct TableFieldCustomIconContent: Swift.Sendable {
        /// The icon set type (link) of the custom icon content for table URL link content.
        public var icon: QuickSightClientTypes.TableFieldIconSetType?

        public init(
            icon: QuickSightClientTypes.TableFieldIconSetType? = nil
        )
        {
            self.icon = icon
        }
    }
}

extension QuickSightClientTypes {

    /// The custom text content (value, font configuration) for the table link content configuration.
    public struct TableFieldCustomTextContent: Swift.Sendable {
        /// The font configuration of the custom text content for the table URL link content.
        /// This member is required.
        public var fontConfiguration: QuickSightClientTypes.FontConfiguration?
        /// The string value of the custom text content for the table URL link content.
        public var value: Swift.String?

        public init(
            fontConfiguration: QuickSightClientTypes.FontConfiguration? = nil,
            value: Swift.String? = nil
        )
        {
            self.fontConfiguration = fontConfiguration
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The URL content (text, icon) for the table link configuration.
    public struct TableFieldLinkContentConfiguration: Swift.Sendable {
        /// The custom icon content for the table link content configuration.
        public var customIconContent: QuickSightClientTypes.TableFieldCustomIconContent?
        /// The custom text content (value, font configuration) for the table link content configuration.
        public var customTextContent: QuickSightClientTypes.TableFieldCustomTextContent?

        public init(
            customIconContent: QuickSightClientTypes.TableFieldCustomIconContent? = nil,
            customTextContent: QuickSightClientTypes.TableFieldCustomTextContent? = nil
        )
        {
            self.customIconContent = customIconContent
            self.customTextContent = customTextContent
        }
    }
}

extension QuickSightClientTypes {

    /// The link configuration of a table field URL.
    public struct TableFieldLinkConfiguration: Swift.Sendable {
        /// The URL content (text, icon) for the table link configuration.
        /// This member is required.
        public var content: QuickSightClientTypes.TableFieldLinkContentConfiguration?
        /// The URL target (new tab, new window, same tab) for the table link configuration.
        /// This member is required.
        public var target: QuickSightClientTypes.URLTargetConfiguration?

        public init(
            content: QuickSightClientTypes.TableFieldLinkContentConfiguration? = nil,
            target: QuickSightClientTypes.URLTargetConfiguration? = nil
        )
        {
            self.content = content
            self.target = target
        }
    }
}

extension QuickSightClientTypes {

    /// The URL configuration for a table field.
    public struct TableFieldURLConfiguration: Swift.Sendable {
        /// The image configuration of a table field URL.
        public var imageConfiguration: QuickSightClientTypes.TableFieldImageConfiguration?
        /// The link configuration of a table field URL.
        public var linkConfiguration: QuickSightClientTypes.TableFieldLinkConfiguration?

        public init(
            imageConfiguration: QuickSightClientTypes.TableFieldImageConfiguration? = nil,
            linkConfiguration: QuickSightClientTypes.TableFieldLinkConfiguration? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.linkConfiguration = linkConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The options for a table field.
    public struct TableFieldOption: Swift.Sendable {
        /// The custom label for a table field.
        public var customLabel: Swift.String?
        /// The field ID for a table field.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The URL configuration for a table field.
        public var urlStyling: QuickSightClientTypes.TableFieldURLConfiguration?
        /// The visibility of a table field.
        public var visibility: QuickSightClientTypes.Visibility?
        /// The width for a table field.
        public var width: Swift.String?

        public init(
            customLabel: Swift.String? = nil,
            fieldId: Swift.String? = nil,
            urlStyling: QuickSightClientTypes.TableFieldURLConfiguration? = nil,
            visibility: QuickSightClientTypes.Visibility? = nil,
            width: Swift.String? = nil
        )
        {
            self.customLabel = customLabel
            self.fieldId = fieldId
            self.urlStyling = urlStyling
            self.visibility = visibility
            self.width = width
        }
    }
}

extension QuickSightClientTypes {

    /// The field options of a table visual.
    public struct TableFieldOptions: Swift.Sendable {
        /// The order of the field IDs that are configured as field options for a table visual.
        public var order: [Swift.String]?
        /// The settings for the pinned columns of a table visual.
        public var pinnedFieldOptions: QuickSightClientTypes.TablePinnedFieldOptions?
        /// The field options to be configured to a table.
        public var selectedFieldOptions: [QuickSightClientTypes.TableFieldOption]?

        public init(
            order: [Swift.String]? = nil,
            pinnedFieldOptions: QuickSightClientTypes.TablePinnedFieldOptions? = nil,
            selectedFieldOptions: [QuickSightClientTypes.TableFieldOption]? = nil
        )
        {
            self.order = order
            self.pinnedFieldOptions = pinnedFieldOptions
            self.selectedFieldOptions = selectedFieldOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field well for the table.
    public struct TableAggregatedFieldWells: Swift.Sendable {
        /// The group by field well for a pivot table. Values are grouped by group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The values field well for a pivot table. Values are aggregated based on group by fields.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The unaggregated field for a table.
    public struct UnaggregatedField: Swift.Sendable {
        /// The column that is used in the UnaggregatedField.
        /// This member is required.
        public var column: QuickSightClientTypes.ColumnIdentifier?
        /// The custom field ID.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The format configuration of the field.
        public var formatConfiguration: QuickSightClientTypes.FormatConfiguration?

        public init(
            column: QuickSightClientTypes.ColumnIdentifier? = nil,
            fieldId: Swift.String? = nil,
            formatConfiguration: QuickSightClientTypes.FormatConfiguration? = nil
        )
        {
            self.column = column
            self.fieldId = fieldId
            self.formatConfiguration = formatConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The unaggregated field well for the table.
    public struct TableUnaggregatedFieldWells: Swift.Sendable {
        /// The values field well for a pivot table. Values are unaggregated for an unaggregated table.
        public var values: [QuickSightClientTypes.UnaggregatedField]?

        public init(
            values: [QuickSightClientTypes.UnaggregatedField]? = nil
        )
        {
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells for a table visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TableFieldWells: Swift.Sendable {
        /// The aggregated field well for the table.
        public var tableAggregatedFieldWells: QuickSightClientTypes.TableAggregatedFieldWells?
        /// The unaggregated field well for the table.
        public var tableUnaggregatedFieldWells: QuickSightClientTypes.TableUnaggregatedFieldWells?

        public init(
            tableAggregatedFieldWells: QuickSightClientTypes.TableAggregatedFieldWells? = nil,
            tableUnaggregatedFieldWells: QuickSightClientTypes.TableUnaggregatedFieldWells? = nil
        )
        {
            self.tableAggregatedFieldWells = tableAggregatedFieldWells
            self.tableUnaggregatedFieldWells = tableUnaggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The paginated report options for a table visual.
    public struct TablePaginatedReportOptions: Swift.Sendable {
        /// The visibility of repeating header rows on each page.
        public var overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility?
        /// The visibility of printing table overflow across pages.
        public var verticalOverflowVisibility: QuickSightClientTypes.Visibility?

        public init(
            overflowColumnHeaderVisibility: QuickSightClientTypes.Visibility? = nil,
            verticalOverflowVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.overflowColumnHeaderVisibility = overflowColumnHeaderVisibility
            self.verticalOverflowVisibility = verticalOverflowVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration for a TableVisual.
    public struct TableSortConfiguration: Swift.Sendable {
        /// The pagination configuration (page size, page number) for the table.
        public var paginationConfiguration: QuickSightClientTypes.PaginationConfiguration?
        /// The field sort options for rows in the table.
        public var rowSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            paginationConfiguration: QuickSightClientTypes.PaginationConfiguration? = nil,
            rowSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.paginationConfiguration = paginationConfiguration
            self.rowSort = rowSort
        }
    }
}

extension QuickSightClientTypes {

    /// The options for data bars.
    public struct DataBarsOptions: Swift.Sendable {
        /// The field ID for the data bars options.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The color of the negative data bar.
        public var negativeColor: Swift.String?
        /// The color of the positive data bar.
        public var positiveColor: Swift.String?

        public init(
            fieldId: Swift.String? = nil,
            negativeColor: Swift.String? = nil,
            positiveColor: Swift.String? = nil
        )
        {
            self.fieldId = fieldId
            self.negativeColor = negativeColor
            self.positiveColor = positiveColor
        }
    }
}

extension QuickSightClientTypes {

    /// The inline visualization of a specific type to display within a chart.
    public struct TableInlineVisualization: Swift.Sendable {
        /// The configuration of the inline visualization of the data bars within a chart.
        public var dataBars: QuickSightClientTypes.DataBarsOptions?

        public init(
            dataBars: QuickSightClientTypes.DataBarsOptions? = nil
        )
        {
            self.dataBars = dataBars
        }
    }
}

extension QuickSightClientTypes {

    public enum TableOrientation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case horizontal
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [TableOrientation] {
            return [
                .horizontal,
                .vertical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .vertical: return "VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The table options for a table visual.
    public struct TableOptions: Swift.Sendable {
        /// The table cell style of table cells.
        public var cellStyle: QuickSightClientTypes.TableCellStyle?
        /// The table cell style of a table header.
        public var headerStyle: QuickSightClientTypes.TableCellStyle?
        /// The orientation (vertical, horizontal) for a table.
        public var orientation: QuickSightClientTypes.TableOrientation?
        /// The row alternate color options (widget status, row alternate colors) for a table.
        public var rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions?

        public init(
            cellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            headerStyle: QuickSightClientTypes.TableCellStyle? = nil,
            orientation: QuickSightClientTypes.TableOrientation? = nil,
            rowAlternateColorOptions: QuickSightClientTypes.RowAlternateColorOptions? = nil
        )
        {
            self.cellStyle = cellStyle
            self.headerStyle = headerStyle
            self.orientation = orientation
            self.rowAlternateColorOptions = rowAlternateColorOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The total options for a table visual.
    public struct TotalOptions: Swift.Sendable {
        /// The custom label string for the total cells.
        public var customLabel: Swift.String?
        /// The placement (start, end) for the total cells.
        public var placement: QuickSightClientTypes.TableTotalsPlacement?
        /// The scroll status (pinned, scrolled) for the total cells.
        public var scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus?
        /// The total aggregation settings for each value field.
        public var totalAggregationOptions: [QuickSightClientTypes.TotalAggregationOption]?
        /// Cell styling options for the total cells.
        public var totalCellStyle: QuickSightClientTypes.TableCellStyle?
        /// The visibility configuration for the total cells.
        public var totalsVisibility: QuickSightClientTypes.Visibility?

        public init(
            customLabel: Swift.String? = nil,
            placement: QuickSightClientTypes.TableTotalsPlacement? = nil,
            scrollStatus: QuickSightClientTypes.TableTotalsScrollStatus? = nil,
            totalAggregationOptions: [QuickSightClientTypes.TotalAggregationOption]? = nil,
            totalCellStyle: QuickSightClientTypes.TableCellStyle? = nil,
            totalsVisibility: QuickSightClientTypes.Visibility? = nil
        )
        {
            self.customLabel = customLabel
            self.placement = placement
            self.scrollStatus = scrollStatus
            self.totalAggregationOptions = totalAggregationOptions
            self.totalCellStyle = totalCellStyle
            self.totalsVisibility = totalsVisibility
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a TableVisual.
    public struct TableConfiguration: Swift.Sendable {
        /// The field options for a table visual.
        public var fieldOptions: QuickSightClientTypes.TableFieldOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.TableFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The paginated report options for a table visual.
        public var paginatedReportOptions: QuickSightClientTypes.TablePaginatedReportOptions?
        /// The sort configuration for a TableVisual.
        public var sortConfiguration: QuickSightClientTypes.TableSortConfiguration?
        /// A collection of inline visualizations to display within a chart.
        public var tableInlineVisualizations: [QuickSightClientTypes.TableInlineVisualization]?
        /// The table options for a table visual.
        public var tableOptions: QuickSightClientTypes.TableOptions?
        /// The total options for a table visual.
        public var totalOptions: QuickSightClientTypes.TotalOptions?

        public init(
            fieldOptions: QuickSightClientTypes.TableFieldOptions? = nil,
            fieldWells: QuickSightClientTypes.TableFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            paginatedReportOptions: QuickSightClientTypes.TablePaginatedReportOptions? = nil,
            sortConfiguration: QuickSightClientTypes.TableSortConfiguration? = nil,
            tableInlineVisualizations: [QuickSightClientTypes.TableInlineVisualization]? = nil,
            tableOptions: QuickSightClientTypes.TableOptions? = nil,
            totalOptions: QuickSightClientTypes.TotalOptions? = nil
        )
        {
            self.fieldOptions = fieldOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.paginatedReportOptions = paginatedReportOptions
            self.sortConfiguration = sortConfiguration
            self.tableInlineVisualizations = tableInlineVisualizations
            self.tableOptions = tableOptions
            self.totalOptions = totalOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The cell conditional formatting option for a table.
    public struct TableCellConditionalFormatting: Swift.Sendable {
        /// The field ID of the cell for conditional formatting.
        /// This member is required.
        public var fieldId: Swift.String?
        /// The text format of the cell for conditional formatting.
        public var textFormat: QuickSightClientTypes.TextConditionalFormat?

        public init(
            fieldId: Swift.String? = nil,
            textFormat: QuickSightClientTypes.TextConditionalFormat? = nil
        )
        {
            self.fieldId = fieldId
            self.textFormat = textFormat
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting of a table row.
    public struct TableRowConditionalFormatting: Swift.Sendable {
        /// The conditional formatting color (solid, gradient) of the background for a table row.
        public var backgroundColor: QuickSightClientTypes.ConditionalFormattingColor?
        /// The conditional formatting color (solid, gradient) of the text for a table row.
        public var textColor: QuickSightClientTypes.ConditionalFormattingColor?

        public init(
            backgroundColor: QuickSightClientTypes.ConditionalFormattingColor? = nil,
            textColor: QuickSightClientTypes.ConditionalFormattingColor? = nil
        )
        {
            self.backgroundColor = backgroundColor
            self.textColor = textColor
        }
    }
}

extension QuickSightClientTypes {

    /// Conditional formatting options for a PivotTableVisual.
    public struct TableConditionalFormattingOption: Swift.Sendable {
        /// The cell conditional formatting option for a table.
        public var cell: QuickSightClientTypes.TableCellConditionalFormatting?
        /// The row conditional formatting option for a table.
        public var row: QuickSightClientTypes.TableRowConditionalFormatting?

        public init(
            cell: QuickSightClientTypes.TableCellConditionalFormatting? = nil,
            row: QuickSightClientTypes.TableRowConditionalFormatting? = nil
        )
        {
            self.cell = cell
            self.row = row
        }
    }
}

extension QuickSightClientTypes {

    /// The conditional formatting for a PivotTableVisual.
    public struct TableConditionalFormatting: Swift.Sendable {
        /// Conditional formatting options for a PivotTableVisual.
        public var conditionalFormattingOptions: [QuickSightClientTypes.TableConditionalFormattingOption]?

        public init(
            conditionalFormattingOptions: [QuickSightClientTypes.TableConditionalFormattingOption]? = nil
        )
        {
            self.conditionalFormattingOptions = conditionalFormattingOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A table visual. For more information, see [Using tables as visuals](https://docs.aws.amazon.com/quicksight/latest/user/tabular.html) in the Amazon QuickSight User Guide.
    public struct TableVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.TableConfiguration?
        /// The conditional formatting for a PivotTableVisual.
        public var conditionalFormatting: QuickSightClientTypes.TableConditionalFormatting?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.TableConfiguration? = nil,
            conditionalFormatting: QuickSightClientTypes.TableConditionalFormatting? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.conditionalFormatting = conditionalFormatting
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// Aggregated field wells of a tree map.
    public struct TreeMapAggregatedFieldWells: Swift.Sendable {
        /// The color field well of a tree map. Values are grouped by aggregations based on group by fields.
        public var colors: [QuickSightClientTypes.MeasureField]?
        /// The group by field well of a tree map. Values are grouped based on group by fields.
        public var groups: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a tree map. Values are aggregated based on group by fields.
        public var sizes: [QuickSightClientTypes.MeasureField]?

        public init(
            colors: [QuickSightClientTypes.MeasureField]? = nil,
            groups: [QuickSightClientTypes.DimensionField]? = nil,
            sizes: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.colors = colors
            self.groups = groups
            self.sizes = sizes
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a tree map. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct TreeMapFieldWells: Swift.Sendable {
        /// The aggregated field wells of a tree map.
        public var treeMapAggregatedFieldWells: QuickSightClientTypes.TreeMapAggregatedFieldWells?

        public init(
            treeMapAggregatedFieldWells: QuickSightClientTypes.TreeMapAggregatedFieldWells? = nil
        )
        {
            self.treeMapAggregatedFieldWells = treeMapAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a tree map.
    public struct TreeMapSortConfiguration: Swift.Sendable {
        /// The limit on the number of groups that are displayed.
        public var treeMapGroupItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public var treeMapSort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            treeMapGroupItemsLimitConfiguration: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            treeMapSort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.treeMapGroupItemsLimitConfiguration = treeMapGroupItemsLimitConfiguration
            self.treeMapSort = treeMapSort
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a tree map.
    public struct TreeMapConfiguration: Swift.Sendable {
        /// The label options (label text, label visibility) for the colors displayed in a tree map.
        public var colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The color options (gradient color, point of divergence) of a tree map.
        public var colorScale: QuickSightClientTypes.ColorScale?
        /// The options that determine if visual data labels are displayed.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.TreeMapFieldWells?
        /// The label options (label text, label visibility) of the groups that are displayed in a tree map.
        public var groupLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend display setup of the visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The label options (label text, label visibility) of the sizes that are displayed in a tree map.
        public var sizeLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a tree map.
        public var sortConfiguration: QuickSightClientTypes.TreeMapSortConfiguration?
        /// The tooltip display setup of the visual.
        public var tooltip: QuickSightClientTypes.TooltipOptions?

        public init(
            colorLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorScale: QuickSightClientTypes.ColorScale? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.TreeMapFieldWells? = nil,
            groupLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            sizeLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.TreeMapSortConfiguration? = nil,
            tooltip: QuickSightClientTypes.TooltipOptions? = nil
        )
        {
            self.colorLabelOptions = colorLabelOptions
            self.colorScale = colorScale
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.groupLabelOptions = groupLabelOptions
            self.interactions = interactions
            self.legend = legend
            self.sizeLabelOptions = sizeLabelOptions
            self.sortConfiguration = sortConfiguration
            self.tooltip = tooltip
        }
    }
}

extension QuickSightClientTypes {

    /// A tree map. For more information, see [Using tree maps](https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html) in the Amazon QuickSight User Guide.
    public struct TreeMapVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.TreeMapConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.TreeMapConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The color configuration for individual groups within a waterfall visual.
    public struct WaterfallChartGroupColorConfiguration: Swift.Sendable {
        /// Defines the color for the negative bars of a waterfall chart.
        public var negativeBarColor: Swift.String?
        /// Defines the color for the positive bars of a waterfall chart.
        public var positiveBarColor: Swift.String?
        /// Defines the color for the total bars of a waterfall chart.
        public var totalBarColor: Swift.String?

        public init(
            negativeBarColor: Swift.String? = nil,
            positiveBarColor: Swift.String? = nil,
            totalBarColor: Swift.String? = nil
        )
        {
            self.negativeBarColor = negativeBarColor
            self.positiveBarColor = positiveBarColor
            self.totalBarColor = totalBarColor
        }
    }
}

extension QuickSightClientTypes {

    /// The color configuration of a waterfall visual.
    public struct WaterfallChartColorConfiguration: Swift.Sendable {
        /// The color configuration for individual groups within a waterfall visual.
        public var groupColorConfiguration: QuickSightClientTypes.WaterfallChartGroupColorConfiguration?

        public init(
            groupColorConfiguration: QuickSightClientTypes.WaterfallChartGroupColorConfiguration? = nil
        )
        {
            self.groupColorConfiguration = groupColorConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a waterfall visual.
    public struct WaterfallChartAggregatedFieldWells: Swift.Sendable {
        /// The breakdown field wells of a waterfall visual.
        public var breakdowns: [QuickSightClientTypes.DimensionField]?
        /// The category field wells of a waterfall visual.
        public var categories: [QuickSightClientTypes.DimensionField]?
        /// The value field wells of a waterfall visual.
        public var values: [QuickSightClientTypes.MeasureField]?

        public init(
            breakdowns: [QuickSightClientTypes.DimensionField]? = nil,
            categories: [QuickSightClientTypes.DimensionField]? = nil,
            values: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.breakdowns = breakdowns
            self.categories = categories
            self.values = values
        }
    }
}

extension QuickSightClientTypes {

    /// The field well configuration of a waterfall visual.
    public struct WaterfallChartFieldWells: Swift.Sendable {
        /// The field well configuration of a waterfall visual.
        public var waterfallChartAggregatedFieldWells: QuickSightClientTypes.WaterfallChartAggregatedFieldWells?

        public init(
            waterfallChartAggregatedFieldWells: QuickSightClientTypes.WaterfallChartAggregatedFieldWells? = nil
        )
        {
            self.waterfallChartAggregatedFieldWells = waterfallChartAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a waterfall visual.
    public struct WaterfallChartSortConfiguration: Swift.Sendable {
        /// The limit on the number of bar groups that are displayed.
        public var breakdownItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of the category fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            breakdownItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.breakdownItemsLimit = breakdownItemsLimit
            self.categorySort = categorySort
        }
    }
}

extension QuickSightClientTypes {

    /// The options that determine the presentation of a waterfall visual.
    public struct WaterfallChartOptions: Swift.Sendable {
        /// This option determines the total bar label of a waterfall visual.
        public var totalBarLabel: Swift.String?

        public init(
            totalBarLabel: Swift.String? = nil
        )
        {
            self.totalBarLabel = totalBarLabel
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration for a waterfall visual.
    public struct WaterfallChartConfiguration: Swift.Sendable {
        /// The options that determine the presentation of the category axis.
        public var categoryAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the category axis label.
        public var categoryAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The color configuration of a waterfall visual.
        public var colorConfiguration: QuickSightClientTypes.WaterfallChartColorConfiguration?
        /// The data label configuration of a waterfall visual.
        public var dataLabels: QuickSightClientTypes.DataLabelOptions?
        /// The field well configuration of a waterfall visual.
        public var fieldWells: QuickSightClientTypes.WaterfallChartFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The legend configuration of a waterfall visual.
        public var legend: QuickSightClientTypes.LegendOptions?
        /// The options that determine the presentation of the y-axis.
        public var primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions?
        /// The options that determine the presentation of the y-axis label.
        public var primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The sort configuration of a waterfall visual.
        public var sortConfiguration: QuickSightClientTypes.WaterfallChartSortConfiguration?
        /// The visual palette configuration of a waterfall visual.
        public var visualPalette: QuickSightClientTypes.VisualPalette?
        /// The options that determine the presentation of a waterfall visual.
        public var waterfallChartOptions: QuickSightClientTypes.WaterfallChartOptions?

        public init(
            categoryAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            categoryAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            colorConfiguration: QuickSightClientTypes.WaterfallChartColorConfiguration? = nil,
            dataLabels: QuickSightClientTypes.DataLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.WaterfallChartFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            legend: QuickSightClientTypes.LegendOptions? = nil,
            primaryYAxisDisplayOptions: QuickSightClientTypes.AxisDisplayOptions? = nil,
            primaryYAxisLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            sortConfiguration: QuickSightClientTypes.WaterfallChartSortConfiguration? = nil,
            visualPalette: QuickSightClientTypes.VisualPalette? = nil,
            waterfallChartOptions: QuickSightClientTypes.WaterfallChartOptions? = nil
        )
        {
            self.categoryAxisDisplayOptions = categoryAxisDisplayOptions
            self.categoryAxisLabelOptions = categoryAxisLabelOptions
            self.colorConfiguration = colorConfiguration
            self.dataLabels = dataLabels
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.legend = legend
            self.primaryYAxisDisplayOptions = primaryYAxisDisplayOptions
            self.primaryYAxisLabelOptions = primaryYAxisLabelOptions
            self.sortConfiguration = sortConfiguration
            self.visualPalette = visualPalette
            self.waterfallChartOptions = waterfallChartOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A waterfall chart. For more information, see [Using waterfall charts](https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html) in the Amazon QuickSight User Guide.
    public struct WaterfallVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration for a waterfall visual.
        public var chartConfiguration: QuickSightClientTypes.WaterfallChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.WaterfallChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The aggregated field wells of a word cloud.
    public struct WordCloudAggregatedFieldWells: Swift.Sendable {
        /// The group by field well of a word cloud. Values are grouped by group by fields.
        public var groupBy: [QuickSightClientTypes.DimensionField]?
        /// The size field well of a word cloud. Values are aggregated based on group by fields.
        public var size: [QuickSightClientTypes.MeasureField]?

        public init(
            groupBy: [QuickSightClientTypes.DimensionField]? = nil,
            size: [QuickSightClientTypes.MeasureField]? = nil
        )
        {
            self.groupBy = groupBy
            self.size = size
        }
    }
}

extension QuickSightClientTypes {

    /// The field wells of a word cloud visual. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct WordCloudFieldWells: Swift.Sendable {
        /// The aggregated field wells of a word cloud.
        public var wordCloudAggregatedFieldWells: QuickSightClientTypes.WordCloudAggregatedFieldWells?

        public init(
            wordCloudAggregatedFieldWells: QuickSightClientTypes.WordCloudAggregatedFieldWells? = nil
        )
        {
            self.wordCloudAggregatedFieldWells = wordCloudAggregatedFieldWells
        }
    }
}

extension QuickSightClientTypes {

    /// The sort configuration of a word cloud visual.
    public struct WordCloudSortConfiguration: Swift.Sendable {
        /// The limit on the number of groups that are displayed in a word cloud.
        public var categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration?
        /// The sort configuration of group by fields.
        public var categorySort: [QuickSightClientTypes.FieldSortOptions]?

        public init(
            categoryItemsLimit: QuickSightClientTypes.ItemsLimitConfiguration? = nil,
            categorySort: [QuickSightClientTypes.FieldSortOptions]? = nil
        )
        {
            self.categoryItemsLimit = categoryItemsLimit
            self.categorySort = categorySort
        }
    }
}

extension QuickSightClientTypes {

    public enum WordCloudCloudLayout: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fluid
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudCloudLayout] {
            return [
                .fluid,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fluid: return "FLUID"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum WordCloudWordCasing: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case existingCase
        case lowerCase
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordCasing] {
            return [
                .existingCase,
                .lowerCase
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .existingCase: return "EXISTING_CASE"
            case .lowerCase: return "LOWER_CASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum WordCloudWordOrientation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case horizontal
        case horizontalAndVertical
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordOrientation] {
            return [
                .horizontal,
                .horizontalAndVertical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .horizontal: return "HORIZONTAL"
            case .horizontalAndVertical: return "HORIZONTAL_AND_VERTICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum WordCloudWordPadding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case medium
        case `none`
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordPadding] {
            return [
                .large,
                .medium,
                .none,
                .small
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case .small: return "SMALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum WordCloudWordScaling: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case emphasize
        case normal
        case sdkUnknown(Swift.String)

        public static var allCases: [WordCloudWordScaling] {
            return [
                .emphasize,
                .normal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .emphasize: return "EMPHASIZE"
            case .normal: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The word cloud options for a word cloud visual.
    public struct WordCloudOptions: Swift.Sendable {
        /// The cloud layout options (fluid, normal) of a word cloud.
        public var cloudLayout: QuickSightClientTypes.WordCloudCloudLayout?
        /// The length limit of each word from 1-100.
        public var maximumStringLength: Swift.Int?
        /// The word casing options (lower_case, existing_case) for the words in a word cloud.
        public var wordCasing: QuickSightClientTypes.WordCloudWordCasing?
        /// The word orientation options (horizontal, horizontal_and_vertical) for the words in a word cloud.
        public var wordOrientation: QuickSightClientTypes.WordCloudWordOrientation?
        /// The word padding options (none, small, medium, large) for the words in a word cloud.
        public var wordPadding: QuickSightClientTypes.WordCloudWordPadding?
        /// The word scaling options (emphasize, normal) for the words in a word cloud.
        public var wordScaling: QuickSightClientTypes.WordCloudWordScaling?

        public init(
            cloudLayout: QuickSightClientTypes.WordCloudCloudLayout? = nil,
            maximumStringLength: Swift.Int? = nil,
            wordCasing: QuickSightClientTypes.WordCloudWordCasing? = nil,
            wordOrientation: QuickSightClientTypes.WordCloudWordOrientation? = nil,
            wordPadding: QuickSightClientTypes.WordCloudWordPadding? = nil,
            wordScaling: QuickSightClientTypes.WordCloudWordScaling? = nil
        )
        {
            self.cloudLayout = cloudLayout
            self.maximumStringLength = maximumStringLength
            self.wordCasing = wordCasing
            self.wordOrientation = wordOrientation
            self.wordPadding = wordPadding
            self.wordScaling = wordScaling
        }
    }
}

extension QuickSightClientTypes {

    /// The configuration of a word cloud visual.
    public struct WordCloudChartConfiguration: Swift.Sendable {
        /// The label options (label text, label visibility, and sort icon visibility) for the word cloud category.
        public var categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions?
        /// The field wells of the visual.
        public var fieldWells: QuickSightClientTypes.WordCloudFieldWells?
        /// The general visual interactions setup for a visual.
        public var interactions: QuickSightClientTypes.VisualInteractionOptions?
        /// The sort configuration of a word cloud visual.
        public var sortConfiguration: QuickSightClientTypes.WordCloudSortConfiguration?
        /// The options for a word cloud visual.
        public var wordCloudOptions: QuickSightClientTypes.WordCloudOptions?

        public init(
            categoryLabelOptions: QuickSightClientTypes.ChartAxisLabelOptions? = nil,
            fieldWells: QuickSightClientTypes.WordCloudFieldWells? = nil,
            interactions: QuickSightClientTypes.VisualInteractionOptions? = nil,
            sortConfiguration: QuickSightClientTypes.WordCloudSortConfiguration? = nil,
            wordCloudOptions: QuickSightClientTypes.WordCloudOptions? = nil
        )
        {
            self.categoryLabelOptions = categoryLabelOptions
            self.fieldWells = fieldWells
            self.interactions = interactions
            self.sortConfiguration = sortConfiguration
            self.wordCloudOptions = wordCloudOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A word cloud. For more information, see [Using word clouds](https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html) in the Amazon QuickSight User Guide.
    public struct WordCloudVisual: Swift.Sendable {
        /// The list of custom actions that are configured for a visual.
        public var actions: [QuickSightClientTypes.VisualCustomAction]?
        /// The configuration settings of the visual.
        public var chartConfiguration: QuickSightClientTypes.WordCloudChartConfiguration?
        /// The column hierarchy that is used during drill-downs and drill-ups.
        public var columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]?
        /// The subtitle that is displayed on the visual.
        public var subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions?
        /// The title that is displayed on the visual.
        public var title: QuickSightClientTypes.VisualTitleLabelOptions?
        /// The unique identifier of a visual. This identifier must be unique within the context of a dashboard, template, or analysis. Two dashboards, analyses, or templates can have visuals with the same identifiers..
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            actions: [QuickSightClientTypes.VisualCustomAction]? = nil,
            chartConfiguration: QuickSightClientTypes.WordCloudChartConfiguration? = nil,
            columnHierarchies: [QuickSightClientTypes.ColumnHierarchy]? = nil,
            subtitle: QuickSightClientTypes.VisualSubtitleLabelOptions? = nil,
            title: QuickSightClientTypes.VisualTitleLabelOptions? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.chartConfiguration = chartConfiguration
            self.columnHierarchies = columnHierarchies
            self.subtitle = subtitle
            self.title = title
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// A visual displayed on a sheet in an analysis, dashboard, or template. This is a union type structure. For this structure to be valid, only one of the attributes can be defined.
    public struct Visual: Swift.Sendable {
        /// A bar chart. For more information, see [Using bar charts](https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html) in the Amazon QuickSight User Guide.
        public var barChartVisual: QuickSightClientTypes.BarChartVisual?
        /// A box plot. For more information, see [Using box plots](https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html) in the Amazon QuickSight User Guide.
        public var boxPlotVisual: QuickSightClientTypes.BoxPlotVisual?
        /// A combo chart. For more information, see [Using combo charts](https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html) in the Amazon QuickSight User Guide.
        public var comboChartVisual: QuickSightClientTypes.ComboChartVisual?
        /// A visual that contains custom content. For more information, see [Using custom visual content](https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html) in the Amazon QuickSight User Guide.
        public var customContentVisual: QuickSightClientTypes.CustomContentVisual?
        /// An empty visual.
        public var emptyVisual: QuickSightClientTypes.EmptyVisual?
        /// A filled map. For more information, see [Creating filled maps](https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html) in the Amazon QuickSight User Guide.
        public var filledMapVisual: QuickSightClientTypes.FilledMapVisual?
        /// A funnel chart. For more information, see [Using funnel charts](https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html) in the Amazon QuickSight User Guide.
        public var funnelChartVisual: QuickSightClientTypes.FunnelChartVisual?
        /// A gauge chart. For more information, see [Using gauge charts](https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html) in the Amazon QuickSight User Guide.
        public var gaugeChartVisual: QuickSightClientTypes.GaugeChartVisual?
        /// A geospatial map or a points on map visual. For more information, see [Creating point maps](https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html) in the Amazon QuickSight User Guide.
        public var geospatialMapVisual: QuickSightClientTypes.GeospatialMapVisual?
        /// A heat map. For more information, see [Using heat maps](https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html) in the Amazon QuickSight User Guide.
        public var heatMapVisual: QuickSightClientTypes.HeatMapVisual?
        /// A histogram. For more information, see [Using histograms](https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html) in the Amazon QuickSight User Guide.
        public var histogramVisual: QuickSightClientTypes.HistogramVisual?
        /// An insight visual. For more information, see [Working with insights](https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html) in the Amazon QuickSight User Guide.
        public var insightVisual: QuickSightClientTypes.InsightVisual?
        /// A key performance indicator (KPI). For more information, see [Using KPIs](https://docs.aws.amazon.com/quicksight/latest/user/kpi.html) in the Amazon QuickSight User Guide.
        public var kpiVisual: QuickSightClientTypes.KPIVisual?
        /// A line chart. For more information, see [Using line charts](https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html) in the Amazon QuickSight User Guide.
        public var lineChartVisual: QuickSightClientTypes.LineChartVisual?
        /// A pie or donut chart. For more information, see [Using pie charts](https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html) in the Amazon QuickSight User Guide.
        public var pieChartVisual: QuickSightClientTypes.PieChartVisual?
        /// A pivot table. For more information, see [Using pivot tables](https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html) in the Amazon QuickSight User Guide.
        public var pivotTableVisual: QuickSightClientTypes.PivotTableVisual?
        /// A radar chart visual. For more information, see [Using radar charts](https://docs.aws.amazon.com/quicksight/latest/user/radar-chart.html) in the Amazon QuickSight User Guide.
        public var radarChartVisual: QuickSightClientTypes.RadarChartVisual?
        /// A sankey diagram. For more information, see [Using Sankey diagrams](https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html) in the Amazon QuickSight User Guide.
        public var sankeyDiagramVisual: QuickSightClientTypes.SankeyDiagramVisual?
        /// A scatter plot. For more information, see [Using scatter plots](https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html) in the Amazon QuickSight User Guide.
        public var scatterPlotVisual: QuickSightClientTypes.ScatterPlotVisual?
        /// A table visual. For more information, see [Using tables as visuals](https://docs.aws.amazon.com/quicksight/latest/user/tabular.html) in the Amazon QuickSight User Guide.
        public var tableVisual: QuickSightClientTypes.TableVisual?
        /// A tree map. For more information, see [Using tree maps](https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html) in the Amazon QuickSight User Guide.
        public var treeMapVisual: QuickSightClientTypes.TreeMapVisual?
        /// A waterfall chart. For more information, see [Using waterfall charts](https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html) in the Amazon QuickSight User Guide.
        public var waterfallVisual: QuickSightClientTypes.WaterfallVisual?
        /// A word cloud. For more information, see [Using word clouds](https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html) in the Amazon QuickSight User Guide.
        public var wordCloudVisual: QuickSightClientTypes.WordCloudVisual?

        public init(
            barChartVisual: QuickSightClientTypes.BarChartVisual? = nil,
            boxPlotVisual: QuickSightClientTypes.BoxPlotVisual? = nil,
            comboChartVisual: QuickSightClientTypes.ComboChartVisual? = nil,
            customContentVisual: QuickSightClientTypes.CustomContentVisual? = nil,
            emptyVisual: QuickSightClientTypes.EmptyVisual? = nil,
            filledMapVisual: QuickSightClientTypes.FilledMapVisual? = nil,
            funnelChartVisual: QuickSightClientTypes.FunnelChartVisual? = nil,
            gaugeChartVisual: QuickSightClientTypes.GaugeChartVisual? = nil,
            geospatialMapVisual: QuickSightClientTypes.GeospatialMapVisual? = nil,
            heatMapVisual: QuickSightClientTypes.HeatMapVisual? = nil,
            histogramVisual: QuickSightClientTypes.HistogramVisual? = nil,
            insightVisual: QuickSightClientTypes.InsightVisual? = nil,
            kpiVisual: QuickSightClientTypes.KPIVisual? = nil,
            lineChartVisual: QuickSightClientTypes.LineChartVisual? = nil,
            pieChartVisual: QuickSightClientTypes.PieChartVisual? = nil,
            pivotTableVisual: QuickSightClientTypes.PivotTableVisual? = nil,
            radarChartVisual: QuickSightClientTypes.RadarChartVisual? = nil,
            sankeyDiagramVisual: QuickSightClientTypes.SankeyDiagramVisual? = nil,
            scatterPlotVisual: QuickSightClientTypes.ScatterPlotVisual? = nil,
            tableVisual: QuickSightClientTypes.TableVisual? = nil,
            treeMapVisual: QuickSightClientTypes.TreeMapVisual? = nil,
            waterfallVisual: QuickSightClientTypes.WaterfallVisual? = nil,
            wordCloudVisual: QuickSightClientTypes.WordCloudVisual? = nil
        )
        {
            self.barChartVisual = barChartVisual
            self.boxPlotVisual = boxPlotVisual
            self.comboChartVisual = comboChartVisual
            self.customContentVisual = customContentVisual
            self.emptyVisual = emptyVisual
            self.filledMapVisual = filledMapVisual
            self.funnelChartVisual = funnelChartVisual
            self.gaugeChartVisual = gaugeChartVisual
            self.geospatialMapVisual = geospatialMapVisual
            self.heatMapVisual = heatMapVisual
            self.histogramVisual = histogramVisual
            self.insightVisual = insightVisual
            self.kpiVisual = kpiVisual
            self.lineChartVisual = lineChartVisual
            self.pieChartVisual = pieChartVisual
            self.pivotTableVisual = pivotTableVisual
            self.radarChartVisual = radarChartVisual
            self.sankeyDiagramVisual = sankeyDiagramVisual
            self.scatterPlotVisual = scatterPlotVisual
            self.tableVisual = tableVisual
            self.treeMapVisual = treeMapVisual
            self.waterfallVisual = waterfallVisual
            self.wordCloudVisual = wordCloudVisual
        }
    }
}

extension QuickSightClientTypes {

    /// A sheet is an object that contains a set of visuals that are viewed together on one page in a paginated report. Every analysis and dashboard must contain at least one sheet.
    public struct SheetDefinition: Swift.Sendable {
        /// The layout content type of the sheet. Choose one of the following options:
        ///
        /// * PAGINATED: Creates a sheet for a paginated report.
        ///
        /// * INTERACTIVE: Creates a sheet for an interactive dashboard.
        public var contentType: QuickSightClientTypes.SheetContentType?
        /// A description of the sheet.
        public var description: Swift.String?
        /// The list of filter controls that are on a sheet. For more information, see [Adding filter controls to analysis sheets](https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html) in the Amazon QuickSight User Guide.
        public var filterControls: [QuickSightClientTypes.FilterControl]?
        /// Layouts define how the components of a sheet are arranged. For more information, see [Types of layout](https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html) in the Amazon QuickSight User Guide.
        public var layouts: [QuickSightClientTypes.Layout]?
        /// The name of the sheet. This name is displayed on the sheet's tab in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The list of parameter controls that are on a sheet. For more information, see [Using a Control with a Parameter in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html) in the Amazon QuickSight User Guide.
        public var parameterControls: [QuickSightClientTypes.ParameterControl]?
        /// The control layouts of the sheet.
        public var sheetControlLayouts: [QuickSightClientTypes.SheetControlLayout]?
        /// The unique identifier of a sheet.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The text boxes that are on a sheet.
        public var textBoxes: [QuickSightClientTypes.SheetTextBox]?
        /// The title of the sheet.
        public var title: Swift.String?
        /// A list of the visuals that are on a sheet. Visual placement is determined by the layout of the sheet.
        public var visuals: [QuickSightClientTypes.Visual]?

        public init(
            contentType: QuickSightClientTypes.SheetContentType? = nil,
            description: Swift.String? = nil,
            filterControls: [QuickSightClientTypes.FilterControl]? = nil,
            layouts: [QuickSightClientTypes.Layout]? = nil,
            name: Swift.String? = nil,
            parameterControls: [QuickSightClientTypes.ParameterControl]? = nil,
            sheetControlLayouts: [QuickSightClientTypes.SheetControlLayout]? = nil,
            sheetId: Swift.String? = nil,
            textBoxes: [QuickSightClientTypes.SheetTextBox]? = nil,
            title: Swift.String? = nil,
            visuals: [QuickSightClientTypes.Visual]? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.filterControls = filterControls
            self.layouts = layouts
            self.name = name
            self.parameterControls = parameterControls
            self.sheetControlLayouts = sheetControlLayouts
            self.sheetId = sheetId
            self.textBoxes = textBoxes
            self.title = title
            self.visuals = visuals
        }
    }
}

extension QuickSightClientTypes {

    /// The definition of an analysis.
    public struct AnalysisDefinition: Swift.Sendable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the analysis.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of analysis-level column configurations. Column configurations can be used to set default formatting for a column to be used throughout an analysis.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset identifier declarations. This mapping allows the usage of dataset identifiers instead of dataset ARNs throughout analysis sub-structures.
        /// This member is required.
        public var dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]?
        /// Filter definitions for an analysis. For more information, see [Filtering Data in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// An array of option definitions for an analysis.
        public var options: QuickSightClientTypes.AssetOptions?
        /// An array of parameter declarations for an analysis. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// A structure that describes the query execution options.
        public var queryExecutionOptions: QuickSightClientTypes.QueryExecutionOptions?
        /// An array of sheet definitions for an analysis. Each SheetDefinition provides detailed information about a sheet within this analysis.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init(
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            options: QuickSightClientTypes.AssetOptions? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            queryExecutionOptions: QuickSightClientTypes.QueryExecutionOptions? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.queryExecutionOptions = queryExecutionOptions
            self.sheets = sheets
        }
    }
}

extension QuickSightClientTypes {

    public enum AnalysisFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysisName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightUser
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisFilterAttribute] {
            return [
                .analysisName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightUser,
                .quicksightViewerOrOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysisName: return "ANALYSIS_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightUser: return "QUICKSIGHT_USER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum FilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stringequals
        case stringlike
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterOperator] {
            return [
                .stringequals,
                .stringlike
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stringequals: return "StringEquals"
            case .stringlike: return "StringLike"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A filter that you apply when searching for one or more analyses.
    public struct AnalysisSearchFilter: Swift.Sendable {
        /// The name of the value that you want to use as a filter, for example "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the analysis' owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as the only owner of the analysis are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners of the analyses are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any analyses with that ARN listed as one of the owners or viewers of the analyses are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * ANALYSIS_NAME: Any analyses whose names have a substring match to this value will be returned.
        public var name: QuickSightClientTypes.AnalysisFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value ANALYSIS_NAME.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example "Value". An example is "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.AnalysisFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// Dataset reference.
    public struct DataSetReference: Swift.Sendable {
        /// Dataset Amazon Resource Name (ARN).
        /// This member is required.
        public var dataSetArn: Swift.String?
        /// Dataset placeholder.
        /// This member is required.
        public var dataSetPlaceholder: Swift.String?

        public init(
            dataSetArn: Swift.String? = nil,
            dataSetPlaceholder: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.dataSetPlaceholder = dataSetPlaceholder
        }
    }
}

extension QuickSightClientTypes {

    /// The source template of an analysis.
    public struct AnalysisSourceTemplate: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the source template of an analysis.
        /// This member is required.
        public var arn: Swift.String?
        /// The dataset references of the source template of an analysis.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init(
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }
}

extension QuickSightClientTypes {

    /// The source entity of an analysis.
    public struct AnalysisSourceEntity: Swift.Sendable {
        /// The source template for the source entity of the analysis.
        public var sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate?

        public init(
            sourceTemplate: QuickSightClientTypes.AnalysisSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }
}

extension QuickSightClientTypes {

    /// The summary metadata that describes an analysis.
    public struct AnalysisSummary: Swift.Sendable {
        /// The ID of the analysis. This ID displays in the URL.
        public var analysisId: Swift.String?
        /// The Amazon Resource Name (ARN) for the analysis.
        public var arn: Swift.String?
        /// The time that the analysis was created.
        public var createdTime: Foundation.Date?
        /// The time that the analysis was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the analysis. This name is displayed in the Amazon QuickSight console.
        public var name: Swift.String?
        /// The last known status for the analysis.
        public var status: QuickSightClientTypes.ResourceStatus?

        public init(
            analysisId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil
        )
        {
            self.analysisId = analysisId
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.status = status
        }
    }
}

extension QuickSightClientTypes {

    public enum AnchorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case today
        case sdkUnknown(Swift.String)

        public static var allCases: [AnchorType] {
            return [
                .today
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .today: return "TODAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition of the Anchor.
    public struct Anchor: Swift.Sendable {
        /// The AnchorType for the Anchor.
        public var anchorType: QuickSightClientTypes.AnchorType?
        /// The offset of the Anchor.
        public var offset: Swift.Int
        /// The TimeGranularity of the Anchor.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?

        public init(
            anchorType: QuickSightClientTypes.AnchorType? = nil,
            offset: Swift.Int = 0,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil
        )
        {
            self.anchorType = anchorType
            self.offset = offset
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    public enum AnonymousUserDashboardEmbeddingConfigurationDisabledFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sharedView
        case sdkUnknown(Swift.String)

        public static var allCases: [AnonymousUserDashboardEmbeddingConfigurationDisabledFeature] {
            return [
                .sharedView
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sharedView: return "SHARED_VIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum AnonymousUserDashboardEmbeddingConfigurationEnabledFeature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sharedView
        case sdkUnknown(Swift.String)

        public static var allCases: [AnonymousUserDashboardEmbeddingConfigurationEnabledFeature] {
            return [
                .sharedView
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sharedView: return "SHARED_VIEW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The shared view settings of an embedded dashboard.
    public struct SharedViewConfigurations: Swift.Sendable {
        /// The shared view settings of an embedded dashboard.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }
}

extension QuickSightClientTypes {

    /// The feature configuration for an embedded dashboard.
    public struct AnonymousUserDashboardFeatureConfigurations: Swift.Sendable {
        /// The shared view settings of an embedded dashboard.
        public var sharedView: QuickSightClientTypes.SharedViewConfigurations?

        public init(
            sharedView: QuickSightClientTypes.SharedViewConfigurations? = nil
        )
        {
            self.sharedView = sharedView
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the dashboard that you want to embed.
    public struct AnonymousUserDashboardEmbeddingConfiguration: Swift.Sendable {
        /// A list of all disabled features of a specified anonymous dashboard.
        public var disabledFeatures: [QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationDisabledFeature]?
        /// A list of all enabled features of a specified anonymous dashboard.
        public var enabledFeatures: [QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationEnabledFeature]?
        /// The feature configuration for an embedded dashboard.
        public var featureConfigurations: QuickSightClientTypes.AnonymousUserDashboardFeatureConfigurations?
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard. The Amazon Resource Name (ARN) of this dashboard must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init(
            disabledFeatures: [QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationDisabledFeature]? = nil,
            enabledFeatures: [QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationEnabledFeature]? = nil,
            featureConfigurations: QuickSightClientTypes.AnonymousUserDashboardFeatureConfigurations? = nil,
            initialDashboardId: Swift.String? = nil
        )
        {
            self.disabledFeatures = disabledFeatures
            self.enabledFeatures = enabledFeatures
            self.featureConfigurations = featureConfigurations
            self.initialDashboardId = initialDashboardId
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the following elements:
    ///
    /// * The DashboardId of the dashboard that has the visual that you want to embed.
    ///
    /// * The SheetId of the sheet that has the visual that you want to embed.
    ///
    /// * The VisualId of the visual that you want to embed.
    ///
    ///
    /// The DashboardId, SheetId, and VisualId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
    public struct DashboardVisualId: Swift.Sendable {
        /// The ID of the dashboard that has the visual that you want to embed. The DashboardId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console. You can also get the DashboardId with a ListDashboards API operation.
        /// This member is required.
        public var dashboardId: Swift.String?
        /// The ID of the sheet that the has visual that you want to embed. The SheetId can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        /// This member is required.
        public var sheetId: Swift.String?
        /// The ID of the visual that you want to embed. The VisualID can be found in the IDs for developers section of the Embed visual pane of the visual's on-visual menu of the Amazon QuickSight console.
        /// This member is required.
        public var visualId: Swift.String?

        public init(
            dashboardId: Swift.String? = nil,
            sheetId: Swift.String? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.dashboardId = dashboardId
            self.sheetId = sheetId
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.
    public struct AnonymousUserDashboardVisualEmbeddingConfiguration: Swift.Sendable {
        /// The visual ID for the visual that you want the user to see. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId?

        public init(
            initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId? = nil
        )
        {
            self.initialDashboardVisualId = initialDashboardVisualId
        }
    }
}

extension QuickSightClientTypes {

    /// The settings that you want to use for the Generative Q&A experience.
    public struct AnonymousUserGenerativeQnAEmbeddingConfiguration: Swift.Sendable {
        /// The Amazon QuickSight Q topic ID of the new reader experience topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Generative Q&A experience with this new reader experience topic pre selected. The Amazon Resource Name (ARN) of this Q new reader experience topic must be included in the AuthorizedResourceArns parameter. Otherwise, the request fails with an InvalidParameterValueException error.
        /// This member is required.
        public var initialTopicId: Swift.String?

        public init(
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }
}

extension QuickSightClientTypes {

    /// The settings that you want to use with the Q search bar.
    public struct AnonymousUserQSearchBarEmbeddingConfiguration: Swift.Sendable {
        /// The Amazon QuickSight Q topic ID of the legacy topic that you want the anonymous user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders the Q search bar with this legacy topic pre-selected. The Amazon Resource Name (ARN) of this Q legacy topic must be included in the AuthorizedResourceArns parameter. Otherwise, the request fails with an InvalidParameterValueException error.
        /// This member is required.
        public var initialTopicId: Swift.String?

        public init(
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }
}

extension QuickSightClientTypes {

    /// The type of experience you want to embed. For anonymous users, you can embed Amazon QuickSight dashboards.
    public struct AnonymousUserEmbeddingExperienceConfiguration: Swift.Sendable {
        /// The type of embedding experience. In this case, Amazon QuickSight dashboards.
        public var dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public var dashboardVisual: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration?
        /// The Generative Q&A experience that you want to use for anonymous user embedding.
        public var generativeQnA: QuickSightClientTypes.AnonymousUserGenerativeQnAEmbeddingConfiguration?
        /// The Q search bar that you want to use for anonymous user embedding.
        public var qSearchBar: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration?

        public init(
            dashboard: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration? = nil,
            dashboardVisual: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration? = nil,
            generativeQnA: QuickSightClientTypes.AnonymousUserGenerativeQnAEmbeddingConfiguration? = nil,
            qSearchBar: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.generativeQnA = generativeQnA
            self.qSearchBar = qSearchBar
        }
    }
}

extension QuickSightClientTypes {

    public enum SnapshotFileFormatType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case excel
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotFileFormatType] {
            return [
                .csv,
                .excel,
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .excel: return "EXCEL"
            case .pdf: return "PDF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum SnapshotFileSheetSelectionScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allVisuals
        case selectedVisuals
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotFileSheetSelectionScope] {
            return [
                .allVisuals,
                .selectedVisuals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allVisuals: return "ALL_VISUALS"
            case .selectedVisuals: return "SELECTED_VISUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains information that identifies the snapshot that needs to be generated.
    public struct SnapshotFileSheetSelection: Swift.Sendable {
        /// The selection scope of the visuals on a sheet of a dashboard that you are generating a snapthot of. You can choose one of the following options.
        ///
        /// * ALL_VISUALS - Selects all visuals that are on the sheet. This value is required if the snapshot is a PDF.
        ///
        /// * SELECTED_VISUALS - Select the visual that you want to add to the snapshot. This value is required if the snapshot is a CSV or Excel workbook.
        /// This member is required.
        public var selectionScope: QuickSightClientTypes.SnapshotFileSheetSelectionScope?
        /// The sheet ID of the dashboard to generate the snapshot artifact from. This value is required for CSV, Excel, and PDF format types.
        /// This member is required.
        public var sheetId: Swift.String?
        /// A structure that lists the IDs of the visuals in the selected sheet. Supported visual types are table, pivot table visuals. This value is required if you are generating a CSV or Excel workbook. This value supports a maximum of 1 visual ID for CSV and 5 visual IDs across up to 5 sheet selections for Excel. If you are generating an Excel workbook, the order of the visual IDs provided in this structure determines the order of the worksheets in the Excel file.
        public var visualIds: [Swift.String]?

        public init(
            selectionScope: QuickSightClientTypes.SnapshotFileSheetSelectionScope? = nil,
            sheetId: Swift.String? = nil,
            visualIds: [Swift.String]? = nil
        )
        {
            self.selectionScope = selectionScope
            self.sheetId = sheetId
            self.visualIds = visualIds
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the information for the snapshot that you want to generate. This information is provided by you when you start a new snapshot job.
    public struct SnapshotFile: Swift.Sendable {
        /// The format of the snapshot file to be generated. You can choose between CSV, Excel, or PDF.
        /// This member is required.
        public var formatType: QuickSightClientTypes.SnapshotFileFormatType?
        /// A list of SnapshotFileSheetSelection objects that contain information on the dashboard sheet that is exported. These objects provide information about the snapshot artifacts that are generated during the job. This structure can hold a maximum of 5 CSV configurations, 5 Excel configurations, or 1 configuration for PDF.
        /// This member is required.
        public var sheetSelections: [QuickSightClientTypes.SnapshotFileSheetSelection]?

        public init(
            formatType: QuickSightClientTypes.SnapshotFileFormatType? = nil,
            sheetSelections: [QuickSightClientTypes.SnapshotFileSheetSelection]? = nil
        )
        {
            self.formatType = formatType
            self.sheetSelections = sheetSelections
        }
    }
}

extension QuickSightClientTypes {

    /// Information on the error that caused the snapshot job to fail.
    public struct SnapshotJobResultErrorInfo: Swift.Sendable {
        /// The error message.
        public var errorMessage: Swift.String?
        /// The error type.
        public var errorType: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }
}

extension QuickSightClientTypes {

    /// An optional structure that contains the Amazon S3 bucket configuration that the generated snapshots are stored in. If you don't provide this information, generated snapshots are stored in the default Amazon QuickSight bucket.
    public struct S3BucketConfiguration: Swift.Sendable {
        /// The name of an existing Amazon S3 bucket where the generated snapshot artifacts are sent.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The prefix of the Amazon S3 bucket that the generated snapshots are stored in.
        /// This member is required.
        public var bucketPrefix: Swift.String?
        /// The region that the Amazon S3 bucket is located in. The bucket must be located in the same region that the StartDashboardSnapshotJob API call is made.
        /// This member is required.
        public var bucketRegion: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            bucketRegion: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.bucketRegion = bucketRegion
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that describes the Amazon S3 settings to use to save the generated dashboard snapshot.
    public struct SnapshotS3DestinationConfiguration: Swift.Sendable {
        /// A structure that contains details about the Amazon S3 bucket that the generated dashboard snapshot is saved in.
        /// This member is required.
        public var bucketConfiguration: QuickSightClientTypes.S3BucketConfiguration?

        public init(
            bucketConfiguration: QuickSightClientTypes.S3BucketConfiguration? = nil
        )
        {
            self.bucketConfiguration = bucketConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// The Amazon S3 result from the snapshot job. The result includes the DestinationConfiguration and the Amazon S3 Uri. If an error occured during the job, the result returns information on the error.
    public struct SnapshotJobS3Result: Swift.Sendable {
        /// An array of error records that describe any failures that occur while the dashboard snapshot job runs.
        public var errorInfo: [QuickSightClientTypes.SnapshotJobResultErrorInfo]?
        /// A list of Amazon S3 bucket configurations that are provided when you make a StartDashboardSnapshotJob API call.
        public var s3DestinationConfiguration: QuickSightClientTypes.SnapshotS3DestinationConfiguration?
        /// The Amazon S3 Uri.
        public var s3Uri: Swift.String?

        public init(
            errorInfo: [QuickSightClientTypes.SnapshotJobResultErrorInfo]? = nil,
            s3DestinationConfiguration: QuickSightClientTypes.SnapshotS3DestinationConfiguration? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.errorInfo = errorInfo
            self.s3DestinationConfiguration = s3DestinationConfiguration
            self.s3Uri = s3Uri
        }
    }
}

extension QuickSightClientTypes.SnapshotJobS3Result: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnapshotJobS3Result(errorInfo: \(Swift.String(describing: errorInfo)), s3DestinationConfiguration: \(Swift.String(describing: s3DestinationConfiguration)), s3Uri: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A structure that contains information on the generated snapshot file groups.
    public struct SnapshotJobResultFileGroup: Swift.Sendable {
        /// A list of SnapshotFile objects.
        public var files: [QuickSightClientTypes.SnapshotFile]?
        /// A list of SnapshotJobS3Result objects.
        public var s3Results: [QuickSightClientTypes.SnapshotJobS3Result]?

        public init(
            files: [QuickSightClientTypes.SnapshotFile]? = nil,
            s3Results: [QuickSightClientTypes.SnapshotJobS3Result]? = nil
        )
        {
            self.files = files
            self.s3Results = s3Results
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the file groups that are requested for the artifact generation in a StartDashboardSnapshotJob API call.
    public struct AnonymousUserSnapshotJobResult: Swift.Sendable {
        /// A list of SnapshotJobResultFileGroup objects that contain information on the files that are requested during a StartDashboardSnapshotJob API call. If the job succeeds, these objects contain the location where the snapshot artifacts are stored. If the job fails, the objects contain information about the error that caused the job to fail.
        public var fileGroups: [QuickSightClientTypes.SnapshotJobResultFileGroup]?

        public init(
            fileGroups: [QuickSightClientTypes.SnapshotJobResultFileGroup]? = nil
        )
        {
            self.fileGroups = fileGroups
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobAnalysisPropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobAnalysisPropertyToOverride] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "Name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific Analysis resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobAnalysisOverrideProperties: Swift.Sendable {
        /// The ARN of the specific Analysis resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of Analysis resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobAnalysisPropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobAnalysisPropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobDashboardPropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobDashboardPropertyToOverride] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "Name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific Dashboard resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobDashboardOverrideProperties: Swift.Sendable {
        /// The ARN of the specific Dashboard resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of Dashboard resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobDashboardPropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobDashboardPropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobDataSetPropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobDataSetPropertyToOverride] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "Name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific DataSet resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobDataSetOverrideProperties: Swift.Sendable {
        /// The ARN of the specific DataSet resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of DataSet resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobDataSetPropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobDataSetPropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobDataSourcePropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case catalog
        case clusterId
        case database
        case dataSetName
        case disableSsl
        case domain
        case host
        case instanceId
        case manifestFileLocation
        case name
        case password
        case port
        case productType
        case roleArn
        case secretArn
        case username
        case warehouse
        case workGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobDataSourcePropertyToOverride] {
            return [
                .catalog,
                .clusterId,
                .database,
                .dataSetName,
                .disableSsl,
                .domain,
                .host,
                .instanceId,
                .manifestFileLocation,
                .name,
                .password,
                .port,
                .productType,
                .roleArn,
                .secretArn,
                .username,
                .warehouse,
                .workGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .catalog: return "Catalog"
            case .clusterId: return "ClusterId"
            case .database: return "Database"
            case .dataSetName: return "DataSetName"
            case .disableSsl: return "DisableSsl"
            case .domain: return "Domain"
            case .host: return "Host"
            case .instanceId: return "InstanceId"
            case .manifestFileLocation: return "ManifestFileLocation"
            case .name: return "Name"
            case .password: return "Password"
            case .port: return "Port"
            case .productType: return "ProductType"
            case .roleArn: return "RoleArn"
            case .secretArn: return "SecretArn"
            case .username: return "Username"
            case .warehouse: return "Warehouse"
            case .workGroup: return "WorkGroup"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific DataSource resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobDataSourceOverrideProperties: Swift.Sendable {
        /// The ARN of the specific DataSource resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of DataSource resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobDataSourcePropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobDataSourcePropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobFolderPropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case parentFolderArn
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobFolderPropertyToOverride] {
            return [
                .name,
                .parentFolderArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "Name"
            case .parentFolderArn: return "ParentFolderArn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific Folder resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobFolderOverrideProperties: Swift.Sendable {
        /// The ARN of the specific Folder resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of Folder resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobFolderPropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobFolderPropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobRefreshSchedulePropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startAfterDateTime
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobRefreshSchedulePropertyToOverride] {
            return [
                .startAfterDateTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startAfterDateTime: return "StartAfterDateTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific RefreshSchedule resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobRefreshScheduleOverrideProperties: Swift.Sendable {
        /// The ARN of the specific RefreshSchedule resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of RefreshSchedule resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobRefreshSchedulePropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobRefreshSchedulePropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    /// An optional structure that configures resource ID overrides for the export job.
    public struct AssetBundleExportJobResourceIdOverrideConfiguration: Swift.Sendable {
        /// An option to request a CloudFormation variable for a prefix to be prepended to each resource's ID before import. The prefix is only added to the asset IDs and does not change the name of the asset.
        public var prefixForAllResources: Swift.Bool

        public init(
            prefixForAllResources: Swift.Bool = false
        )
        {
            self.prefixForAllResources = prefixForAllResources
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobThemePropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobThemePropertyToOverride] {
            return [
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "Name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific Theme resource is parameterized in the returned CloudFormation template.
    public struct AssetBundleExportJobThemeOverrideProperties: Swift.Sendable {
        /// The ARN of the specific Theme resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of Theme resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobThemePropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobThemePropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobVPCConnectionPropertyToOverride: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dnsResolvers
        case name
        case roleArn
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobVPCConnectionPropertyToOverride] {
            return [
                .dnsResolvers,
                .name,
                .roleArn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dnsResolvers: return "DnsResolvers"
            case .name: return "Name"
            case .roleArn: return "RoleArn"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Controls how a specific VPCConnection resource is parameterized in the outputted CloudFormation template.
    public struct AssetBundleExportJobVPCConnectionOverrideProperties: Swift.Sendable {
        /// The ARN of the specific VPCConnection resource whose override properties are configured in this structure.
        /// This member is required.
        public var arn: Swift.String?
        /// A list of VPCConnection resource properties to generate variables for in the returned CloudFormation template.
        /// This member is required.
        public var properties: [QuickSightClientTypes.AssetBundleExportJobVPCConnectionPropertyToOverride]?

        public init(
            arn: Swift.String? = nil,
            properties: [QuickSightClientTypes.AssetBundleExportJobVPCConnectionPropertyToOverride]? = nil
        )
        {
            self.arn = arn
            self.properties = properties
        }
    }
}

extension QuickSightClientTypes {

    /// An optional collection of CloudFormation property configurations that control how the export job is generated.
    public struct AssetBundleCloudFormationOverridePropertyConfiguration: Swift.Sendable {
        /// An optional list of structures that control how Analysis resources are parameterized in the returned CloudFormation template.
        public var analyses: [QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties]?
        /// An optional list of structures that control how Dashboard resources are parameterized in the returned CloudFormation template.
        public var dashboards: [QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties]?
        /// An optional list of structures that control how DataSet resources are parameterized in the returned CloudFormation template.
        public var dataSets: [QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties]?
        /// An optional list of structures that control how DataSource resources are parameterized in the returned CloudFormation template.
        public var dataSources: [QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties]?
        /// An optional list of structures that controls how Folder resources are parameterized in the returned CloudFormation template.
        public var folders: [QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties]?
        /// An optional list of structures that control how RefreshSchedule resources are parameterized in the returned CloudFormation template.
        public var refreshSchedules: [QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties]?
        /// An optional list of structures that control how resource IDs are parameterized in the returned CloudFormation template.
        public var resourceIdOverrideConfiguration: QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration?
        /// An optional list of structures that control how Theme resources are parameterized in the returned CloudFormation template.
        public var themes: [QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties]?
        /// An optional list of structures that control how VPCConnection resources are parameterized in the returned CloudFormation template.
        public var vpcConnections: [QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties]?

        public init(
            analyses: [QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties]? = nil,
            dashboards: [QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties]? = nil,
            dataSets: [QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties]? = nil,
            dataSources: [QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties]? = nil,
            folders: [QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties]? = nil,
            refreshSchedules: [QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties]? = nil,
            resourceIdOverrideConfiguration: QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration? = nil,
            themes: [QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties]? = nil,
            vpcConnections: [QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties]? = nil
        )
        {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.folders = folders
            self.refreshSchedules = refreshSchedules
            self.resourceIdOverrideConfiguration = resourceIdOverrideConfiguration
            self.themes = themes
            self.vpcConnections = vpcConnections
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudformationJson
        case quicksightJson
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportFormat] {
            return [
                .cloudformationJson,
                .quicksightJson
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudformationJson: return "CLOUDFORMATION_JSON"
            case .quicksightJson: return "QUICKSIGHT_JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Describes an error that occurred during an Asset Bundle export job.
    public struct AssetBundleExportJobError: Swift.Sendable {
        /// The ARN of the resource whose processing caused an error.
        public var arn: Swift.String?
        /// A description of the error.
        public var message: Swift.String?
        /// The specific error type of the error that occurred.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleExportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case queuedForImmediateExecution
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleExportJobStatus] {
            return [
                .failed,
                .inProgress,
                .queuedForImmediateExecution,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queuedForImmediateExecution: return "QUEUED_FOR_IMMEDIATE_EXECUTION"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A summary of the export job that includes details of the job's configuration and its current status.
    public struct AssetBundleExportJobSummary: Swift.Sendable {
        /// The ARN of the export job.
        public var arn: Swift.String?
        /// The ID of the export job.
        public var assetBundleExportJobId: Swift.String?
        /// The time that the export job was created.
        public var createdTime: Foundation.Date?
        /// The format for the export job.
        public var exportFormat: QuickSightClientTypes.AssetBundleExportFormat?
        /// The flag that determines the inclusion of resource dependencies in the returned asset bundle.
        public var includeAllDependencies: Swift.Bool
        /// The flag that determines the inclusion of permissions associated with each resource ARN.
        public var includePermissions: Swift.Bool
        /// The flag that determines the inclusion of tags associated with each resource ARN.
        public var includeTags: Swift.Bool
        /// The current status of the export job.
        public var jobStatus: QuickSightClientTypes.AssetBundleExportJobStatus?

        public init(
            arn: Swift.String? = nil,
            assetBundleExportJobId: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            exportFormat: QuickSightClientTypes.AssetBundleExportFormat? = nil,
            includeAllDependencies: Swift.Bool = false,
            includePermissions: Swift.Bool = false,
            includeTags: Swift.Bool = false,
            jobStatus: QuickSightClientTypes.AssetBundleExportJobStatus? = nil
        )
        {
            self.arn = arn
            self.assetBundleExportJobId = assetBundleExportJobId
            self.createdTime = createdTime
            self.exportFormat = exportFormat
            self.includeAllDependencies = includeAllDependencies
            self.includePermissions = includePermissions
            self.includeTags = includeTags
            self.jobStatus = jobStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The option to relax the validation that is required to export each asset. When StrictModeForAllResource is set to false, validation is skipped for specific UI errors.
    public struct AssetBundleExportJobValidationStrategy: Swift.Sendable {
        /// A Boolean value that indicates whether to export resources under strict or lenient mode.
        public var strictModeForAllResources: Swift.Bool

        public init(
            strictModeForAllResources: Swift.Bool = false
        )
        {
            self.strictModeForAllResources = strictModeForAllResources
        }
    }
}

extension QuickSightClientTypes {

    /// Describes a warning that occurred during an Asset Bundle export job.
    public struct AssetBundleExportJobWarning: Swift.Sendable {
        /// The ARN of the resource whose processing caused a warning.
        public var arn: Swift.String?
        /// A description of the warning.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleImportFailureAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doNothing
        case rollback
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleImportFailureAction] {
            return [
                .doNothing,
                .rollback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doNothing: return "DO_NOTHING"
            case .rollback: return "ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single analysis that is being imported.
    public struct AssetBundleImportJobAnalysisOverrideParameters: Swift.Sendable {
        /// The ID of the analysis that you ant to apply overrides to.
        /// This member is required.
        public var analysisId: Swift.String?
        /// A new name for the analysis.
        public var name: Swift.String?

        public init(
            analysisId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.analysisId = analysisId
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the permissions for the resource that you want to override in an asset bundle import job.
    public struct AssetBundleResourcePermissions: Swift.Sendable {
        /// A list of IAM actions to grant permissions on.
        /// This member is required.
        public var actions: [Swift.String]?
        /// A list of principals to grant permissions on.
        /// This member is required.
        public var principals: [Swift.String]?

        public init(
            actions: [Swift.String]? = nil,
            principals: [Swift.String]? = nil
        )
        {
            self.actions = actions
            self.principals = principals
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of analysis IDs.
    public struct AssetBundleImportJobAnalysisOverridePermissions: Swift.Sendable {
        /// A list of analysis IDs that you want to apply overrides to. You can use * to override all analyses in this asset bundle.
        /// This member is required.
        public var analysisIds: [Swift.String]?
        /// A list of permissions for the analyses that you want to apply overrides to.
        /// This member is required.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            analysisIds: [Swift.String]? = nil,
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.analysisIds = analysisIds
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// The key or keys of the key-value pairs for the resource tag or tags assigned to the resource.
    public struct Tag: Swift.Sendable {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of analysis IDs.
    public struct AssetBundleImportJobAnalysisOverrideTags: Swift.Sendable {
        /// A list of analysis IDs that you want to apply overrides to. You can use * to override all analyses in this asset bundle.
        /// This member is required.
        public var analysisIds: [Swift.String]?
        /// A list of tags for the analyses that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?

        public init(
            analysisIds: [Swift.String]? = nil,
            tags: [QuickSightClientTypes.Tag]? = nil
        )
        {
            self.analysisIds = analysisIds
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single dashboard that is being imported.
    public struct AssetBundleImportJobDashboardOverrideParameters: Swift.Sendable {
        /// The ID of the dashboard that you want to apply overrides to.
        /// This member is required.
        public var dashboardId: Swift.String?
        /// A new name for the dashboard.
        public var name: Swift.String?

        public init(
            dashboardId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dashboardId = dashboardId
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the configuration of a shared link to an Amazon QuickSight dashboard.
    public struct AssetBundleResourceLinkSharingConfiguration: Swift.Sendable {
        /// A list of link sharing permissions for the dashboards that you want to apply overrides to.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of dashboard IDs.
    public struct AssetBundleImportJobDashboardOverridePermissions: Swift.Sendable {
        /// A list of dashboard IDs that you want to apply overrides to. You can use * to override all dashboards in this asset bundle.
        /// This member is required.
        public var dashboardIds: [Swift.String]?
        /// A structure that contains the link sharing configurations that you want to apply overrides to.
        public var linkSharingConfiguration: QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration?
        /// A list of permissions for the dashboards that you want to apply overrides to.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            dashboardIds: [Swift.String]? = nil,
            linkSharingConfiguration: QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration? = nil,
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.dashboardIds = dashboardIds
            self.linkSharingConfiguration = linkSharingConfiguration
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of dashboard IDs.
    public struct AssetBundleImportJobDashboardOverrideTags: Swift.Sendable {
        /// A list of dashboard IDs that you want to apply overrides to. You can use * to override all dashboards in this asset bundle.
        /// This member is required.
        public var dashboardIds: [Swift.String]?
        /// A list of tags for the dashboards that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?

        public init(
            dashboardIds: [Swift.String]? = nil,
            tags: [QuickSightClientTypes.Tag]? = nil
        )
        {
            self.dashboardIds = dashboardIds
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single dataset that is being imported.
    public struct AssetBundleImportJobDataSetOverrideParameters: Swift.Sendable {
        /// The ID of the dataset to apply overrides to.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// A new name for the dataset.
        public var name: Swift.String?

        public init(
            dataSetId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataSetId = dataSetId
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of dataset IDs.
    public struct AssetBundleImportJobDataSetOverridePermissions: Swift.Sendable {
        /// A list of dataset IDs that you want to apply overrides to. You can use * to override all datasets in this asset bundle.
        /// This member is required.
        public var dataSetIds: [Swift.String]?
        /// A list of permissions for the datasets that you want to apply overrides to.
        /// This member is required.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            dataSetIds: [Swift.String]? = nil,
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.dataSetIds = dataSetIds
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of dataset IDs.
    public struct AssetBundleImportJobDataSetOverrideTags: Swift.Sendable {
        /// A list of dataset IDs that you want to apply overrides to. You can use * to override all datasets in this asset bundle.
        /// This member is required.
        public var dataSetIds: [Swift.String]?
        /// A list of tags for the datasets that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?

        public init(
            dataSetIds: [Swift.String]? = nil,
            tags: [QuickSightClientTypes.Tag]? = nil
        )
        {
            self.dataSetIds = dataSetIds
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// A username and password credential pair to use to import a data source resource.
    public struct AssetBundleImportJobDataSourceCredentialPair: Swift.Sendable {
        /// The password for the data source connection.
        /// This member is required.
        public var password: Swift.String?
        /// The username for the data source connection.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {

    /// The login credentials to use to import a data source resource.
    public struct AssetBundleImportJobDataSourceCredentials: Swift.Sendable {
        /// A username and password credential pair to be used to create the imported data source. Keep this field blank if you are using a Secrets Manager secret to provide credentials.
        public var credentialPair: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair?
        /// The ARN of the Secrets Manager secret that's used to create the imported data source. Keep this field blank, unless you are using a secret in place of a credential pair.
        public var secretArn: Swift.String?

        public init(
            credentialPair: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetBundleImportJobDataSourceCredentials(secretArn: \(Swift.String(describing: secretArn)), credentialPair: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// Parameters for Amazon Athena.
    public struct AthenaParameters: Swift.Sendable {
        /// Use the RoleArn structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.
        public var roleArn: Swift.String?
        /// The workgroup that Amazon Athena uses.
        public var workGroup: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            workGroup: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.workGroup = workGroup
        }
    }
}

extension QuickSightClientTypes {

    /// Parameters for Amazon Aurora.
    public struct AuroraParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// Parameters for Amazon Aurora PostgreSQL-Compatible Edition.
    public struct AuroraPostgreSqlParameters: Swift.Sendable {
        /// The Amazon Aurora PostgreSQL database to connect to.
        /// This member is required.
        public var database: Swift.String?
        /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
        /// This member is required.
        public var host: Swift.String?
        /// The port that Amazon Aurora PostgreSQL is listening on.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for IoT Analytics.
    public struct AwsIotAnalyticsParameters: Swift.Sendable {
        /// Dataset name.
        /// This member is required.
        public var dataSetName: Swift.String?

        public init(
            dataSetName: Swift.String? = nil
        )
        {
            self.dataSetName = dataSetName
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters that are required to connect to a Google BigQuery data source.
    public struct BigQueryParameters: Swift.Sendable {
        /// The storage location where you create a Google BigQuery data source.
        public var dataSetRegion: Swift.String?
        /// The Google Cloud Platform project ID where your datasource was created.
        /// This member is required.
        public var projectId: Swift.String?

        public init(
            dataSetRegion: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.dataSetRegion = dataSetRegion
            self.projectId = projectId
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters that are required to connect to a Databricks data source.
    public struct DatabricksParameters: Swift.Sendable {
        /// The host name of the Databricks data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Databricks data source.
        /// This member is required.
        public var port: Swift.Int?
        /// The HTTP path of the Databricks data source.
        /// This member is required.
        public var sqlEndpointPath: Swift.String?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            sqlEndpointPath: Swift.String? = nil
        )
        {
            self.host = host
            self.port = port
            self.sqlEndpointPath = sqlEndpointPath
        }
    }
}

extension QuickSightClientTypes {

    /// The required parameters for connecting to an Exasol data source.
    public struct ExasolParameters: Swift.Sendable {
        /// The hostname or IP address of the Exasol data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Exasol data source.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Jira.
    public struct JiraParameters: Swift.Sendable {
        /// The base URL of the Jira site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init(
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for MariaDB.
    public struct MariaDbParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for MySQL.
    public struct MySqlParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Oracle.
    public struct OracleParameters: Swift.Sendable {
        /// The database.
        /// This member is required.
        public var database: Swift.String?
        /// An Oracle host.
        /// This member is required.
        public var host: Swift.String?
        /// The port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for PostgreSQL.
    public struct PostgreSqlParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Presto.
    public struct PrestoParameters: Swift.Sendable {
        /// Catalog.
        /// This member is required.
        public var catalog: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            catalog: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.catalog = catalog
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Amazon RDS.
    public struct RdsParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Instance ID.
        /// This member is required.
        public var instanceId: Swift.String?

        public init(
            database: Swift.String? = nil,
            instanceId: Swift.String? = nil
        )
        {
            self.database = database
            self.instanceId = instanceId
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that grants Amazon QuickSight access to your cluster and make a call to the redshift:GetClusterCredentials API. For more information on the redshift:GetClusterCredentials API, see [GetClusterCredentials](https://docs.aws.amazon.com/redshift/latest/APIReference/API_GetClusterCredentials.html).
    public struct RedshiftIAMParameters: Swift.Sendable {
        /// Automatically creates a database user. If your database doesn't have a DatabaseUser, set this parameter to True. If there is no DatabaseUser, Amazon QuickSight can't connect to your cluster. The RoleArn that you use for this operation must grant access to redshift:CreateClusterUser to successfully create the user.
        public var autoCreateDatabaseUser: Swift.Bool
        /// A list of groups whose permissions will be granted to Amazon QuickSight to access the cluster. These permissions are combined with the permissions granted to Amazon QuickSight by the DatabaseUser. If you choose to include this parameter, the RoleArn must grant access to redshift:JoinGroup.
        public var databaseGroups: [Swift.String]?
        /// The user whose permissions and group memberships will be used by Amazon QuickSight to access the cluster. If this user already exists in your database, Amazon QuickSight is granted the same permissions that the user has. If the user doesn't exist, set the value of AutoCreateDatabaseUser to True to create a new user with PUBLIC permissions.
        public var databaseUser: Swift.String?
        /// Use the RoleArn structure to allow Amazon QuickSight to call redshift:GetClusterCredentials on your cluster. The calling principal must have iam:PassRole access to pass the role to Amazon QuickSight. The role's trust policy must allow the Amazon QuickSight service principal to assume the role.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            autoCreateDatabaseUser: Swift.Bool = false,
            databaseGroups: [Swift.String]? = nil,
            databaseUser: Swift.String? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.autoCreateDatabaseUser = autoCreateDatabaseUser
            self.databaseGroups = databaseGroups
            self.databaseUser = databaseUser
            self.roleArn = roleArn
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for an IAM Identity Center configuration.
    public struct IdentityCenterConfiguration: Swift.Sendable {
        /// A Boolean option that controls whether Trusted Identity Propagation should be used.
        public var enableIdentityPropagation: Swift.Bool?

        public init(
            enableIdentityPropagation: Swift.Bool? = false
        )
        {
            self.enableIdentityPropagation = enableIdentityPropagation
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Amazon Redshift. The ClusterId field can be blank if Host and Port are both set. The Host and Port fields can be blank if the ClusterId field is set.
    public struct RedshiftParameters: Swift.Sendable {
        /// Cluster ID. This field can be blank if the Host and Port are provided.
        public var clusterId: Swift.String?
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host. This field can be blank if ClusterId is provided.
        public var host: Swift.String?
        /// An optional parameter that uses IAM authentication to grant Amazon QuickSight access to your cluster. This parameter can be used instead of [DataSourceCredentials](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DataSourceCredentials.html).
        public var iamParameters: QuickSightClientTypes.RedshiftIAMParameters?
        /// An optional parameter that configures IAM Identity Center authentication to grant Amazon QuickSight access to your cluster. This parameter can only be specified if your Amazon QuickSight account is configured with IAM Identity Center.
        public var identityCenterConfiguration: QuickSightClientTypes.IdentityCenterConfiguration?
        /// Port. This field can be blank if the ClusterId is provided.
        public var port: Swift.Int

        public init(
            clusterId: Swift.String? = nil,
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            iamParameters: QuickSightClientTypes.RedshiftIAMParameters? = nil,
            identityCenterConfiguration: QuickSightClientTypes.IdentityCenterConfiguration? = nil,
            port: Swift.Int = 0
        )
        {
            self.clusterId = clusterId
            self.database = database
            self.host = host
            self.iamParameters = iamParameters
            self.identityCenterConfiguration = identityCenterConfiguration
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// Amazon S3 manifest file location.
    public struct ManifestFileLocation: Swift.Sendable {
        /// Amazon S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 key that identifies an object.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for S3.
    public struct S3Parameters: Swift.Sendable {
        /// Location of the Amazon S3 manifest file. This is NULL if the manifest file was uploaded into Amazon QuickSight.
        /// This member is required.
        public var manifestFileLocation: QuickSightClientTypes.ManifestFileLocation?
        /// Use the RoleArn structure to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use RoleArn to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.
        public var roleArn: Swift.String?

        public init(
            manifestFileLocation: QuickSightClientTypes.ManifestFileLocation? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.manifestFileLocation = manifestFileLocation
            self.roleArn = roleArn
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for ServiceNow.
    public struct ServiceNowParameters: Swift.Sendable {
        /// URL of the base site.
        /// This member is required.
        public var siteBaseUrl: Swift.String?

        public init(
            siteBaseUrl: Swift.String? = nil
        )
        {
            self.siteBaseUrl = siteBaseUrl
        }
    }
}

extension QuickSightClientTypes {

    public enum AuthenticationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case password
        case token
        case x509
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .password,
                .token,
                .x509
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .password: return "PASSWORD"
            case .token: return "TOKEN"
            case .x509: return "X509"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// VPC connection properties.
    public struct VpcConnectionProperties: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the VPC connection.
        /// This member is required.
        public var vpcConnectionArn: Swift.String?

        public init(
            vpcConnectionArn: Swift.String? = nil
        )
        {
            self.vpcConnectionArn = vpcConnectionArn
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains information needed to create a data source connection that uses OAuth client credentials. This option is available for data source connections that are made with Snowflake and Starburst.
    public struct OAuthParameters: Swift.Sendable {
        /// The resource uri of the identity provider.
        public var identityProviderResourceUri: Swift.String?
        /// VPC connection properties.
        public var identityProviderVpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?
        /// The OAuth scope.
        public var oAuthScope: Swift.String?
        /// The token endpoint URL of the identity provider.
        /// This member is required.
        public var tokenProviderUrl: Swift.String?

        public init(
            identityProviderResourceUri: Swift.String? = nil,
            identityProviderVpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil,
            oAuthScope: Swift.String? = nil,
            tokenProviderUrl: Swift.String? = nil
        )
        {
            self.identityProviderResourceUri = identityProviderResourceUri
            self.identityProviderVpcConnectionProperties = identityProviderVpcConnectionProperties
            self.oAuthScope = oAuthScope
            self.tokenProviderUrl = tokenProviderUrl
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Snowflake.
    public struct SnowflakeParameters: Swift.Sendable {
        /// The authentication type that you want to use for your connection. This parameter accepts OAuth and non-OAuth authentication types.
        public var authenticationType: QuickSightClientTypes.AuthenticationType?
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// The database access control role.
        public var databaseAccessControlRole: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// An object that contains information needed to create a data source connection between an Amazon QuickSight account and Snowflake.
        public var oAuthParameters: QuickSightClientTypes.OAuthParameters?
        /// Warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init(
            authenticationType: QuickSightClientTypes.AuthenticationType? = nil,
            database: Swift.String? = nil,
            databaseAccessControlRole: Swift.String? = nil,
            host: Swift.String? = nil,
            oAuthParameters: QuickSightClientTypes.OAuthParameters? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.database = database
            self.databaseAccessControlRole = databaseAccessControlRole
            self.host = host
            self.oAuthParameters = oAuthParameters
            self.warehouse = warehouse
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Spark.
    public struct SparkParameters: Swift.Sendable {
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for SQL Server.
    public struct SqlServerParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    public enum StarburstProductType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterprise
        case galaxy
        case sdkUnknown(Swift.String)

        public static var allCases: [StarburstProductType] {
            return [
                .enterprise,
                .galaxy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "ENTERPRISE"
            case .galaxy: return "GALAXY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters that are required to connect to a Starburst data source.
    public struct StarburstParameters: Swift.Sendable {
        /// The authentication type that you want to use for your connection. This parameter accepts OAuth and non-OAuth authentication types.
        public var authenticationType: QuickSightClientTypes.AuthenticationType?
        /// The catalog name for the Starburst data source.
        /// This member is required.
        public var catalog: Swift.String?
        /// The database access control role.
        public var databaseAccessControlRole: Swift.String?
        /// The host name of the Starburst data source.
        /// This member is required.
        public var host: Swift.String?
        /// An object that contains information needed to create a data source connection between an Amazon QuickSight account and Starburst.
        public var oAuthParameters: QuickSightClientTypes.OAuthParameters?
        /// The port for the Starburst data source.
        /// This member is required.
        public var port: Swift.Int?
        /// The product type for the Starburst data source.
        public var productType: QuickSightClientTypes.StarburstProductType?

        public init(
            authenticationType: QuickSightClientTypes.AuthenticationType? = nil,
            catalog: Swift.String? = nil,
            databaseAccessControlRole: Swift.String? = nil,
            host: Swift.String? = nil,
            oAuthParameters: QuickSightClientTypes.OAuthParameters? = nil,
            port: Swift.Int? = nil,
            productType: QuickSightClientTypes.StarburstProductType? = nil
        )
        {
            self.authenticationType = authenticationType
            self.catalog = catalog
            self.databaseAccessControlRole = databaseAccessControlRole
            self.host = host
            self.oAuthParameters = oAuthParameters
            self.port = port
            self.productType = productType
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Teradata.
    public struct TeradataParameters: Swift.Sendable {
        /// Database.
        /// This member is required.
        public var database: Swift.String?
        /// Host.
        /// This member is required.
        public var host: Swift.String?
        /// Port.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            database: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.database = database
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters that are required to connect to a Trino data source.
    public struct TrinoParameters: Swift.Sendable {
        /// The catalog name for the Trino data source.
        /// This member is required.
        public var catalog: Swift.String?
        /// The host name of the Trino data source.
        /// This member is required.
        public var host: Swift.String?
        /// The port for the Trino data source.
        /// This member is required.
        public var port: Swift.Int?

        public init(
            catalog: Swift.String? = nil,
            host: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.catalog = catalog
            self.host = host
            self.port = port
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters for Twitter.
    public struct TwitterParameters: Swift.Sendable {
        /// Maximum number of rows to query Twitter.
        /// This member is required.
        public var maxRows: Swift.Int?
        /// Twitter query string.
        /// This member is required.
        public var query: Swift.String?

        public init(
            maxRows: Swift.Int? = nil,
            query: Swift.String? = nil
        )
        {
            self.maxRows = maxRows
            self.query = query
        }
    }
}

extension QuickSightClientTypes {

    /// The parameters that Amazon QuickSight uses to connect to your underlying data source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum DataSourceParameters: Swift.Sendable {
        /// The parameters for OpenSearch.
        case amazonelasticsearchparameters(QuickSightClientTypes.AmazonElasticsearchParameters)
        /// The parameters for Amazon Athena.
        case athenaparameters(QuickSightClientTypes.AthenaParameters)
        /// The parameters for Amazon Aurora MySQL.
        case auroraparameters(QuickSightClientTypes.AuroraParameters)
        /// The parameters for Amazon Aurora.
        case aurorapostgresqlparameters(QuickSightClientTypes.AuroraPostgreSqlParameters)
        /// The parameters for IoT Analytics.
        case awsiotanalyticsparameters(QuickSightClientTypes.AwsIotAnalyticsParameters)
        /// The parameters for Jira.
        case jiraparameters(QuickSightClientTypes.JiraParameters)
        /// The parameters for MariaDB.
        case mariadbparameters(QuickSightClientTypes.MariaDbParameters)
        /// The parameters for MySQL.
        case mysqlparameters(QuickSightClientTypes.MySqlParameters)
        /// The parameters for Oracle.
        case oracleparameters(QuickSightClientTypes.OracleParameters)
        /// The parameters for PostgreSQL.
        case postgresqlparameters(QuickSightClientTypes.PostgreSqlParameters)
        /// The parameters for Presto.
        case prestoparameters(QuickSightClientTypes.PrestoParameters)
        /// The parameters for Amazon RDS.
        case rdsparameters(QuickSightClientTypes.RdsParameters)
        /// The parameters for Amazon Redshift.
        case redshiftparameters(QuickSightClientTypes.RedshiftParameters)
        /// The parameters for S3.
        case s3parameters(QuickSightClientTypes.S3Parameters)
        /// The parameters for ServiceNow.
        case servicenowparameters(QuickSightClientTypes.ServiceNowParameters)
        /// The parameters for Snowflake.
        case snowflakeparameters(QuickSightClientTypes.SnowflakeParameters)
        /// The parameters for Spark.
        case sparkparameters(QuickSightClientTypes.SparkParameters)
        /// The parameters for SQL Server.
        case sqlserverparameters(QuickSightClientTypes.SqlServerParameters)
        /// The parameters for Teradata.
        case teradataparameters(QuickSightClientTypes.TeradataParameters)
        /// The parameters for Twitter.
        case twitterparameters(QuickSightClientTypes.TwitterParameters)
        /// The parameters for OpenSearch.
        case amazonopensearchparameters(QuickSightClientTypes.AmazonOpenSearchParameters)
        /// The parameters for Exasol.
        case exasolparameters(QuickSightClientTypes.ExasolParameters)
        /// The parameters that are required to connect to a Databricks data source.
        case databricksparameters(QuickSightClientTypes.DatabricksParameters)
        /// The parameters that are required to connect to a Starburst data source.
        case starburstparameters(QuickSightClientTypes.StarburstParameters)
        /// The parameters that are required to connect to a Trino data source.
        case trinoparameters(QuickSightClientTypes.TrinoParameters)
        /// The parameters that are required to connect to a Google BigQuery data source.
        case bigqueryparameters(QuickSightClientTypes.BigQueryParameters)
        case sdkUnknown(Swift.String)
    }
}

extension QuickSightClientTypes {

    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying data source.
    public struct SslProperties: Swift.Sendable {
        /// A Boolean option to control whether SSL should be disabled.
        public var disableSsl: Swift.Bool

        public init(
            disableSsl: Swift.Bool = false
        )
        {
            self.disableSsl = disableSsl
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single data source that is being imported.
    public struct AssetBundleImportJobDataSourceOverrideParameters: Swift.Sendable {
        /// An optional structure that provides the credentials to be used to create the imported data source.
        public var credentials: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials?
        /// The ID of the data source to apply overrides to.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying data source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
        /// A new name for the data source.
        public var name: Swift.String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying data source.
        public var sslProperties: QuickSightClientTypes.SslProperties?
        /// VPC connection properties.
        public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

        public init(
            credentials: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials? = nil,
            dataSourceId: Swift.String? = nil,
            dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
            name: Swift.String? = nil,
            sslProperties: QuickSightClientTypes.SslProperties? = nil,
            vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
        )
        {
            self.credentials = credentials
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.name = name
            self.sslProperties = sslProperties
            self.vpcConnectionProperties = vpcConnectionProperties
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of data source IDs.
    public struct AssetBundleImportJobDataSourceOverridePermissions: Swift.Sendable {
        /// A list of data source IDs that you want to apply overrides to. You can use * to override all data sources in this asset bundle.
        /// This member is required.
        public var dataSourceIds: [Swift.String]?
        /// A list of permissions for the data source that you want to apply overrides to.
        /// This member is required.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            dataSourceIds: [Swift.String]? = nil,
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.dataSourceIds = dataSourceIds
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of data source IDs.
    public struct AssetBundleImportJobDataSourceOverrideTags: Swift.Sendable {
        /// A list of data source IDs that you want to apply overrides to. You can use * to override all data sources in this asset bundle.
        /// This member is required.
        public var dataSourceIds: [Swift.String]?
        /// A list of tags for the data source that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?

        public init(
            dataSourceIds: [Swift.String]? = nil,
            tags: [QuickSightClientTypes.Tag]? = nil
        )
        {
            self.dataSourceIds = dataSourceIds
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// Describes an error that occurred within an Asset Bundle import execution.
    public struct AssetBundleImportJobError: Swift.Sendable {
        /// The ARN of the resource whose processing caused an error.
        public var arn: Swift.String?
        /// A description of the error.
        public var message: Swift.String?
        /// The specific error type or the error that occurred.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single folder that is being imported.
    public struct AssetBundleImportJobFolderOverrideParameters: Swift.Sendable {
        /// The ID of the folder that you want to apply overrides to.
        /// This member is required.
        public var folderId: Swift.String?
        /// A new name for the folder.
        public var name: Swift.String?
        /// A new parent folder arn. This change can only be applied if the import creates a brand new folder. Existing folders cannot be moved.
        public var parentFolderArn: Swift.String?

        public init(
            folderId: Swift.String? = nil,
            name: Swift.String? = nil,
            parentFolderArn: Swift.String? = nil
        )
        {
            self.folderId = folderId
            self.name = name
            self.parentFolderArn = parentFolderArn
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of folder IDs.
    public struct AssetBundleImportJobFolderOverridePermissions: Swift.Sendable {
        /// A list of folder IDs that you want to apply overrides to. You can use * to override all folders in this asset bundle.
        /// This member is required.
        public var folderIds: [Swift.String]?
        /// A structure that contains the permissions for the resource that you want to override in an asset bundle import job.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?

        public init(
            folderIds: [Swift.String]? = nil,
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil
        )
        {
            self.folderIds = folderIds
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of folder IDs.
    public struct AssetBundleImportJobFolderOverrideTags: Swift.Sendable {
        /// A list of folder IDs that you want to apply overrides to. You can use * to override all folders in this asset bundle.
        /// This member is required.
        public var folderIds: [Swift.String]?
        /// A list of tags for the folders that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?

        public init(
            folderIds: [Swift.String]? = nil,
            tags: [QuickSightClientTypes.Tag]? = nil
        )
        {
            self.folderIds = folderIds
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// A list of overrides for a specific RefreshsSchedule resource that is present in the asset bundle that is imported.
    public struct AssetBundleImportJobRefreshScheduleOverrideParameters: Swift.Sendable {
        /// A partial identifier for the specific RefreshSchedule resource that is being overridden. This structure is used together with the ScheduleID structure.
        /// This member is required.
        public var dataSetId: Swift.String?
        /// A partial identifier for the specific RefreshSchedule resource being overridden. This structure is used together with the DataSetId structure.
        /// This member is required.
        public var scheduleId: Swift.String?
        /// An override for the StartAfterDateTime of a RefreshSchedule. Make sure that the StartAfterDateTime is set to a time that takes place in the future.
        public var startAfterDateTime: Foundation.Date?

        public init(
            dataSetId: Swift.String? = nil,
            scheduleId: Swift.String? = nil,
            startAfterDateTime: Foundation.Date? = nil
        )
        {
            self.dataSetId = dataSetId
            self.scheduleId = scheduleId
            self.startAfterDateTime = startAfterDateTime
        }
    }
}

extension QuickSightClientTypes {

    /// An optional structure that configures resource ID overrides for the import job.
    public struct AssetBundleImportJobResourceIdOverrideConfiguration: Swift.Sendable {
        /// An option to request a CloudFormation variable for a prefix to be prepended to each resource's ID before import. The prefix is only added to the asset IDs and does not change the name of the asset.
        public var prefixForAllResources: Swift.String?

        public init(
            prefixForAllResources: Swift.String? = nil
        )
        {
            self.prefixForAllResources = prefixForAllResources
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single theme that is imported.
    public struct AssetBundleImportJobThemeOverrideParameters: Swift.Sendable {
        /// A new name for the theme.
        public var name: Swift.String?
        /// The ID of the theme to apply overrides to.
        /// This member is required.
        public var themeId: Swift.String?

        public init(
            name: Swift.String? = nil,
            themeId: Swift.String? = nil
        )
        {
            self.name = name
            self.themeId = themeId
        }
    }
}

extension QuickSightClientTypes {

    /// The override parameters for a single VPC connection that is imported.
    public struct AssetBundleImportJobVPCConnectionOverrideParameters: Swift.Sendable {
        /// An optional override of DNS resolvers to be used by the VPC connection.
        public var dnsResolvers: [Swift.String]?
        /// A new name for the VPC connection.
        public var name: Swift.String?
        /// An optional override of the role ARN to be used by the VPC connection.
        public var roleArn: Swift.String?
        /// A new security group ID for the VPC connection you are importing. This field is required if you are importing the VPC connection from another Amazon Web Services account or Region.
        public var securityGroupIds: [Swift.String]?
        /// A list of new subnet IDs for the VPC connection you are importing. This field is required if you are importing the VPC connection from another Amazon Web Services account or Region.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC Connection to apply overrides to.
        /// This member is required.
        public var vpcConnectionId: Swift.String?

        public init(
            dnsResolvers: [Swift.String]? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcConnectionId: Swift.String? = nil
        )
        {
            self.dnsResolvers = dnsResolvers
            self.name = name
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcConnectionId = vpcConnectionId
        }
    }
}

extension QuickSightClientTypes {

    /// A list of overrides that modify the asset bundle resource configuration before the resource is imported.
    public struct AssetBundleImportJobOverrideParameters: Swift.Sendable {
        /// A list of overrides for any Analysis resources that are present in the asset bundle that is imported.
        public var analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters]?
        /// A list of overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public var dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters]?
        /// A list of overrides for any DataSet resources that are present in the asset bundle that is imported.
        public var dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters]?
        /// A list of overrides for any DataSource resources that are present in the asset bundle that is imported.
        public var dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters]?
        /// A list of overrides for any Folder resources that are present in the asset bundle that is imported.
        public var folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters]?
        /// A list of overrides for any RefreshSchedule resources that are present in the asset bundle that is imported.
        public var refreshSchedules: [QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters]?
        /// An optional structure that configures resource ID overrides to be applied within the import job.
        public var resourceIdOverrideConfiguration: QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration?
        /// A list of overrides for any Theme resources that are present in the asset bundle that is imported.
        public var themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters]?
        /// A list of overrides for any VPCConnection resources that are present in the asset bundle that is imported.
        public var vpcConnections: [QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters]?

        public init(
            analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters]? = nil,
            dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters]? = nil,
            dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters]? = nil,
            dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters]? = nil,
            folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters]? = nil,
            refreshSchedules: [QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters]? = nil,
            resourceIdOverrideConfiguration: QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration? = nil,
            themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters]? = nil,
            vpcConnections: [QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters]? = nil
        )
        {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.folders = folders
            self.refreshSchedules = refreshSchedules
            self.resourceIdOverrideConfiguration = resourceIdOverrideConfiguration
            self.themes = themes
            self.vpcConnections = vpcConnections
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of permissions to be applied to a list of theme IDs.
    public struct AssetBundleImportJobThemeOverridePermissions: Swift.Sendable {
        /// A list of permissions for the themes that you want to apply overrides to.
        /// This member is required.
        public var permissions: QuickSightClientTypes.AssetBundleResourcePermissions?
        /// A list of theme IDs that you want to apply overrides to. You can use * to override all themes in this asset bundle.
        /// This member is required.
        public var themeIds: [Swift.String]?

        public init(
            permissions: QuickSightClientTypes.AssetBundleResourcePermissions? = nil,
            themeIds: [Swift.String]? = nil
        )
        {
            self.permissions = permissions
            self.themeIds = themeIds
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the override permission configurations that modify the permissions for specified resources before the resource is imported.
    public struct AssetBundleImportJobOverridePermissions: Swift.Sendable {
        /// A list of permissions overrides for any Analysis resources that are present in the asset bundle that is imported.
        public var analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions]?
        /// A list of permissions overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public var dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions]?
        /// A list of permissions overrides for any DataSet resources that are present in the asset bundle that is imported.
        public var dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions]?
        /// A list of permissions overrides for any DataSource resources that are present in the asset bundle that is imported.
        public var dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions]?
        /// A list of permissions for the folders that you want to apply overrides to.
        public var folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions]?
        /// A list of permissions overrides for any Theme resources that are present in the asset bundle that is imported.
        public var themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions]?

        public init(
            analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions]? = nil,
            dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions]? = nil,
            dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions]? = nil,
            dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions]? = nil,
            folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions]? = nil,
            themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions]? = nil
        )
        {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.folders = folders
            self.themes = themes
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of theme IDs.
    public struct AssetBundleImportJobThemeOverrideTags: Swift.Sendable {
        /// A list of tags for the themes that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?
        /// A list of theme IDs that you want to apply overrides to. You can use * to override all themes in this asset bundle.
        /// This member is required.
        public var themeIds: [Swift.String]?

        public init(
            tags: [QuickSightClientTypes.Tag]? = nil,
            themeIds: [Swift.String]? = nil
        )
        {
            self.tags = tags
            self.themeIds = themeIds
        }
    }
}

extension QuickSightClientTypes {

    /// An object that contains a list of tags to be assigned to a list of VPC connection IDs.
    public struct AssetBundleImportJobVPCConnectionOverrideTags: Swift.Sendable {
        /// A list of tags for the VPC connections that you want to apply overrides to.
        /// This member is required.
        public var tags: [QuickSightClientTypes.Tag]?
        /// A list of VPC connection IDs that you want to apply overrides to. You can use * to override all VPC connections in this asset bundle.
        /// This member is required.
        public var vpcConnectionIds: [Swift.String]?

        public init(
            tags: [QuickSightClientTypes.Tag]? = nil,
            vpcConnectionIds: [Swift.String]? = nil
        )
        {
            self.tags = tags
            self.vpcConnectionIds = vpcConnectionIds
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the override tag configuration that modify the tags that are assigned to specified resources before the resource is imported.
    public struct AssetBundleImportJobOverrideTags: Swift.Sendable {
        /// A list of tag overrides for any Analysis resources that are present in the asset bundle that is imported.
        public var analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags]?
        /// A list of tag overrides for any Dashboard resources that are present in the asset bundle that is imported.
        public var dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags]?
        /// A list of tag overrides for any DataSet resources that are present in the asset bundle that is imported.
        public var dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags]?
        /// A list of tag overrides for any DataSource resources that are present in the asset bundle that is imported.
        public var dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags]?
        /// A list of tag overrides for any Folder resources that are present in the asset bundle that is imported.
        public var folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags]?
        /// A list of tag overrides for any Theme resources that are present in the asset bundle that is imported.
        public var themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags]?
        /// A list of tag overrides for any VPCConnection resources that are present in the asset bundle that is imported.
        public var vpcConnections: [QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags]?

        public init(
            analyses: [QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags]? = nil,
            dashboards: [QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags]? = nil,
            dataSets: [QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags]? = nil,
            dataSources: [QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags]? = nil,
            folders: [QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags]? = nil,
            themes: [QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags]? = nil,
            vpcConnections: [QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags]? = nil
        )
        {
            self.analyses = analyses
            self.dashboards = dashboards
            self.dataSets = dataSets
            self.dataSources = dataSources
            self.folders = folders
            self.themes = themes
            self.vpcConnections = vpcConnections
        }
    }
}

extension QuickSightClientTypes {

    /// An optional parameter that overrides the validation strategy for all analyses and dashboards before the resource is imported.
    public struct AssetBundleImportJobOverrideValidationStrategy: Swift.Sendable {
        /// A Boolean value that indicates whether to import all analyses and dashboards under strict or lenient mode.
        public var strictModeForAllResources: Swift.Bool

        public init(
            strictModeForAllResources: Swift.Bool = false
        )
        {
            self.strictModeForAllResources = strictModeForAllResources
        }
    }
}

extension QuickSightClientTypes {

    public enum AssetBundleImportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case failedRollbackCompleted
        case failedRollbackError
        case failedRollbackInProgress
        case inProgress
        case queuedForImmediateExecution
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetBundleImportJobStatus] {
            return [
                .failed,
                .failedRollbackCompleted,
                .failedRollbackError,
                .failedRollbackInProgress,
                .inProgress,
                .queuedForImmediateExecution,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .failedRollbackCompleted: return "FAILED_ROLLBACK_COMPLETED"
            case .failedRollbackError: return "FAILED_ROLLBACK_ERROR"
            case .failedRollbackInProgress: return "FAILED_ROLLBACK_IN_PROGRESS"
            case .inProgress: return "IN_PROGRESS"
            case .queuedForImmediateExecution: return "QUEUED_FOR_IMMEDIATE_EXECUTION"
            case .successful: return "SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A summary of the import job that includes details of the requested job's configuration and its current status.
    public struct AssetBundleImportJobSummary: Swift.Sendable {
        /// The ARN of the import job.
        public var arn: Swift.String?
        /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
        public var assetBundleImportJobId: Swift.String?
        /// The time that the import job was created.
        public var createdTime: Foundation.Date?
        /// The failure action for the import job.
        public var failureAction: QuickSightClientTypes.AssetBundleImportFailureAction?
        /// The current status of the import job.
        public var jobStatus: QuickSightClientTypes.AssetBundleImportJobStatus?

        public init(
            arn: Swift.String? = nil,
            assetBundleImportJobId: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            failureAction: QuickSightClientTypes.AssetBundleImportFailureAction? = nil,
            jobStatus: QuickSightClientTypes.AssetBundleImportJobStatus? = nil
        )
        {
            self.arn = arn
            self.assetBundleImportJobId = assetBundleImportJobId
            self.createdTime = createdTime
            self.failureAction = failureAction
            self.jobStatus = jobStatus
        }
    }
}

extension QuickSightClientTypes {

    /// Describes a warning that occurred during an Asset Bundle import job.
    public struct AssetBundleImportJobWarning: Swift.Sendable {
        /// The ARN of the resource that the warning occurred for.
        public var arn: Swift.String?
        /// A description of the warning that occurred during an Asset Bundle import job.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.message = message
        }
    }
}

extension QuickSightClientTypes {

    /// The source of the asset bundle zip file that contains the data that you want to import. The file must be in QUICKSIGHT_JSON format.
    public struct AssetBundleImportSource: Swift.Sendable {
        /// The bytes of the base64 encoded asset bundle import zip file. This file can't exceed 20 MB. If you are calling the API operations from the Amazon Web Services SDK for Java, JavaScript, Python, or PHP, the SDK encodes base64 automatically to allow the direct setting of the zip file's bytes. If you are using an SDK for a different language or receiving related errors, try to base64 encode your data.
        public var body: Foundation.Data?
        /// The Amazon S3 URI for an asset bundle import file that exists in an Amazon S3 bucket that the caller has read access to. The file must be a zip format file and can't exceed 20 MB.
        public var s3Uri: Swift.String?

        public init(
            body: Foundation.Data? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.body = body
            self.s3Uri = s3Uri
        }
    }
}

extension QuickSightClientTypes.AssetBundleImportSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetBundleImportSource(s3Uri: \(Swift.String(describing: s3Uri)), body: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A description of the import source that you provide at the start of an import job. This value is set to either Body or S3Uri, depending on how the StartAssetBundleImportJobRequest is configured.
    public struct AssetBundleImportSourceDescription: Swift.Sendable {
        /// An HTTPS download URL for the provided asset bundle that you optionally provided at the start of the import job. This URL is valid for five minutes after issuance. Call DescribeAssetBundleExportJob again for a fresh URL if needed. The downloaded asset bundle is a .qs zip file.
        public var body: Swift.String?
        /// The Amazon S3 URI that you provided at the start of the import job.
        public var s3Uri: Swift.String?

        public init(
            body: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.body = body
            self.s3Uri = s3Uri
        }
    }
}

extension QuickSightClientTypes.AssetBundleImportSourceDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetBundleImportSourceDescription(s3Uri: \(Swift.String(describing: s3Uri)), body: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum AssignmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case draft
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssignmentStatus] {
            return [
                .disabled,
                .draft,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .draft: return "DRAFT"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum AuthenticationMethodOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeDirectory
        case iamAndQuicksight
        case iamIdentityCenter
        case iamOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethodOption] {
            return [
                .activeDirectory,
                .iamAndQuicksight,
                .iamIdentityCenter,
                .iamOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .iamAndQuicksight: return "IAM_AND_QUICKSIGHT"
            case .iamIdentityCenter: return "IAM_IDENTITY_CENTER"
            case .iamOnly: return "IAM_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum ServiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case redshift
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .redshift
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .redshift: return "REDSHIFT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The authorized targets that are associated with a service.
    public struct AuthorizedTargetsByService: Swift.Sendable {
        /// Aist of authorized targets that are represented by IAM Identity Center application ARNs.
        public var authorizedTargets: [Swift.String]?
        /// The name of the Amazon Web Services service.
        public var service: QuickSightClientTypes.ServiceType?

        public init(
            authorizedTargets: [Swift.String]? = nil,
            service: QuickSightClientTypes.ServiceType? = nil
        )
        {
            self.authorizedTargets = authorizedTargets
            self.service = service
        }
    }
}

extension QuickSightClientTypes {

    public enum AuthorSpecifiedAggregation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case distinctCount
        case max
        case median
        case min
        case percentile
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorSpecifiedAggregation] {
            return [
                .average,
                .count,
                .distinctCount,
                .max,
                .median,
                .min,
                .percentile,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .percentile: return "PERCENTILE"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An internal failure occurred.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// One or more parameters has a value that isn't valid.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterValueException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    public enum ExceptionResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountSettings
        case dataSet
        case dataSource
        case group
        case iampolicyAssignment
        case ingestion
        case namespace
        case user
        case vpcConnection
        case sdkUnknown(Swift.String)

        public static var allCases: [ExceptionResourceType] {
            return [
                .accountSettings,
                .dataSet,
                .dataSource,
                .group,
                .iampolicyAssignment,
                .ingestion,
                .namespace,
                .user,
                .vpcConnection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountSettings: return "ACCOUNT_SETTINGS"
            case .dataSet: return "DATA_SET"
            case .dataSource: return "DATA_SOURCE"
            case .group: return "GROUP"
            case .iampolicyAssignment: return "IAMPOLICY_ASSIGNMENT"
            case .ingestion: return "INGESTION"
            case .namespace: return "NAMESPACE"
            case .user: return "USER"
            case .vpcConnection: return "VPC_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
        /// The resource type for this request.
        public internal(set) var resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceType = resourceType
    }
}

/// Access is throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    public enum ContributionAnalysisDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case decrease
        case increase
        case neutral
        case sdkUnknown(Swift.String)

        public static var allCases: [ContributionAnalysisDirection] {
            return [
                .decrease,
                .increase,
                .neutral
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .decrease: return "DECREASE"
            case .increase: return "INCREASE"
            case .neutral: return "NEUTRAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for the ContributionAnalysisFactor.
    public struct ContributionAnalysisFactor: Swift.Sendable {
        /// The field name of the ContributionAnalysisFactor.
        public var fieldName: Swift.String?

        public init(
            fieldName: Swift.String? = nil
        )
        {
            self.fieldName = fieldName
        }
    }
}

extension QuickSightClientTypes {

    public enum ContributionAnalysisSortType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absoluteDifference
        case contributionPercentage
        case deviationFromExpected
        case percentageDifference
        case sdkUnknown(Swift.String)

        public static var allCases: [ContributionAnalysisSortType] {
            return [
                .absoluteDifference,
                .contributionPercentage,
                .deviationFromExpected,
                .percentageDifference
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absoluteDifference: return "ABSOLUTE_DIFFERENCE"
            case .contributionPercentage: return "CONTRIBUTION_PERCENTAGE"
            case .deviationFromExpected: return "DEVIATION_FROM_EXPECTED"
            case .percentageDifference: return "PERCENTAGE_DIFFERENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for the identifier.
    public struct Identifier: Swift.Sendable {
        /// The identity of the identifier.
        /// This member is required.
        public var identity: Swift.String?

        public init(
            identity: Swift.String? = nil
        )
        {
            self.identity = identity
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicSortDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicSortDirection] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for the FilterAggMetrics.
    public struct FilterAggMetrics: Swift.Sendable {
        /// The function for the FilterAggMetrics.
        public var function: QuickSightClientTypes.AggType?
        /// The metric operand of the FilterAggMetrics.
        public var metricOperand: QuickSightClientTypes.Identifier?
        /// The sort direction for FilterAggMetrics.
        public var sortDirection: QuickSightClientTypes.TopicSortDirection?

        public init(
            function: QuickSightClientTypes.AggType? = nil,
            metricOperand: QuickSightClientTypes.Identifier? = nil,
            sortDirection: QuickSightClientTypes.TopicSortDirection? = nil
        )
        {
            self.function = function
            self.metricOperand = metricOperand
            self.sortDirection = sortDirection
        }
    }
}

extension QuickSightClientTypes {

    public enum ConstantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collective
        case range
        case singular
        case sdkUnknown(Swift.String)

        public static var allCases: [ConstantType] {
            return [
                .collective,
                .range,
                .singular
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collective: return "COLLECTIVE"
            case .range: return "RANGE"
            case .singular: return "SINGULAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a CollectiveConstantEntry.
    public struct CollectiveConstantEntry: Swift.Sendable {
        /// The ConstantType of a CollectiveConstantEntry.
        public var constantType: QuickSightClientTypes.ConstantType?
        /// The value of a CollectiveConstantEntry.
        public var value: Swift.String?

        public init(
            constantType: QuickSightClientTypes.ConstantType? = nil,
            value: Swift.String? = nil
        )
        {
            self.constantType = constantType
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicConstantValue.
    public struct TopicConstantValue: Swift.Sendable {
        /// The constant type of a TopicConstantValue.
        public var constantType: QuickSightClientTypes.ConstantType?
        /// The maximum for the TopicConstantValue.
        public var maximum: Swift.String?
        /// The minimum for the TopicConstantValue.
        public var minimum: Swift.String?
        /// The value of the TopicConstantValue.
        public var value: Swift.String?
        /// The value list of the TopicConstantValue.
        public var valueList: [QuickSightClientTypes.CollectiveConstantEntry]?

        public init(
            constantType: QuickSightClientTypes.ConstantType? = nil,
            maximum: Swift.String? = nil,
            minimum: Swift.String? = nil,
            value: Swift.String? = nil,
            valueList: [QuickSightClientTypes.CollectiveConstantEntry]? = nil
        )
        {
            self.constantType = constantType
            self.maximum = maximum
            self.minimum = minimum
            self.value = value
            self.valueList = valueList
        }
    }
}

extension QuickSightClientTypes {

    public enum FilterClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditionalValueFilter
        case enforcedValueFilter
        case namedValueFilter
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterClass] {
            return [
                .conditionalValueFilter,
                .enforcedValueFilter,
                .namedValueFilter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditionalValueFilter: return "CONDITIONAL_VALUE_FILTER"
            case .enforcedValueFilter: return "ENFORCED_VALUE_FILTER"
            case .namedValueFilter: return "NAMED_VALUE_FILTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicIRFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acceptAllFilter
        case categoryFilter
        case dateRangeFilter
        case equals
        case numericEqualityFilter
        case numericRangeFilter
        case rankLimitFilter
        case relativeDateFilter
        case topBottomFilter
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicIRFilterType] {
            return [
                .acceptAllFilter,
                .categoryFilter,
                .dateRangeFilter,
                .equals,
                .numericEqualityFilter,
                .numericRangeFilter,
                .rankLimitFilter,
                .relativeDateFilter,
                .topBottomFilter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acceptAllFilter: return "ACCEPT_ALL_FILTER"
            case .categoryFilter: return "CATEGORY_FILTER"
            case .dateRangeFilter: return "DATE_RANGE_FILTER"
            case .equals: return "EQUALS"
            case .numericEqualityFilter: return "NUMERIC_EQUALITY_FILTER"
            case .numericRangeFilter: return "NUMERIC_RANGE_FILTER"
            case .rankLimitFilter: return "RANK_LIMIT_FILTER"
            case .relativeDateFilter: return "RELATIVE_DATE_FILTER"
            case .topBottomFilter: return "TOP_BOTTOM_FILTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicIRFilterFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case containsString
        case endsWith
        case exact
        case last
        case next
        case now
        case previous
        case startsWith
        case `this`
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicIRFilterFunction] {
            return [
                .contains,
                .containsString,
                .endsWith,
                .exact,
                .last,
                .next,
                .now,
                .previous,
                .startsWith,
                .this
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .containsString: return "CONTAINS_STRING"
            case .endsWith: return "ENDS_WITH"
            case .exact: return "EXACT"
            case .last: return "LAST"
            case .next: return "NEXT"
            case .now: return "NOW"
            case .previous: return "PREVIOUS"
            case .startsWith: return "STARTS_WITH"
            case .this: return "THIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum NullFilterOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allValues
        case nonNullsOnly
        case nullsOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [NullFilterOption] {
            return [
                .allValues,
                .nonNullsOnly,
                .nullsOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allValues: return "ALL_VALUES"
            case .nonNullsOnly: return "NON_NULLS_ONLY"
            case .nullsOnly: return "NULLS_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicIRFilterOption.
    public struct TopicIRFilterOption: Swift.Sendable {
        /// The agg metrics for the TopicIRFilterOption.
        public var aggMetrics: [QuickSightClientTypes.FilterAggMetrics]?
        /// The aggregation for the TopicIRFilterOption.
        public var aggregation: QuickSightClientTypes.AggType?
        /// The aggregation function parameters for the TopicIRFilterOption.
        public var aggregationFunctionParameters: [Swift.String: Swift.String]?
        /// The AggregationPartitionBy for the TopicIRFilterOption.
        public var aggregationPartitionBy: [QuickSightClientTypes.AggregationPartitionBy]?
        /// The anchor for the TopicIRFilterOption.
        public var anchor: QuickSightClientTypes.Anchor?
        /// The constant for the TopicIRFilterOption.
        public var constant: QuickSightClientTypes.TopicConstantValue?
        /// The filter class for the TopicIRFilterOption.
        public var filterClass: QuickSightClientTypes.FilterClass?
        /// The filter type for the TopicIRFilterOption.
        public var filterType: QuickSightClientTypes.TopicIRFilterType?
        /// The function for the TopicIRFilterOption.
        public var function: QuickSightClientTypes.TopicIRFilterFunction?
        /// The inclusive for the TopicIRFilterOption.
        public var inclusive: Swift.Bool
        /// The inverse for the TopicIRFilterOption.
        public var inverse: Swift.Bool
        /// The last next offset for the TopicIRFilterOption.
        public var lastNextOffset: QuickSightClientTypes.TopicConstantValue?
        /// The null filter for the TopicIRFilterOption.
        public var nullFilter: QuickSightClientTypes.NullFilterOption?
        /// The operand field for the TopicIRFilterOption.
        public var operandField: QuickSightClientTypes.Identifier?
        /// The range for the TopicIRFilterOption.
        public var range: QuickSightClientTypes.TopicConstantValue?
        /// The sort direction for the TopicIRFilterOption.
        public var sortDirection: QuickSightClientTypes.TopicSortDirection?
        /// The time granularity for the TopicIRFilterOption.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The TopBottomLimit for the TopicIRFilterOption.
        public var topBottomLimit: QuickSightClientTypes.TopicConstantValue?

        public init(
            aggMetrics: [QuickSightClientTypes.FilterAggMetrics]? = nil,
            aggregation: QuickSightClientTypes.AggType? = nil,
            aggregationFunctionParameters: [Swift.String: Swift.String]? = nil,
            aggregationPartitionBy: [QuickSightClientTypes.AggregationPartitionBy]? = nil,
            anchor: QuickSightClientTypes.Anchor? = nil,
            constant: QuickSightClientTypes.TopicConstantValue? = nil,
            filterClass: QuickSightClientTypes.FilterClass? = nil,
            filterType: QuickSightClientTypes.TopicIRFilterType? = nil,
            function: QuickSightClientTypes.TopicIRFilterFunction? = nil,
            inclusive: Swift.Bool = false,
            inverse: Swift.Bool = false,
            lastNextOffset: QuickSightClientTypes.TopicConstantValue? = nil,
            nullFilter: QuickSightClientTypes.NullFilterOption? = nil,
            operandField: QuickSightClientTypes.Identifier? = nil,
            range: QuickSightClientTypes.TopicConstantValue? = nil,
            sortDirection: QuickSightClientTypes.TopicSortDirection? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            topBottomLimit: QuickSightClientTypes.TopicConstantValue? = nil
        )
        {
            self.aggMetrics = aggMetrics
            self.aggregation = aggregation
            self.aggregationFunctionParameters = aggregationFunctionParameters
            self.aggregationPartitionBy = aggregationPartitionBy
            self.anchor = anchor
            self.constant = constant
            self.filterClass = filterClass
            self.filterType = filterType
            self.function = function
            self.inclusive = inclusive
            self.inverse = inverse
            self.lastNextOffset = lastNextOffset
            self.nullFilter = nullFilter
            self.operandField = operandField
            self.range = range
            self.sortDirection = sortDirection
            self.timeGranularity = timeGranularity
            self.topBottomLimit = topBottomLimit
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for the ContributionAnalysisTimeRanges.
    public struct ContributionAnalysisTimeRanges: Swift.Sendable {
        /// The end range for the ContributionAnalysisTimeRanges.
        public var endRange: QuickSightClientTypes.TopicIRFilterOption?
        /// The start range for the ContributionAnalysisTimeRanges.
        public var startRange: QuickSightClientTypes.TopicIRFilterOption?

        public init(
            endRange: QuickSightClientTypes.TopicIRFilterOption? = nil,
            startRange: QuickSightClientTypes.TopicIRFilterOption? = nil
        )
        {
            self.endRange = endRange
            self.startRange = startRange
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicIRContributionAnalysis.
    public struct TopicIRContributionAnalysis: Swift.Sendable {
        /// The direction for the TopicIRContributionAnalysis.
        public var direction: QuickSightClientTypes.ContributionAnalysisDirection?
        /// The factors for a TopicIRContributionAnalysis.
        public var factors: [QuickSightClientTypes.ContributionAnalysisFactor]?
        /// The sort type for the TopicIRContributionAnalysis.
        public var sortType: QuickSightClientTypes.ContributionAnalysisSortType?
        /// The time ranges for the TopicIRContributionAnalysis.
        public var timeRanges: QuickSightClientTypes.ContributionAnalysisTimeRanges?

        public init(
            direction: QuickSightClientTypes.ContributionAnalysisDirection? = nil,
            factors: [QuickSightClientTypes.ContributionAnalysisFactor]? = nil,
            sortType: QuickSightClientTypes.ContributionAnalysisSortType? = nil,
            timeRanges: QuickSightClientTypes.ContributionAnalysisTimeRanges? = nil
        )
        {
            self.direction = direction
            self.factors = factors
            self.sortType = sortType
            self.timeRanges = timeRanges
        }
    }
}

extension QuickSightClientTypes {

    public enum DisplayFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case currency
        case date
        case number
        case percent
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DisplayFormat] {
            return [
                .auto,
                .currency,
                .date,
                .number,
                .percent,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .currency: return "CURRENCY"
            case .date: return "DATE"
            case .number: return "NUMBER"
            case .percent: return "PERCENT"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicNumericSeparatorSymbol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comma
        case dot
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicNumericSeparatorSymbol] {
            return [
                .comma,
                .dot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comma: return "COMMA"
            case .dot: return "DOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a negative format.
    public struct NegativeFormat: Swift.Sendable {
        /// The prefix for a negative format.
        public var `prefix`: Swift.String?
        /// The suffix for a negative format.
        public var suffix: Swift.String?

        public init(
            `prefix`: Swift.String? = nil,
            suffix: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
            self.suffix = suffix
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents additional options for display formatting.
    public struct DisplayFormatOptions: Swift.Sendable {
        /// Determines the blank cell format.
        public var blankCellFormat: Swift.String?
        /// The currency symbol, such as USD.
        public var currencySymbol: Swift.String?
        /// Determines the DateTime format.
        public var dateFormat: Swift.String?
        /// Determines the decimal separator.
        public var decimalSeparator: QuickSightClientTypes.TopicNumericSeparatorSymbol?
        /// Determines the number of fraction digits.
        public var fractionDigits: Swift.Int
        /// Determines the grouping separator.
        public var groupingSeparator: Swift.String?
        /// The negative format.
        public var negativeFormat: QuickSightClientTypes.NegativeFormat?
        /// The prefix value for a display format.
        public var `prefix`: Swift.String?
        /// The suffix value for a display format.
        public var suffix: Swift.String?
        /// The unit scaler. Valid values for this structure are: NONE, AUTO, THOUSANDS, MILLIONS, BILLIONS, and TRILLIONS.
        public var unitScaler: QuickSightClientTypes.NumberScale?
        /// A Boolean value that indicates whether to use blank cell format.
        public var useBlankCellFormat: Swift.Bool
        /// A Boolean value that indicates whether to use grouping.
        public var useGrouping: Swift.Bool

        public init(
            blankCellFormat: Swift.String? = nil,
            currencySymbol: Swift.String? = nil,
            dateFormat: Swift.String? = nil,
            decimalSeparator: QuickSightClientTypes.TopicNumericSeparatorSymbol? = nil,
            fractionDigits: Swift.Int = 0,
            groupingSeparator: Swift.String? = nil,
            negativeFormat: QuickSightClientTypes.NegativeFormat? = nil,
            `prefix`: Swift.String? = nil,
            suffix: Swift.String? = nil,
            unitScaler: QuickSightClientTypes.NumberScale? = nil,
            useBlankCellFormat: Swift.Bool = false,
            useGrouping: Swift.Bool = false
        )
        {
            self.blankCellFormat = blankCellFormat
            self.currencySymbol = currencySymbol
            self.dateFormat = dateFormat
            self.decimalSeparator = decimalSeparator
            self.fractionDigits = fractionDigits
            self.groupingSeparator = groupingSeparator
            self.negativeFormat = negativeFormat
            self.`prefix` = `prefix`
            self.suffix = suffix
            self.unitScaler = unitScaler
            self.useBlankCellFormat = useBlankCellFormat
            self.useGrouping = useGrouping
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a NamedEntityRef.
    public struct NamedEntityRef: Swift.Sendable {
        /// The NamedEntityName for the NamedEntityRef.
        public var namedEntityName: Swift.String?

        public init(
            namedEntityName: Swift.String? = nil
        )
        {
            self.namedEntityName = namedEntityName
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicSortClause.
    public struct TopicSortClause: Swift.Sendable {
        /// The operand for a TopicSortClause.
        public var operand: QuickSightClientTypes.Identifier?
        /// The sort direction for the TopicSortClause.
        public var sortDirection: QuickSightClientTypes.TopicSortDirection?

        public init(
            operand: QuickSightClientTypes.Identifier? = nil,
            sortDirection: QuickSightClientTypes.TopicSortDirection? = nil
        )
        {
            self.operand = operand
            self.sortDirection = sortDirection
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicIRGroupBy.
    public struct TopicIRGroupBy: Swift.Sendable {
        /// The display format for the TopicIRGroupBy.
        public var displayFormat: QuickSightClientTypes.DisplayFormat?
        /// A structure that represents additional options for display formatting.
        public var displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions?
        /// The field name for the TopicIRGroupBy.
        public var fieldName: QuickSightClientTypes.Identifier?
        /// The named entity for the TopicIRGroupBy.
        public var namedEntity: QuickSightClientTypes.NamedEntityRef?
        /// The sort for the TopicIRGroupBy.
        public var sort: QuickSightClientTypes.TopicSortClause?
        /// The time granularity for the TopicIRGroupBy.
        public var timeGranularity: QuickSightClientTypes.TopicTimeGranularity?

        public init(
            displayFormat: QuickSightClientTypes.DisplayFormat? = nil,
            displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions? = nil,
            fieldName: QuickSightClientTypes.Identifier? = nil,
            namedEntity: QuickSightClientTypes.NamedEntityRef? = nil,
            sort: QuickSightClientTypes.TopicSortClause? = nil,
            timeGranularity: QuickSightClientTypes.TopicTimeGranularity? = nil
        )
        {
            self.displayFormat = displayFormat
            self.displayFormatOptions = displayFormatOptions
            self.fieldName = fieldName
            self.namedEntity = namedEntity
            self.sort = sort
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    public enum ComparisonMethodType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case diff
        case diffAsPerc
        case movingAverage
        case percentOfTotal
        case percDiff
        case popCurrentDiff
        case popCurrentDiffAsPerc
        case popOvertimeDiff
        case popOvertimeDiffAsPerc
        case runningSum
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonMethodType] {
            return [
                .diff,
                .diffAsPerc,
                .movingAverage,
                .percentOfTotal,
                .percDiff,
                .popCurrentDiff,
                .popCurrentDiffAsPerc,
                .popOvertimeDiff,
                .popOvertimeDiffAsPerc,
                .runningSum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .diff: return "DIFF"
            case .diffAsPerc: return "DIFF_AS_PERC"
            case .movingAverage: return "MOVING_AVERAGE"
            case .percentOfTotal: return "PERCENT_OF_TOTAL"
            case .percDiff: return "PERC_DIFF"
            case .popCurrentDiff: return "POP_CURRENT_DIFF"
            case .popCurrentDiffAsPerc: return "POP_CURRENT_DIFF_AS_PERC"
            case .popOvertimeDiff: return "POP_OVERTIME_DIFF"
            case .popOvertimeDiffAsPerc: return "POP_OVERTIME_DIFF_AS_PERC"
            case .runningSum: return "RUNNING_SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition of a TopicIRComparisonMethod.
    public struct TopicIRComparisonMethod: Swift.Sendable {
        /// The period for the TopicIRComparisonMethod.
        public var period: QuickSightClientTypes.TopicTimeGranularity?
        /// The type for the TopicIRComparisonMethod.
        public var type: QuickSightClientTypes.ComparisonMethodType?
        /// The window size for the TopicIRComparisonMethod.
        public var windowSize: Swift.Int

        public init(
            period: QuickSightClientTypes.TopicTimeGranularity? = nil,
            type: QuickSightClientTypes.ComparisonMethodType? = nil,
            windowSize: Swift.Int = 0
        )
        {
            self.period = period
            self.type = type
            self.windowSize = windowSize
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicIRMetric.
    public struct TopicIRMetric: Swift.Sendable {
        /// The calculated field references for the TopicIRMetric.
        public var calculatedFieldReferences: [QuickSightClientTypes.Identifier]?
        /// The comparison method for the TopicIRMetric.
        public var comparisonMethod: QuickSightClientTypes.TopicIRComparisonMethod?
        /// The display format for the TopicIRMetric.
        public var displayFormat: QuickSightClientTypes.DisplayFormat?
        /// A structure that represents additional options for display formatting.
        public var displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions?
        /// The expression for the TopicIRMetric.
        public var expression: Swift.String?
        /// The function for the TopicIRMetric.
        public var function: QuickSightClientTypes.AggFunction?
        /// The metric ID for the TopicIRMetric.
        public var metricId: QuickSightClientTypes.Identifier?
        /// The named entity for the TopicIRMetric.
        public var namedEntity: QuickSightClientTypes.NamedEntityRef?
        /// The operands for the TopicIRMetric.
        public var operands: [QuickSightClientTypes.Identifier]?

        public init(
            calculatedFieldReferences: [QuickSightClientTypes.Identifier]? = nil,
            comparisonMethod: QuickSightClientTypes.TopicIRComparisonMethod? = nil,
            displayFormat: QuickSightClientTypes.DisplayFormat? = nil,
            displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions? = nil,
            expression: Swift.String? = nil,
            function: QuickSightClientTypes.AggFunction? = nil,
            metricId: QuickSightClientTypes.Identifier? = nil,
            namedEntity: QuickSightClientTypes.NamedEntityRef? = nil,
            operands: [QuickSightClientTypes.Identifier]? = nil
        )
        {
            self.calculatedFieldReferences = calculatedFieldReferences
            self.comparisonMethod = comparisonMethod
            self.displayFormat = displayFormat
            self.displayFormatOptions = displayFormatOptions
            self.expression = expression
            self.function = function
            self.metricId = metricId
            self.namedEntity = namedEntity
            self.operands = operands
        }
    }
}

extension QuickSightClientTypes.TopicIRMetric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicIRMetric(calculatedFieldReferences: \(Swift.String(describing: calculatedFieldReferences)), comparisonMethod: \(Swift.String(describing: comparisonMethod)), displayFormat: \(Swift.String(describing: displayFormat)), displayFormatOptions: \(Swift.String(describing: displayFormatOptions)), function: \(Swift.String(describing: function)), metricId: \(Swift.String(describing: metricId)), namedEntity: \(Swift.String(describing: namedEntity)), operands: \(Swift.String(describing: operands)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The definition for a VisualOptions.
    public struct VisualOptions: Swift.Sendable {
        /// The type for a VisualOptions.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicIR.
    public struct TopicIR: Swift.Sendable {
        /// The contribution analysis for the TopicIR.
        public var contributionAnalysis: QuickSightClientTypes.TopicIRContributionAnalysis?
        /// The filters for the TopicIR.
        public var filters: [[QuickSightClientTypes.TopicIRFilterOption]]?
        /// The GroupBy list for the TopicIR.
        public var groupByList: [QuickSightClientTypes.TopicIRGroupBy]?
        /// The metrics for the TopicIR.
        public var metrics: [QuickSightClientTypes.TopicIRMetric]?
        /// The sort for the TopicIR.
        public var sort: QuickSightClientTypes.TopicSortClause?
        /// The visual for the TopicIR.
        public var visual: QuickSightClientTypes.VisualOptions?

        public init(
            contributionAnalysis: QuickSightClientTypes.TopicIRContributionAnalysis? = nil,
            filters: [[QuickSightClientTypes.TopicIRFilterOption]]? = nil,
            groupByList: [QuickSightClientTypes.TopicIRGroupBy]? = nil,
            metrics: [QuickSightClientTypes.TopicIRMetric]? = nil,
            sort: QuickSightClientTypes.TopicSortClause? = nil,
            visual: QuickSightClientTypes.VisualOptions? = nil
        )
        {
            self.contributionAnalysis = contributionAnalysis
            self.filters = filters
            self.groupByList = groupByList
            self.metrics = metrics
            self.sort = sort
            self.visual = visual
        }
    }
}

extension QuickSightClientTypes {

    public enum VisualRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complimentary
        case fallback
        case fragment
        case multiIntent
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [VisualRole] {
            return [
                .complimentary,
                .fallback,
                .fragment,
                .multiIntent,
                .primary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complimentary: return "COMPLIMENTARY"
            case .fallback: return "FALLBACK"
            case .fragment: return "FRAGMENT"
            case .multiIntent: return "MULTI_INTENT"
            case .primary: return "PRIMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for the slot.
    public struct Slot: Swift.Sendable {
        /// The slot ID of the slot.
        public var slotId: Swift.String?
        /// The visual ID for the slot.
        public var visualId: Swift.String?

        public init(
            slotId: Swift.String? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.slotId = slotId
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicTemplate.
    public struct TopicTemplate: Swift.Sendable {
        /// The slots for the TopicTemplate.
        public var slots: [QuickSightClientTypes.Slot]?
        /// The template type for the TopicTemplate.
        public var templateType: Swift.String?

        public init(
            slots: [QuickSightClientTypes.Slot]? = nil,
            templateType: Swift.String? = nil
        )
        {
            self.slots = slots
            self.templateType = templateType
        }
    }
}

extension QuickSightClientTypes {

    public enum ReviewedAnswerErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datasetDoesNotExist
        case duplicatedAnswer
        case internalError
        case invalidData
        case invalidDatasetArn
        case missingAnswer
        case missingRequiredFields
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewedAnswerErrorCode] {
            return [
                .datasetDoesNotExist,
                .duplicatedAnswer,
                .internalError,
                .invalidData,
                .invalidDatasetArn,
                .missingAnswer,
                .missingRequiredFields
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datasetDoesNotExist: return "DATASET_DOES_NOT_EXIST"
            case .duplicatedAnswer: return "DUPLICATED_ANSWER"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidData: return "INVALID_DATA"
            case .invalidDatasetArn: return "INVALID_DATASET_ARN"
            case .missingAnswer: return "MISSING_ANSWER"
            case .missingRequiredFields: return "MISSING_REQUIRED_FIELDS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a InvalidTopicReviewedAnswer.
    public struct InvalidTopicReviewedAnswer: Swift.Sendable {
        /// The answer ID for the InvalidTopicReviewedAnswer.
        public var answerId: Swift.String?
        /// The error that is returned for the InvalidTopicReviewedAnswer.
        public var error: QuickSightClientTypes.ReviewedAnswerErrorCode?

        public init(
            answerId: Swift.String? = nil,
            error: QuickSightClientTypes.ReviewedAnswerErrorCode? = nil
        )
        {
            self.answerId = answerId
            self.error = error
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a SucceededTopicReviewedAnswer.
    public struct SucceededTopicReviewedAnswer: Swift.Sendable {
        /// The answer ID for the SucceededTopicReviewedAnswer.
        public var answerId: Swift.String?

        public init(
            answerId: Swift.String? = nil
        )
        {
            self.answerId = answerId
        }
    }
}

public struct BatchCreateTopicReviewedAnswerOutput: Swift.Sendable {
    /// The definition of Answers that are invalid and not created.
    public var invalidAnswers: [QuickSightClientTypes.InvalidTopicReviewedAnswer]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The definition of Answers that are successfully created.
    public var succeededAnswers: [QuickSightClientTypes.SucceededTopicReviewedAnswer]?
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID for the topic reviewed answer that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        invalidAnswers: [QuickSightClientTypes.InvalidTopicReviewedAnswer]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        succeededAnswers: [QuickSightClientTypes.SucceededTopicReviewedAnswer]? = nil,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.invalidAnswers = invalidAnswers
        self.requestId = requestId
        self.status = status
        self.succeededAnswers = succeededAnswers
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct BatchDeleteTopicReviewedAnswerInput: Swift.Sendable {
    /// The Answer IDs of the Answers to be deleted.
    public var answerIds: [Swift.String]?
    /// The ID of the Amazon Web Services account that you want to delete a reviewed answers in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the topic reviewed answer that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        answerIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.answerIds = answerIds
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct BatchDeleteTopicReviewedAnswerOutput: Swift.Sendable {
    /// The definition of Answers that are invalid and not deleted.
    public var invalidAnswers: [QuickSightClientTypes.InvalidTopicReviewedAnswer]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The definition of Answers that are successfully deleted.
    public var succeededAnswers: [QuickSightClientTypes.SucceededTopicReviewedAnswer]?
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic reviewed answer that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        invalidAnswers: [QuickSightClientTypes.InvalidTopicReviewedAnswer]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        succeededAnswers: [QuickSightClientTypes.SucceededTopicReviewedAnswer]? = nil,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.invalidAnswers = invalidAnswers
        self.requestId = requestId
        self.status = status
        self.succeededAnswers = succeededAnswers
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

extension QuickSightClientTypes {

    /// The bookmarks configuration of an embedded dashboard.
    public struct BookmarksConfigurations: Swift.Sendable {
        /// A Boolean value that determines whether a user can bookmark an embedded dashboard.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for tile borders for visuals.
    public struct BorderStyle: Swift.Sendable {
        /// The option to enable display of borders for visuals.
        public var show: Swift.Bool?

        public init(
            show: Swift.Bool? = false
        )
        {
            self.show = show
        }
    }
}

extension QuickSightClientTypes {

    /// A calculated column for a dataset.
    public struct CalculatedColumn: Swift.Sendable {
        /// A unique ID to identify a calculated column. During a dataset update, if the column ID of a calculated column matches that of an existing calculated column, Amazon QuickSight preserves the existing calculated column.
        /// This member is required.
        public var columnId: Swift.String?
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// An expression that defines the calculated column.
        /// This member is required.
        public var expression: Swift.String?

        public init(
            columnId: Swift.String? = nil,
            columnName: Swift.String? = nil,
            expression: Swift.String? = nil
        )
        {
            self.columnId = columnId
            self.columnName = columnName
            self.expression = expression
        }
    }
}

extension QuickSightClientTypes.CalculatedColumn: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CalculatedColumn(columnId: \(Swift.String(describing: columnId)), columnName: \(Swift.String(describing: columnName)), expression: \"CONTENT_REDACTED\")"}
}

/// The resource specified already exists.
public struct ResourceExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
        /// The resource type for this request.
        public internal(set) var resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceType = resourceType
    }
}

public struct CancelIngestionInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

public struct CancelIngestionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum ColumnDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datetime
        case decimal
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .datetime,
                .decimal,
                .integer,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum ColumnDataSubType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixed
        case float
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataSubType] {
            return [
                .fixed,
                .float
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixed: return "FIXED"
            case .float: return "FLOAT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that casts a column to a different type.
    public struct CastColumnTypeOperation: Swift.Sendable {
        /// Column name.
        /// This member is required.
        public var columnName: Swift.String?
        /// When casting a column from string to datetime type, you can supply a string in a format supported by Amazon QuickSight to denote the source data format.
        public var format: Swift.String?
        /// New column data type.
        /// This member is required.
        public var newColumnType: QuickSightClientTypes.ColumnDataType?
        /// The sub data type of the new column. Sub types are only available for decimal columns that are part of a SPICE dataset.
        public var subType: QuickSightClientTypes.ColumnDataSubType?

        public init(
            columnName: Swift.String? = nil,
            format: Swift.String? = nil,
            newColumnType: QuickSightClientTypes.ColumnDataType? = nil,
            subType: QuickSightClientTypes.ColumnDataSubType? = nil
        )
        {
            self.columnName = columnName
            self.format = format
            self.newColumnType = newColumnType
            self.subType = subType
        }
    }
}

extension QuickSightClientTypes {

    public enum CategoryFilterFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case exact
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterFunction] {
            return [
                .contains,
                .exact
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .exact: return "EXACT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum CategoryFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customFilter
        case customFilterList
        case filterList
        case sdkUnknown(Swift.String)

        public static var allCases: [CategoryFilterType] {
            return [
                .customFilter,
                .customFilterList,
                .filterList
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customFilter: return "CUSTOM_FILTER"
            case .customFilterList: return "CUSTOM_FILTER_LIST"
            case .filterList: return "FILTER_LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents the cell value synonym.
    public struct CellValueSynonym: Swift.Sendable {
        /// The cell value.
        public var cellValue: Swift.String?
        /// Other names or aliases for the cell value.
        public var synonyms: [Swift.String]?

        public init(
            cellValue: Swift.String? = nil,
            synonyms: [Swift.String]? = nil
        )
        {
            self.cellValue = cellValue
            self.synonyms = synonyms
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a collective constant.
    public struct CollectiveConstant: Swift.Sendable {
        /// A list of values for the collective constant.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension QuickSightClientTypes {

    public enum ColumnDataRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dimension
        case measure
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataRole] {
            return [
                .dimension,
                .measure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dimension: return "DIMENSION"
            case .measure: return "MEASURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Metadata that contains a description for a column.
    public struct ColumnDescription: Swift.Sendable {
        /// The text of a description for a column.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }
}

extension QuickSightClientTypes.ColumnDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnDescription(text: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum GeoSpatialCountryCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case us
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialCountryCode] {
            return [
                .us
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .us: return "US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Geospatial column group that denotes a hierarchy.
    public struct GeoSpatialColumnGroup: Swift.Sendable {
        /// Columns in this hierarchy.
        /// This member is required.
        public var columns: [Swift.String]?
        /// Country code.
        public var countryCode: QuickSightClientTypes.GeoSpatialCountryCode?
        /// A display name for the hierarchy.
        /// This member is required.
        public var name: Swift.String?

        public init(
            columns: [Swift.String]? = nil,
            countryCode: QuickSightClientTypes.GeoSpatialCountryCode? = nil,
            name: Swift.String? = nil
        )
        {
            self.columns = columns
            self.countryCode = countryCode
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// Groupings of columns that work together in certain Amazon QuickSight features. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnGroup: Swift.Sendable {
        /// Geospatial column group that denotes a hierarchy.
        public var geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup?

        public init(
            geoSpatialColumnGroup: QuickSightClientTypes.GeoSpatialColumnGroup? = nil
        )
        {
            self.geoSpatialColumnGroup = geoSpatialColumnGroup
        }
    }
}

extension QuickSightClientTypes {

    /// A structure describing the name, data type, and geographic role of the columns.
    public struct ColumnGroupColumnSchema: Swift.Sendable {
        /// The name of the column group's column schema.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// The column group schema.
    public struct ColumnGroupSchema: Swift.Sendable {
        /// A structure containing the list of schemas for column group columns.
        public var columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]?
        /// The name of the column group schema.
        public var name: Swift.String?

        public init(
            columnGroupColumnSchemaList: [QuickSightClientTypes.ColumnGroupColumnSchema]? = nil,
            name: Swift.String? = nil
        )
        {
            self.columnGroupColumnSchemaList = columnGroupColumnSchemaList
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    /// A rule defined to grant access on one or more restricted columns. Each dataset can have multiple rules. To create a restricted column, you add it to one or more rules. Each rule must contain at least one column and at least one user or group. To be able to see a restricted column, a user or group needs to be added to a rule for that column.
    public struct ColumnLevelPermissionRule: Swift.Sendable {
        /// An array of column names.
        public var columnNames: [Swift.String]?
        /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or groups.
        public var principals: [Swift.String]?

        public init(
            columnNames: [Swift.String]? = nil,
            principals: [Swift.String]? = nil
        )
        {
            self.columnNames = columnNames
            self.principals = principals
        }
    }
}

extension QuickSightClientTypes {

    public enum ColumnOrderingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greaterIsBetter
        case lesserIsBetter
        case specified
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnOrderingType] {
            return [
                .greaterIsBetter,
                .lesserIsBetter,
                .specified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greaterIsBetter: return "GREATER_IS_BETTER"
            case .lesserIsBetter: return "LESSER_IS_BETTER"
            case .specified: return "SPECIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The column schema.
    public struct ColumnSchema: Swift.Sendable {
        /// The data type of the column schema.
        public var dataType: Swift.String?
        /// The geographic role of the column schema.
        public var geographicRole: Swift.String?
        /// The name of the column schema.
        public var name: Swift.String?

        public init(
            dataType: Swift.String? = nil,
            geographicRole: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.geographicRole = geographicRole
            self.name = name
        }
    }
}

extension QuickSightClientTypes {

    public enum GeoSpatialDataRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case city
        case country
        case county
        case latitude
        case longitude
        case postcode
        case state
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoSpatialDataRole] {
            return [
                .city,
                .country,
                .county,
                .latitude,
                .longitude,
                .postcode,
                .state
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .city: return "CITY"
            case .country: return "COUNTRY"
            case .county: return "COUNTY"
            case .latitude: return "LATITUDE"
            case .longitude: return "LONGITUDE"
            case .postcode: return "POSTCODE"
            case .state: return "STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A tag for a column in a [TagColumnOperation](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html) structure. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct ColumnTag: Swift.Sendable {
        /// A description for a column.
        public var columnDescription: QuickSightClientTypes.ColumnDescription?
        /// A geospatial role for a column.
        public var columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole?

        public init(
            columnDescription: QuickSightClientTypes.ColumnDescription? = nil,
            columnGeographicRole: QuickSightClientTypes.GeoSpatialDataRole? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnGeographicRole = columnGeographicRole
        }
    }
}

extension QuickSightClientTypes {

    public enum ColumnTagName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case columnDescription
        case columnGeographicRole
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnTagName] {
            return [
                .columnDescription,
                .columnGeographicRole
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .columnDescription: return "COLUMN_DESCRIPTION"
            case .columnGeographicRole: return "COLUMN_GEOGRAPHIC_ROLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum UndefinedSpecifiedValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case least
        case most
        case sdkUnknown(Swift.String)

        public static var allCases: [UndefinedSpecifiedValueType] {
            return [
                .least,
                .most
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .least: return "LEAST"
            case .most: return "MOST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a comparative order.
    public struct ComparativeOrder: Swift.Sendable {
        /// The list of columns to be used in the ordering.
        public var specifedOrder: [Swift.String]?
        /// The treat of undefined specified values. Valid values for this structure are LEAST and MOST.
        public var treatUndefinedSpecifiedValues: QuickSightClientTypes.UndefinedSpecifiedValueType?
        /// The ordering type for a column. Valid values for this structure are GREATER_IS_BETTER, LESSER_IS_BETTER and SPECIFIED.
        public var useOrdering: QuickSightClientTypes.ColumnOrderingType?

        public init(
            specifedOrder: [Swift.String]? = nil,
            treatUndefinedSpecifiedValues: QuickSightClientTypes.UndefinedSpecifiedValueType? = nil,
            useOrdering: QuickSightClientTypes.ColumnOrderingType? = nil
        )
        {
            self.specifedOrder = specifedOrder
            self.treatUndefinedSpecifiedValues = treatUndefinedSpecifiedValues
            self.useOrdering = useOrdering
        }
    }
}

/// A resource is already in a state that indicates an operation is happening that must complete before a new update can be applied.
public struct ConcurrentUpdatingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentUpdatingException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// This resource is currently unavailable.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
        /// The resource type for this request.
        public internal(set) var resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceType = resourceType
    }
}

public struct CreateAccountCustomizationInput: Swift.Sendable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region. You can add these to an Amazon Web Services account and a QuickSight namespace. For example, you can add a default theme by setting AccountCustomization to the midnight theme: "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight::aws:theme/MIDNIGHT" }. Or, you can add a custom theme by specifying "AccountCustomization": { "DefaultTheme": "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639" }.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to add customizations to.
    public var namespace: Swift.String?
    /// A list of the tags that you want to attach to this resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.tags = tags
    }
}

public struct CreateAccountCustomizationOutput: Swift.Sendable {
    /// The Amazon QuickSight customizations you're adding in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the customization that you created for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to customize Amazon QuickSight for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization you're creating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

/// One or more preconditions aren't met.
public struct PreconditionNotMetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionNotMetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct CreateAccountSubscriptionInput: Swift.Sendable {
    /// The name of your Amazon QuickSight account. This name is unique over all of Amazon Web Services, and it appears only when users sign in. You can't change AccountName value after the Amazon QuickSight account is created.
    /// This member is required.
    public var accountName: Swift.String?
    /// The name of your Active Directory. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
    public var activeDirectoryName: Swift.String?
    /// The admin group associated with your Active Directory or IAM Identity Center account. Either this field or the AdminProGroup field is required if ACTIVE_DIRECTORY or IAM_IDENTITY_CENTER is the selected authentication method of the new Amazon QuickSight account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var adminGroup: [Swift.String]?
    /// The admin pro group associated with your Active Directory or IAM Identity Center account. Either this field or the AdminGroup field is required if ACTIVE_DIRECTORY or IAM_IDENTITY_CENTER is the selected authentication method of the new Amazon QuickSight account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var adminProGroup: [Swift.String]?
    /// The method that you want to use to authenticate your Amazon QuickSight account. If you choose ACTIVE_DIRECTORY, provide an ActiveDirectoryName and an AdminGroup associated with your Active Directory. If you choose IAM_IDENTITY_CENTER, provide an AdminGroup associated with your IAM Identity Center account.
    /// This member is required.
    public var authenticationMethod: QuickSightClientTypes.AuthenticationMethodOption?
    /// The author group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var authorGroup: [Swift.String]?
    /// The author pro group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var authorProGroup: [Swift.String]?
    /// The Amazon Web Services account ID of the account that you're using to create your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A 10-digit phone number for the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var contactNumber: Swift.String?
    /// The ID of the Active Directory that is associated with your Amazon QuickSight account.
    public var directoryId: Swift.String?
    /// The edition of Amazon QuickSight that you want your account to have. Currently, you can choose from ENTERPRISE or ENTERPRISE_AND_Q. If you choose ENTERPRISE_AND_Q, the following parameters are required:
    ///
    /// * FirstName
    ///
    /// * LastName
    ///
    /// * EmailAddress
    ///
    /// * ContactNumber
    public var edition: QuickSightClientTypes.Edition?
    /// The email address of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var emailAddress: Swift.String?
    /// The first name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var firstName: Swift.String?
    /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
    public var iamIdentityCenterInstanceArn: Swift.String?
    /// The last name of the author of the Amazon QuickSight account to use for future communications. This field is required if ENTERPPRISE_AND_Q is the selected edition of the new Amazon QuickSight account.
    public var lastName: Swift.String?
    /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon QuickSight account or Amazon QuickSight subscription.
    /// This member is required.
    public var notificationEmail: Swift.String?
    /// The reader group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var readerGroup: [Swift.String]?
    /// The reader pro group associated with your Active Directory or IAM Identity Center account. For more information about using IAM Identity Center in Amazon QuickSight, see [Using IAM Identity Center with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html) in the Amazon QuickSight User Guide. For more information about using Active Directory in Amazon QuickSight, see [Using Active Directory with Amazon QuickSight Enterprise Edition](https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html) in the Amazon QuickSight User Guide.
    public var readerProGroup: [Swift.String]?
    /// The realm of the Active Directory that is associated with your Amazon QuickSight account. This field is required if ACTIVE_DIRECTORY is the selected authentication method of the new Amazon QuickSight account.
    public var realm: Swift.String?

    public init(
        accountName: Swift.String? = nil,
        activeDirectoryName: Swift.String? = nil,
        adminGroup: [Swift.String]? = nil,
        adminProGroup: [Swift.String]? = nil,
        authenticationMethod: QuickSightClientTypes.AuthenticationMethodOption? = nil,
        authorGroup: [Swift.String]? = nil,
        authorProGroup: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        contactNumber: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        edition: QuickSightClientTypes.Edition? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        iamIdentityCenterInstanceArn: Swift.String? = nil,
        lastName: Swift.String? = nil,
        notificationEmail: Swift.String? = nil,
        readerGroup: [Swift.String]? = nil,
        readerProGroup: [Swift.String]? = nil,
        realm: Swift.String? = nil
    )
    {
        self.accountName = accountName
        self.activeDirectoryName = activeDirectoryName
        self.adminGroup = adminGroup
        self.adminProGroup = adminProGroup
        self.authenticationMethod = authenticationMethod
        self.authorGroup = authorGroup
        self.authorProGroup = authorProGroup
        self.awsAccountId = awsAccountId
        self.contactNumber = contactNumber
        self.directoryId = directoryId
        self.edition = edition
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.iamIdentityCenterInstanceArn = iamIdentityCenterInstanceArn
        self.lastName = lastName
        self.notificationEmail = notificationEmail
        self.readerGroup = readerGroup
        self.readerProGroup = readerProGroup
        self.realm = realm
    }
}

extension QuickSightClientTypes {

    /// A SignupResponse object that contains a summary of a newly created account.
    public struct SignupResponse: Swift.Sendable {
        /// The name of your Amazon QuickSight account.
        public var accountName: Swift.String?
        /// The type of Active Directory that is being used to authenticate the Amazon QuickSight account. Valid values are SIMPLE_AD, AD_CONNECTOR, and MICROSOFT_AD.
        public var directoryType: Swift.String?
        /// A Boolean that is TRUE if the Amazon QuickSight uses IAM as an authentication method.
        public var iamUser: Swift.Bool
        /// The user login name for your Amazon QuickSight account.
        public var userLoginName: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            directoryType: Swift.String? = nil,
            iamUser: Swift.Bool = false,
            userLoginName: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.directoryType = directoryType
            self.iamUser = iamUser
            self.userLoginName = userLoginName
        }
    }
}

public struct CreateAccountSubscriptionOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A SignupResponse object that returns information about a newly created Amazon QuickSight account.
    public var signupResponse: QuickSightClientTypes.SignupResponse?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        signupResponse: QuickSightClientTypes.SignupResponse? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.signupResponse = signupResponse
        self.status = status
    }
}

/// A limit is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
        /// Limit exceeded.
        public internal(set) var resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceType: QuickSightClientTypes.ExceptionResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
        self.properties.resourceType = resourceType
    }
}

/// This error indicates that you are calling an operation on an Amazon QuickSight subscription where the edition doesn't include support for that operation. Amazon Amazon QuickSight currently has Standard Edition and Enterprise Edition. Not every operation and capability is available in every edition.
public struct UnsupportedUserEditionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedUserEditionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    /// A date-time parameter.
    public struct DateTimeParameter: Swift.Sendable {
        /// A display name for the date-time parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the date-time parameter.
        /// This member is required.
        public var values: [Foundation.Date]?

        public init(
            name: Swift.String? = nil,
            values: [Foundation.Date]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension QuickSightClientTypes.DateTimeParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DateTimeParameter(name: \(Swift.String(describing: name)), values: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A decimal parameter.
    public struct DecimalParameter: Swift.Sendable {
        /// A display name for the decimal parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the decimal parameter.
        /// This member is required.
        public var values: [Swift.Double]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension QuickSightClientTypes.DecimalParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DecimalParameter(name: \(Swift.String(describing: name)), values: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// An integer parameter.
    public struct IntegerParameter: Swift.Sendable {
        /// The name of the integer parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values for the integer parameter.
        /// This member is required.
        public var values: [Swift.Int]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.Int]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension QuickSightClientTypes.IntegerParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntegerParameter(name: \(Swift.String(describing: name)), values: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A string parameter.
    public struct StringParameter: Swift.Sendable {
        /// A display name for a string parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The values of a string parameter.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension QuickSightClientTypes.StringParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StringParameter(name: \(Swift.String(describing: name)), values: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A list of Amazon QuickSight parameters and the list's override values.
    public struct Parameters: Swift.Sendable {
        /// The parameters that have a data type of date-time.
        public var dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]?
        /// The parameters that have a data type of decimal.
        public var decimalParameters: [QuickSightClientTypes.DecimalParameter]?
        /// The parameters that have a data type of integer.
        public var integerParameters: [QuickSightClientTypes.IntegerParameter]?
        /// The parameters that have a data type of string.
        public var stringParameters: [QuickSightClientTypes.StringParameter]?

        public init(
            dateTimeParameters: [QuickSightClientTypes.DateTimeParameter]? = nil,
            decimalParameters: [QuickSightClientTypes.DecimalParameter]? = nil,
            integerParameters: [QuickSightClientTypes.IntegerParameter]? = nil,
            stringParameters: [QuickSightClientTypes.StringParameter]? = nil
        )
        {
            self.dateTimeParameters = dateTimeParameters
            self.decimalParameters = decimalParameters
            self.integerParameters = integerParameters
            self.stringParameters = stringParameters
        }
    }
}

extension QuickSightClientTypes {

    /// Permission for the resource.
    public struct ResourcePermission: Swift.Sendable {
        /// The IAM action to grant or revoke permissions on.
        /// This member is required.
        public var actions: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the principal. This can be one of the following:
        ///
        /// * The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)
        ///
        /// * The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)
        ///
        /// * The ARN of an Amazon Web Services account root: This is an IAM ARN rather than a QuickSight ARN. Use this option only to share resources (templates) across Amazon Web Services accounts. (This is less common.)
        /// This member is required.
        public var principal: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            principal: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principal = principal
        }
    }
}

extension QuickSightClientTypes {

    public enum ValidationStrategyMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lenient
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationStrategyMode] {
            return [
                .lenient,
                .strict
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lenient: return "LENIENT"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The option to relax the validation that is required to create and update analyses, dashboards, and templates with definition objects. When you set this value to LENIENT, validation is skipped for specific errors.
    public struct ValidationStrategy: Swift.Sendable {
        /// The mode of validation for the asset to be created or updated. When you set this value to STRICT, strict validation for every error is enforced. When you set this value to LENIENT, validation is skipped for specific UI errors.
        /// This member is required.
        public var mode: QuickSightClientTypes.ValidationStrategyMode?

        public init(
            mode: QuickSightClientTypes.ValidationStrategyMode? = nil
        )
        {
            self.mode = mode
        }
    }
}

public struct CreateAnalysisInput: Swift.Sendable {
    /// The ID for the analysis that you're creating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you are creating an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// When you create the analysis, Amazon QuickSight adds the analysis to these folders.
    public var folderArns: [Swift.String]?
    /// A descriptive name for the analysis that you're creating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that describes the principals and the resource-level permissions on an analysis. You can use the Permissions structure to grant permissions by providing a list of Identity and Access Management (IAM) action information for each principal listed by Amazon Resource Name (ARN). To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A source entity to use for the analysis that you're creating. This metadata structure contains details that describe a source template and one or more datasets. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the analysis.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The ARN for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?
    /// The option to relax the validation needed to create an analysis with definition objects. This skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        folderArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.folderArns = folderArns
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
        self.validationStrategy = validationStrategy
    }
}

public struct CreateAnalysisOutput: Swift.Sendable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN for the analysis.
    public var arn: Swift.String?
    /// The status of the creation of the analysis.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    /// A transform operation that creates calculated columns. Columns created in one such operation form a lexical closure.
    public struct CreateColumnsOperation: Swift.Sendable {
        /// Calculated columns to create.
        /// This member is required.
        public var columns: [QuickSightClientTypes.CalculatedColumn]?

        public init(
            columns: [QuickSightClientTypes.CalculatedColumn]? = nil
        )
        {
            self.columns = columns
        }
    }
}

extension QuickSightClientTypes {

    /// The drill down options for data points in a dashbaord.
    public struct DataPointDrillUpDownOption: Swift.Sendable {
        /// The status of the drill down options of data points.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The data point menu options of a dashboard.
    public struct DataPointMenuLabelOption: Swift.Sendable {
        /// The status of the data point menu options.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The data point tooltip options.
    public struct DataPointTooltipOption: Swift.Sendable {
        /// The status of the data point tool tip options.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// Export to .csv option.
    public struct ExportToCSVOption: Swift.Sendable {
        /// Availability status.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// Determines whether or not hidden fields are visible on exported dashbaords.
    public struct ExportWithHiddenFieldsOption: Swift.Sendable {
        /// The status of the export with hidden fields options.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    public enum DashboardUIState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collapsed
        case expanded
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardUIState] {
            return [
                .collapsed,
                .expanded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collapsed: return "COLLAPSED"
            case .expanded: return "EXPANDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Sheet controls option.
    public struct SheetControlsOption: Swift.Sendable {
        /// Visibility state.
        public var visibilityState: QuickSightClientTypes.DashboardUIState?

        public init(
            visibilityState: QuickSightClientTypes.DashboardUIState? = nil
        )
        {
            self.visibilityState = visibilityState
        }
    }
}

extension QuickSightClientTypes {

    /// The sheet layout maximization options of a dashbaord.
    public struct SheetLayoutElementMaximizationOption: Swift.Sendable {
        /// The status of the sheet layout maximization options of a dashbaord.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The axis sort options for a visual.
    public struct VisualAxisSortOption: Swift.Sendable {
        /// The availaiblity status of a visual's axis sort options.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// Determines if hidden fields are included in an exported dashboard.
    public struct ExportHiddenFieldsOption: Swift.Sendable {
        /// The status of the export hidden fields options of a dashbaord.
        public var availabilityStatus: QuickSightClientTypes.DashboardBehavior?

        public init(
            availabilityStatus: QuickSightClientTypes.DashboardBehavior? = nil
        )
        {
            self.availabilityStatus = availabilityStatus
        }
    }
}

extension QuickSightClientTypes {

    /// The visual publish options of a visual in a dashboard
    public struct DashboardVisualPublishOptions: Swift.Sendable {
        /// Determines if hidden fields are included in an exported dashboard.
        public var exportHiddenFieldsOption: QuickSightClientTypes.ExportHiddenFieldsOption?

        public init(
            exportHiddenFieldsOption: QuickSightClientTypes.ExportHiddenFieldsOption? = nil
        )
        {
            self.exportHiddenFieldsOption = exportHiddenFieldsOption
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard publish options.
    public struct DashboardPublishOptions: Swift.Sendable {
        /// Ad hoc (one-time) filtering option.
        public var adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption?
        /// The drill-down options of data points in a dashboard.
        public var dataPointDrillUpDownOption: QuickSightClientTypes.DataPointDrillUpDownOption?
        /// The data point menu label options of a dashboard.
        public var dataPointMenuLabelOption: QuickSightClientTypes.DataPointMenuLabelOption?
        /// The data point tool tip options of a dashboard.
        public var dataPointTooltipOption: QuickSightClientTypes.DataPointTooltipOption?
        /// Export to .csv option.
        public var exportToCSVOption: QuickSightClientTypes.ExportToCSVOption?
        /// Determines if hidden fields are exported with a dashboard.
        public var exportWithHiddenFieldsOption: QuickSightClientTypes.ExportWithHiddenFieldsOption?
        /// Sheet controls option.
        public var sheetControlsOption: QuickSightClientTypes.SheetControlsOption?
        /// The sheet layout maximization options of a dashbaord.
        public var sheetLayoutElementMaximizationOption: QuickSightClientTypes.SheetLayoutElementMaximizationOption?
        /// The axis sort options of a dashboard.
        public var visualAxisSortOption: QuickSightClientTypes.VisualAxisSortOption?
        /// The menu options of a visual in a dashboard.
        public var visualMenuOption: QuickSightClientTypes.VisualMenuOption?
        /// The visual publish options of a visual in a dashboard.
        @available(*, deprecated, message: "VisualPublishOptions property will reach its end of standard support in a future release. To perform this action, use ExportWithHiddenFields.")
        public var visualPublishOptions: QuickSightClientTypes.DashboardVisualPublishOptions?

        public init(
            adHocFilteringOption: QuickSightClientTypes.AdHocFilteringOption? = nil,
            dataPointDrillUpDownOption: QuickSightClientTypes.DataPointDrillUpDownOption? = nil,
            dataPointMenuLabelOption: QuickSightClientTypes.DataPointMenuLabelOption? = nil,
            dataPointTooltipOption: QuickSightClientTypes.DataPointTooltipOption? = nil,
            exportToCSVOption: QuickSightClientTypes.ExportToCSVOption? = nil,
            exportWithHiddenFieldsOption: QuickSightClientTypes.ExportWithHiddenFieldsOption? = nil,
            sheetControlsOption: QuickSightClientTypes.SheetControlsOption? = nil,
            sheetLayoutElementMaximizationOption: QuickSightClientTypes.SheetLayoutElementMaximizationOption? = nil,
            visualAxisSortOption: QuickSightClientTypes.VisualAxisSortOption? = nil,
            visualMenuOption: QuickSightClientTypes.VisualMenuOption? = nil,
            visualPublishOptions: QuickSightClientTypes.DashboardVisualPublishOptions? = nil
        )
        {
            self.adHocFilteringOption = adHocFilteringOption
            self.dataPointDrillUpDownOption = dataPointDrillUpDownOption
            self.dataPointMenuLabelOption = dataPointMenuLabelOption
            self.dataPointTooltipOption = dataPointTooltipOption
            self.exportToCSVOption = exportToCSVOption
            self.exportWithHiddenFieldsOption = exportWithHiddenFieldsOption
            self.sheetControlsOption = sheetControlsOption
            self.sheetLayoutElementMaximizationOption = sheetLayoutElementMaximizationOption
            self.visualAxisSortOption = visualAxisSortOption
            self.visualMenuOption = visualMenuOption
            self.visualPublishOptions = visualPublishOptions
        }
    }
}

extension QuickSightClientTypes {

    /// The contents of a dashboard.
    public struct DashboardVersionDefinition: Swift.Sendable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the dashboard.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of dashboard-level column configurations. Column configurations are used to set the default formatting for a column that is used throughout a dashboard.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset identifier declarations. With this mapping,you can use dataset identifiers instead of dataset Amazon Resource Names (ARNs) throughout the dashboard's sub-structures.
        /// This member is required.
        public var dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]?
        /// The filter definitions for a dashboard. For more information, see [Filtering Data in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// An array of option definitions for a dashboard.
        public var options: QuickSightClientTypes.AssetOptions?
        /// The parameter declarations for a dashboard. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// An array of sheet definitions for a dashboard.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init(
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetIdentifierDeclarations: [QuickSightClientTypes.DataSetIdentifierDeclaration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            options: QuickSightClientTypes.AssetOptions? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetIdentifierDeclarations = dataSetIdentifierDeclarations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.sheets = sheets
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the configuration of a shareable link to the dashboard.
    public struct LinkSharingConfiguration: Swift.Sendable {
        /// A structure that contains the permissions of a shareable link.
        public var permissions: [QuickSightClientTypes.ResourcePermission]?

        public init(
            permissions: [QuickSightClientTypes.ResourcePermission]? = nil
        )
        {
            self.permissions = permissions
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard source template.
    public struct DashboardSourceTemplate: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Dataset references.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init(
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard source entity.
    public struct DashboardSourceEntity: Swift.Sendable {
        /// Source template.
        public var sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate?

        public init(
            sourceTemplate: QuickSightClientTypes.DashboardSourceTemplate? = nil
        )
        {
            self.sourceTemplate = sourceTemplate
        }
    }
}

public struct CreateDashboardInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account where you want to create the dashboard.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// When you create the dashboard, Amazon QuickSight adds the dashboard to these folders.
    public var folderArns: [Swift.String]?
    /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
    public var linkEntities: [Swift.String]?
    /// A structure that contains the permissions of a shareable link to the dashboard.
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters for the creation of the dashboard, which you want to use to override the default settings. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A structure that contains the permissions of the dashboard. You can use this structure for granting permissions by providing a list of IAM action information for each principal ARN. To specify no permissions, omit the permissions list.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only create a dashboard from a template, so you use a SourceTemplate entity. If you need to create a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplateARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dashboard.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that is used in the source entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// The option to relax the validation needed to create a dashboard with definition objects. This option skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        folderArns: [Swift.String]? = nil,
        linkEntities: [Swift.String]? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeArn: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.definition = definition
        self.folderArns = folderArns
        self.linkEntities = linkEntities
        self.linkSharingConfiguration = linkSharingConfiguration
        self.name = name
        self.parameters = parameters
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.themeArn = themeArn
        self.validationStrategy = validationStrategy
        self.versionDescription = versionDescription
    }
}

public struct CreateDashboardOutput: Swift.Sendable {
    /// The ARN of the dashboard.
    public var arn: Swift.String?
    /// The status of the dashboard creation request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number of the first version that is created.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

extension QuickSightClientTypes {

    /// The default values of a date time parameter.
    public struct DateTimeDatasetParameterDefaultValues: Swift.Sendable {
        /// A list of static default values for a given date time parameter.
        public var staticValues: [Foundation.Date]?

        public init(
            staticValues: [Foundation.Date]? = nil
        )
        {
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes {

    /// The value type of the parameter. The value type is used to validate the parameter before it is evaluated.
    public enum DatasetParameterValueType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiValued
        case singleValued
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetParameterValueType] {
            return [
                .multiValued,
                .singleValued
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiValued: return "MULTI_VALUED"
            case .singleValued: return "SINGLE_VALUED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A date time parameter for a dataset.
    public struct DateTimeDatasetParameter: Swift.Sendable {
        /// A list of default values for a given date time parameter. This structure only accepts static values.
        public var defaultValues: QuickSightClientTypes.DateTimeDatasetParameterDefaultValues?
        /// An identifier for the parameter that is created in the dataset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the date time parameter that is created in the dataset.
        /// This member is required.
        public var name: Swift.String?
        /// The time granularity of the date time parameter.
        public var timeGranularity: QuickSightClientTypes.TimeGranularity?
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        /// This member is required.
        public var valueType: QuickSightClientTypes.DatasetParameterValueType?

        public init(
            defaultValues: QuickSightClientTypes.DateTimeDatasetParameterDefaultValues? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            timeGranularity: QuickSightClientTypes.TimeGranularity? = nil,
            valueType: QuickSightClientTypes.DatasetParameterValueType? = nil
        )
        {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.timeGranularity = timeGranularity
            self.valueType = valueType
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of a decimal parameter.
    public struct DecimalDatasetParameterDefaultValues: Swift.Sendable {
        /// A list of static default values for a given decimal parameter.
        public var staticValues: [Swift.Double]?

        public init(
            staticValues: [Swift.Double]? = nil
        )
        {
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes {

    /// A decimal parameter for a dataset.
    public struct DecimalDatasetParameter: Swift.Sendable {
        /// A list of default values for a given decimal parameter. This structure only accepts static values.
        public var defaultValues: QuickSightClientTypes.DecimalDatasetParameterDefaultValues?
        /// An identifier for the decimal parameter created in the dataset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the decimal parameter that is created in the dataset.
        /// This member is required.
        public var name: Swift.String?
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        /// This member is required.
        public var valueType: QuickSightClientTypes.DatasetParameterValueType?

        public init(
            defaultValues: QuickSightClientTypes.DecimalDatasetParameterDefaultValues? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            valueType: QuickSightClientTypes.DatasetParameterValueType? = nil
        )
        {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of an integer parameter.
    public struct IntegerDatasetParameterDefaultValues: Swift.Sendable {
        /// A list of static default values for a given integer parameter.
        public var staticValues: [Swift.Int]?

        public init(
            staticValues: [Swift.Int]? = nil
        )
        {
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes {

    /// An integer parameter for a dataset.
    public struct IntegerDatasetParameter: Swift.Sendable {
        /// A list of default values for a given integer parameter. This structure only accepts static values.
        public var defaultValues: QuickSightClientTypes.IntegerDatasetParameterDefaultValues?
        /// An identifier for the integer parameter created in the dataset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the integer parameter that is created in the dataset.
        /// This member is required.
        public var name: Swift.String?
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        /// This member is required.
        public var valueType: QuickSightClientTypes.DatasetParameterValueType?

        public init(
            defaultValues: QuickSightClientTypes.IntegerDatasetParameterDefaultValues? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            valueType: QuickSightClientTypes.DatasetParameterValueType? = nil
        )
        {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }
    }
}

extension QuickSightClientTypes {

    /// The default values of a string parameter.
    public struct StringDatasetParameterDefaultValues: Swift.Sendable {
        /// A list of static default values for a given string parameter.
        public var staticValues: [Swift.String]?

        public init(
            staticValues: [Swift.String]? = nil
        )
        {
            self.staticValues = staticValues
        }
    }
}

extension QuickSightClientTypes {

    /// A string parameter for a dataset.
    public struct StringDatasetParameter: Swift.Sendable {
        /// A list of default values for a given string dataset parameter type. This structure only accepts static values.
        public var defaultValues: QuickSightClientTypes.StringDatasetParameterDefaultValues?
        /// An identifier for the string parameter that is created in the dataset.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the string parameter that is created in the dataset.
        /// This member is required.
        public var name: Swift.String?
        /// The value type of the dataset parameter. Valid values are single value or multi value.
        /// This member is required.
        public var valueType: QuickSightClientTypes.DatasetParameterValueType?

        public init(
            defaultValues: QuickSightClientTypes.StringDatasetParameterDefaultValues? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            valueType: QuickSightClientTypes.DatasetParameterValueType? = nil
        )
        {
            self.defaultValues = defaultValues
            self.id = id
            self.name = name
            self.valueType = valueType
        }
    }
}

extension QuickSightClientTypes {

    /// A parameter that is created in a dataset. The parameter can be a string, integer, decimal, or datetime data type.
    public struct DatasetParameter: Swift.Sendable {
        /// A date time parameter that is created in the dataset.
        public var dateTimeDatasetParameter: QuickSightClientTypes.DateTimeDatasetParameter?
        /// A decimal parameter that is created in the dataset.
        public var decimalDatasetParameter: QuickSightClientTypes.DecimalDatasetParameter?
        /// An integer parameter that is created in the dataset.
        public var integerDatasetParameter: QuickSightClientTypes.IntegerDatasetParameter?
        /// A string parameter that is created in the dataset.
        public var stringDatasetParameter: QuickSightClientTypes.StringDatasetParameter?

        public init(
            dateTimeDatasetParameter: QuickSightClientTypes.DateTimeDatasetParameter? = nil,
            decimalDatasetParameter: QuickSightClientTypes.DecimalDatasetParameter? = nil,
            integerDatasetParameter: QuickSightClientTypes.IntegerDatasetParameter? = nil,
            stringDatasetParameter: QuickSightClientTypes.StringDatasetParameter? = nil
        )
        {
            self.dateTimeDatasetParameter = dateTimeDatasetParameter
            self.decimalDatasetParameter = decimalDatasetParameter
            self.integerDatasetParameter = integerDatasetParameter
            self.stringDatasetParameter = stringDatasetParameter
        }
    }
}

extension QuickSightClientTypes {

    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public struct DataSetUsageConfiguration: Swift.Sendable {
        /// An option that controls whether a child dataset of a direct query can use this dataset as a source.
        public var disableUseAsDirectQuerySource: Swift.Bool
        /// An option that controls whether a child dataset that's stored in QuickSight can use this dataset as a source.
        public var disableUseAsImportedSource: Swift.Bool

        public init(
            disableUseAsDirectQuerySource: Swift.Bool = false,
            disableUseAsImportedSource: Swift.Bool = false
        )
        {
            self.disableUseAsDirectQuerySource = disableUseAsDirectQuerySource
            self.disableUseAsImportedSource = disableUseAsImportedSource
        }
    }
}

extension QuickSightClientTypes {

    /// A FieldFolder element is a folder that contains fields and nested subfolders.
    public struct FieldFolder: Swift.Sendable {
        /// A folder has a list of columns. A column can only be in one folder.
        public var columns: [Swift.String]?
        /// The description for a field folder.
        public var description: Swift.String?

        public init(
            columns: [Swift.String]? = nil,
            description: Swift.String? = nil
        )
        {
            self.columns = columns
            self.description = description
        }
    }
}

extension QuickSightClientTypes {

    public enum DataSetImportMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directQuery
        case spice
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetImportMode] {
            return [
                .directQuery,
                .spice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directQuery: return "DIRECT_QUERY"
            case .spice: return "SPICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that filters rows based on a condition.
    public struct FilterOperation: Swift.Sendable {
        /// An expression that must evaluate to a Boolean value. Rows for which the expression evaluates to true are kept in the dataset.
        /// This member is required.
        public var conditionExpression: Swift.String?

        public init(
            conditionExpression: Swift.String? = nil
        )
        {
            self.conditionExpression = conditionExpression
        }
    }
}

extension QuickSightClientTypes.FilterOperation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FilterOperation(conditionExpression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The configuration that overrides the existing default values for a dataset parameter that is inherited from another dataset.
    public struct NewDefaultValues: Swift.Sendable {
        /// A list of static default values for a given date time parameter.
        public var dateTimeStaticValues: [Foundation.Date]?
        /// A list of static default values for a given decimal parameter.
        public var decimalStaticValues: [Swift.Double]?
        /// A list of static default values for a given integer parameter.
        public var integerStaticValues: [Swift.Int]?
        /// A list of static default values for a given string parameter.
        public var stringStaticValues: [Swift.String]?

        public init(
            dateTimeStaticValues: [Foundation.Date]? = nil,
            decimalStaticValues: [Swift.Double]? = nil,
            integerStaticValues: [Swift.Int]? = nil,
            stringStaticValues: [Swift.String]? = nil
        )
        {
            self.dateTimeStaticValues = dateTimeStaticValues
            self.decimalStaticValues = decimalStaticValues
            self.integerStaticValues = integerStaticValues
            self.stringStaticValues = stringStaticValues
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that overrides the dataset parameter values that are defined in another dataset.
    public struct OverrideDatasetParameterOperation: Swift.Sendable {
        /// The new default values for the parameter.
        public var newDefaultValues: QuickSightClientTypes.NewDefaultValues?
        /// The new name for the parameter.
        public var newParameterName: Swift.String?
        /// The name of the parameter to be overridden with different values.
        /// This member is required.
        public var parameterName: Swift.String?

        public init(
            newDefaultValues: QuickSightClientTypes.NewDefaultValues? = nil,
            newParameterName: Swift.String? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.newDefaultValues = newDefaultValues
            self.newParameterName = newParameterName
            self.parameterName = parameterName
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that projects columns. Operations that come after a projection can only refer to projected columns.
    public struct ProjectOperation: Swift.Sendable {
        /// Projected columns.
        /// This member is required.
        public var projectedColumns: [Swift.String]?

        public init(
            projectedColumns: [Swift.String]? = nil
        )
        {
            self.projectedColumns = projectedColumns
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that renames a column.
    public struct RenameColumnOperation: Swift.Sendable {
        /// The name of the column to be renamed.
        /// This member is required.
        public var columnName: Swift.String?
        /// The new name for the column.
        /// This member is required.
        public var newColumnName: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            newColumnName: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.newColumnName = newColumnName
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that tags a column with additional information.
    public struct TagColumnOperation: Swift.Sendable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The dataset column tag, currently only used for geospatial type tagging. This is not tags for the Amazon Web Services tagging feature.
        /// This member is required.
        public var tags: [QuickSightClientTypes.ColumnTag]?

        public init(
            columnName: Swift.String? = nil,
            tags: [QuickSightClientTypes.ColumnTag]? = nil
        )
        {
            self.columnName = columnName
            self.tags = tags
        }
    }
}

extension QuickSightClientTypes {

    /// A transform operation that removes tags associated with a column.
    public struct UntagColumnOperation: Swift.Sendable {
        /// The column that this operation acts on.
        /// This member is required.
        public var columnName: Swift.String?
        /// The column tags to remove from this column.
        /// This member is required.
        public var tagNames: [QuickSightClientTypes.ColumnTagName]?

        public init(
            columnName: Swift.String? = nil,
            tagNames: [QuickSightClientTypes.ColumnTagName]? = nil
        )
        {
            self.columnName = columnName
            self.tagNames = tagNames
        }
    }
}

extension QuickSightClientTypes {

    /// A data transformation on a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum TransformOperation: Swift.Sendable {
        /// An operation that projects columns. Operations that come after a projection can only refer to projected columns.
        case projectoperation(QuickSightClientTypes.ProjectOperation)
        /// An operation that filters rows based on some condition.
        case filteroperation(QuickSightClientTypes.FilterOperation)
        /// An operation that creates calculated columns. Columns created in one such operation form a lexical closure.
        case createcolumnsoperation(QuickSightClientTypes.CreateColumnsOperation)
        /// An operation that renames a column.
        case renamecolumnoperation(QuickSightClientTypes.RenameColumnOperation)
        /// A transform operation that casts a column to a different type.
        case castcolumntypeoperation(QuickSightClientTypes.CastColumnTypeOperation)
        /// An operation that tags a column with additional information.
        case tagcolumnoperation(QuickSightClientTypes.TagColumnOperation)
        /// A transform operation that removes tags associated with a column.
        case untagcolumnoperation(QuickSightClientTypes.UntagColumnOperation)
        /// A transform operation that overrides the dataset parameter values that are defined in another dataset.
        case overridedatasetparameteroperation(QuickSightClientTypes.OverrideDatasetParameterOperation)
        case sdkUnknown(Swift.String)
    }
}

extension QuickSightClientTypes {

    /// Properties associated with the columns participating in a join.
    public struct JoinKeyProperties: Swift.Sendable {
        /// A value that indicates that a row in a table is uniquely identified by the columns in a join key. This is used by Amazon QuickSight to optimize query performance.
        public var uniqueKey: Swift.Bool?

        public init(
            uniqueKey: Swift.Bool? = false
        )
        {
            self.uniqueKey = uniqueKey
        }
    }
}

extension QuickSightClientTypes {

    public enum JoinType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inner
        case `left`
        case outer
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinType] {
            return [
                .inner,
                .left,
                .outer,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inner: return "INNER"
            case .left: return "LEFT"
            case .outer: return "OUTER"
            case .right: return "RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The instructions associated with a join.
    public struct JoinInstruction: Swift.Sendable {
        /// Join key properties of the left operand.
        public var leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the left side of a join.
        /// This member is required.
        public var leftOperand: Swift.String?
        /// The join instructions provided in the ON clause of a join.
        /// This member is required.
        public var onClause: Swift.String?
        /// Join key properties of the right operand.
        public var rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties?
        /// The operand on the right side of a join.
        /// This member is required.
        public var rightOperand: Swift.String?
        /// The type of join that it is.
        /// This member is required.
        public var type: QuickSightClientTypes.JoinType?

        public init(
            leftJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            leftOperand: Swift.String? = nil,
            onClause: Swift.String? = nil,
            rightJoinKeyProperties: QuickSightClientTypes.JoinKeyProperties? = nil,
            rightOperand: Swift.String? = nil,
            type: QuickSightClientTypes.JoinType? = nil
        )
        {
            self.leftJoinKeyProperties = leftJoinKeyProperties
            self.leftOperand = leftOperand
            self.onClause = onClause
            self.rightJoinKeyProperties = rightJoinKeyProperties
            self.rightOperand = rightOperand
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the source of a logical table. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct LogicalTableSource: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the parent dataset.
        public var dataSetArn: Swift.String?
        /// Specifies the result of a join of two logical tables.
        public var joinInstruction: QuickSightClientTypes.JoinInstruction?
        /// Physical table ID.
        public var physicalTableId: Swift.String?

        public init(
            dataSetArn: Swift.String? = nil,
            joinInstruction: QuickSightClientTypes.JoinInstruction? = nil,
            physicalTableId: Swift.String? = nil
        )
        {
            self.dataSetArn = dataSetArn
            self.joinInstruction = joinInstruction
            self.physicalTableId = physicalTableId
        }
    }
}

extension QuickSightClientTypes {

    /// A logical table is a unit that joins and that data transformations operate on. A logical table has a source, which can be either a physical table or result of a join. When a logical table points to a physical table, the logical table acts as a mutable copy of that physical table through transform operations.
    public struct LogicalTable: Swift.Sendable {
        /// A display name for the logical table.
        /// This member is required.
        public var alias: Swift.String?
        /// Transform operations that act on this logical table. For this structure to be valid, only one of the attributes can be non-null.
        public var dataTransforms: [QuickSightClientTypes.TransformOperation]?
        /// Source of this logical table.
        /// This member is required.
        public var source: QuickSightClientTypes.LogicalTableSource?

        public init(
            alias: Swift.String? = nil,
            dataTransforms: [QuickSightClientTypes.TransformOperation]? = nil,
            source: QuickSightClientTypes.LogicalTableSource? = nil
        )
        {
            self.alias = alias
            self.dataTransforms = dataTransforms
            self.source = source
        }
    }
}

extension QuickSightClientTypes {

    public enum InputColumnDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bit
        case boolean
        case datetime
        case decimal
        case integer
        case json
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [InputColumnDataType] {
            return [
                .bit,
                .boolean,
                .datetime,
                .decimal,
                .integer,
                .json,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bit: return "BIT"
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .decimal: return "DECIMAL"
            case .integer: return "INTEGER"
            case .json: return "JSON"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Metadata for a column that is used as the input of a transform operation.
    public struct InputColumn: Swift.Sendable {
        /// The name of this column in the underlying data source.
        /// This member is required.
        public var name: Swift.String?
        /// The sub data type of the column. Sub types are only available for decimal columns that are part of a SPICE dataset.
        public var subType: QuickSightClientTypes.ColumnDataSubType?
        /// The data type of the column.
        /// This member is required.
        public var type: QuickSightClientTypes.InputColumnDataType?

        public init(
            name: Swift.String? = nil,
            subType: QuickSightClientTypes.ColumnDataSubType? = nil,
            type: QuickSightClientTypes.InputColumnDataType? = nil
        )
        {
            self.name = name
            self.subType = subType
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A physical table type built from the results of the custom SQL query.
    public struct CustomSql: Swift.Sendable {
        /// The column schema from the SQL query result set.
        public var columns: [QuickSightClientTypes.InputColumn]?
        /// The Amazon Resource Name (ARN) of the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A display name for the SQL query result.
        /// This member is required.
        public var name: Swift.String?
        /// The SQL query.
        /// This member is required.
        public var sqlQuery: Swift.String?

        public init(
            columns: [QuickSightClientTypes.InputColumn]? = nil,
            dataSourceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sqlQuery: Swift.String? = nil
        )
        {
            self.columns = columns
            self.dataSourceArn = dataSourceArn
            self.name = name
            self.sqlQuery = sqlQuery
        }
    }
}

extension QuickSightClientTypes {

    /// A physical table type for relational data sources.
    public struct RelationalTable: Swift.Sendable {
        /// The catalog associated with a table.
        public var catalog: Swift.String?
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// The column schema of the table.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// The name of the relational table.
        /// This member is required.
        public var name: Swift.String?
        /// The schema name. This name applies to certain relational database engines.
        public var schema: Swift.String?

        public init(
            catalog: Swift.String? = nil,
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.name = name
            self.schema = schema
        }
    }
}

extension QuickSightClientTypes {

    public enum FileFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clf
        case csv
        case elf
        case json
        case tsv
        case xlsx
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .clf,
                .csv,
                .elf,
                .json,
                .tsv,
                .xlsx
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clf: return "CLF"
            case .csv: return "CSV"
            case .elf: return "ELF"
            case .json: return "JSON"
            case .tsv: return "TSV"
            case .xlsx: return "XLSX"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum TextQualifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case doubleQuote
        case singleQuote
        case sdkUnknown(Swift.String)

        public static var allCases: [TextQualifier] {
            return [
                .doubleQuote,
                .singleQuote
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .doubleQuote: return "DOUBLE_QUOTE"
            case .singleQuote: return "SINGLE_QUOTE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the format for a source file or files.
    public struct UploadSettings: Swift.Sendable {
        /// Whether the file has a header row, or the files each have a header row.
        public var containsHeader: Swift.Bool?
        /// The delimiter between values in the file.
        public var delimiter: Swift.String?
        /// File format.
        public var format: QuickSightClientTypes.FileFormat?
        /// A row number to start reading data from.
        public var startFromRow: Swift.Int?
        /// Text qualifier.
        public var textQualifier: QuickSightClientTypes.TextQualifier?

        public init(
            containsHeader: Swift.Bool? = false,
            delimiter: Swift.String? = nil,
            format: QuickSightClientTypes.FileFormat? = nil,
            startFromRow: Swift.Int? = nil,
            textQualifier: QuickSightClientTypes.TextQualifier? = nil
        )
        {
            self.containsHeader = containsHeader
            self.delimiter = delimiter
            self.format = format
            self.startFromRow = startFromRow
            self.textQualifier = textQualifier
        }
    }
}

extension QuickSightClientTypes {

    /// A physical table type for an S3 data source.
    public struct S3Source: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the data source.
        /// This member is required.
        public var dataSourceArn: Swift.String?
        /// A physical table type for an S3 data source. For files that aren't JSON, only STRING data types are supported in input columns.
        /// This member is required.
        public var inputColumns: [QuickSightClientTypes.InputColumn]?
        /// Information about the format for the S3 source file or files.
        public var uploadSettings: QuickSightClientTypes.UploadSettings?

        public init(
            dataSourceArn: Swift.String? = nil,
            inputColumns: [QuickSightClientTypes.InputColumn]? = nil,
            uploadSettings: QuickSightClientTypes.UploadSettings? = nil
        )
        {
            self.dataSourceArn = dataSourceArn
            self.inputColumns = inputColumns
            self.uploadSettings = uploadSettings
        }
    }
}

extension QuickSightClientTypes {

    /// A view of a data source that contains information about the shape of the data in the underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public enum PhysicalTable: Swift.Sendable {
        /// A physical table type for relational data sources.
        case relationaltable(QuickSightClientTypes.RelationalTable)
        /// A physical table type built from the results of the custom SQL query.
        case customsql(QuickSightClientTypes.CustomSql)
        /// A physical table type for as S3 data source.
        case s3source(QuickSightClientTypes.S3Source)
        case sdkUnknown(Swift.String)
    }
}

extension QuickSightClientTypes {

    public enum RowLevelPermissionFormatVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case version1
        case version2
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionFormatVersion] {
            return [
                .version1,
                .version2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .version1: return "VERSION_1"
            case .version2: return "VERSION_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum RowLevelPermissionPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case denyAccess
        case grantAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RowLevelPermissionPolicy] {
            return [
                .denyAccess,
                .grantAccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .denyAccess: return "DENY_ACCESS"
            case .grantAccess: return "GRANT_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Information about a dataset that contains permissions for row-level security (RLS). The permissions dataset maps fields to users or groups. For more information, see [Using Row-Level Security (RLS) to Restrict Access to a Dataset](https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html) in the Amazon QuickSight User Guide. The option to deny permissions by setting PermissionPolicy to DENY_ACCESS is not supported for new RLS datasets.
    public struct RowLevelPermissionDataSet: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the dataset that contains permissions for RLS.
        /// This member is required.
        public var arn: Swift.String?
        /// The user or group rules associated with the dataset that contains permissions for RLS. By default, FormatVersion is VERSION_1. When FormatVersion is VERSION_1, UserName and GroupName are required. When FormatVersion is VERSION_2, UserARN and GroupARN are required, and Namespace must not exist.
        public var formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion?
        /// The namespace associated with the dataset that contains permissions for RLS.
        public var namespace: Swift.String?
        /// The type of permissions to use when interpreting the permissions for RLS. DENY_ACCESS is included for backward compatibility only.
        /// This member is required.
        public var permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy?
        /// The status of the row-level security permission dataset. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?

        public init(
            arn: Swift.String? = nil,
            formatVersion: QuickSightClientTypes.RowLevelPermissionFormatVersion? = nil,
            namespace: Swift.String? = nil,
            permissionPolicy: QuickSightClientTypes.RowLevelPermissionPolicy? = nil,
            status: QuickSightClientTypes.Status? = nil
        )
        {
            self.arn = arn
            self.formatVersion = formatVersion
            self.namespace = namespace
            self.permissionPolicy = permissionPolicy
            self.status = status
        }
    }
}

extension QuickSightClientTypes {

    /// A set of rules associated with a tag.
    public struct RowLevelPermissionTagRule: Swift.Sendable {
        /// The column name that a tag key is assigned to.
        /// This member is required.
        public var columnName: Swift.String?
        /// A string that you want to use to filter by all the values in a column in the dataset and donâ€™t want to list the values one by one. For example, you can use an asterisk as your match all value.
        public var matchAllValue: Swift.String?
        /// The unique key for a tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.
        public var tagMultiValueDelimiter: Swift.String?

        public init(
            columnName: Swift.String? = nil,
            matchAllValue: Swift.String? = nil,
            tagKey: Swift.String? = nil,
            tagMultiValueDelimiter: Swift.String? = nil
        )
        {
            self.columnName = columnName
            self.matchAllValue = matchAllValue
            self.tagKey = tagKey
            self.tagMultiValueDelimiter = tagMultiValueDelimiter
        }
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RowLevelPermissionTagRule(columnName: \(Swift.String(describing: columnName)), tagKey: \(Swift.String(describing: tagKey)), tagMultiValueDelimiter: \(Swift.String(describing: tagMultiValueDelimiter)), matchAllValue: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// The configuration of tags on a dataset to set row-level security.
    public struct RowLevelPermissionTagConfiguration: Swift.Sendable {
        /// The status of row-level security tags. If enabled, the status is ENABLED. If disabled, the status is DISABLED.
        public var status: QuickSightClientTypes.Status?
        /// A list of tag configuration rules to apply to a dataset. All tag configurations have the OR condition. Tags within each tile will be joined (AND). At least one rule in this structure must have all tag values assigned to it to apply Row-level security (RLS) to the dataset.
        public var tagRuleConfigurations: [[Swift.String]]?
        /// A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.
        /// This member is required.
        public var tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]?

        public init(
            status: QuickSightClientTypes.Status? = nil,
            tagRuleConfigurations: [[Swift.String]]? = nil,
            tagRules: [QuickSightClientTypes.RowLevelPermissionTagRule]? = nil
        )
        {
            self.status = status
            self.tagRuleConfigurations = tagRuleConfigurations
            self.tagRules = tagRules
        }
    }
}

public struct CreateDataSetInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// An ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The parameter declarations of the dataset.
    public var datasetParameters: [QuickSightClientTypes.DatasetParameter]?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]?
    /// When you create the dataset, Amazon QuickSight adds the dataset to these folders.
    public var folderArns: [Swift.String]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data that you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the dataset.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        datasetParameters: [QuickSightClientTypes.DatasetParameter]? = nil,
        fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]? = nil,
        folderArns: [Swift.String]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.datasetParameters = datasetParameters
        self.fieldFolders = fieldFolders
        self.folderArns = folderArns
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.permissions = permissions
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        self.tags = tags
    }
}

public struct CreateDataSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

/// The customer managed key that is registered to your Amazon QuickSight account is unavailable.
public struct CustomerManagedKeyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this operation.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomerManagedKeyUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    /// The combination of user name and password that are used as credentials.
    public struct CredentialPair: Swift.Sendable {
        /// A set of alternate data source parameters that you want to share for these credentials. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the new data source with the existing credentials. If the AlternateDataSourceParameters list is null, the DataSourceParameters originally used with these Credentials is automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// Password.
        /// This member is required.
        public var password: Swift.String?
        /// User name.
        /// This member is required.
        public var username: Swift.String?

        public init(
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.password = password
            self.username = username
        }
    }
}

extension QuickSightClientTypes {

    /// Data source credentials. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
    public struct DataSourceCredentials: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a data source that has the credential pair that you want to use. When CopySourceArn is not null, the credential pair from the data source in the ARN is used as the credentials for the DataSourceCredentials structure.
        public var copySourceArn: Swift.String?
        /// Credential pair. For more information, see [CredentialPair](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html).
        public var credentialPair: QuickSightClientTypes.CredentialPair?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public var secretArn: Swift.String?

        public init(
            copySourceArn: Swift.String? = nil,
            credentialPair: QuickSightClientTypes.CredentialPair? = nil,
            secretArn: Swift.String? = nil
        )
        {
            self.copySourceArn = copySourceArn
            self.credentialPair = credentialPair
            self.secretArn = secretArn
        }
    }
}

extension QuickSightClientTypes.DataSourceCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {

    public enum DataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adobeAnalytics
        case amazonElasticsearch
        case amazonOpensearch
        case athena
        case aurora
        case auroraPostgresql
        case awsIotAnalytics
        case bigquery
        case databricks
        case exasol
        case github
        case jira
        case mariadb
        case mysql
        case oracle
        case postgresql
        case presto
        case redshift
        case s3
        case salesforce
        case servicenow
        case snowflake
        case spark
        case sqlserver
        case starburst
        case teradata
        case timestream
        case trino
        case twitter
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .adobeAnalytics,
                .amazonElasticsearch,
                .amazonOpensearch,
                .athena,
                .aurora,
                .auroraPostgresql,
                .awsIotAnalytics,
                .bigquery,
                .databricks,
                .exasol,
                .github,
                .jira,
                .mariadb,
                .mysql,
                .oracle,
                .postgresql,
                .presto,
                .redshift,
                .s3,
                .salesforce,
                .servicenow,
                .snowflake,
                .spark,
                .sqlserver,
                .starburst,
                .teradata,
                .timestream,
                .trino,
                .twitter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adobeAnalytics: return "ADOBE_ANALYTICS"
            case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
            case .amazonOpensearch: return "AMAZON_OPENSEARCH"
            case .athena: return "ATHENA"
            case .aurora: return "AURORA"
            case .auroraPostgresql: return "AURORA_POSTGRESQL"
            case .awsIotAnalytics: return "AWS_IOT_ANALYTICS"
            case .bigquery: return "BIGQUERY"
            case .databricks: return "DATABRICKS"
            case .exasol: return "EXASOL"
            case .github: return "GITHUB"
            case .jira: return "JIRA"
            case .mariadb: return "MARIADB"
            case .mysql: return "MYSQL"
            case .oracle: return "ORACLE"
            case .postgresql: return "POSTGRESQL"
            case .presto: return "PRESTO"
            case .redshift: return "REDSHIFT"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .servicenow: return "SERVICENOW"
            case .snowflake: return "SNOWFLAKE"
            case .spark: return "SPARK"
            case .sqlserver: return "SQLSERVER"
            case .starburst: return "STARBURST"
            case .teradata: return "TERADATA"
            case .timestream: return "TIMESTREAM"
            case .trino: return "TRINO"
            case .twitter: return "TWITTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDataSourceInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// An ID for the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// When you create the data source, Amazon QuickSight adds the data source to these folders.
    public var folderArns: [Swift.String]?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the data source.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The type of the data source. To return a list of all data sources, use ListDataSources. Use AMAZON_ELASTICSEARCH for Amazon OpenSearch Service.
    /// This member is required.
    public var type: QuickSightClientTypes.DataSourceType?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init(
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        folderArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        type: QuickSightClientTypes.DataSourceType? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.folderArns = folderArns
        self.name = name
        self.permissions = permissions
        self.sslProperties = sslProperties
        self.tags = tags
        self.type = type
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

extension CreateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataSourceInput(awsAccountId: \(Swift.String(describing: awsAccountId)), dataSourceId: \(Swift.String(describing: dataSourceId)), dataSourceParameters: \(Swift.String(describing: dataSourceParameters)), folderArns: \(Swift.String(describing: folderArns)), name: \(Swift.String(describing: name)), permissions: \(Swift.String(describing: permissions)), sslProperties: \(Swift.String(describing: sslProperties)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), vpcConnectionProperties: \(Swift.String(describing: vpcConnectionProperties)), credentials: \"CONTENT_REDACTED\")"}
}

public struct CreateDataSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The status of creating the data source.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum FolderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case restricted
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderType] {
            return [
                .restricted,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum SharingModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case namespace
        case sdkUnknown(Swift.String)

        public static var allCases: [SharingModel] {
            return [
                .account,
                .namespace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .namespace: return "NAMESPACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFolderInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account where you want to create the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The type of folder. By default, folderType is SHARED.
    public var folderType: QuickSightClientTypes.FolderType?
    /// The name of the folder.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) for the parent folder. ParentFolderArn can be null. An empty parentFolderArn creates a root-level folder.
    public var parentFolderArn: Swift.String?
    /// A structure that describes the principals and the resource-level permissions of a folder. To specify no permissions, omit Permissions.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// An optional parameter that determines the sharing scope of the folder. The default value for this parameter is ACCOUNT.
    public var sharingModel: QuickSightClientTypes.SharingModel?
    /// Tags for the folder.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        folderType: QuickSightClientTypes.FolderType? = nil,
        name: Swift.String? = nil,
        parentFolderArn: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sharingModel: QuickSightClientTypes.SharingModel? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.folderType = folderType
        self.name = name
        self.parentFolderArn = parentFolderArn
        self.permissions = permissions
        self.sharingModel = sharingModel
        self.tags = tags
    }
}

public struct CreateFolderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the newly created folder.
    public var arn: Swift.String?
    /// The folder ID for the newly created folder.
    public var folderId: Swift.String?
    /// The request ID for the newly created folder.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum MemberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysis
        case dashboard
        case dataset
        case datasource
        case topic
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .analysis,
                .dashboard,
                .dataset,
                .datasource,
                .topic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysis: return "ANALYSIS"
            case .dashboard: return "DASHBOARD"
            case .dataset: return "DATASET"
            case .datasource: return "DATASOURCE"
            case .topic: return "TOPIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFolderMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset that you want to add to the folder.
    /// This member is required.
    public var memberId: Swift.String?
    /// The member type of the asset that you want to add to a folder.
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

extension QuickSightClientTypes {

    /// An asset in a Amazon QuickSight folder, such as a dashboard, analysis, or dataset.
    public struct FolderMember: Swift.Sendable {
        /// The ID of an asset in the folder.
        public var memberId: Swift.String?
        /// The type of asset that it is.
        public var memberType: QuickSightClientTypes.MemberType?

        public init(
            memberId: Swift.String? = nil,
            memberType: QuickSightClientTypes.MemberType? = nil
        )
        {
            self.memberId = memberId
            self.memberType = memberType
        }
    }
}

public struct CreateFolderMembershipOutput: Swift.Sendable {
    /// Information about the member in the folder.
    public var folderMember: QuickSightClientTypes.FolderMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folderMember: QuickSightClientTypes.FolderMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMember = folderMember
        self.requestId = requestId
        self.status = status
    }
}

/// The request object for this operation.
public struct CreateGroupInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A description for the group that you want to create.
    public var description: Swift.String?
    /// A name for the group that you want to create.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace that you want the group to be a part of.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

extension QuickSightClientTypes {

    /// A group in Amazon QuickSight consists of a set of users. You can use groups to make it easier to manage access and security.
    public struct Group: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the group.
        public var arn: Swift.String?
        /// The group description.
        public var description: Swift.String?
        /// The name of the group.
        public var groupName: Swift.String?
        /// The principal ID of the group.
        public var principalId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            groupName: Swift.String? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.groupName = groupName
            self.principalId = principalId
        }
    }
}

/// The response object for this operation.
public struct CreateGroupOutput: Swift.Sendable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

public struct CreateGroupMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to add the user to.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to add to the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that you want the user to be a part of.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

extension QuickSightClientTypes {

    /// A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .
    public struct GroupMember: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the group member (user).
        public var arn: Swift.String?
        /// The name of the group member (user).
        public var memberName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            memberName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.memberName = memberName
        }
    }
}

public struct CreateGroupMembershipOutput: Swift.Sendable {
    /// The group member.
    public var groupMember: QuickSightClientTypes.GroupMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupMember: QuickSightClientTypes.GroupMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

public struct CreateIAMPolicyAssignmentInput: Swift.Sendable {
    /// The name of the assignment, also called a rule. The name must be unique within the Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    /// This member is required.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account where you want to assign an IAM policy to Amazon QuickSight users or groups.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String: [Swift.String]]?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init(
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String: [Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

public struct CreateIAMPolicyAssignmentOutput: Swift.Sendable {
    /// The ID for the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment. The name must be unique within the Amazon Web Services account.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String: [Swift.String]]?
    /// The ARN for the IAM policy that is applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String: [Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    /// This defines the type of ingestion user wants to trigger. This is part of create ingestion request.
    public enum IngestionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullRefresh
        case incrementalRefresh
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .fullRefresh,
                .incrementalRefresh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIngestionInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?
    /// The type of ingestion that you want to create.
    public var ingestionType: QuickSightClientTypes.IngestionType?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionType: QuickSightClientTypes.IngestionType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
        self.ingestionType = ingestionType
    }
}

extension QuickSightClientTypes {

    public enum IngestionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initialized
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initialized,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIngestionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the data ingestion.
    public var arn: Swift.String?
    /// An ID for the ingestion.
    public var ingestionId: Swift.String?
    /// The ingestion status.
    public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.ingestionId = ingestionId
        self.ingestionStatus = ingestionStatus
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum IdentityStore: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityStore] {
            return [
                .quicksight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNamespaceInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create the Amazon QuickSight namespace in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    /// This member is required.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name that you want to use to describe the new namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The tags that you want to associate with the namespace that you're creating.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        awsAccountId: Swift.String? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        namespace: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.identityStore = identityStore
        self.namespace = namespace
        self.tags = tags
    }
}

extension QuickSightClientTypes {

    public enum NamespaceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case creating
        case deleting
        case nonRetryableFailure
        case retryableFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceStatus] {
            return [
                .created,
                .creating,
                .deleting,
                .nonRetryableFailure,
                .retryableFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .nonRetryableFailure: return "NON_RETRYABLE_FAILURE"
            case .retryableFailure: return "RETRYABLE_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNamespaceOutput: Swift.Sendable {
    /// The ARN of the Amazon QuickSight namespace you created.
    public var arn: Swift.String?
    /// The Amazon Web Services Region; that you want to use for the free SPICE capacity for the new namespace. This is set to the region that you run CreateNamespace in.
    public var capacityRegion: Swift.String?
    /// The status of the creation of the namespace. This is an asynchronous process. A status of CREATED means that your namespace is ready to use. If an error occurs, it indicates if the process is retryable or non-retryable. In the case of a non-retryable error, refer to the error message for follow-up tasks.
    public var creationStatus: QuickSightClientTypes.NamespaceStatus?
    /// Specifies the type of your user identity directory. Currently, this supports users with an identity type of QUICKSIGHT.
    public var identityStore: QuickSightClientTypes.IdentityStore?
    /// The name of the new namespace that you created.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        capacityRegion: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
        identityStore: QuickSightClientTypes.IdentityStore? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.capacityRegion = capacityRegion
        self.creationStatus = creationStatus
        self.identityStore = identityStore
        self.name = name
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum RefreshInterval: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case hourly
        case minute15
        case minute30
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [RefreshInterval] {
            return [
                .daily,
                .hourly,
                .minute15,
                .minute30,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .minute15: return "MINUTE15"
            case .minute30: return "MINUTE30"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum DayOfWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The refresh on entity for weekly or monthly schedules.
    public struct ScheduleRefreshOnEntity: Swift.Sendable {
        /// The day of the month that you want to schedule refresh on.
        public var dayOfMonth: Swift.String?
        /// The day of the week that you want to schedule a refresh on.
        public var dayOfWeek: QuickSightClientTypes.DayOfWeek?

        public init(
            dayOfMonth: Swift.String? = nil,
            dayOfWeek: QuickSightClientTypes.DayOfWeek? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
        }
    }
}

extension QuickSightClientTypes {

    /// Specifies the interval between each scheduled refresh of a dataset.
    public struct RefreshFrequency: Swift.Sendable {
        /// The interval between scheduled refreshes. Valid values are as follows:
        ///
        /// * MINUTE15: The dataset refreshes every 15 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.
        ///
        /// * MINUTE30:The dataset refreshes every 30 minutes. This value is only supported for incremental refreshes. This interval can only be used for one schedule per dataset.
        ///
        /// * HOURLY: The dataset refreshes every hour. This interval can only be used for one schedule per dataset.
        ///
        /// * DAILY: The dataset refreshes every day.
        ///
        /// * WEEKLY: The dataset refreshes every week.
        ///
        /// * MONTHLY: The dataset refreshes every month.
        /// This member is required.
        public var interval: QuickSightClientTypes.RefreshInterval?
        /// The day of the week that you want to schedule the refresh on. This value is required for weekly and monthly refresh intervals.
        public var refreshOnDay: QuickSightClientTypes.ScheduleRefreshOnEntity?
        /// The time of day that you want the datset to refresh. This value is expressed in HH:MM format. This field is not required for schedules that refresh hourly.
        public var timeOfTheDay: Swift.String?
        /// The timezone that you want the refresh schedule to use. The timezone ID must match a corresponding ID found on java.util.time.getAvailableIDs().
        public var timezone: Swift.String?

        public init(
            interval: QuickSightClientTypes.RefreshInterval? = nil,
            refreshOnDay: QuickSightClientTypes.ScheduleRefreshOnEntity? = nil,
            timeOfTheDay: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.interval = interval
            self.refreshOnDay = refreshOnDay
            self.timeOfTheDay = timeOfTheDay
            self.timezone = timezone
        }
    }
}

extension QuickSightClientTypes {

    /// The refresh schedule of a dataset.
    public struct RefreshSchedule: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the refresh schedule.
        public var arn: Swift.String?
        /// The type of refresh that a datset undergoes. Valid values are as follows:
        ///
        /// * FULL_REFRESH: A complete refresh of a dataset.
        ///
        /// * INCREMENTAL_REFRESH: A partial refresh of some rows of a dataset, based on the time window specified.
        ///
        ///
        /// For more information on full and incremental refreshes, see [Refreshing SPICE data](https://docs.aws.amazon.com/quicksight/latest/user/refreshing-imported-data.html) in the Amazon QuickSight User Guide.
        /// This member is required.
        public var refreshType: QuickSightClientTypes.IngestionType?
        /// The frequency for the refresh schedule.
        /// This member is required.
        public var scheduleFrequency: QuickSightClientTypes.RefreshFrequency?
        /// An identifier for the refresh schedule.
        /// This member is required.
        public var scheduleId: Swift.String?
        /// Time after which the refresh schedule can be started, expressed in YYYY-MM-DDTHH:MM:SS format.
        public var startAfterDateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            refreshType: QuickSightClientTypes.IngestionType? = nil,
            scheduleFrequency: QuickSightClientTypes.RefreshFrequency? = nil,
            scheduleId: Swift.String? = nil,
            startAfterDateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.refreshType = refreshType
            self.scheduleFrequency = scheduleFrequency
            self.scheduleId = scheduleId
            self.startAfterDateTime = startAfterDateTime
        }
    }
}

public struct CreateRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The refresh schedule.
    /// This member is required.
    public var schedule: QuickSightClientTypes.RefreshSchedule?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        schedule: QuickSightClientTypes.RefreshSchedule? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.schedule = schedule
    }
}

public struct CreateRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the refresh schedule.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The ID of the refresh schedule.
    public var scheduleId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        scheduleId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.scheduleId = scheduleId
        self.status = status
    }
}

extension QuickSightClientTypes {

    public enum Role: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case adminPro
        case author
        case authorPro
        case reader
        case readerPro
        case sdkUnknown(Swift.String)

        public static var allCases: [Role] {
            return [
                .admin,
                .adminPro,
                .author,
                .authorPro,
                .reader,
                .readerPro
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .adminPro: return "ADMIN_PRO"
            case .author: return "AUTHOR"
            case .authorPro: return "AUTHOR_PRO"
            case .reader: return "READER"
            case .readerPro: return "READER_PRO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRoleMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to add to the role.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that the role belongs to.
    /// This member is required.
    public var namespace: Swift.String?
    /// The role that you want to add a group to.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.memberName = memberName
        self.namespace = namespace
        self.role = role
    }
}

public struct CreateRoleMembershipOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    /// Dataset schema.
    public struct DataSetSchema: Swift.Sendable {
        /// A structure containing the list of column schemas.
        public var columnSchemaList: [QuickSightClientTypes.ColumnSchema]?

        public init(
            columnSchemaList: [QuickSightClientTypes.ColumnSchema]? = nil
        )
        {
            self.columnSchemaList = columnSchemaList
        }
    }
}

extension QuickSightClientTypes {

    /// Dataset configuration.
    public struct DataSetConfiguration: Swift.Sendable {
        /// A structure containing the list of column group schemas.
        public var columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]?
        /// Dataset schema.
        public var dataSetSchema: QuickSightClientTypes.DataSetSchema?
        /// Placeholder.
        public var placeholder: Swift.String?

        public init(
            columnGroupSchemaList: [QuickSightClientTypes.ColumnGroupSchema]? = nil,
            dataSetSchema: QuickSightClientTypes.DataSetSchema? = nil,
            placeholder: Swift.String? = nil
        )
        {
            self.columnGroupSchemaList = columnGroupSchemaList
            self.dataSetSchema = dataSetSchema
            self.placeholder = placeholder
        }
    }
}

extension QuickSightClientTypes {

    /// The detailed definition of a template.
    public struct TemplateVersionDefinition: Swift.Sendable {
        /// The configuration for default analysis settings.
        public var analysisDefaults: QuickSightClientTypes.AnalysisDefaults?
        /// An array of calculated field definitions for the template.
        public var calculatedFields: [QuickSightClientTypes.CalculatedField]?
        /// An array of template-level column configurations. Column configurations are used to set default formatting for a column that's used throughout a template.
        public var columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]?
        /// An array of dataset configurations. These configurations define the required columns for each dataset used within a template.
        /// This member is required.
        public var dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]?
        /// Filter definitions for a template. For more information, see [Filtering Data](https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html) in the Amazon QuickSight User Guide.
        public var filterGroups: [QuickSightClientTypes.FilterGroup]?
        /// An array of option definitions for a template.
        public var options: QuickSightClientTypes.AssetOptions?
        /// An array of parameter declarations for a template. Parameters are named variables that can transfer a value for use by an action or an object. For more information, see [Parameters in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html) in the Amazon QuickSight User Guide.
        public var parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]?
        /// A structure that describes the query execution options.
        public var queryExecutionOptions: QuickSightClientTypes.QueryExecutionOptions?
        /// An array of sheet definitions for a template.
        public var sheets: [QuickSightClientTypes.SheetDefinition]?

        public init(
            analysisDefaults: QuickSightClientTypes.AnalysisDefaults? = nil,
            calculatedFields: [QuickSightClientTypes.CalculatedField]? = nil,
            columnConfigurations: [QuickSightClientTypes.ColumnConfiguration]? = nil,
            dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]? = nil,
            filterGroups: [QuickSightClientTypes.FilterGroup]? = nil,
            options: QuickSightClientTypes.AssetOptions? = nil,
            parameterDeclarations: [QuickSightClientTypes.ParameterDeclaration]? = nil,
            queryExecutionOptions: QuickSightClientTypes.QueryExecutionOptions? = nil,
            sheets: [QuickSightClientTypes.SheetDefinition]? = nil
        )
        {
            self.analysisDefaults = analysisDefaults
            self.calculatedFields = calculatedFields
            self.columnConfigurations = columnConfigurations
            self.dataSetConfigurations = dataSetConfigurations
            self.filterGroups = filterGroups
            self.options = options
            self.parameterDeclarations = parameterDeclarations
            self.queryExecutionOptions = queryExecutionOptions
            self.sheets = sheets
        }
    }
}

extension QuickSightClientTypes {

    /// The source analysis of the template.
    public struct TemplateSourceAnalysis: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// A structure containing information about the dataset references used as placeholders in the template.
        /// This member is required.
        public var dataSetReferences: [QuickSightClientTypes.DataSetReference]?

        public init(
            arn: Swift.String? = nil,
            dataSetReferences: [QuickSightClientTypes.DataSetReference]? = nil
        )
        {
            self.arn = arn
            self.dataSetReferences = dataSetReferences
        }
    }
}

extension QuickSightClientTypes {

    /// The source template of the template.
    public struct TemplateSourceTemplate: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension QuickSightClientTypes {

    /// The source entity of the template.
    public struct TemplateSourceEntity: Swift.Sendable {
        /// The source analysis, if it is based on an analysis.
        public var sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis?
        /// The source template, if it is based on an template.
        public var sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate?

        public init(
            sourceAnalysis: QuickSightClientTypes.TemplateSourceAnalysis? = nil,
            sourceTemplate: QuickSightClientTypes.TemplateSourceTemplate? = nil
        )
        {
            self.sourceAnalysis = sourceAnalysis
            self.sourceTemplate = sourceTemplate
        }
    }
}

public struct CreateTemplateInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. You use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// A display name for the template.
    public var name: Swift.String?
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The entity that you are using as a source when you create the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder. Either a SourceEntity or a Definition must be provided in order for the request to be valid.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the template that you want to create. This template is unique per Amazon Web Services Region; in each Amazon Web Services account.
    /// This member is required.
    public var templateId: Swift.String?
    /// TThe option to relax the validation needed to create a template with definition objects. This skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?
    /// A description of the current template version being created. This API operation creates the first version of the template. Every time UpdateTemplate is called, a new version is created. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.permissions = permissions
        self.sourceEntity = sourceEntity
        self.tags = tags
        self.templateId = templateId
        self.validationStrategy = validationStrategy
        self.versionDescription = versionDescription
    }
}

public struct CreateTemplateOutput: Swift.Sendable {
    /// The ARN for the template.
    public var arn: Swift.String?
    /// The template creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

public struct CreateTemplateAliasInput: Swift.Sendable {
    /// The name that you want to give to the template alias that you're creating. Don't start the alias name with the $ character. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you creating an alias for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

extension QuickSightClientTypes {

    /// The template alias.
    public struct TemplateAlias: Swift.Sendable {
        /// The display name of the template alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the template alias.
        public var arn: Swift.String?
        /// The version number of the template alias.
        public var templateVersionNumber: Swift.Int?

        public init(
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            templateVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.templateVersionNumber = templateVersionNumber
        }
    }
}

public struct CreateTemplateAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

extension QuickSightClientTypes {

    /// The theme colors that are used for data colors in charts. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5.
    public struct DataColorPalette: Swift.Sendable {
        /// The hexadecimal codes for the colors.
        public var colors: [Swift.String]?
        /// The hexadecimal code of a color that applies to charts where a lack of data is highlighted.
        public var emptyFillColor: Swift.String?
        /// The minimum and maximum hexadecimal codes that describe a color gradient.
        public var minMaxGradient: [Swift.String]?

        public init(
            colors: [Swift.String]? = nil,
            emptyFillColor: Swift.String? = nil,
            minMaxGradient: [Swift.String]? = nil
        )
        {
            self.colors = colors
            self.emptyFillColor = emptyFillColor
            self.minMaxGradient = minMaxGradient
        }
    }
}

extension QuickSightClientTypes {

    /// Display options related to tiles on a sheet.
    public struct TileStyle: Swift.Sendable {
        /// The border around a tile.
        public var border: QuickSightClientTypes.BorderStyle?

        public init(
            border: QuickSightClientTypes.BorderStyle? = nil
        )
        {
            self.border = border
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for gutter spacing between tiles on a sheet.
    public struct GutterStyle: Swift.Sendable {
        /// This Boolean value controls whether to display a gutter space between sheet tiles.
        public var show: Swift.Bool?

        public init(
            show: Swift.Bool? = false
        )
        {
            self.show = show
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for margins around the outside edge of sheets.
    public struct MarginStyle: Swift.Sendable {
        /// This Boolean value controls whether to display sheet margins.
        public var show: Swift.Bool?

        public init(
            show: Swift.Bool? = false
        )
        {
            self.show = show
        }
    }
}

extension QuickSightClientTypes {

    /// The display options for the layout of tiles on a sheet.
    public struct TileLayoutStyle: Swift.Sendable {
        /// The gutter settings that apply between tiles.
        public var gutter: QuickSightClientTypes.GutterStyle?
        /// The margin settings that apply around the outside edge of sheets.
        public var margin: QuickSightClientTypes.MarginStyle?

        public init(
            gutter: QuickSightClientTypes.GutterStyle? = nil,
            margin: QuickSightClientTypes.MarginStyle? = nil
        )
        {
            self.gutter = gutter
            self.margin = margin
        }
    }
}

extension QuickSightClientTypes {

    /// The theme display options for sheets.
    public struct SheetStyle: Swift.Sendable {
        /// The display options for tiles.
        public var tile: QuickSightClientTypes.TileStyle?
        /// The layout options for tiles.
        public var tileLayout: QuickSightClientTypes.TileLayoutStyle?

        public init(
            tile: QuickSightClientTypes.TileStyle? = nil,
            tileLayout: QuickSightClientTypes.TileLayoutStyle? = nil
        )
        {
            self.tile = tile
            self.tileLayout = tileLayout
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the font settings.
    public struct Font: Swift.Sendable {
        /// Determines the font family settings.
        public var fontFamily: Swift.String?

        public init(
            fontFamily: Swift.String? = nil
        )
        {
            self.fontFamily = fontFamily
        }
    }
}

extension QuickSightClientTypes {

    /// Determines the typography options.
    public struct Typography: Swift.Sendable {
        /// Determines the list of font families.
        public var fontFamilies: [QuickSightClientTypes.Font]?

        public init(
            fontFamilies: [QuickSightClientTypes.Font]? = nil
        )
        {
            self.fontFamilies = fontFamilies
        }
    }
}

extension QuickSightClientTypes {

    /// The theme colors that apply to UI and to charts, excluding data colors. The colors description is a hexadecimal color code that consists of six alphanumerical characters, prefixed with #, for example #37BFF5. For more information, see [Using Themes in Amazon QuickSight](https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html) in the Amazon QuickSight User Guide.
    public struct UIColorPalette: Swift.Sendable {
        /// This color is that applies to selected states and buttons.
        public var accent: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the accent color.
        public var accentForeground: Swift.String?
        /// The color that applies to error messages.
        public var danger: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the error color.
        public var dangerForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as dimensions.
        public var dimension: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the dimension color.
        public var dimensionForeground: Swift.String?
        /// The color that applies to the names of fields that are identified as measures.
        public var measure: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the measure color.
        public var measureForeground: Swift.String?
        /// The background color that applies to visuals and other high emphasis UI.
        public var primaryBackground: Swift.String?
        /// The color of text and other foreground elements that appear over the primary background regions, such as grid lines, borders, table banding, icons, and so on.
        public var primaryForeground: Swift.String?
        /// The background color that applies to the sheet background and sheet controls.
        public var secondaryBackground: Swift.String?
        /// The foreground color that applies to any sheet title, sheet control text, or UI that appears over the secondary background.
        public var secondaryForeground: Swift.String?
        /// The color that applies to success messages, for example the check mark for a successful download.
        public var success: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the success color.
        public var successForeground: Swift.String?
        /// This color that applies to warning and informational messages.
        public var warning: Swift.String?
        /// The foreground color that applies to any text or other elements that appear over the warning color.
        public var warningForeground: Swift.String?

        public init(
            accent: Swift.String? = nil,
            accentForeground: Swift.String? = nil,
            danger: Swift.String? = nil,
            dangerForeground: Swift.String? = nil,
            dimension: Swift.String? = nil,
            dimensionForeground: Swift.String? = nil,
            measure: Swift.String? = nil,
            measureForeground: Swift.String? = nil,
            primaryBackground: Swift.String? = nil,
            primaryForeground: Swift.String? = nil,
            secondaryBackground: Swift.String? = nil,
            secondaryForeground: Swift.String? = nil,
            success: Swift.String? = nil,
            successForeground: Swift.String? = nil,
            warning: Swift.String? = nil,
            warningForeground: Swift.String? = nil
        )
        {
            self.accent = accent
            self.accentForeground = accentForeground
            self.danger = danger
            self.dangerForeground = dangerForeground
            self.dimension = dimension
            self.dimensionForeground = dimensionForeground
            self.measure = measure
            self.measureForeground = measureForeground
            self.primaryBackground = primaryBackground
            self.primaryForeground = primaryForeground
            self.secondaryBackground = secondaryBackground
            self.secondaryForeground = secondaryForeground
            self.success = success
            self.successForeground = successForeground
            self.warning = warning
            self.warningForeground = warningForeground
        }
    }
}

extension QuickSightClientTypes {

    /// The theme configuration. This configuration contains all of the display properties for a theme.
    public struct ThemeConfiguration: Swift.Sendable {
        /// Color properties that apply to chart data colors.
        public var dataColorPalette: QuickSightClientTypes.DataColorPalette?
        /// Display options related to sheets.
        public var sheet: QuickSightClientTypes.SheetStyle?
        /// Determines the typography options.
        public var typography: QuickSightClientTypes.Typography?
        /// Color properties that apply to the UI and to charts, excluding the colors that apply to data.
        public var uiColorPalette: QuickSightClientTypes.UIColorPalette?

        public init(
            dataColorPalette: QuickSightClientTypes.DataColorPalette? = nil,
            sheet: QuickSightClientTypes.SheetStyle? = nil,
            typography: QuickSightClientTypes.Typography? = nil,
            uiColorPalette: QuickSightClientTypes.UIColorPalette? = nil
        )
        {
            self.dataColorPalette = dataColorPalette
            self.sheet = sheet
            self.typography = typography
            self.uiColorPalette = uiColorPalette
        }
    }
}

public struct CreateThemeInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account where you want to store the new theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the theme that a custom theme will inherit from. All themes inherit from one of the starting themes defined by Amazon QuickSight. For a list of the starting themes, use ListThemes or choose Themes from within an analysis.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    /// This member is required.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// A display name for the theme.
    /// This member is required.
    public var name: Swift.String?
    /// A valid grouping of resource permissions to apply to the new theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// A map of the key-value pairs for the resource tag or tags that you want to add to the resource.
    public var tags: [QuickSightClientTypes.Tag]?
    /// An ID for the theme that you want to create. The theme ID is unique per Amazon Web Services Region in each Amazon Web Services account.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the first version of the theme that you're creating. Every time UpdateTheme is called, a new version is created. Each version of the theme has a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.permissions = permissions
        self.tags = tags
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

public struct CreateThemeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The theme creation status.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new theme.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

public struct CreateThemeAliasInput: Swift.Sendable {
    /// The name that you want to give to the theme alias that you are creating. The alias name can't begin with a $. Alias names that start with $ are reserved by Amazon QuickSight.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme for the new theme alias.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme alias.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

extension QuickSightClientTypes {

    /// An alias for a theme.
    public struct ThemeAlias: Swift.Sendable {
        /// The display name of the theme alias.
        public var aliasName: Swift.String?
        /// The Amazon Resource Name (ARN) of the theme alias.
        public var arn: Swift.String?
        /// The version number of the theme alias.
        public var themeVersionNumber: Swift.Int?

        public init(
            aliasName: Swift.String? = nil,
            arn: Swift.String? = nil,
            themeVersionNumber: Swift.Int? = nil
        )
        {
            self.aliasName = aliasName
            self.arn = arn
            self.themeVersionNumber = themeVersionNumber
        }
    }
}

public struct CreateThemeAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

extension QuickSightClientTypes {

    /// Configuration options for a Topic.
    public struct TopicConfigOptions: Swift.Sendable {
        /// Enables Amazon Q Business Insights for a Topic.
        public var qBusinessInsightsEnabled: Swift.Bool?

        public init(
            qBusinessInsightsEnabled: Swift.Bool? = nil
        )
        {
            self.qBusinessInsightsEnabled = qBusinessInsightsEnabled
        }
    }
}

extension QuickSightClientTypes {

    public enum DefaultAggregation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case distinctCount
        case max
        case median
        case min
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultAggregation] {
            return [
                .average,
                .count,
                .distinctCount,
                .max,
                .median,
                .min,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a default formatting definition.
    public struct DefaultFormatting: Swift.Sendable {
        /// The display format. Valid values for this structure are AUTO, PERCENT, CURRENCY, NUMBER, DATE, and STRING.
        public var displayFormat: QuickSightClientTypes.DisplayFormat?
        /// The additional options for display formatting.
        public var displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions?

        public init(
            displayFormat: QuickSightClientTypes.DisplayFormat? = nil,
            displayFormatOptions: QuickSightClientTypes.DisplayFormatOptions? = nil
        )
        {
            self.displayFormat = displayFormat
            self.displayFormatOptions = displayFormatOptions
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a semantic type.
    public struct SemanticType: Swift.Sendable {
        /// The semantic type falsey cell value.
        public var falseyCellValue: Swift.String?
        /// The other names or aliases for the false cell value.
        public var falseyCellValueSynonyms: [Swift.String]?
        /// The semantic type sub type name.
        public var subTypeName: Swift.String?
        /// The semantic type truthy cell value.
        public var truthyCellValue: Swift.String?
        /// The other names or aliases for the true cell value.
        public var truthyCellValueSynonyms: [Swift.String]?
        /// The semantic type name.
        public var typeName: Swift.String?
        /// The semantic type parameters.
        public var typeParameters: [Swift.String: Swift.String]?

        public init(
            falseyCellValue: Swift.String? = nil,
            falseyCellValueSynonyms: [Swift.String]? = nil,
            subTypeName: Swift.String? = nil,
            truthyCellValue: Swift.String? = nil,
            truthyCellValueSynonyms: [Swift.String]? = nil,
            typeName: Swift.String? = nil,
            typeParameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.falseyCellValue = falseyCellValue
            self.falseyCellValueSynonyms = falseyCellValueSynonyms
            self.subTypeName = subTypeName
            self.truthyCellValue = truthyCellValue
            self.truthyCellValueSynonyms = truthyCellValueSynonyms
            self.typeName = typeName
            self.typeParameters = typeParameters
        }
    }
}

extension QuickSightClientTypes.SemanticType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SemanticType(subTypeName: \(Swift.String(describing: subTypeName)), typeName: \(Swift.String(describing: typeName)), typeParameters: \(Swift.String(describing: typeParameters)), falseyCellValue: \"CONTENT_REDACTED\", falseyCellValueSynonyms: \"CONTENT_REDACTED\", truthyCellValue: \"CONTENT_REDACTED\", truthyCellValueSynonyms: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A structure that represents a calculated field.
    public struct TopicCalculatedField: Swift.Sendable {
        /// The default aggregation. Valid values for this structure are SUM, MAX, MIN, COUNT, DISTINCT_COUNT, and AVERAGE.
        public var aggregation: QuickSightClientTypes.DefaultAggregation?
        /// The list of aggregation types that are allowed for the calculated field. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public var allowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]?
        /// The calculated field description.
        public var calculatedFieldDescription: Swift.String?
        /// The calculated field name.
        /// This member is required.
        public var calculatedFieldName: Swift.String?
        /// The other names or aliases for the calculated field.
        public var calculatedFieldSynonyms: [Swift.String]?
        /// The other names or aliases for the calculated field cell value.
        public var cellValueSynonyms: [QuickSightClientTypes.CellValueSynonym]?
        /// The column data role for a calculated field. Valid values for this structure are DIMENSION and MEASURE.
        public var columnDataRole: QuickSightClientTypes.ColumnDataRole?
        /// The order in which data is displayed for the calculated field when it's used in a comparative context.
        public var comparativeOrder: QuickSightClientTypes.ComparativeOrder?
        /// The default formatting definition.
        public var defaultFormatting: QuickSightClientTypes.DefaultFormatting?
        /// A Boolean value that indicates if a calculated field is visible in the autocomplete.
        public var disableIndexing: Swift.Bool?
        /// The calculated field expression.
        /// This member is required.
        public var expression: Swift.String?
        /// A boolean value that indicates if a calculated field is included in the topic.
        public var isIncludedInTopic: Swift.Bool
        /// A Boolean value that indicates whether to never aggregate calculated field in filters.
        public var neverAggregateInFilter: Swift.Bool
        /// The non additive for the table style target.
        public var nonAdditive: Swift.Bool?
        /// The list of aggregation types that are not allowed for the calculated field. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public var notAllowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]?
        /// The semantic type.
        public var semanticType: QuickSightClientTypes.SemanticType?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TopicTimeGranularity?

        public init(
            aggregation: QuickSightClientTypes.DefaultAggregation? = nil,
            allowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]? = nil,
            calculatedFieldDescription: Swift.String? = nil,
            calculatedFieldName: Swift.String? = nil,
            calculatedFieldSynonyms: [Swift.String]? = nil,
            cellValueSynonyms: [QuickSightClientTypes.CellValueSynonym]? = nil,
            columnDataRole: QuickSightClientTypes.ColumnDataRole? = nil,
            comparativeOrder: QuickSightClientTypes.ComparativeOrder? = nil,
            defaultFormatting: QuickSightClientTypes.DefaultFormatting? = nil,
            disableIndexing: Swift.Bool? = nil,
            expression: Swift.String? = nil,
            isIncludedInTopic: Swift.Bool = false,
            neverAggregateInFilter: Swift.Bool = false,
            nonAdditive: Swift.Bool? = nil,
            notAllowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]? = nil,
            semanticType: QuickSightClientTypes.SemanticType? = nil,
            timeGranularity: QuickSightClientTypes.TopicTimeGranularity? = nil
        )
        {
            self.aggregation = aggregation
            self.allowedAggregations = allowedAggregations
            self.calculatedFieldDescription = calculatedFieldDescription
            self.calculatedFieldName = calculatedFieldName
            self.calculatedFieldSynonyms = calculatedFieldSynonyms
            self.cellValueSynonyms = cellValueSynonyms
            self.columnDataRole = columnDataRole
            self.comparativeOrder = comparativeOrder
            self.defaultFormatting = defaultFormatting
            self.disableIndexing = disableIndexing
            self.expression = expression
            self.isIncludedInTopic = isIncludedInTopic
            self.neverAggregateInFilter = neverAggregateInFilter
            self.nonAdditive = nonAdditive
            self.notAllowedAggregations = notAllowedAggregations
            self.semanticType = semanticType
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes.TopicCalculatedField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicCalculatedField(aggregation: \(Swift.String(describing: aggregation)), allowedAggregations: \(Swift.String(describing: allowedAggregations)), calculatedFieldDescription: \(Swift.String(describing: calculatedFieldDescription)), calculatedFieldName: \(Swift.String(describing: calculatedFieldName)), calculatedFieldSynonyms: \(Swift.String(describing: calculatedFieldSynonyms)), cellValueSynonyms: \(Swift.String(describing: cellValueSynonyms)), columnDataRole: \(Swift.String(describing: columnDataRole)), comparativeOrder: \(Swift.String(describing: comparativeOrder)), defaultFormatting: \(Swift.String(describing: defaultFormatting)), disableIndexing: \(Swift.String(describing: disableIndexing)), isIncludedInTopic: \(Swift.String(describing: isIncludedInTopic)), neverAggregateInFilter: \(Swift.String(describing: neverAggregateInFilter)), nonAdditive: \(Swift.String(describing: nonAdditive)), notAllowedAggregations: \(Swift.String(describing: notAllowedAggregations)), semanticType: \(Swift.String(describing: semanticType)), timeGranularity: \(Swift.String(describing: timeGranularity)), expression: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// Represents a column in a dataset.
    public struct TopicColumn: Swift.Sendable {
        /// The type of aggregation that is performed on the column data when it's queried.
        public var aggregation: QuickSightClientTypes.DefaultAggregation?
        /// The list of aggregation types that are allowed for the column. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public var allowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]?
        /// The other names or aliases for the column cell value.
        public var cellValueSynonyms: [QuickSightClientTypes.CellValueSynonym]?
        /// The role of the column in the data. Valid values are DIMENSION and MEASURE.
        public var columnDataRole: QuickSightClientTypes.ColumnDataRole?
        /// A description of the column and its contents.
        public var columnDescription: Swift.String?
        /// A user-friendly name for the column.
        public var columnFriendlyName: Swift.String?
        /// The name of the column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The other names or aliases for the column.
        public var columnSynonyms: [Swift.String]?
        /// The order in which data is displayed for the column when it's used in a comparative context.
        public var comparativeOrder: QuickSightClientTypes.ComparativeOrder?
        /// The default formatting used for values in the column.
        public var defaultFormatting: QuickSightClientTypes.DefaultFormatting?
        /// A Boolean value that indicates whether the column shows in the autocomplete functionality.
        public var disableIndexing: Swift.Bool?
        /// A Boolean value that indicates whether the column is included in the query results.
        public var isIncludedInTopic: Swift.Bool
        /// A Boolean value that indicates whether to aggregate the column data when it's used in a filter context.
        public var neverAggregateInFilter: Swift.Bool
        /// The non additive value for the column.
        public var nonAdditive: Swift.Bool?
        /// The list of aggregation types that are not allowed for the column. Valid values for this structure are COUNT, DISTINCT_COUNT, MIN, MAX, MEDIAN, SUM, AVERAGE, STDEV, STDEVP, VAR, VARP, and PERCENTILE.
        public var notAllowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]?
        /// The semantic type of data contained in the column.
        public var semanticType: QuickSightClientTypes.SemanticType?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TopicTimeGranularity?

        public init(
            aggregation: QuickSightClientTypes.DefaultAggregation? = nil,
            allowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]? = nil,
            cellValueSynonyms: [QuickSightClientTypes.CellValueSynonym]? = nil,
            columnDataRole: QuickSightClientTypes.ColumnDataRole? = nil,
            columnDescription: Swift.String? = nil,
            columnFriendlyName: Swift.String? = nil,
            columnName: Swift.String? = nil,
            columnSynonyms: [Swift.String]? = nil,
            comparativeOrder: QuickSightClientTypes.ComparativeOrder? = nil,
            defaultFormatting: QuickSightClientTypes.DefaultFormatting? = nil,
            disableIndexing: Swift.Bool? = nil,
            isIncludedInTopic: Swift.Bool = false,
            neverAggregateInFilter: Swift.Bool = false,
            nonAdditive: Swift.Bool? = nil,
            notAllowedAggregations: [QuickSightClientTypes.AuthorSpecifiedAggregation]? = nil,
            semanticType: QuickSightClientTypes.SemanticType? = nil,
            timeGranularity: QuickSightClientTypes.TopicTimeGranularity? = nil
        )
        {
            self.aggregation = aggregation
            self.allowedAggregations = allowedAggregations
            self.cellValueSynonyms = cellValueSynonyms
            self.columnDataRole = columnDataRole
            self.columnDescription = columnDescription
            self.columnFriendlyName = columnFriendlyName
            self.columnName = columnName
            self.columnSynonyms = columnSynonyms
            self.comparativeOrder = comparativeOrder
            self.defaultFormatting = defaultFormatting
            self.disableIndexing = disableIndexing
            self.isIncludedInTopic = isIncludedInTopic
            self.neverAggregateInFilter = neverAggregateInFilter
            self.nonAdditive = nonAdditive
            self.notAllowedAggregations = notAllowedAggregations
            self.semanticType = semanticType
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a data aggregation.
    public struct DataAggregation: Swift.Sendable {
        /// The level of time precision that is used to aggregate DateTime values.
        public var datasetRowDateGranularity: QuickSightClientTypes.TopicTimeGranularity?
        /// The column name for the default date.
        public var defaultDateColumnName: Swift.String?

        public init(
            datasetRowDateGranularity: QuickSightClientTypes.TopicTimeGranularity? = nil,
            defaultDateColumnName: Swift.String? = nil
        )
        {
            self.datasetRowDateGranularity = datasetRowDateGranularity
            self.defaultDateColumnName = defaultDateColumnName
        }
    }
}

extension QuickSightClientTypes {

    /// A constant used in a category filter.
    public struct TopicCategoryFilterConstant: Swift.Sendable {
        /// A collective constant used in a category filter. This element is used to specify a list of values for the constant.
        public var collectiveConstant: QuickSightClientTypes.CollectiveConstant?
        /// The type of category filter constant. This element is used to specify whether a constant is a singular or collective. Valid values are SINGULAR and COLLECTIVE.
        public var constantType: QuickSightClientTypes.ConstantType?
        /// A singular constant used in a category filter. This element is used to specify a single value for the constant.
        public var singularConstant: Swift.String?

        public init(
            collectiveConstant: QuickSightClientTypes.CollectiveConstant? = nil,
            constantType: QuickSightClientTypes.ConstantType? = nil,
            singularConstant: Swift.String? = nil
        )
        {
            self.collectiveConstant = collectiveConstant
            self.constantType = constantType
            self.singularConstant = singularConstant
        }
    }
}

extension QuickSightClientTypes.TopicCategoryFilterConstant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a category filter.
    public struct TopicCategoryFilter: Swift.Sendable {
        /// The category filter function. Valid values for this structure are EXACT and CONTAINS.
        public var categoryFilterFunction: QuickSightClientTypes.CategoryFilterFunction?
        /// The category filter type. This element is used to specify whether a filter is a simple category filter or an inverse category filter.
        public var categoryFilterType: QuickSightClientTypes.CategoryFilterType?
        /// The constant used in a category filter.
        public var constant: QuickSightClientTypes.TopicCategoryFilterConstant?
        /// A Boolean value that indicates if the filter is inverse.
        public var inverse: Swift.Bool

        public init(
            categoryFilterFunction: QuickSightClientTypes.CategoryFilterFunction? = nil,
            categoryFilterType: QuickSightClientTypes.CategoryFilterType? = nil,
            constant: QuickSightClientTypes.TopicCategoryFilterConstant? = nil,
            inverse: Swift.Bool = false
        )
        {
            self.categoryFilterFunction = categoryFilterFunction
            self.categoryFilterType = categoryFilterType
            self.constant = constant
            self.inverse = inverse
        }
    }
}

extension QuickSightClientTypes.TopicCategoryFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicCategoryFilter(categoryFilterFunction: \(Swift.String(describing: categoryFilterFunction)), categoryFilterType: \(Swift.String(describing: categoryFilterType)), inverse: \(Swift.String(describing: inverse)), constant: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A structure that represents a range constant.
    public struct RangeConstant: Swift.Sendable {
        /// The maximum value for a range constant.
        public var maximum: Swift.String?
        /// The minimum value for a range constant.
        public var minimum: Swift.String?

        public init(
            maximum: Swift.String? = nil,
            minimum: Swift.String? = nil
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }
}

extension QuickSightClientTypes {

    /// A constant value that is used in a range filter to specify the endpoints of the range.
    public struct TopicRangeFilterConstant: Swift.Sendable {
        /// The data type of the constant value that is used in a range filter. Valid values for this structure are RANGE.
        public var constantType: QuickSightClientTypes.ConstantType?
        /// The value of the constant that is used to specify the endpoints of a range filter.
        public var rangeConstant: QuickSightClientTypes.RangeConstant?

        public init(
            constantType: QuickSightClientTypes.ConstantType? = nil,
            rangeConstant: QuickSightClientTypes.RangeConstant? = nil
        )
        {
            self.constantType = constantType
            self.rangeConstant = rangeConstant
        }
    }
}

extension QuickSightClientTypes.TopicRangeFilterConstant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {

    /// A filter used to restrict data based on a range of dates or times.
    public struct TopicDateRangeFilter: Swift.Sendable {
        /// The constant used in a date range filter.
        public var constant: QuickSightClientTypes.TopicRangeFilterConstant?
        /// A Boolean value that indicates whether the date range filter should include the boundary values. If set to true, the filter includes the start and end dates. If set to false, the filter excludes them.
        public var inclusive: Swift.Bool

        public init(
            constant: QuickSightClientTypes.TopicRangeFilterConstant? = nil,
            inclusive: Swift.Bool = false
        )
        {
            self.constant = constant
            self.inclusive = inclusive
        }
    }
}

extension QuickSightClientTypes.TopicDateRangeFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicDateRangeFilter(inclusive: \(Swift.String(describing: inclusive)), constant: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum NamedFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case categoryFilter
        case dateRangeFilter
        case numericEqualityFilter
        case numericRangeFilter
        case relativeDateFilter
        case sdkUnknown(Swift.String)

        public static var allCases: [NamedFilterType] {
            return [
                .categoryFilter,
                .dateRangeFilter,
                .numericEqualityFilter,
                .numericRangeFilter,
                .relativeDateFilter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .categoryFilter: return "CATEGORY_FILTER"
            case .dateRangeFilter: return "DATE_RANGE_FILTER"
            case .numericEqualityFilter: return "NUMERIC_EQUALITY_FILTER"
            case .numericRangeFilter: return "NUMERIC_RANGE_FILTER"
            case .relativeDateFilter: return "RELATIVE_DATE_FILTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum NamedFilterAggType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case distinctCount
        case max
        case median
        case min
        case noAggregation
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [NamedFilterAggType] {
            return [
                .average,
                .count,
                .distinctCount,
                .max,
                .median,
                .min,
                .noAggregation,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .noAggregation: return "NO_AGGREGATION"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a singular filter constant, used in filters to specify a single value to match against.
    public struct TopicSingularFilterConstant: Swift.Sendable {
        /// The type of the singular filter constant. Valid values for this structure are SINGULAR.
        public var constantType: QuickSightClientTypes.ConstantType?
        /// The value of the singular filter constant.
        public var singularConstant: Swift.String?

        public init(
            constantType: QuickSightClientTypes.ConstantType? = nil,
            singularConstant: Swift.String? = nil
        )
        {
            self.constantType = constantType
            self.singularConstant = singularConstant
        }
    }
}

extension QuickSightClientTypes.TopicSingularFilterConstant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QuickSightClientTypes {

    /// A filter that filters topics based on the value of a numeric field. The filter includes only topics whose numeric field value matches the specified value.
    public struct TopicNumericEqualityFilter: Swift.Sendable {
        /// An aggregation function that specifies how to calculate the value of a numeric field for a topic. Valid values for this structure are NO_AGGREGATION, SUM, AVERAGE, COUNT, DISTINCT_COUNT, MAX, MEDIAN, MIN, STDEV, STDEVP, VAR, and VARP.
        public var aggregation: QuickSightClientTypes.NamedFilterAggType?
        /// The constant used in a numeric equality filter.
        public var constant: QuickSightClientTypes.TopicSingularFilterConstant?

        public init(
            aggregation: QuickSightClientTypes.NamedFilterAggType? = nil,
            constant: QuickSightClientTypes.TopicSingularFilterConstant? = nil
        )
        {
            self.aggregation = aggregation
            self.constant = constant
        }
    }
}

extension QuickSightClientTypes.TopicNumericEqualityFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicNumericEqualityFilter(aggregation: \(Swift.String(describing: aggregation)), constant: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A filter that filters topics based on the value of a numeric field. The filter includes only topics whose numeric field value falls within the specified range.
    public struct TopicNumericRangeFilter: Swift.Sendable {
        /// An aggregation function that specifies how to calculate the value of a numeric field for a topic, Valid values for this structure are NO_AGGREGATION, SUM, AVERAGE, COUNT, DISTINCT_COUNT, MAX, MEDIAN, MIN, STDEV, STDEVP, VAR, and VARP.
        public var aggregation: QuickSightClientTypes.NamedFilterAggType?
        /// The constant used in a numeric range filter.
        public var constant: QuickSightClientTypes.TopicRangeFilterConstant?
        /// A Boolean value that indicates whether the endpoints of the numeric range are included in the filter. If set to true, topics whose numeric field value is equal to the endpoint values will be included in the filter. If set to false, topics whose numeric field value is equal to the endpoint values will be excluded from the filter.
        public var inclusive: Swift.Bool

        public init(
            aggregation: QuickSightClientTypes.NamedFilterAggType? = nil,
            constant: QuickSightClientTypes.TopicRangeFilterConstant? = nil,
            inclusive: Swift.Bool = false
        )
        {
            self.aggregation = aggregation
            self.constant = constant
            self.inclusive = inclusive
        }
    }
}

extension QuickSightClientTypes.TopicNumericRangeFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicNumericRangeFilter(aggregation: \(Swift.String(describing: aggregation)), inclusive: \(Swift.String(describing: inclusive)), constant: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum TopicRelativeDateFilterFunction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case last
        case next
        case now
        case previous
        case `this`
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicRelativeDateFilterFunction] {
            return [
                .last,
                .next,
                .now,
                .previous,
                .this
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .last: return "LAST"
            case .next: return "NEXT"
            case .now: return "NOW"
            case .previous: return "PREVIOUS"
            case .this: return "THIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a relative date filter.
    public struct TopicRelativeDateFilter: Swift.Sendable {
        /// The constant used in a relative date filter.
        public var constant: QuickSightClientTypes.TopicSingularFilterConstant?
        /// The function to be used in a relative date filter to determine the range of dates to include in the results. Valid values for this structure are BEFORE, AFTER, and BETWEEN.
        public var relativeDateFilterFunction: QuickSightClientTypes.TopicRelativeDateFilterFunction?
        /// The level of time precision that is used to aggregate DateTime values.
        public var timeGranularity: QuickSightClientTypes.TopicTimeGranularity?

        public init(
            constant: QuickSightClientTypes.TopicSingularFilterConstant? = nil,
            relativeDateFilterFunction: QuickSightClientTypes.TopicRelativeDateFilterFunction? = nil,
            timeGranularity: QuickSightClientTypes.TopicTimeGranularity? = nil
        )
        {
            self.constant = constant
            self.relativeDateFilterFunction = relativeDateFilterFunction
            self.timeGranularity = timeGranularity
        }
    }
}

extension QuickSightClientTypes.TopicRelativeDateFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TopicRelativeDateFilter(relativeDateFilterFunction: \(Swift.String(describing: relativeDateFilterFunction)), timeGranularity: \(Swift.String(describing: timeGranularity)), constant: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// A structure that represents a filter used to select items for a topic.
    public struct TopicFilter: Swift.Sendable {
        /// The category filter that is associated with this filter.
        public var categoryFilter: QuickSightClientTypes.TopicCategoryFilter?
        /// The date range filter.
        public var dateRangeFilter: QuickSightClientTypes.TopicDateRangeFilter?
        /// The class of the filter. Valid values for this structure are ENFORCED_VALUE_FILTER, CONDITIONAL_VALUE_FILTER, and NAMED_VALUE_FILTER.
        public var filterClass: QuickSightClientTypes.FilterClass?
        /// A description of the filter used to select items for a topic.
        public var filterDescription: Swift.String?
        /// The name of the filter.
        /// This member is required.
        public var filterName: Swift.String?
        /// The other names or aliases for the filter.
        public var filterSynonyms: [Swift.String]?
        /// The type of the filter. Valid values for this structure are CATEGORY_FILTER, NUMERIC_EQUALITY_FILTER, NUMERIC_RANGE_FILTER, DATE_RANGE_FILTER, and RELATIVE_DATE_FILTER.
        public var filterType: QuickSightClientTypes.NamedFilterType?
        /// The numeric equality filter.
        public var numericEqualityFilter: QuickSightClientTypes.TopicNumericEqualityFilter?
        /// The numeric range filter.
        public var numericRangeFilter: QuickSightClientTypes.TopicNumericRangeFilter?
        /// The name of the field that the filter operates on.
        /// This member is required.
        public var operandFieldName: Swift.String?
        /// The relative date filter.
        public var relativeDateFilter: QuickSightClientTypes.TopicRelativeDateFilter?

        public init(
            categoryFilter: QuickSightClientTypes.TopicCategoryFilter? = nil,
            dateRangeFilter: QuickSightClientTypes.TopicDateRangeFilter? = nil,
            filterClass: QuickSightClientTypes.FilterClass? = nil,
            filterDescription: Swift.String? = nil,
            filterName: Swift.String? = nil,
            filterSynonyms: [Swift.String]? = nil,
            filterType: QuickSightClientTypes.NamedFilterType? = nil,
            numericEqualityFilter: QuickSightClientTypes.TopicNumericEqualityFilter? = nil,
            numericRangeFilter: QuickSightClientTypes.TopicNumericRangeFilter? = nil,
            operandFieldName: Swift.String? = nil,
            relativeDateFilter: QuickSightClientTypes.TopicRelativeDateFilter? = nil
        )
        {
            self.categoryFilter = categoryFilter
            self.dateRangeFilter = dateRangeFilter
            self.filterClass = filterClass
            self.filterDescription = filterDescription
            self.filterName = filterName
            self.filterSynonyms = filterSynonyms
            self.filterType = filterType
            self.numericEqualityFilter = numericEqualityFilter
            self.numericRangeFilter = numericRangeFilter
            self.operandFieldName = operandFieldName
            self.relativeDateFilter = relativeDateFilter
        }
    }
}

extension QuickSightClientTypes {

    public enum NamedEntityAggType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case custom
        case distinctCount
        case max
        case median
        case min
        case percentile
        case stdev
        case stdevp
        case sum
        case `var`
        case varp
        case sdkUnknown(Swift.String)

        public static var allCases: [NamedEntityAggType] {
            return [
                .average,
                .count,
                .custom,
                .distinctCount,
                .max,
                .median,
                .min,
                .percentile,
                .stdev,
                .stdevp,
                .sum,
                .var,
                .varp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .custom: return "CUSTOM"
            case .distinctCount: return "DISTINCT_COUNT"
            case .max: return "MAX"
            case .median: return "MEDIAN"
            case .min: return "MIN"
            case .percentile: return "PERCENTILE"
            case .stdev: return "STDEV"
            case .stdevp: return "STDEVP"
            case .sum: return "SUM"
            case .var: return "VAR"
            case .varp: return "VARP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a metric.
    public struct NamedEntityDefinitionMetric: Swift.Sendable {
        /// The aggregation of a named entity. Valid values for this structure are SUM, MIN, MAX, COUNT, AVERAGE, DISTINCT_COUNT, STDEV, STDEVP, VAR, VARP, PERCENTILE, MEDIAN, and CUSTOM.
        public var aggregation: QuickSightClientTypes.NamedEntityAggType?
        /// The additional parameters for an aggregation function.
        public var aggregationFunctionParameters: [Swift.String: Swift.String]?

        public init(
            aggregation: QuickSightClientTypes.NamedEntityAggType? = nil,
            aggregationFunctionParameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.aggregation = aggregation
            self.aggregationFunctionParameters = aggregationFunctionParameters
        }
    }
}

extension QuickSightClientTypes {

    public enum PropertyRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case id
        case primary
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyRole] {
            return [
                .id,
                .primary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .id: return "ID"
            case .primary: return "PRIMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum PropertyUsage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dimension
        case inherit
        case measure
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyUsage] {
            return [
                .dimension,
                .inherit,
                .measure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dimension: return "DIMENSION"
            case .inherit: return "INHERIT"
            case .measure: return "MEASURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a named entity.
    public struct NamedEntityDefinition: Swift.Sendable {
        /// The name of the entity.
        public var fieldName: Swift.String?
        /// The definition of a metric.
        public var metric: QuickSightClientTypes.NamedEntityDefinitionMetric?
        /// The property name to be used for the named entity.
        public var propertyName: Swift.String?
        /// The property role. Valid values for this structure are PRIMARY and ID.
        public var propertyRole: QuickSightClientTypes.PropertyRole?
        /// The property usage. Valid values for this structure are INHERIT, DIMENSION, and MEASURE.
        public var propertyUsage: QuickSightClientTypes.PropertyUsage?

        public init(
            fieldName: Swift.String? = nil,
            metric: QuickSightClientTypes.NamedEntityDefinitionMetric? = nil,
            propertyName: Swift.String? = nil,
            propertyRole: QuickSightClientTypes.PropertyRole? = nil,
            propertyUsage: QuickSightClientTypes.PropertyUsage? = nil
        )
        {
            self.fieldName = fieldName
            self.metric = metric
            self.propertyName = propertyName
            self.propertyRole = propertyRole
            self.propertyUsage = propertyUsage
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a semantic entity type.
    public struct SemanticEntityType: Swift.Sendable {
        /// The semantic entity sub type name.
        public var subTypeName: Swift.String?
        /// The semantic entity type name.
        public var typeName: Swift.String?
        /// The semantic entity type parameters.
        public var typeParameters: [Swift.String: Swift.String]?

        public init(
            subTypeName: Swift.String? = nil,
            typeName: Swift.String? = nil,
            typeParameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.subTypeName = subTypeName
            self.typeName = typeName
            self.typeParameters = typeParameters
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a named entity.
    public struct TopicNamedEntity: Swift.Sendable {
        /// The definition of a named entity.
        public var definition: [QuickSightClientTypes.NamedEntityDefinition]?
        /// The description of the named entity.
        public var entityDescription: Swift.String?
        /// The name of the named entity.
        /// This member is required.
        public var entityName: Swift.String?
        /// The other names or aliases for the named entity.
        public var entitySynonyms: [Swift.String]?
        /// The type of named entity that a topic represents.
        public var semanticEntityType: QuickSightClientTypes.SemanticEntityType?

        public init(
            definition: [QuickSightClientTypes.NamedEntityDefinition]? = nil,
            entityDescription: Swift.String? = nil,
            entityName: Swift.String? = nil,
            entitySynonyms: [Swift.String]? = nil,
            semanticEntityType: QuickSightClientTypes.SemanticEntityType? = nil
        )
        {
            self.definition = definition
            self.entityDescription = entityDescription
            self.entityName = entityName
            self.entitySynonyms = entitySynonyms
            self.semanticEntityType = semanticEntityType
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a dataset.
    public struct DatasetMetadata: Swift.Sendable {
        /// The list of calculated field definitions.
        public var calculatedFields: [QuickSightClientTypes.TopicCalculatedField]?
        /// The list of column definitions.
        public var columns: [QuickSightClientTypes.TopicColumn]?
        /// The definition of a data aggregation.
        public var dataAggregation: QuickSightClientTypes.DataAggregation?
        /// The Amazon Resource Name (ARN) of the dataset.
        /// This member is required.
        public var datasetArn: Swift.String?
        /// The description of the dataset.
        public var datasetDescription: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The list of filter definitions.
        public var filters: [QuickSightClientTypes.TopicFilter]?
        /// The list of named entities definitions.
        public var namedEntities: [QuickSightClientTypes.TopicNamedEntity]?

        public init(
            calculatedFields: [QuickSightClientTypes.TopicCalculatedField]? = nil,
            columns: [QuickSightClientTypes.TopicColumn]? = nil,
            dataAggregation: QuickSightClientTypes.DataAggregation? = nil,
            datasetArn: Swift.String? = nil,
            datasetDescription: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            filters: [QuickSightClientTypes.TopicFilter]? = nil,
            namedEntities: [QuickSightClientTypes.TopicNamedEntity]? = nil
        )
        {
            self.calculatedFields = calculatedFields
            self.columns = columns
            self.dataAggregation = dataAggregation
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetName = datasetName
            self.filters = filters
            self.namedEntities = namedEntities
        }
    }
}

extension QuickSightClientTypes {

    public enum TopicUserExperienceVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case legacy
        case newReaderExperience
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicUserExperienceVersion] {
            return [
                .legacy,
                .newReaderExperience
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .legacy: return "LEGACY"
            case .newReaderExperience: return "NEW_READER_EXPERIENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that describes the details of a topic, such as its name, description, and associated data sets.
    public struct TopicDetails: Swift.Sendable {
        /// Configuration options for a Topic.
        public var configOptions: QuickSightClientTypes.TopicConfigOptions?
        /// The data sets that the topic is associated with.
        public var dataSets: [QuickSightClientTypes.DatasetMetadata]?
        /// The description of the topic.
        public var description: Swift.String?
        /// The name of the topic.
        public var name: Swift.String?
        /// The user experience version of a topic.
        public var userExperienceVersion: QuickSightClientTypes.TopicUserExperienceVersion?

        public init(
            configOptions: QuickSightClientTypes.TopicConfigOptions? = nil,
            dataSets: [QuickSightClientTypes.DatasetMetadata]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            userExperienceVersion: QuickSightClientTypes.TopicUserExperienceVersion? = nil
        )
        {
            self.configOptions = configOptions
            self.dataSets = dataSets
            self.description = description
            self.name = name
            self.userExperienceVersion = userExperienceVersion
        }
    }
}

public struct CreateTopicInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that you want to create a topic in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags that are assigned to the dataset.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The definition of a topic to create.
    /// This member is required.
    public var topic: QuickSightClientTypes.TopicDetails?
    /// The ID for the topic that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        topic: QuickSightClientTypes.TopicDetails? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.tags = tags
        self.topic = topic
        self.topicId = topicId
    }
}

public struct CreateTopicOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the topic.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the topic refresh.
    public var refreshArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the topic that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        refreshArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.refreshArn = refreshArn
        self.requestId = requestId
        self.status = status
        self.topicId = topicId
    }
}

extension QuickSightClientTypes {

    public enum TopicScheduleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicScheduleType] {
            return [
                .daily,
                .hourly,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that represents a topic refresh schedule.
    public struct TopicRefreshSchedule: Swift.Sendable {
        /// A Boolean value that controls whether to schedule runs at the same schedule that is specified in SPICE dataset.
        /// This member is required.
        public var basedOnSpiceSchedule: Swift.Bool
        /// A Boolean value that controls whether to schedule is enabled.
        /// This member is required.
        public var isEnabled: Swift.Bool?
        /// The time of day when the refresh should run, for example, Monday-Sunday.
        public var repeatAt: Swift.String?
        /// The starting date and time for the refresh schedule.
        public var startingAt: Foundation.Date?
        /// The timezone that you want the refresh schedule to use.
        public var timezone: Swift.String?
        /// The type of refresh schedule. Valid values for this structure are HOURLY, DAILY, WEEKLY, and MONTHLY.
        public var topicScheduleType: QuickSightClientTypes.TopicScheduleType?

        public init(
            basedOnSpiceSchedule: Swift.Bool = false,
            isEnabled: Swift.Bool? = nil,
            repeatAt: Swift.String? = nil,
            startingAt: Foundation.Date? = nil,
            timezone: Swift.String? = nil,
            topicScheduleType: QuickSightClientTypes.TopicScheduleType? = nil
        )
        {
            self.basedOnSpiceSchedule = basedOnSpiceSchedule
            self.isEnabled = isEnabled
            self.repeatAt = repeatAt
            self.startingAt = startingAt
            self.timezone = timezone
            self.topicScheduleType = topicScheduleType
        }
    }
}

public struct CreateTopicRefreshScheduleInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic you're creating a refresh schedule for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the dataset.
    /// This member is required.
    public var datasetArn: Swift.String?
    /// The name of the dataset.
    public var datasetName: Swift.String?
    /// The definition of a refresh schedule.
    /// This member is required.
    public var refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        datasetArn: Swift.String? = nil,
        datasetName: Swift.String? = nil,
        refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.refreshSchedule = refreshSchedule
        self.topicId = topicId
    }
}

public struct CreateTopicRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct CreateVPCConnectionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account where you want to create a new VPC connection.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
    public var dnsResolvers: [Swift.String]?
    /// The display name for the VPC connection.
    /// This member is required.
    public var name: Swift.String?
    /// The IAM role to associate with the VPC connection.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of security group IDs for the VPC connection.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs for the VPC connection.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// A map of the key-value pairs for the resource tag or tags assigned to the VPC connection.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
    /// This member is required.
    public var vpcConnectionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dnsResolvers: [Swift.String]? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dnsResolvers = dnsResolvers
        self.name = name
        self.roleArn = roleArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcConnectionId = vpcConnectionId
    }
}

extension QuickSightClientTypes {

    public enum VPCConnectionAvailabilityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case partiallyAvailable
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [VPCConnectionAvailabilityStatus] {
            return [
                .available,
                .partiallyAvailable,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .partiallyAvailable: return "PARTIALLY_AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum VPCConnectionResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case creationSuccessful
        case deleted
        case deletionFailed
        case deletionInProgress
        case updateFailed
        case updateInProgress
        case updateSuccessful
        case sdkUnknown(Swift.String)

        public static var allCases: [VPCConnectionResourceStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .creationSuccessful,
                .deleted,
                .deletionFailed,
                .deletionInProgress,
                .updateFailed,
                .updateInProgress,
                .updateSuccessful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .creationSuccessful: return "CREATION_SUCCESSFUL"
            case .deleted: return "DELETED"
            case .deletionFailed: return "DELETION_FAILED"
            case .deletionInProgress: return "DELETION_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSuccessful: return "UPDATE_SUCCESSFUL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateVPCConnectionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the VPC connection.
    public var arn: Swift.String?
    /// The availability status of the VPC connection.
    public var availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus?
    /// The status of the creation of the VPC connection.
    public var creationStatus: QuickSightClientTypes.VPCConnectionResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the VPC connection that you're creating. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var vpcConnectionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus? = nil,
        creationStatus: QuickSightClientTypes.VPCConnectionResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.availabilityStatus = availabilityStatus
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.vpcConnectionId = vpcConnectionId
    }
}

extension QuickSightClientTypes {

    public enum DashboardErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case columnGeographicRoleMismatch
        case columnReplacementMissing
        case columnTypeMismatch
        case dataSetNotFound
        case internalFailure
        case parameterNotFound
        case parameterTypeInvalid
        case parameterValueIncompatible
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardErrorType] {
            return [
                .accessDenied,
                .columnGeographicRoleMismatch,
                .columnReplacementMissing,
                .columnTypeMismatch,
                .dataSetNotFound,
                .internalFailure,
                .parameterNotFound,
                .parameterTypeInvalid,
                .parameterValueIncompatible,
                .sourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .columnGeographicRoleMismatch: return "COLUMN_GEOGRAPHIC_ROLE_MISMATCH"
            case .columnReplacementMissing: return "COLUMN_REPLACEMENT_MISSING"
            case .columnTypeMismatch: return "COLUMN_TYPE_MISMATCH"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .parameterNotFound: return "PARAMETER_NOT_FOUND"
            case .parameterTypeInvalid: return "PARAMETER_TYPE_INVALID"
            case .parameterValueIncompatible: return "PARAMETER_VALUE_INCOMPATIBLE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard error.
    public struct DashboardError: Swift.Sendable {
        /// Message.
        public var message: Swift.String?
        /// Type.
        public var type: QuickSightClientTypes.DashboardErrorType?
        /// Lists the violated entities that caused the dashboard error.
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DashboardErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard version.
    public struct DashboardVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: Foundation.Date?
        /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with this version of the dashboard.
        public var dataSetArns: [Swift.String]?
        /// Description.
        public var description: Swift.String?
        /// Errors associated with this dashboard version.
        public var errors: [QuickSightClientTypes.DashboardError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with a version of the dashboard.
        public var themeArn: Swift.String?
        /// Version number for this version of the dashboard.
        public var versionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dataSetArns: [Swift.String]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.DashboardError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSetArns = dataSetArns
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard.
    public struct Dashboard: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard was created.
        public var createdTime: Foundation.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dashboard was published.
        public var lastPublishedTime: Foundation.Date?
        /// The last time that this dashboard was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
        public var linkEntities: [Swift.String]?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Version.
        public var version: QuickSightClientTypes.DashboardVersion?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            linkEntities: [Swift.String]? = nil,
            name: Swift.String? = nil,
            version: QuickSightClientTypes.DashboardVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.linkEntities = linkEntities
            self.name = name
            self.version = version
        }
    }
}

extension QuickSightClientTypes {

    public enum DashboardFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dashboardName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightUser
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardFilterAttribute] {
            return [
                .dashboardName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightUser,
                .quicksightViewerOrOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dashboardName: return "DASHBOARD_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightUser: return "QUICKSIGHT_USER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A filter that you apply when searching for dashboards.
    public struct DashboardSearchFilter: Swift.Sendable {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the dashboards's owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as the only owner of the dashboard are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners of the dashboards are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any dashboards with that ARN listed as one of the owners or viewers of the dashboards are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DASHBOARD_NAME: Any dashboards whose names have a substring match to this value will be returned.
        public var name: QuickSightClientTypes.DashboardFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DASHBOARD_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_USER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.DashboardFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard summary.
    public struct DashboardSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard was created.
        public var createdTime: Foundation.Date?
        /// Dashboard ID.
        public var dashboardId: Swift.String?
        /// The last time that this dashboard was published.
        public var lastPublishedTime: Foundation.Date?
        /// The last time that this dashboard was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A display name for the dashboard.
        public var name: Swift.String?
        /// Published version number.
        public var publishedVersionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dashboardId: Swift.String? = nil,
            lastPublishedTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            publishedVersionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dashboardId = dashboardId
            self.lastPublishedTime = lastPublishedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishedVersionNumber = publishedVersionNumber
        }
    }
}

extension QuickSightClientTypes {

    /// Dashboard version summary.
    public struct DashboardVersionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The time that this dashboard version was created.
        public var createdTime: Foundation.Date?
        /// Description.
        public var description: Swift.String?
        /// Source entity ARN.
        public var sourceEntityArn: Swift.String?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// Version number.
        public var versionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.versionNumber = versionNumber
        }
    }
}

extension QuickSightClientTypes {

    /// Output column.
    public struct OutputColumn: Swift.Sendable {
        /// A description for a column.
        public var description: Swift.String?
        /// The display name of the column..
        public var name: Swift.String?
        /// The sub data type of the column.
        public var subType: QuickSightClientTypes.ColumnDataSubType?
        /// The data type of the column.
        public var type: QuickSightClientTypes.ColumnDataType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            subType: QuickSightClientTypes.ColumnDataSubType? = nil,
            type: QuickSightClientTypes.ColumnDataType? = nil
        )
        {
            self.description = description
            self.name = name
            self.subType = subType
            self.type = type
        }
    }
}

extension QuickSightClientTypes.OutputColumn: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputColumn(name: \(Swift.String(describing: name)), subType: \(Swift.String(describing: subType)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    /// Dataset.
    public struct DataSet: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
        public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
        /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
        public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
        /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset isn't imported into SPICE.
        public var consumedSpiceCapacityInBytes: Swift.Int
        /// The time that this dataset was created.
        public var createdTime: Foundation.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// The usage configuration to apply to child datasets that reference this dataset as a source.
        public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
        /// The parameters that are declared in a dataset.
        public var datasetParameters: [QuickSightClientTypes.DatasetParameter]?
        /// The folder that contains fields and nested subfolders for your dataset.
        public var fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// Configures the combination and transformation of the data from the physical tables.
        public var logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The list of columns after all transforms. These columns are available in templates, analyses, and dashboards.
        public var outputColumns: [QuickSightClientTypes.OutputColumn]?
        /// Declares the physical tables that are available in the underlying data sources.
        public var physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// The element you can use to define tags for row-level security.
        public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

        public init(
            arn: Swift.String? = nil,
            columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
            columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
            consumedSpiceCapacityInBytes: Swift.Int = 0,
            createdTime: Foundation.Date? = nil,
            dataSetId: Swift.String? = nil,
            dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
            datasetParameters: [QuickSightClientTypes.DatasetParameter]? = nil,
            fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]? = nil,
            name: Swift.String? = nil,
            outputColumns: [QuickSightClientTypes.OutputColumn]? = nil,
            physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
        )
        {
            self.arn = arn
            self.columnGroups = columnGroups
            self.columnLevelPermissionRules = columnLevelPermissionRules
            self.consumedSpiceCapacityInBytes = consumedSpiceCapacityInBytes
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.dataSetUsageConfiguration = dataSetUsageConfiguration
            self.datasetParameters = datasetParameters
            self.fieldFolders = fieldFolders
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.logicalTableMap = logicalTableMap
            self.name = name
            self.outputColumns = outputColumns
            self.physicalTableMap = physicalTableMap
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
        }
    }
}

extension QuickSightClientTypes {

    public enum DataSetFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datasetName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case quicksightOwner
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetFilterAttribute] {
            return [
                .datasetName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .quicksightOwner,
                .quicksightViewerOrOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datasetName: return "DATASET_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum LookbackWindowSizeUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [LookbackWindowSizeUnit] {
            return [
                .day,
                .hour,
                .week
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The lookback window setup of an incremental refresh configuration.
    public struct LookbackWindow: Swift.Sendable {
        /// The name of the lookback window column.
        /// This member is required.
        public var columnName: Swift.String?
        /// The lookback window column size.
        /// This member is required.
        public var size: Swift.Int?
        /// The size unit that is used for the lookback window column. Valid values for this structure are HOUR, DAY, and WEEK.
        /// This member is required.
        public var sizeUnit: QuickSightClientTypes.LookbackWindowSizeUnit?

        public init(
            columnName: Swift.String? = nil,
            size: Swift.Int? = nil,
            sizeUnit: QuickSightClientTypes.LookbackWindowSizeUnit? = nil
        )
        {
            self.columnName = columnName
            self.size = size
            self.sizeUnit = sizeUnit
        }
    }
}

extension QuickSightClientTypes {

    /// The incremental refresh configuration for a dataset.
    public struct IncrementalRefresh: Swift.Sendable {
        /// The lookback window setup for an incremental refresh configuration.
        /// This member is required.
        public var lookbackWindow: QuickSightClientTypes.LookbackWindow?

        public init(
            lookbackWindow: QuickSightClientTypes.LookbackWindow? = nil
        )
        {
            self.lookbackWindow = lookbackWindow
        }
    }
}

extension QuickSightClientTypes {

    /// The refresh configuration of a dataset.
    public struct RefreshConfiguration: Swift.Sendable {
        /// The incremental refresh for the dataset.
        /// This member is required.
        public var incrementalRefresh: QuickSightClientTypes.IncrementalRefresh?

        public init(
            incrementalRefresh: QuickSightClientTypes.IncrementalRefresh? = nil
        )
        {
            self.incrementalRefresh = incrementalRefresh
        }
    }
}

extension QuickSightClientTypes {

    /// The refresh properties of a dataset.
    public struct DataSetRefreshProperties: Swift.Sendable {
        /// The refresh configuration for a dataset.
        /// This member is required.
        public var refreshConfiguration: QuickSightClientTypes.RefreshConfiguration?

        public init(
            refreshConfiguration: QuickSightClientTypes.RefreshConfiguration? = nil
        )
        {
            self.refreshConfiguration = refreshConfiguration
        }
    }
}

extension QuickSightClientTypes {

    /// A filter that you apply when searching for datasets.
    public struct DataSetSearchFilter: Swift.Sendable {
        /// The name of the value that you want to use as a filter, for example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the dataset owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners of the dataset are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as the only owner of the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners if the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any datasets with that ARN listed as one of the owners or viewers of the dataset are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DATASET_NAME: Any datasets whose names have a substring match to this value will be returned.
        /// This member is required.
        public var name: QuickSightClientTypes.DataSetFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose datasets you want to search in the "Value" field. For example, "Name":"QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east- 1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the datasets you are searching for. For example, "Name":"DATASET_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASET_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, in this case QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.DataSetFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// Dataset summary.
    public struct DataSetSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the dataset.
        public var arn: Swift.String?
        /// A value that indicates if the dataset has column level permission configured.
        public var columnLevelPermissionRulesApplied: Swift.Bool
        /// The time that this dataset was created.
        public var createdTime: Foundation.Date?
        /// The ID of the dataset.
        public var dataSetId: Swift.String?
        /// A value that indicates whether you want to import the data into SPICE.
        public var importMode: QuickSightClientTypes.DataSetImportMode?
        /// The last time that this dataset was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A display name for the dataset.
        public var name: Swift.String?
        /// The row-level security configuration for the dataset.
        public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
        /// Whether or not the row level permission tags are applied.
        public var rowLevelPermissionTagConfigurationApplied: Swift.Bool

        public init(
            arn: Swift.String? = nil,
            columnLevelPermissionRulesApplied: Swift.Bool = false,
            createdTime: Foundation.Date? = nil,
            dataSetId: Swift.String? = nil,
            importMode: QuickSightClientTypes.DataSetImportMode? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
            rowLevelPermissionTagConfigurationApplied: Swift.Bool = false
        )
        {
            self.arn = arn
            self.columnLevelPermissionRulesApplied = columnLevelPermissionRulesApplied
            self.createdTime = createdTime
            self.dataSetId = dataSetId
            self.importMode = importMode
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
            self.rowLevelPermissionTagConfigurationApplied = rowLevelPermissionTagConfigurationApplied
        }
    }
}

extension QuickSightClientTypes {

    public enum DataSourceErrorInfoType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case conflict
        case copySourceNotFound
        case engineVersionNotSupported
        case genericSqlFailure
        case timeout
        case unknown
        case unknownHost
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceErrorInfoType] {
            return [
                .accessDenied,
                .conflict,
                .copySourceNotFound,
                .engineVersionNotSupported,
                .genericSqlFailure,
                .timeout,
                .unknown,
                .unknownHost
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .conflict: return "CONFLICT"
            case .copySourceNotFound: return "COPY_SOURCE_NOT_FOUND"
            case .engineVersionNotSupported: return "ENGINE_VERSION_NOT_SUPPORTED"
            case .genericSqlFailure: return "GENERIC_SQL_FAILURE"
            case .timeout: return "TIMEOUT"
            case .unknown: return "UNKNOWN"
            case .unknownHost: return "UNKNOWN_HOST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Error information for the data source creation or update.
    public struct DataSourceErrorInfo: Swift.Sendable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.DataSourceErrorInfoType?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.DataSourceErrorInfoType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The structure of a data source.
    public struct DataSource: Swift.Sendable {
        /// A set of alternate data source parameters that you want to share for the credentials stored with this data source. The credentials are applied in tandem with the data source parameters when you copy a data source by using a create or update request. The API operation compares the DataSourceParameters structure that's in the request with the structures in the AlternateDataSourceParameters allow list. If the structures are an exact match, the request is allowed to use the credentials from this existing data source. If the AlternateDataSourceParameters list is null, the Credentials originally used with this DataSourceParameters are automatically allowed.
        public var alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]?
        /// The Amazon Resource Name (ARN) of the data source.
        public var arn: Swift.String?
        /// The time that this data source was created.
        public var createdTime: Foundation.Date?
        /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var dataSourceId: Swift.String?
        /// The parameters that Amazon QuickSight uses to connect to your underlying source. This is a variant type structure. For this structure to be valid, only one of the attributes can be non-null.
        public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
        /// Error information from the last update or the creation of the data source.
        public var errorInfo: QuickSightClientTypes.DataSourceErrorInfo?
        /// The last time that this data source was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A display name for the data source.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.
        public var secretArn: Swift.String?
        /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
        public var sslProperties: QuickSightClientTypes.SslProperties?
        /// The HTTP status of the request.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The type of the data source. This type indicates which database engine the data source connects to.
        public var type: QuickSightClientTypes.DataSourceType?
        /// The VPC connection information. You need to use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
        public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

        public init(
            alternateDataSourceParameters: [QuickSightClientTypes.DataSourceParameters]? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dataSourceId: Swift.String? = nil,
            dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
            errorInfo: QuickSightClientTypes.DataSourceErrorInfo? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            sslProperties: QuickSightClientTypes.SslProperties? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            type: QuickSightClientTypes.DataSourceType? = nil,
            vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
        )
        {
            self.alternateDataSourceParameters = alternateDataSourceParameters
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.dataSourceParameters = dataSourceParameters
            self.errorInfo = errorInfo
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.secretArn = secretArn
            self.sslProperties = sslProperties
            self.status = status
            self.type = type
            self.vpcConnectionProperties = vpcConnectionProperties
        }
    }
}

extension QuickSightClientTypes {

    public enum DataSourceFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case datasourceName
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceFilterAttribute] {
            return [
                .datasourceName,
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .datasourceName: return "DATASOURCE_NAME"
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A filter that you apply when searching for data sources.
    public struct DataSourceSearchFilter: Swift.Sendable {
        /// The name of the value that you want to use as a filter, for example, "Name": "DIRECT_QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners or viewers of the data sources are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as one of the owners if the data source are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any data sources with that ARN listed as the only owner of the data source are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DATASOURCE_NAME: Any data sources whose names have a substring match to the provided value are returned.
        /// This member is required.
        public var name: QuickSightClientTypes.DataSourceFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose data sources you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the data sources you are searching for. For example, "Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value DATASOURCE_NAME.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item, for example DIRECT_QUICKSIGHT_OWNER, that you want to use as a filter, for example, "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1".
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.DataSourceFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// A DataSourceSummary object that returns a summary of a data source.
    public struct DataSourceSummary: Swift.Sendable {
        /// The arn of the datasource.
        public var arn: Swift.String?
        /// The date and time that the data source was created. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public var createdTime: Foundation.Date?
        /// The unique ID of the data source.
        public var dataSourceId: Swift.String?
        /// The date and time the data source was last updated. This value is expressed in MM-DD-YYYY HH:MM:SS format.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of the data source.
        public var name: Swift.String?
        /// The type of the data source.
        public var type: QuickSightClientTypes.DataSourceType?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            dataSourceId: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            type: QuickSightClientTypes.DataSourceType? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSourceId = dataSourceId
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.type = type
        }
    }
}

public struct DeleteAccountCustomizationInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to delete Amazon QuickSight customizations from in this Amazon Web Services Region.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're deleting the customizations from.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

public struct DeleteAccountCustomizationOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteAccountSubscriptionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account that you want to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

public struct DeleteAccountSubscriptionOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteAnalysisInput: Swift.Sendable {
    /// The ID of the analysis that you're deleting.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account where you want to delete an analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// This option defaults to the value NoForceDeleteWithoutRecovery. To immediately delete the analysis, add the ForceDeleteWithoutRecovery option. You can't restore an analysis after it's deleted.
    public var forceDeleteWithoutRecovery: Swift.Bool?
    /// A value that specifies the number of days that Amazon QuickSight waits before it deletes the analysis. You can't use this parameter with the ForceDeleteWithoutRecovery option in the same API call. The default value is 30.
    public var recoveryWindowInDays: Swift.Int?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        forceDeleteWithoutRecovery: Swift.Bool? = false,
        recoveryWindowInDays: Swift.Int? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.forceDeleteWithoutRecovery = forceDeleteWithoutRecovery
        self.recoveryWindowInDays = recoveryWindowInDays
    }
}

public struct DeleteAnalysisOutput: Swift.Sendable {
    /// The ID of the deleted analysis.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the deleted analysis.
    public var arn: Swift.String?
    /// The date and time that the analysis is scheduled to be deleted.
    public var deletionTime: Foundation.Date?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        deletionTime: Foundation.Date? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.deletionTime = deletionTime
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteDashboardInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard. If the version number property is provided, only the specified version of the dashboard is deleted.
    public var versionNumber: Swift.Int?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

public struct DeleteDashboardOutput: Swift.Sendable {
    /// The Secure Socket Layer (SSL) properties that apply for the resource.
    public var arn: Swift.String?
    /// The ID of the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteDataSetInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct DeleteDataSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteDataSetRefreshPropertiesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct DeleteDataSetRefreshPropertiesOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteDataSourceInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

public struct DeleteDataSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data source that you deleted.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteFolderInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

public struct DeleteFolderOutput: Swift.Sendable {
    /// The Amazon Resource Name of the deleted folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteFolderMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Folder ID.
    /// This member is required.
    public var folderId: Swift.String?
    /// The ID of the asset that you want to delete.
    /// This member is required.
    public var memberId: Swift.String?
    /// The member type of the asset that you want to delete from a folder.
    /// This member is required.
    public var memberType: QuickSightClientTypes.MemberType?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        memberType: QuickSightClientTypes.MemberType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.memberId = memberId
        self.memberType = memberType
    }
}

public struct DeleteFolderMembershipOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteGroupInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want to delete.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

public struct DeleteGroupOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteGroupMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to delete the user from.
    /// This member is required.
    public var groupName: Swift.String?
    /// The name of the user that you want to delete from the group membership.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace of the group that you want to remove a user from.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

public struct DeleteGroupMembershipOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteIAMPolicyAssignmentInput: Swift.Sendable {
    /// The name of the assignment.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services account ID where you want to delete the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

public struct DeleteIAMPolicyAssignmentOutput: Swift.Sendable {
    /// The name of the assignment.
    public var assignmentName: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        assignmentName: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentName = assignmentName
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteIdentityPropagationConfigInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that you want to delete an identity propagation configuration from.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the Amazon Web Services service that you want to delete the associated access scopes and authorized targets from.
    /// This member is required.
    public var service: QuickSightClientTypes.ServiceType?

    public init(
        awsAccountId: Swift.String? = nil,
        service: QuickSightClientTypes.ServiceType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.service = service
    }
}

public struct DeleteIdentityPropagationConfigOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteNamespaceInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to delete the Amazon QuickSight namespace from.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to delete.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

public struct DeleteNamespaceOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The ID of the refresh schedule.
    /// This member is required.
    public var scheduleId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        scheduleId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.scheduleId = scheduleId
    }
}

public struct DeleteRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the refresh schedule.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The ID of the refresh schedule.
    public var scheduleId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        scheduleId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.scheduleId = scheduleId
        self.status = status
    }
}

public struct DeleteRoleCustomPermissionInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that includes the role.
    /// This member is required.
    public var namespace: Swift.String?
    /// The role that you want to remove permissions from.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.role = role
    }
}

public struct DeleteRoleCustomPermissionOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteRoleMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that contains the role.
    /// This member is required.
    public var namespace: Swift.String?
    /// The role that you want to remove permissions from.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.memberName = memberName
        self.namespace = namespace
        self.role = role
    }
}

public struct DeleteRoleMembershipOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteTemplateInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the template that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the template you want to delete.
    /// This member is required.
    public var templateId: Swift.String?
    /// Specifies the version of the template that you want to delete. If you don't provide a version number, DeleteTemplate deletes all versions of the template.
    public var versionNumber: Swift.Int?

    public init(
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

public struct DeleteTemplateOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template.
    public var templateId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

public struct DeleteTemplateAliasInput: Swift.Sendable {
    /// The name for the template alias. To delete a specific alias, you delete the version that the alias points to. You can specify the alias name, or specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the item to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template that the specified alias is for.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

public struct DeleteTemplateAliasOutput: Swift.Sendable {
    /// The name for the template alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the template you want to delete.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the template associated with the deletion.
    public var templateId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
    }
}

public struct DeleteThemeInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the theme that you're deleting.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An ID for the theme that you want to delete.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version of the theme that you want to delete. Note: If you don't provide a version number, you're using this call to DeleteTheme to delete all versions of the theme.
    public var versionNumber: Swift.Int?

    public init(
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

public struct DeleteThemeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme.
    public var themeId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

public struct DeleteThemeAliasInput: Swift.Sendable {
    /// The unique name for the theme alias to delete.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that the specified alias is for.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

public struct DeleteThemeAliasOutput: Swift.Sendable {
    /// The name for the theme alias.
    public var aliasName: Swift.String?
    /// The Amazon Resource Name (ARN) of the theme resource using the deleted alias.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// An ID for the theme associated with the deletion.
    public var themeId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
    }
}

public struct DeleteTopicInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic that you want to delete.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the topic that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct DeleteTopicOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the topic.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the topic that you want to delete. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.topicId = topicId
    }
}

public struct DeleteTopicRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.datasetId = datasetId
        self.topicId = topicId
    }
}

public struct DeleteTopicRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct DeleteUserInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to delete.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

public struct DeleteUserOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

///
public struct DeleteUserByPrincipalIdInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The principal ID of the user.
    /// This member is required.
    public var principalId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.principalId = principalId
    }
}

public struct DeleteUserByPrincipalIdOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct DeleteVPCConnectionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account where you want to delete a VPC connection.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
    /// This member is required.
    public var vpcConnectionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.vpcConnectionId = vpcConnectionId
    }
}

public struct DeleteVPCConnectionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted VPC connection.
    public var arn: Swift.String?
    /// The availability status of the VPC connection.
    public var availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus?
    /// The deletion status of the VPC connection.
    public var deletionStatus: QuickSightClientTypes.VPCConnectionResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
    public var vpcConnectionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus? = nil,
        deletionStatus: QuickSightClientTypes.VPCConnectionResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.availabilityStatus = availabilityStatus
        self.deletionStatus = deletionStatus
        self.requestId = requestId
        self.status = status
        self.vpcConnectionId = vpcConnectionId
    }
}

public struct DescribeAccountCustomizationInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to describe Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you want to describe Amazon QuickSight customizations for.
    public var namespace: Swift.String?
    /// The Resolved flag works with the other parameters to determine which view of Amazon QuickSight customizations is returned. You can add this flag to your command to use the same view that Amazon QuickSight uses to identify which customizations to apply to the console. Omit this flag, or set it to no-resolved, to reveal customizations that are configured at different levels.
    public var resolved: Swift.Bool?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        resolved: Swift.Bool? = false
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.resolved = resolved
    }
}

public struct DescribeAccountCustomizationOutput: Swift.Sendable {
    /// The Amazon QuickSight customizations that exist in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) of the customization that's associated with this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you're describing.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight namespace that you're describing.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeAccountSettingsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAccountSettingsOutput: Swift.Sendable {
    /// The Amazon QuickSight settings for this Amazon Web Services account. This information includes the edition of Amazon Amazon QuickSight that you subscribed to (Standard or Enterprise) and the notification email for the Amazon QuickSight subscription. In the QuickSight console, the Amazon QuickSight subscription is sometimes referred to as a QuickSight "account" even though it's technically not an account by itself. Instead, it's a subscription to the Amazon QuickSight service for your Amazon Web Services account. The edition that you subscribe to applies to Amazon QuickSight in every Amazon Web Services Region where you use it.
    public var accountSettings: QuickSightClientTypes.AccountSettings?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        accountSettings: QuickSightClientTypes.AccountSettings? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountSettings = accountSettings
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeAccountSubscriptionInput: Swift.Sendable {
    /// The Amazon Web Services account ID associated with your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAccountSubscriptionOutput: Swift.Sendable {
    /// A structure that contains the following elements:
    ///
    /// * Your Amazon QuickSight account name.
    ///
    /// * The edition of Amazon QuickSight that your account is using.
    ///
    /// * The notification email address that is associated with the Amazon QuickSight account.
    ///
    /// * The authentication type of the Amazon QuickSight account.
    ///
    /// * The status of the Amazon QuickSight account's subscription.
    public var accountInfo: QuickSightClientTypes.AccountInfo?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        accountInfo: QuickSightClientTypes.AccountInfo? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountInfo = accountInfo
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeAnalysisInput: Swift.Sendable {
    /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAnalysisOutput: Swift.Sendable {
    /// A metadata structure that contains summary information for the analysis that you're describing.
    public var analysis: QuickSightClientTypes.Analysis?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysis: QuickSightClientTypes.Analysis? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysis = analysis
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeAnalysisDefinitionInput: Swift.Sendable {
    /// The ID of the analysis that you're describing. The ID is part of the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAnalysisDefinitionOutput: Swift.Sendable {
    /// The ID of the analysis described.
    public var analysisId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// Errors associated with the analysis.
    public var errors: [QuickSightClientTypes.AnalysisError]?
    /// The descriptive name of the analysis.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the analysis.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the theme of the analysis.
    public var themeArn: Swift.String?

    public init(
        analysisId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        errors: [QuickSightClientTypes.AnalysisError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.themeArn = themeArn
    }
}

public struct DescribeAnalysisPermissionsInput: Swift.Sendable {
    /// The ID of the analysis whose permissions you're describing. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're describing. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAnalysisPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the analysis whose permissions you're describing.
    public var analysisArn: Swift.String?
    /// The ID of the analysis whose permissions you're describing.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeAssetBundleExportJobInput: Swift.Sendable {
    /// The ID of the job that you want described. The job ID is set when you start a new job with a StartAssetBundleExportJob API call.
    /// This member is required.
    public var assetBundleExportJobId: Swift.String?
    /// The ID of the Amazon Web Services account the export job is executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        assetBundleExportJobId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.assetBundleExportJobId = assetBundleExportJobId
        self.awsAccountId = awsAccountId
    }
}

extension QuickSightClientTypes {

    public enum IncludeFolderMembers: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case oneLevel
        case recurse
        case sdkUnknown(Swift.String)

        public static var allCases: [IncludeFolderMembers] {
            return [
                .none,
                .oneLevel,
                .recurse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .oneLevel: return "ONE_LEVEL"
            case .recurse: return "RECURSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeAssetBundleExportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the export job.
    public var arn: Swift.String?
    /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleExportJob API call.
    public var assetBundleExportJobId: Swift.String?
    /// The ID of the Amazon Web Services account that the export job was executed in.
    public var awsAccountId: Swift.String?
    /// The CloudFormation override property configuration for the export job.
    public var cloudFormationOverridePropertyConfiguration: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration?
    /// The time that the export job was created.
    public var createdTime: Foundation.Date?
    /// The URL to download the exported asset bundle data from. This URL is available only after the job has succeeded. This URL is valid for 5 minutes after issuance. Call DescribeAssetBundleExportJob again for a fresh URL if needed. The downloaded asset bundle is a zip file named assetbundle-{jobId}.qs. The file has a .qs extension. This URL can't be used in a StartAssetBundleImportJob API call and should only be used for download purposes.
    public var downloadUrl: Swift.String?
    /// An array of error records that describes any failures that occurred during the export job processing. Error records accumulate while the job runs. The complete set of error records is available after the job has completed and failed.
    public var errors: [QuickSightClientTypes.AssetBundleExportJobError]?
    /// The format of the exported asset bundle. A QUICKSIGHT_JSON formatted file can be used to make a StartAssetBundleImportJob API call. A CLOUDFORMATION_JSON formatted file can be used in the CloudFormation console and with the CloudFormation APIs.
    public var exportFormat: QuickSightClientTypes.AssetBundleExportFormat?
    /// The include dependencies flag.
    public var includeAllDependencies: Swift.Bool
    /// A setting that determines whether folder members are included.
    public var includeFolderMembers: QuickSightClientTypes.IncludeFolderMembers?
    /// The include folder memberships flag.
    public var includeFolderMemberships: Swift.Bool
    /// The include permissions flag.
    public var includePermissions: Swift.Bool
    /// The include tags flag.
    public var includeTags: Swift.Bool
    /// Indicates the status of a job through its queuing and execution. Poll this DescribeAssetBundleExportApi until JobStatus is either SUCCESSFUL or FAILED.
    public var jobStatus: QuickSightClientTypes.AssetBundleExportJobStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A list of resource ARNs that exported with the job.
    public var resourceArns: [Swift.String]?
    /// The HTTP status of the response.
    public var status: Swift.Int
    /// The validation strategy that is used to export the analysis or dashboard.
    public var validationStrategy: QuickSightClientTypes.AssetBundleExportJobValidationStrategy?
    /// An array of warning records that describe the analysis or dashboard that is exported. This array includes UI errors that can be skipped during the validation process. This property only appears if StrictModeForAllResources in ValidationStrategy is set to FALSE.
    public var warnings: [QuickSightClientTypes.AssetBundleExportJobWarning]?

    public init(
        arn: Swift.String? = nil,
        assetBundleExportJobId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        cloudFormationOverridePropertyConfiguration: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration? = nil,
        createdTime: Foundation.Date? = nil,
        downloadUrl: Swift.String? = nil,
        errors: [QuickSightClientTypes.AssetBundleExportJobError]? = nil,
        exportFormat: QuickSightClientTypes.AssetBundleExportFormat? = nil,
        includeAllDependencies: Swift.Bool = false,
        includeFolderMembers: QuickSightClientTypes.IncludeFolderMembers? = nil,
        includeFolderMemberships: Swift.Bool = false,
        includePermissions: Swift.Bool = false,
        includeTags: Swift.Bool = false,
        jobStatus: QuickSightClientTypes.AssetBundleExportJobStatus? = nil,
        requestId: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        status: Swift.Int = 0,
        validationStrategy: QuickSightClientTypes.AssetBundleExportJobValidationStrategy? = nil,
        warnings: [QuickSightClientTypes.AssetBundleExportJobWarning]? = nil
    )
    {
        self.arn = arn
        self.assetBundleExportJobId = assetBundleExportJobId
        self.awsAccountId = awsAccountId
        self.cloudFormationOverridePropertyConfiguration = cloudFormationOverridePropertyConfiguration
        self.createdTime = createdTime
        self.downloadUrl = downloadUrl
        self.errors = errors
        self.exportFormat = exportFormat
        self.includeAllDependencies = includeAllDependencies
        self.includeFolderMembers = includeFolderMembers
        self.includeFolderMemberships = includeFolderMemberships
        self.includePermissions = includePermissions
        self.includeTags = includeTags
        self.jobStatus = jobStatus
        self.requestId = requestId
        self.resourceArns = resourceArns
        self.status = status
        self.validationStrategy = validationStrategy
        self.warnings = warnings
    }
}

extension DescribeAssetBundleExportJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetBundleExportJobOutput(arn: \(Swift.String(describing: arn)), assetBundleExportJobId: \(Swift.String(describing: assetBundleExportJobId)), awsAccountId: \(Swift.String(describing: awsAccountId)), cloudFormationOverridePropertyConfiguration: \(Swift.String(describing: cloudFormationOverridePropertyConfiguration)), createdTime: \(Swift.String(describing: createdTime)), errors: \(Swift.String(describing: errors)), exportFormat: \(Swift.String(describing: exportFormat)), includeAllDependencies: \(Swift.String(describing: includeAllDependencies)), includeFolderMembers: \(Swift.String(describing: includeFolderMembers)), includeFolderMemberships: \(Swift.String(describing: includeFolderMemberships)), includePermissions: \(Swift.String(describing: includePermissions)), includeTags: \(Swift.String(describing: includeTags)), jobStatus: \(Swift.String(describing: jobStatus)), requestId: \(Swift.String(describing: requestId)), resourceArns: \(Swift.String(describing: resourceArns)), status: \(Swift.String(describing: status)), validationStrategy: \(Swift.String(describing: validationStrategy)), warnings: \(Swift.String(describing: warnings)), downloadUrl: \"CONTENT_REDACTED\")"}
}

public struct DescribeAssetBundleImportJobInput: Swift.Sendable {
    /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleImportJob API call.
    /// This member is required.
    public var assetBundleImportJobId: Swift.String?
    /// The ID of the Amazon Web Services account the import job was executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        assetBundleImportJobId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil
    )
    {
        self.assetBundleImportJobId = assetBundleImportJobId
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeAssetBundleImportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the import job.
    public var arn: Swift.String?
    /// The ID of the job. The job ID is set when you start a new job with a StartAssetBundleImportJob API call.
    public var assetBundleImportJobId: Swift.String?
    /// The source of the asset bundle zip file that contains the data that is imported by the job.
    public var assetBundleImportSource: QuickSightClientTypes.AssetBundleImportSourceDescription?
    /// The ID of the Amazon Web Services account the import job was executed in.
    public var awsAccountId: Swift.String?
    /// The time that the import job was created.
    public var createdTime: Foundation.Date?
    /// An array of error records that describes any failures that occurred during the export job processing. Error records accumulate while the job is still running. The complete set of error records is available after the job has completed and failed.
    public var errors: [QuickSightClientTypes.AssetBundleImportJobError]?
    /// The failure action for the import job.
    public var failureAction: QuickSightClientTypes.AssetBundleImportFailureAction?
    /// Indicates the status of a job through its queuing and execution. Poll the DescribeAssetBundleImport API until JobStatus returns one of the following values:
    ///
    /// * SUCCESSFUL
    ///
    /// * FAILED
    ///
    /// * FAILED_ROLLBACK_COMPLETED
    ///
    /// * FAILED_ROLLBACK_ERROR
    public var jobStatus: QuickSightClientTypes.AssetBundleImportJobStatus?
    /// Optional overrides that are applied to the resource configuration before import.
    public var overrideParameters: QuickSightClientTypes.AssetBundleImportJobOverrideParameters?
    /// Optional permission overrides that are applied to the resource configuration before import.
    public var overridePermissions: QuickSightClientTypes.AssetBundleImportJobOverridePermissions?
    /// Optional tag overrides that are applied to the resource configuration before import.
    public var overrideTags: QuickSightClientTypes.AssetBundleImportJobOverrideTags?
    /// An optional validation strategy override for all analyses and dashboards to be applied to the resource configuration before import.
    public var overrideValidationStrategy: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// An array of error records that describes any failures that occurred while an import job was attempting a rollback. Error records accumulate while the job is still running. The complete set of error records is available after the job has completed and failed.
    public var rollbackErrors: [QuickSightClientTypes.AssetBundleImportJobError]?
    /// The HTTP status of the response.
    public var status: Swift.Int
    /// An array of warning records that describe all permitted errors that are encountered during the import job.
    public var warnings: [QuickSightClientTypes.AssetBundleImportJobWarning]?

    public init(
        arn: Swift.String? = nil,
        assetBundleImportJobId: Swift.String? = nil,
        assetBundleImportSource: QuickSightClientTypes.AssetBundleImportSourceDescription? = nil,
        awsAccountId: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        errors: [QuickSightClientTypes.AssetBundleImportJobError]? = nil,
        failureAction: QuickSightClientTypes.AssetBundleImportFailureAction? = nil,
        jobStatus: QuickSightClientTypes.AssetBundleImportJobStatus? = nil,
        overrideParameters: QuickSightClientTypes.AssetBundleImportJobOverrideParameters? = nil,
        overridePermissions: QuickSightClientTypes.AssetBundleImportJobOverridePermissions? = nil,
        overrideTags: QuickSightClientTypes.AssetBundleImportJobOverrideTags? = nil,
        overrideValidationStrategy: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy? = nil,
        requestId: Swift.String? = nil,
        rollbackErrors: [QuickSightClientTypes.AssetBundleImportJobError]? = nil,
        status: Swift.Int = 0,
        warnings: [QuickSightClientTypes.AssetBundleImportJobWarning]? = nil
    )
    {
        self.arn = arn
        self.assetBundleImportJobId = assetBundleImportJobId
        self.assetBundleImportSource = assetBundleImportSource
        self.awsAccountId = awsAccountId
        self.createdTime = createdTime
        self.errors = errors
        self.failureAction = failureAction
        self.jobStatus = jobStatus
        self.overrideParameters = overrideParameters
        self.overridePermissions = overridePermissions
        self.overrideTags = overrideTags
        self.overrideValidationStrategy = overrideValidationStrategy
        self.requestId = requestId
        self.rollbackErrors = rollbackErrors
        self.status = status
        self.warnings = warnings
    }
}

public struct DescribeDashboardInput: Swift.Sendable {
    /// The alias name.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
    public var versionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

public struct DescribeDashboardOutput: Swift.Sendable {
    /// Information about the dashboard.
    public var dashboard: QuickSightClientTypes.Dashboard?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of this request.
    public var status: Swift.Int

    public init(
        dashboard: QuickSightClientTypes.Dashboard? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboard = dashboard
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDashboardDefinitionInput: Swift.Sendable {
    /// The alias name.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number for the dashboard. If a version number isn't passed, the latest published dashboard version is described.
    public var versionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

public struct DescribeDashboardDefinitionOutput: Swift.Sendable {
    /// The ID of the dashboard described.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// Errors associated with this dashboard version.
    public var errors: [QuickSightClientTypes.DashboardError]?
    /// The display name of the dashboard.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the dashboard version.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the theme of the dashboard.
    public var themeArn: Swift.String?

    public init(
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        errors: [QuickSightClientTypes.DashboardError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.themeArn = themeArn
    }
}

public struct DescribeDashboardPermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're describing permissions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the IAM policy.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
    }
}

public struct DescribeDashboardPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// A structure that contains the configuration of a shareable link that grants access to the dashboard. Your users can use the link to view and interact with the dashboard, if the dashboard has been shared with them. For more information about sharing dashboards, see [Sharing Dashboards](https://docs.aws.amazon.com/quicksight/latest/user/sharing-a-dashboard.html).
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// A structure that contains the permissions for the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDashboardSnapshotJobInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dashboard that you have started a snapshot job for.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
    /// This member is required.
    public var snapshotJobId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        snapshotJobId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.snapshotJobId = snapshotJobId
    }
}

extension QuickSightClientTypes {

    public enum SnapshotJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case queued
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [SnapshotJobStatus] {
            return [
                .completed,
                .failed,
                .queued,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .queued: return "QUEUED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains information on the Amazon S3 destinations of the generated snapshot.
    public struct SnapshotDestinationConfiguration: Swift.Sendable {
        /// A list of SnapshotS3DestinationConfiguration objects that contain Amazon S3 destination configurations. This structure can hold a maximum of 1 S3DestinationConfiguration.
        public var s3Destinations: [QuickSightClientTypes.SnapshotS3DestinationConfiguration]?

        public init(
            s3Destinations: [QuickSightClientTypes.SnapshotS3DestinationConfiguration]? = nil
        )
        {
            self.s3Destinations = s3Destinations
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains the information on the snapshot files.
    public struct SnapshotFileGroup: Swift.Sendable {
        /// A list of SnapshotFile objects that contain the information on the snapshot files that need to be generated. This structure can hold 1 configuration at a time.
        public var files: [QuickSightClientTypes.SnapshotFile]?

        public init(
            files: [QuickSightClientTypes.SnapshotFile]? = nil
        )
        {
            self.files = files
        }
    }
}

extension QuickSightClientTypes {

    /// Describes the configuration of the dashboard snapshot.
    public struct SnapshotConfiguration: Swift.Sendable {
        /// A structure that contains information on the Amazon S3 bucket that the generated snapshot is stored in.
        public var destinationConfiguration: QuickSightClientTypes.SnapshotDestinationConfiguration?
        /// A list of SnapshotJobResultFileGroup objects that contain information about the snapshot that is generated. This list can hold a maximum of 6 FileGroup configurations.
        /// This member is required.
        public var fileGroups: [QuickSightClientTypes.SnapshotFileGroup]?
        /// A list of Amazon QuickSight parameters and the list's override values.
        public var parameters: QuickSightClientTypes.Parameters?

        public init(
            destinationConfiguration: QuickSightClientTypes.SnapshotDestinationConfiguration? = nil,
            fileGroups: [QuickSightClientTypes.SnapshotFileGroup]? = nil,
            parameters: QuickSightClientTypes.Parameters? = nil
        )
        {
            self.destinationConfiguration = destinationConfiguration
            self.fileGroups = fileGroups
            self.parameters = parameters
        }
    }
}

extension QuickSightClientTypes {

    /// Use this structure to redact sensitive information that you provide about an anonymous user from the snapshot.
    public struct SnapshotAnonymousUserRedacted: Swift.Sendable {
        /// The tag keys for the RowLevelPermissionTags.
        public var rowLevelPermissionTagKeys: [Swift.String]?

        public init(
            rowLevelPermissionTagKeys: [Swift.String]? = nil
        )
        {
            self.rowLevelPermissionTagKeys = rowLevelPermissionTagKeys
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains information about the users that the dashboard snapshot is generated for. Sensitive user information is excluded.
    public struct SnapshotUserConfigurationRedacted: Swift.Sendable {
        /// An array of records that describe anonymous users that the dashboard snapshot is generated for. Sensitive user information is excluded.
        public var anonymousUsers: [QuickSightClientTypes.SnapshotAnonymousUserRedacted]?

        public init(
            anonymousUsers: [QuickSightClientTypes.SnapshotAnonymousUserRedacted]? = nil
        )
        {
            self.anonymousUsers = anonymousUsers
        }
    }
}

public struct DescribeDashboardSnapshotJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is generated when you start a new job with a StartDashboardSnapshotJob API call.
    public var arn: Swift.String?
    /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
    public var awsAccountId: Swift.String?
    /// The time that the snapshot job was created.
    public var createdTime: Foundation.Date?
    /// The ID of the dashboard that you have started a snapshot job for.
    public var dashboardId: Swift.String?
    /// Indicates the status of a job. The status updates as the job executes. This shows one of the following values.
    ///
    /// * COMPLETED - The job was completed successfully.
    ///
    /// * FAILED - The job failed to execute.
    ///
    /// * QUEUED - The job is queued and hasn't started yet.
    ///
    /// * RUNNING - The job is still running.
    public var jobStatus: QuickSightClientTypes.SnapshotJobStatus?
    /// The time that the snapshot job status was last updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The snapshot configuration of the job. This information is provided when you make a StartDashboardSnapshotJob API call.
    public var snapshotConfiguration: QuickSightClientTypes.SnapshotConfiguration?
    /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
    public var snapshotJobId: Swift.String?
    /// The HTTP status of the request
    public var status: Swift.Int
    /// The user configuration for the snapshot job. This information is provided when you make a StartDashboardSnapshotJob API call.
    public var userConfiguration: QuickSightClientTypes.SnapshotUserConfigurationRedacted?

    public init(
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        dashboardId: Swift.String? = nil,
        jobStatus: QuickSightClientTypes.SnapshotJobStatus? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        requestId: Swift.String? = nil,
        snapshotConfiguration: QuickSightClientTypes.SnapshotConfiguration? = nil,
        snapshotJobId: Swift.String? = nil,
        status: Swift.Int = 0,
        userConfiguration: QuickSightClientTypes.SnapshotUserConfigurationRedacted? = nil
    )
    {
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.createdTime = createdTime
        self.dashboardId = dashboardId
        self.jobStatus = jobStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.requestId = requestId
        self.snapshotConfiguration = snapshotConfiguration
        self.snapshotJobId = snapshotJobId
        self.status = status
        self.userConfiguration = userConfiguration
    }
}

public struct DescribeDashboardSnapshotJobResultInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dashboard that you have started a snapshot job for.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The ID of the job to be described. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
    /// This member is required.
    public var snapshotJobId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        snapshotJobId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.snapshotJobId = snapshotJobId
    }
}

extension QuickSightClientTypes {

    /// An object that contains information on the error that caused the snapshot job to fail.
    public struct SnapshotJobErrorInfo: Swift.Sendable {
        /// The error message.
        public var errorMessage: Swift.String?
        /// The error type.
        public var errorType: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }
}

extension QuickSightClientTypes {

    /// An object that provides information on the result of a snapshot job. This object provides information about the job, the job status, and the location of the generated file.
    public struct SnapshotJobResult: Swift.Sendable {
        /// A list of AnonymousUserSnapshotJobResult objects that contain information on anonymous users and their user configurations. This data provided by you when you make a StartDashboardSnapshotJob API call.
        public var anonymousUsers: [QuickSightClientTypes.AnonymousUserSnapshotJobResult]?

        public init(
            anonymousUsers: [QuickSightClientTypes.AnonymousUserSnapshotJobResult]? = nil
        )
        {
            self.anonymousUsers = anonymousUsers
        }
    }
}

public struct DescribeDashboardSnapshotJobResultOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is generated when you start a new job with a StartDashboardSnapshotJob API call.
    public var arn: Swift.String?
    /// The time that a snapshot job was created.
    public var createdTime: Foundation.Date?
    /// Displays information for the error that caused a job to fail.
    public var errorInfo: QuickSightClientTypes.SnapshotJobErrorInfo?
    /// Indicates the status of a job after it has reached a terminal state. A finished snapshot job will retuen a COMPLETED or FAILED status.
    public var jobStatus: QuickSightClientTypes.SnapshotJobStatus?
    /// The time that a snapshot job status was last updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The result of the snapshot job. Jobs that have successfully completed will return the S3Uri where they are located. Jobs that have failedwill return information on the error that caused the job to fail.
    public var result: QuickSightClientTypes.SnapshotJobResult?
    /// The HTTP status of the request
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        errorInfo: QuickSightClientTypes.SnapshotJobErrorInfo? = nil,
        jobStatus: QuickSightClientTypes.SnapshotJobStatus? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        requestId: Swift.String? = nil,
        result: QuickSightClientTypes.SnapshotJobResult? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.errorInfo = errorInfo
        self.jobStatus = jobStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.requestId = requestId
        self.result = result
        self.status = status
    }
}

public struct DescribeDataSetInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct DescribeDataSetOutput: Swift.Sendable {
    /// Information on the dataset.
    public var dataSet: QuickSightClientTypes.DataSet?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSet: QuickSightClientTypes.DataSet? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSet = dataSet
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDataSetPermissionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct DescribeDataSetPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// A list of resource permissions on the dataset.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDataSetRefreshPropertiesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct DescribeDataSetRefreshPropertiesOutput: Swift.Sendable {
    /// The dataset refresh properties.
    public var dataSetRefreshProperties: QuickSightClientTypes.DataSetRefreshProperties?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSetRefreshProperties: QuickSightClientTypes.DataSetRefreshProperties? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetRefreshProperties = dataSetRefreshProperties
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDataSourceInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

public struct DescribeDataSourceOutput: Swift.Sendable {
    /// The information on the data source.
    public var dataSource: QuickSightClientTypes.DataSource?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSource: QuickSightClientTypes.DataSource? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSource = dataSource
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeDataSourcePermissionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
    }
}

public struct DescribeDataSourcePermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions on the data source.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeFolderInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
    }
}

extension QuickSightClientTypes {

    /// A folder in Amazon QuickSight.
    public struct Folder: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: Foundation.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// An array of ancestor ARN strings for the folder.
        public var folderPath: [Swift.String]?
        /// The type of folder it is.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A display name for the folder.
        public var name: Swift.String?
        /// The sharing scope of the folder.
        public var sharingModel: QuickSightClientTypes.SharingModel?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            folderId: Swift.String? = nil,
            folderPath: [Swift.String]? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sharingModel: QuickSightClientTypes.SharingModel? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderPath = folderPath
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sharingModel = sharingModel
        }
    }
}

public struct DescribeFolderOutput: Swift.Sendable {
    /// Information about the folder.
    public var folder: QuickSightClientTypes.Folder?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folder: QuickSightClientTypes.Folder? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folder = folder
        self.requestId = requestId
        self.status = status
    }
}

/// The NextToken value isn't valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct DescribeFolderPermissionsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace of the folder whose permissions you want described.
    public var namespace: Swift.String?
    /// A pagination token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct DescribeFolderPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The pagination token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about the permissions on the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.nextToken = nextToken
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeFolderResolvedPermissionsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace of the folder whose permissions you want described.
    public var namespace: Swift.String?
    /// A pagination token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct DescribeFolderResolvedPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// A pagination token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.nextToken = nextToken
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeGroupInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to describe.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want described.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.namespace = namespace
    }
}

public struct DescribeGroupOutput: Swift.Sendable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeGroupMembershipInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to search.
    /// This member is required.
    public var groupName: Swift.String?
    /// The user name of the user that you want to search for.
    /// This member is required.
    public var memberName: Swift.String?
    /// The namespace that includes the group you are searching within.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        memberName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.memberName = memberName
        self.namespace = namespace
    }
}

public struct DescribeGroupMembershipOutput: Swift.Sendable {
    /// A member of an Amazon QuickSight group. Currently, group members must be users. Groups can't be members of another group. .
    public var groupMember: QuickSightClientTypes.GroupMember?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupMember: QuickSightClientTypes.GroupMember? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMember = groupMember
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeIAMPolicyAssignmentInput: Swift.Sendable {
    /// The name of the assignment, also called a rule.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the assignment that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the assignment.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        assignmentName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

extension QuickSightClientTypes {

    /// An Identity and Access Management (IAM) policy assignment.
    public struct IAMPolicyAssignment: Swift.Sendable {
        /// Assignment ID.
        public var assignmentId: Swift.String?
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
        /// The Amazon Web Services account ID.
        public var awsAccountId: Swift.String?
        /// Identities.
        public var identities: [Swift.String: [Swift.String]]?
        /// The Amazon Resource Name (ARN) for the IAM policy.
        public var policyArn: Swift.String?

        public init(
            assignmentId: Swift.String? = nil,
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
            awsAccountId: Swift.String? = nil,
            identities: [Swift.String: [Swift.String]]? = nil,
            policyArn: Swift.String? = nil
        )
        {
            self.assignmentId = assignmentId
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
            self.awsAccountId = awsAccountId
            self.identities = identities
            self.policyArn = policyArn
        }
    }
}

public struct DescribeIAMPolicyAssignmentOutput: Swift.Sendable {
    /// Information describing the IAM policy assignment.
    public var iamPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        iamPolicyAssignment: QuickSightClientTypes.IAMPolicyAssignment? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iamPolicyAssignment = iamPolicyAssignment
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeIngestionInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// An ID for the ingestion.
    /// This member is required.
    public var ingestionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.ingestionId = ingestionId
    }
}

extension QuickSightClientTypes {

    public enum IngestionErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountCapacityLimitExceeded
        case connectionFailure
        case cursorNotEnabled
        case customerError
        case dataSetDeleted
        case dataSetNotSpice
        case dataSetSizeLimitExceeded
        case dataSourceAuthFailed
        case dataSourceConnectionFailed
        case dataSourceNotFound
        case dataToleranceException
        case duplicateColumnNamesFound
        case elasticsearchCursorNotEnabled
        case failureToAssumeRole
        case failureToProcessJsonFile
        case iamRoleNotAvailable
        case ingestionCanceled
        case ingestionSuperseded
        case internalServiceError
        case invalidDataprepSyntax
        case invalidDataSourceConfig
        case invalidDateFormat
        case iotDataSetFileEmpty
        case iotFileNotFound
        case oauthTokenFailure
        case passwordAuthenticationFailure
        case permissionDenied
        case permissionNotFound
        case queryTimeout
        case refreshSuppressedByEdit
        case rowSizeLimitExceeded
        case s3FileInaccessible
        case s3ManifestError
        case s3UploadedFileDeleted
        case sourceApiLimitExceededFailure
        case sourceResourceLimitExceeded
        case spiceTableNotFound
        case sqlException
        case sqlInvalidParameterValue
        case sqlNumericOverflow
        case sqlSchemaMismatchError
        case sqlTableNotFound
        case sslCertificateValidationFailure
        case unresolvableHost
        case unroutableHost
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionErrorType] {
            return [
                .accountCapacityLimitExceeded,
                .connectionFailure,
                .cursorNotEnabled,
                .customerError,
                .dataSetDeleted,
                .dataSetNotSpice,
                .dataSetSizeLimitExceeded,
                .dataSourceAuthFailed,
                .dataSourceConnectionFailed,
                .dataSourceNotFound,
                .dataToleranceException,
                .duplicateColumnNamesFound,
                .elasticsearchCursorNotEnabled,
                .failureToAssumeRole,
                .failureToProcessJsonFile,
                .iamRoleNotAvailable,
                .ingestionCanceled,
                .ingestionSuperseded,
                .internalServiceError,
                .invalidDataprepSyntax,
                .invalidDataSourceConfig,
                .invalidDateFormat,
                .iotDataSetFileEmpty,
                .iotFileNotFound,
                .oauthTokenFailure,
                .passwordAuthenticationFailure,
                .permissionDenied,
                .permissionNotFound,
                .queryTimeout,
                .refreshSuppressedByEdit,
                .rowSizeLimitExceeded,
                .s3FileInaccessible,
                .s3ManifestError,
                .s3UploadedFileDeleted,
                .sourceApiLimitExceededFailure,
                .sourceResourceLimitExceeded,
                .spiceTableNotFound,
                .sqlException,
                .sqlInvalidParameterValue,
                .sqlNumericOverflow,
                .sqlSchemaMismatchError,
                .sqlTableNotFound,
                .sslCertificateValidationFailure,
                .unresolvableHost,
                .unroutableHost
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountCapacityLimitExceeded: return "ACCOUNT_CAPACITY_LIMIT_EXCEEDED"
            case .connectionFailure: return "CONNECTION_FAILURE"
            case .cursorNotEnabled: return "CURSOR_NOT_ENABLED"
            case .customerError: return "CUSTOMER_ERROR"
            case .dataSetDeleted: return "DATA_SET_DELETED"
            case .dataSetNotSpice: return "DATA_SET_NOT_SPICE"
            case .dataSetSizeLimitExceeded: return "DATA_SET_SIZE_LIMIT_EXCEEDED"
            case .dataSourceAuthFailed: return "DATA_SOURCE_AUTH_FAILED"
            case .dataSourceConnectionFailed: return "DATA_SOURCE_CONNECTION_FAILED"
            case .dataSourceNotFound: return "DATA_SOURCE_NOT_FOUND"
            case .dataToleranceException: return "DATA_TOLERANCE_EXCEPTION"
            case .duplicateColumnNamesFound: return "DUPLICATE_COLUMN_NAMES_FOUND"
            case .elasticsearchCursorNotEnabled: return "ELASTICSEARCH_CURSOR_NOT_ENABLED"
            case .failureToAssumeRole: return "FAILURE_TO_ASSUME_ROLE"
            case .failureToProcessJsonFile: return "FAILURE_TO_PROCESS_JSON_FILE"
            case .iamRoleNotAvailable: return "IAM_ROLE_NOT_AVAILABLE"
            case .ingestionCanceled: return "INGESTION_CANCELED"
            case .ingestionSuperseded: return "INGESTION_SUPERSEDED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidDataprepSyntax: return "INVALID_DATAPREP_SYNTAX"
            case .invalidDataSourceConfig: return "INVALID_DATA_SOURCE_CONFIG"
            case .invalidDateFormat: return "INVALID_DATE_FORMAT"
            case .iotDataSetFileEmpty: return "IOT_DATA_SET_FILE_EMPTY"
            case .iotFileNotFound: return "IOT_FILE_NOT_FOUND"
            case .oauthTokenFailure: return "OAUTH_TOKEN_FAILURE"
            case .passwordAuthenticationFailure: return "PASSWORD_AUTHENTICATION_FAILURE"
            case .permissionDenied: return "PERMISSION_DENIED"
            case .permissionNotFound: return "PERMISSION_NOT_FOUND"
            case .queryTimeout: return "QUERY_TIMEOUT"
            case .refreshSuppressedByEdit: return "REFRESH_SUPPRESSED_BY_EDIT"
            case .rowSizeLimitExceeded: return "ROW_SIZE_LIMIT_EXCEEDED"
            case .s3FileInaccessible: return "S3_FILE_INACCESSIBLE"
            case .s3ManifestError: return "S3_MANIFEST_ERROR"
            case .s3UploadedFileDeleted: return "S3_UPLOADED_FILE_DELETED"
            case .sourceApiLimitExceededFailure: return "SOURCE_API_LIMIT_EXCEEDED_FAILURE"
            case .sourceResourceLimitExceeded: return "SOURCE_RESOURCE_LIMIT_EXCEEDED"
            case .spiceTableNotFound: return "SPICE_TABLE_NOT_FOUND"
            case .sqlException: return "SQL_EXCEPTION"
            case .sqlInvalidParameterValue: return "SQL_INVALID_PARAMETER_VALUE"
            case .sqlNumericOverflow: return "SQL_NUMERIC_OVERFLOW"
            case .sqlSchemaMismatchError: return "SQL_SCHEMA_MISMATCH_ERROR"
            case .sqlTableNotFound: return "SQL_TABLE_NOT_FOUND"
            case .sslCertificateValidationFailure: return "SSL_CERTIFICATE_VALIDATION_FAILURE"
            case .unresolvableHost: return "UNRESOLVABLE_HOST"
            case .unroutableHost: return "UNROUTABLE_HOST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Error information for the SPICE ingestion of a dataset.
    public struct ErrorInfo: Swift.Sendable {
        /// Error message.
        public var message: Swift.String?
        /// Error type.
        public var type: QuickSightClientTypes.IngestionErrorType?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.IngestionErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// Information about a queued dataset SPICE ingestion.
    public struct QueueInfo: Swift.Sendable {
        /// The ID of the ongoing ingestion. The queued ingestion is waiting for the ongoing ingestion to complete.
        /// This member is required.
        public var queuedIngestion: Swift.String?
        /// The ID of the queued ingestion.
        /// This member is required.
        public var waitingOnIngestion: Swift.String?

        public init(
            queuedIngestion: Swift.String? = nil,
            waitingOnIngestion: Swift.String? = nil
        )
        {
            self.queuedIngestion = queuedIngestion
            self.waitingOnIngestion = waitingOnIngestion
        }
    }
}

extension QuickSightClientTypes {

    public enum IngestionRequestSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case manual
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestSource] {
            return [
                .manual,
                .scheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .manual: return "MANUAL"
            case .scheduled: return "SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// This defines the type of ingestion request. This is returned as part of create ingestion response.
    public enum IngestionRequestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edit
        case fullRefresh
        case incrementalRefresh
        case initialIngestion
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionRequestType] {
            return [
                .edit,
                .fullRefresh,
                .incrementalRefresh,
                .initialIngestion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edit: return "EDIT"
            case .fullRefresh: return "FULL_REFRESH"
            case .incrementalRefresh: return "INCREMENTAL_REFRESH"
            case .initialIngestion: return "INITIAL_INGESTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Information about rows for a data set SPICE ingestion.
    public struct RowInfo: Swift.Sendable {
        /// The number of rows that were not ingested.
        public var rowsDropped: Swift.Int?
        /// The number of rows that were ingested.
        public var rowsIngested: Swift.Int?
        /// The total number of rows in the dataset.
        public var totalRowsInDataset: Swift.Int?

        public init(
            rowsDropped: Swift.Int? = 0,
            rowsIngested: Swift.Int? = 0,
            totalRowsInDataset: Swift.Int? = 0
        )
        {
            self.rowsDropped = rowsDropped
            self.rowsIngested = rowsIngested
            self.totalRowsInDataset = totalRowsInDataset
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the SPICE ingestion for a dataset.
    public struct Ingestion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        /// This member is required.
        public var arn: Swift.String?
        /// The time that this ingestion started.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// Error information for this ingestion.
        public var errorInfo: QuickSightClientTypes.ErrorInfo?
        /// Ingestion ID.
        public var ingestionId: Swift.String?
        /// The size of the data ingested, in bytes.
        public var ingestionSizeInBytes: Swift.Int?
        /// Ingestion status.
        /// This member is required.
        public var ingestionStatus: QuickSightClientTypes.IngestionStatus?
        /// The time that this ingestion took, measured in seconds.
        public var ingestionTimeInSeconds: Swift.Int?
        /// Information about a queued dataset SPICE ingestion.
        public var queueInfo: QuickSightClientTypes.QueueInfo?
        /// Event source for this ingestion.
        public var requestSource: QuickSightClientTypes.IngestionRequestSource?
        /// Type of this ingestion.
        public var requestType: QuickSightClientTypes.IngestionRequestType?
        /// Information about rows for a data set SPICE ingestion.
        public var rowInfo: QuickSightClientTypes.RowInfo?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            errorInfo: QuickSightClientTypes.ErrorInfo? = nil,
            ingestionId: Swift.String? = nil,
            ingestionSizeInBytes: Swift.Int? = 0,
            ingestionStatus: QuickSightClientTypes.IngestionStatus? = nil,
            ingestionTimeInSeconds: Swift.Int? = 0,
            queueInfo: QuickSightClientTypes.QueueInfo? = nil,
            requestSource: QuickSightClientTypes.IngestionRequestSource? = nil,
            requestType: QuickSightClientTypes.IngestionRequestType? = nil,
            rowInfo: QuickSightClientTypes.RowInfo? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.errorInfo = errorInfo
            self.ingestionId = ingestionId
            self.ingestionSizeInBytes = ingestionSizeInBytes
            self.ingestionStatus = ingestionStatus
            self.ingestionTimeInSeconds = ingestionTimeInSeconds
            self.queueInfo = queueInfo
            self.requestSource = requestSource
            self.requestType = requestType
            self.rowInfo = rowInfo
        }
    }
}

public struct DescribeIngestionOutput: Swift.Sendable {
    /// Information about the ingestion.
    public var ingestion: QuickSightClientTypes.Ingestion?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        ingestion: QuickSightClientTypes.Ingestion? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestion = ingestion
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeIpRestrictionInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

public struct DescribeIpRestrictionOutput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the IP rules with CIDR range and description.
    public var ipRestrictionRuleMap: [Swift.String: Swift.String]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A map of allowed VPC endpoint IDs and their rule descriptions.
    public var vpcEndpointIdRestrictionRuleMap: [Swift.String: Swift.String]?
    /// A map of allowed VPC IDs and their rule descriptions.
    public var vpcIdRestrictionRuleMap: [Swift.String: Swift.String]?

    public init(
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String: Swift.String]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        vpcEndpointIdRestrictionRuleMap: [Swift.String: Swift.String]? = nil,
        vpcIdRestrictionRuleMap: [Swift.String: Swift.String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
        self.requestId = requestId
        self.status = status
        self.vpcEndpointIdRestrictionRuleMap = vpcEndpointIdRestrictionRuleMap
        self.vpcIdRestrictionRuleMap = vpcIdRestrictionRuleMap
    }
}

public struct DescribeKeyRegistrationInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the customer managed key registration that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Determines whether the request returns the default key only.
    public var defaultKeyOnly: Swift.Bool?

    public init(
        awsAccountId: Swift.String? = nil,
        defaultKeyOnly: Swift.Bool? = false
    )
    {
        self.awsAccountId = awsAccountId
        self.defaultKeyOnly = defaultKeyOnly
    }
}

extension QuickSightClientTypes {

    /// A customer managed key structure that contains the information listed below:
    ///
    /// * KeyArn - The ARN of a KMS key that is registered to a Amazon QuickSight account for encryption and decryption use.
    ///
    /// * DefaultKey - Indicates whether the current key is set as the default key for encryption and decryption use.
    public struct RegisteredCustomerManagedKey: Swift.Sendable {
        /// Indicates whether a RegisteredCustomerManagedKey is set as the default key for encryption and decryption use.
        public var defaultKey: Swift.Bool
        /// The ARN of the KMS key that is registered to a Amazon QuickSight account for encryption and decryption use.
        public var keyArn: Swift.String?

        public init(
            defaultKey: Swift.Bool = false,
            keyArn: Swift.String? = nil
        )
        {
            self.defaultKey = defaultKey
            self.keyArn = keyArn
        }
    }
}

public struct DescribeKeyRegistrationOutput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the customer managed key registration specified in the request.
    public var awsAccountId: Swift.String?
    /// A list of RegisteredCustomerManagedKey objects in a Amazon QuickSight account.
    public var keyRegistration: [QuickSightClientTypes.RegisteredCustomerManagedKey]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        awsAccountId: Swift.String? = nil,
        keyRegistration: [QuickSightClientTypes.RegisteredCustomerManagedKey]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.keyRegistration = keyRegistration
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeNamespaceInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespace that you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to describe.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

extension QuickSightClientTypes {

    public enum NamespaceErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalServiceError
        case permissionDenied
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceErrorType] {
            return [
                .internalServiceError,
                .permissionDenied
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .permissionDenied: return "PERMISSION_DENIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Errors that occur during namespace creation.
    public struct NamespaceError: Swift.Sendable {
        /// The message for the error.
        public var message: Swift.String?
        /// The error type.
        public var type: QuickSightClientTypes.NamespaceErrorType?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.NamespaceErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// The error type.
    public struct NamespaceInfoV2: Swift.Sendable {
        /// The namespace ARN.
        public var arn: Swift.String?
        /// The namespace Amazon Web Services Region.
        public var capacityRegion: Swift.String?
        /// The creation status of a namespace that is not yet completely created.
        public var creationStatus: QuickSightClientTypes.NamespaceStatus?
        /// The identity store used for the namespace.
        public var identityStore: QuickSightClientTypes.IdentityStore?
        /// The name of the error.
        public var name: Swift.String?
        /// An error that occurred when the namespace was created.
        public var namespaceError: QuickSightClientTypes.NamespaceError?

        public init(
            arn: Swift.String? = nil,
            capacityRegion: Swift.String? = nil,
            creationStatus: QuickSightClientTypes.NamespaceStatus? = nil,
            identityStore: QuickSightClientTypes.IdentityStore? = nil,
            name: Swift.String? = nil,
            namespaceError: QuickSightClientTypes.NamespaceError? = nil
        )
        {
            self.arn = arn
            self.capacityRegion = capacityRegion
            self.creationStatus = creationStatus
            self.identityStore = identityStore
            self.name = name
            self.namespaceError = namespaceError
        }
    }
}

public struct DescribeNamespaceOutput: Swift.Sendable {
    /// The information about the namespace that you're describing. The response includes the namespace ARN, name, Amazon Web Services Region, creation status, and identity store. DescribeNamespace also works for namespaces that are in the process of being created. For incomplete namespaces, this API operation lists the namespace error types and messages associated with the creation process.
    public var namespace: QuickSightClientTypes.NamespaceInfoV2?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        namespace: QuickSightClientTypes.NamespaceInfoV2? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeQPersonalizationConfigurationInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the personalization configuration that the user wants described.
    /// This member is required.
    public var awsAccountId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
    }
}

extension QuickSightClientTypes {

    public enum PersonalizationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PersonalizationMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeQPersonalizationConfigurationOutput: Swift.Sendable {
    /// A value that indicates whether personalization is enabled or not.
    public var personalizationMode: QuickSightClientTypes.PersonalizationMode?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        personalizationMode: QuickSightClientTypes.PersonalizationMode? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.personalizationMode = personalizationMode
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The ID of the refresh schedule.
    /// This member is required.
    public var scheduleId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        scheduleId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.scheduleId = scheduleId
    }
}

public struct DescribeRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the refresh schedule.
    public var arn: Swift.String?
    /// The refresh schedule.
    public var refreshSchedule: QuickSightClientTypes.RefreshSchedule?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        refreshSchedule: QuickSightClientTypes.RefreshSchedule? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.refreshSchedule = refreshSchedule
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeRoleCustomPermissionInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that contains the role.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the role whose permissions you want described.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.role = role
    }
}

public struct DescribeRoleCustomPermissionOutput: Swift.Sendable {
    /// The name of the custom permission that is described.
    public var customPermissionsName: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        customPermissionsName: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.customPermissionsName = customPermissionsName
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeTemplateInput: Swift.Sendable {
    /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// (Optional) The number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the template is described.
    public var versionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

extension QuickSightClientTypes {

    public enum TemplateErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case dataSetNotFound
        case internalFailure
        case sourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateErrorType] {
            return [
                .accessDenied,
                .dataSetNotFound,
                .internalFailure,
                .sourceNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .dataSetNotFound: return "DATA_SET_NOT_FOUND"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .sourceNotFound: return "SOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// List of errors that occurred when the template version creation failed.
    public struct TemplateError: Swift.Sendable {
        /// Description of the error type.
        public var message: Swift.String?
        /// Type of error.
        public var type: QuickSightClientTypes.TemplateErrorType?
        /// An error path that shows which entities caused the template error.
        public var violatedEntities: [QuickSightClientTypes.Entity]?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.TemplateErrorType? = nil,
            violatedEntities: [QuickSightClientTypes.Entity]? = nil
        )
        {
            self.message = message
            self.type = type
            self.violatedEntities = violatedEntities
        }
    }
}

extension QuickSightClientTypes {

    /// A version of a template.
    public struct TemplateVersion: Swift.Sendable {
        /// The time that this template version was created.
        public var createdTime: Foundation.Date?
        /// Schema of the dataset identified by the placeholder. Any dashboard created from this template should be bound to new datasets matching the same schema described through this API operation.
        public var dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]?
        /// The description of the template.
        public var description: Swift.String?
        /// Errors associated with this template version.
        public var errors: [QuickSightClientTypes.TemplateError]?
        /// A list of the associated sheets with the unique identifier and name of each sheet.
        public var sheets: [QuickSightClientTypes.Sheet]?
        /// The Amazon Resource Name (ARN) of an analysis or template that was used to create this template.
        public var sourceEntityArn: Swift.String?
        /// The status that is associated with the template.
        ///
        /// * CREATION_IN_PROGRESS
        ///
        /// * CREATION_SUCCESSFUL
        ///
        /// * CREATION_FAILED
        ///
        /// * UPDATE_IN_PROGRESS
        ///
        /// * UPDATE_SUCCESSFUL
        ///
        /// * UPDATE_FAILED
        ///
        /// * DELETED
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The ARN of the theme associated with this version of the template.
        public var themeArn: Swift.String?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init(
            createdTime: Foundation.Date? = nil,
            dataSetConfigurations: [QuickSightClientTypes.DataSetConfiguration]? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.TemplateError]? = nil,
            sheets: [QuickSightClientTypes.Sheet]? = nil,
            sourceEntityArn: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            themeArn: Swift.String? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.createdTime = createdTime
            self.dataSetConfigurations = dataSetConfigurations
            self.description = description
            self.errors = errors
            self.sheets = sheets
            self.sourceEntityArn = sourceEntityArn
            self.status = status
            self.themeArn = themeArn
            self.versionNumber = versionNumber
        }
    }
}

extension QuickSightClientTypes {

    /// A template object. A template is an entity in Amazon QuickSight that encapsulates the metadata required to create an analysis and that you can use to create a dashboard. A template adds a layer of abstraction by using placeholders to replace the dataset associated with an analysis. You can use templates to create dashboards by replacing dataset placeholders with datasets that follow the same schema that was used to create the source analysis and template. You can share templates across Amazon Web Services accounts by allowing users in other Amazon Web Services accounts to create a template or a dashboard from an existing template.
    public struct Template: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the template.
        public var arn: Swift.String?
        /// Time when this was created.
        public var createdTime: Foundation.Date?
        /// Time when this was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The display name of the template.
        public var name: Swift.String?
        /// The ID for the template. This is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?
        /// A structure describing the versions of the template.
        public var version: QuickSightClientTypes.TemplateVersion?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil,
            version: QuickSightClientTypes.TemplateVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.templateId = templateId
            self.version = version
        }
    }
}

public struct DescribeTemplateOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template structure for the object you want to describe.
    public var template: QuickSightClientTypes.Template?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        template: QuickSightClientTypes.Template? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.template = template
    }
}

public struct DescribeTemplateAliasInput: Swift.Sendable {
    /// The name of the template alias that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

public struct DescribeTemplateAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

public struct DescribeTemplateDefinitionInput: Swift.Sendable {
    /// The alias of the template that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template. You must be using the Amazon Web Services account that the template is in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the template that you're describing.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    public var versionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.versionNumber = versionNumber
    }
}

public struct DescribeTemplateDefinitionOutput: Swift.Sendable {
    /// The definition of the template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// Errors associated with the template version.
    public var errors: [QuickSightClientTypes.TemplateError]?
    /// The descriptive name of the template.
    public var name: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// Status associated with the template.
    ///
    /// * CREATION_IN_PROGRESS
    ///
    /// * CREATION_SUCCESSFUL
    ///
    /// * CREATION_FAILED
    ///
    /// * UPDATE_IN_PROGRESS
    ///
    /// * UPDATE_SUCCESSFUL
    ///
    /// * UPDATE_FAILED
    ///
    /// * DELETED
    public var resourceStatus: QuickSightClientTypes.ResourceStatus?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the template described.
    public var templateId: Swift.String?
    /// The ARN of the theme of the template.
    public var themeArn: Swift.String?

    public init(
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        errors: [QuickSightClientTypes.TemplateError]? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        resourceStatus: QuickSightClientTypes.ResourceStatus? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        themeArn: Swift.String? = nil
    )
    {
        self.definition = definition
        self.errors = errors
        self.name = name
        self.requestId = requestId
        self.resourceStatus = resourceStatus
        self.status = status
        self.templateId = templateId
        self.themeArn = themeArn
    }
}

public struct DescribeTemplatePermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the template that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.templateId = templateId
    }
}

public struct DescribeTemplatePermissionsOutput: Swift.Sendable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

public struct DescribeThemeInput: Swift.Sendable {
    /// The alias of the theme that you want to describe. If you name a specific alias, you describe the version that the alias points to. You can specify the latest version of the theme by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to themes.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number for the version to describe. If a VersionNumber parameter value isn't provided, the latest version of the theme is described.
    public var versionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.versionNumber = versionNumber
    }
}

extension QuickSightClientTypes {

    public enum ThemeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case custom
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeType] {
            return [
                .all,
                .custom,
                .quicksight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum ThemeErrorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [ThemeErrorType] {
            return [
                .internalFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// Theme error.
    public struct ThemeError: Swift.Sendable {
        /// The error message.
        public var message: Swift.String?
        /// The type of error.
        public var type: QuickSightClientTypes.ThemeErrorType?

        public init(
            message: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeErrorType? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension QuickSightClientTypes {

    /// A version of a theme.
    public struct ThemeVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
        public var baseThemeId: Swift.String?
        /// The theme configuration, which contains all the theme display properties.
        public var configuration: QuickSightClientTypes.ThemeConfiguration?
        /// The date and time that this theme version was created.
        public var createdTime: Foundation.Date?
        /// The description of the theme.
        public var description: Swift.String?
        /// Errors associated with the theme.
        public var errors: [QuickSightClientTypes.ThemeError]?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme.
        public var versionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            baseThemeId: Swift.String? = nil,
            configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            errors: [QuickSightClientTypes.ThemeError]? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.baseThemeId = baseThemeId
            self.configuration = configuration
            self.createdTime = createdTime
            self.description = description
            self.errors = errors
            self.status = status
            self.versionNumber = versionNumber
        }
    }
}

extension QuickSightClientTypes {

    /// Summary information about a theme.
    public struct Theme: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the theme.
        public var arn: Swift.String?
        /// The date and time that the theme was created.
        public var createdTime: Foundation.Date?
        /// The date and time that the theme was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The name that the user gives to the theme.
        public var name: Swift.String?
        /// The identifier that the user gives to the theme.
        public var themeId: Swift.String?
        /// The type of theme, based on how it was created. Valid values include: QUICKSIGHT and CUSTOM.
        public var type: QuickSightClientTypes.ThemeType?
        /// A version of a theme.
        public var version: QuickSightClientTypes.ThemeVersion?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil,
            type: QuickSightClientTypes.ThemeType? = nil,
            version: QuickSightClientTypes.ThemeVersion? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.themeId = themeId
            self.type = type
            self.version = version
        }
    }
}

public struct DescribeThemeOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The information about the theme that you are describing.
    public var theme: QuickSightClientTypes.Theme?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        theme: QuickSightClientTypes.Theme? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.theme = theme
    }
}

public struct DescribeThemeAliasInput: Swift.Sendable {
    /// The name of the theme alias that you want to describe.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

public struct DescribeThemeAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

public struct DescribeThemePermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the theme that you're describing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme that you want to describe permissions for.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.themeId = themeId
    }
}

public struct DescribeThemePermissionsOutput: Swift.Sendable {
    /// A list of resource permissions set on the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

public struct DescribeTopicInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct DescribeTopicOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the topic.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The definition of a topic.
    public var topic: QuickSightClientTypes.TopicDetails?
    /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topic: QuickSightClientTypes.TopicDetails? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.topic = topic
        self.topicId = topicId
    }
}

public struct DescribeTopicPermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic that you want described.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct DescribeTopicPermissionsOutput: Swift.Sendable {
    /// A list of resource permissions that are configured to the topic.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct DescribeTopicRefreshInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic whose refresh you want to describe.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the refresh, which is performed when the topic is created or updated.
    /// This member is required.
    public var refreshId: Swift.String?
    /// The ID of the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        refreshId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.refreshId = refreshId
        self.topicId = topicId
    }
}

extension QuickSightClientTypes {

    public enum TopicRefreshStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case initialized
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [TopicRefreshStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .initialized,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The details about the refresh of a topic.
    public struct TopicRefreshDetails: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the topic refresh.
        public var refreshArn: Swift.String?
        /// The ID of the refresh, which occurs as a result of topic creation or topic update.
        public var refreshId: Swift.String?
        /// The status of the refresh job that indicates whether the job is still running, completed successfully, or failed.
        public var refreshStatus: QuickSightClientTypes.TopicRefreshStatus?

        public init(
            refreshArn: Swift.String? = nil,
            refreshId: Swift.String? = nil,
            refreshStatus: QuickSightClientTypes.TopicRefreshStatus? = nil
        )
        {
            self.refreshArn = refreshArn
            self.refreshId = refreshId
            self.refreshStatus = refreshStatus
        }
    }
}

public struct DescribeTopicRefreshOutput: Swift.Sendable {
    /// Details of the refresh, which is performed when the topic is created or updated.
    public var refreshDetails: QuickSightClientTypes.TopicRefreshDetails?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        refreshDetails: QuickSightClientTypes.TopicRefreshDetails? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.refreshDetails = refreshDetails
        self.requestId = requestId
        self.status = status
    }
}

public struct DescribeTopicRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The ID of the topic that contains the refresh schedule that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.datasetId = datasetId
        self.topicId = topicId
    }
}

public struct DescribeTopicRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The definition of a refresh schedule.
    public var refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that contains the refresh schedule that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.refreshSchedule = refreshSchedule
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct DescribeUserInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the user that you want to describe.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.userName = userName
    }
}

extension QuickSightClientTypes {

    public enum IdentityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case iamIdentityCenter
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .iam,
                .iamIdentityCenter,
                .quicksight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .iamIdentityCenter: return "IAM_IDENTITY_CENTER"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum UserRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case adminPro
        case author
        case authorPro
        case reader
        case readerPro
        case restrictedAuthor
        case restrictedReader
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .admin,
                .adminPro,
                .author,
                .authorPro,
                .reader,
                .readerPro,
                .restrictedAuthor,
                .restrictedReader
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .adminPro: return "ADMIN_PRO"
            case .author: return "AUTHOR"
            case .authorPro: return "AUTHOR_PRO"
            case .reader: return "READER"
            case .readerPro: return "READER_PRO"
            case .restrictedAuthor: return "RESTRICTED_AUTHOR"
            case .restrictedReader: return "RESTRICTED_READER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A registered user of Amazon QuickSight.
    public struct User: Swift.Sendable {
        /// The active status of user. When you create an Amazon QuickSight user that's not an IAM user or an Active Directory user, that user is inactive until they sign in and provide a password.
        public var active: Swift.Bool
        /// The Amazon Resource Name (ARN) for the user.
        public var arn: Swift.String?
        /// The custom permissions profile associated with this user.
        public var customPermissionsName: Swift.String?
        /// The user's email address.
        public var email: Swift.String?
        /// The type of supported external login provider that provides identity to let the user federate into Amazon QuickSight with an associated IAM role. The type can be one of the following.
        ///
        /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com.
        ///
        /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider.
        public var externalLoginFederationProviderType: Swift.String?
        /// The URL of the external login provider.
        public var externalLoginFederationProviderUrl: Swift.String?
        /// The identity ID for the user in the external login provider.
        public var externalLoginId: Swift.String?
        /// The type of identity authentication used by the user.
        public var identityType: QuickSightClientTypes.IdentityType?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The Amazon QuickSight role for the user. The user role can be one of the following:.
        ///
        /// * READER: A user who has read-only access to dashboards.
        ///
        /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
        ///
        /// * ADMIN: A user who is an author, who can also manage Amazon Amazon QuickSight settings.
        ///
        /// * READER_PRO: Reader Pro adds Generative BI capabilities to the Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can build stories with Amazon Q, and can generate executive summaries from dashboards.
        ///
        /// * AUTHOR_PRO: Author Pro adds Generative BI capabilities to the Author role. Author Pros can author dashboards with natural language with Amazon Q, build stories with Amazon Q, create Topics for Q&A, and generate executive summaries from dashboards.
        ///
        /// * ADMIN_PRO: Admin Pros are Author Pros who can also manage Amazon QuickSight administrative settings. Admin Pro users are billed at Author Pro pricing.
        ///
        /// * RESTRICTED_READER: This role isn't currently available for use.
        ///
        /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
        public var role: QuickSightClientTypes.UserRole?
        /// The user's user name. This value is required if you are registering a user that will be managed in Amazon QuickSight. In the output, the value for UserName is N/A when the value for IdentityType is IAM and the corresponding IAM user is deleted.
        public var userName: Swift.String?

        public init(
            active: Swift.Bool = false,
            arn: Swift.String? = nil,
            customPermissionsName: Swift.String? = nil,
            email: Swift.String? = nil,
            externalLoginFederationProviderType: Swift.String? = nil,
            externalLoginFederationProviderUrl: Swift.String? = nil,
            externalLoginId: Swift.String? = nil,
            identityType: QuickSightClientTypes.IdentityType? = nil,
            principalId: Swift.String? = nil,
            role: QuickSightClientTypes.UserRole? = nil,
            userName: Swift.String? = nil
        )
        {
            self.active = active
            self.arn = arn
            self.customPermissionsName = customPermissionsName
            self.email = email
            self.externalLoginFederationProviderType = externalLoginFederationProviderType
            self.externalLoginFederationProviderUrl = externalLoginFederationProviderUrl
            self.externalLoginId = externalLoginId
            self.identityType = identityType
            self.principalId = principalId
            self.role = role
            self.userName = userName
        }
    }
}

public struct DescribeUserOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user name.
    public var user: QuickSightClientTypes.User?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

public struct DescribeVPCConnectionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account that contains the VPC connection that you want described.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
    /// This member is required.
    public var vpcConnectionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.vpcConnectionId = vpcConnectionId
    }
}

extension QuickSightClientTypes {

    public enum NetworkInterfaceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachmentFailedRollbackFailed
        case available
        case creating
        case creationFailed
        case deleted
        case deleting
        case deletionFailed
        case deletionScheduled
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceStatus] {
            return [
                .attachmentFailedRollbackFailed,
                .available,
                .creating,
                .creationFailed,
                .deleted,
                .deleting,
                .deletionFailed,
                .deletionScheduled,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachmentFailedRollbackFailed: return "ATTACHMENT_FAILED_ROLLBACK_FAILED"
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .creationFailed: return "CREATION_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .deletionFailed: return "DELETION_FAILED"
            case .deletionScheduled: return "DELETION_SCHEDULED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// The structure that contains information about a network interface.
    public struct NetworkInterface: Swift.Sendable {
        /// The availability zone that the network interface resides in.
        public var availabilityZone: Swift.String?
        /// An error message.
        public var errorMessage: Swift.String?
        /// The network interface ID.
        public var networkInterfaceId: Swift.String?
        /// The status of the network interface.
        public var status: QuickSightClientTypes.NetworkInterfaceStatus?
        /// The subnet ID associated with the network interface.
        public var subnetId: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            status: QuickSightClientTypes.NetworkInterfaceStatus? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.errorMessage = errorMessage
            self.networkInterfaceId = networkInterfaceId
            self.status = status
            self.subnetId = subnetId
        }
    }
}

extension QuickSightClientTypes {

    /// The structure of a VPC connection.
    public struct VPCConnection: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var arn: Swift.String?
        /// The availability status of the VPC connection.
        public var availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus?
        /// The time that the VPC connection was created.
        public var createdTime: Foundation.Date?
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public var dnsResolvers: [Swift.String]?
        /// The time that the VPC connection was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The display name for the VPC connection.
        public var name: Swift.String?
        /// A list of network interfaces.
        public var networkInterfaces: [QuickSightClientTypes.NetworkInterface]?
        /// The ARN of the IAM role associated with the VPC connection.
        public var roleArn: Swift.String?
        /// The Amazon EC2 security group IDs associated with the VPC connection.
        public var securityGroupIds: [Swift.String]?
        /// The status of the VPC connection.
        public var status: QuickSightClientTypes.VPCConnectionResourceStatus?
        /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
        public var vpcConnectionId: Swift.String?
        /// The Amazon EC2 VPC ID associated with the VPC connection.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus? = nil,
            createdTime: Foundation.Date? = nil,
            dnsResolvers: [Swift.String]? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            networkInterfaces: [QuickSightClientTypes.NetworkInterface]? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: QuickSightClientTypes.VPCConnectionResourceStatus? = nil,
            vpcConnectionId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.createdTime = createdTime
            self.dnsResolvers = dnsResolvers
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.vpcConnectionId = vpcConnectionId
            self.vpcId = vpcId
        }
    }
}

public struct DescribeVPCConnectionOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A response object that provides information for the specified VPC connection.
    public var vpcConnection: QuickSightClientTypes.VPCConnection?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        vpcConnection: QuickSightClientTypes.VPCConnection? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.vpcConnection = vpcConnection
    }
}

/// The domain specified isn't on the allow list. All domains for embedded dashboards must be added to the approved list by an Amazon QuickSight admin.
public struct DomainNotWhitelistedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DomainNotWhitelistedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    public enum EmbeddingIdentityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymous
        case iam
        case quicksight
        case sdkUnknown(Swift.String)

        public static var allCases: [EmbeddingIdentityType] {
            return [
                .anonymous,
                .iam,
                .quicksight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .iam: return "IAM"
            case .quicksight: return "QUICKSIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An entry that appears when a KeyRegistration update to Amazon QuickSight fails.
    public struct FailedKeyRegistrationEntry: Swift.Sendable {
        /// The ARN of the KMS key that failed to update.
        public var keyArn: Swift.String?
        /// A message that provides information about why a FailedKeyRegistrationEntry error occurred.
        /// This member is required.
        public var message: Swift.String?
        /// A boolean that indicates whether a FailedKeyRegistrationEntry resulted from user error. If the value of this property is True, the error was caused by user error. If the value of this property is False, the error occurred on the backend. If your job continues fail and with a FalseSenderFault value, contact Amazon Web Services Support.
        /// This member is required.
        public var senderFault: Swift.Bool
        /// The HTTP status of a FailedKeyRegistrationEntry error.
        /// This member is required.
        public var statusCode: Swift.Int

        public init(
            keyArn: Swift.String? = nil,
            message: Swift.String? = nil,
            senderFault: Swift.Bool = false,
            statusCode: Swift.Int = 0
        )
        {
            self.keyArn = keyArn
            self.message = message
            self.senderFault = senderFault
            self.statusCode = statusCode
        }
    }
}

extension QuickSightClientTypes {

    public enum FolderFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directQuicksightOwner
        case directQuicksightSoleOwner
        case directQuicksightViewerOrOwner
        case folderName
        case parentFolderArn
        case quicksightOwner
        case quicksightViewerOrOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderFilterAttribute] {
            return [
                .directQuicksightOwner,
                .directQuicksightSoleOwner,
                .directQuicksightViewerOrOwner,
                .folderName,
                .parentFolderArn,
                .quicksightOwner,
                .quicksightViewerOrOwner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directQuicksightOwner: return "DIRECT_QUICKSIGHT_OWNER"
            case .directQuicksightSoleOwner: return "DIRECT_QUICKSIGHT_SOLE_OWNER"
            case .directQuicksightViewerOrOwner: return "DIRECT_QUICKSIGHT_VIEWER_OR_OWNER"
            case .folderName: return "FOLDER_NAME"
            case .parentFolderArn: return "PARENT_FOLDER_ARN"
            case .quicksightOwner: return "QUICKSIGHT_OWNER"
            case .quicksightViewerOrOwner: return "QUICKSIGHT_VIEWER_OR_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// An object that consists of a member Amazon Resource Name (ARN) and a member ID.
    public struct MemberIdArnPair: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the member.
        public var memberArn: Swift.String?
        /// The ID of the member.
        public var memberId: Swift.String?

        public init(
            memberArn: Swift.String? = nil,
            memberId: Swift.String? = nil
        )
        {
            self.memberArn = memberArn
            self.memberId = memberId
        }
    }
}

extension QuickSightClientTypes {

    /// A filter to use to search an Amazon QuickSight folder.
    public struct FolderSearchFilter: Swift.Sendable {
        /// The name of a value that you want to use in the filter. For example, "Name": "QUICKSIGHT_OWNER". Valid values are defined as follows:
        ///
        /// * QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the folder's owners or viewers are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are considered.
        ///
        /// * DIRECT_QUICKSIGHT_SOLE_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as the only owner of the folder are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners of the folders are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * DIRECT_QUICKSIGHT_VIEWER_OR_OWNER: Provide an ARN of a user or group, and any folders with that ARN listed as one of the owners or viewers of the folders are returned. Implicit permissions from folders or groups are not considered.
        ///
        /// * FOLDER_NAME: Any folders whose names have a substring match to this value will be returned.
        ///
        /// * PARENT_FOLDER_ARN: Provide an ARN of a folder, and any folders that are directly under that parent folder are returned. If you choose to use this option and leave the value blank, all root-level folders in the account are returned.
        public var name: QuickSightClientTypes.FolderFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StringEquals". Valid values are "StringEquals" and "StringLike". If you set the operator value to "StringEquals", you need to provide an ownership related filter in the "NAME" field and the arn of the user or group whose folders you want to search in the "Value" field. For example, "Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1". If you set the value to "StringLike", you need to provide the name of the folders you are searching for. For example, "Name":"FOLDER_NAME", "Operator": "StringLike", "Value": "Test". The "StringLike" operator only supports the NAME value FOLDER_NAME.
        public var `operator`: QuickSightClientTypes.FilterOperator?
        /// The value of the named item (in this example, PARENT_FOLDER_ARN), that you want to use as a filter. For example, "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId".
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.FolderFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.FilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// A summary of information about an existing Amazon QuickSight folder.
    public struct FolderSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the folder.
        public var arn: Swift.String?
        /// The time that the folder was created.
        public var createdTime: Foundation.Date?
        /// The ID of the folder.
        public var folderId: Swift.String?
        /// The type of folder.
        public var folderType: QuickSightClientTypes.FolderType?
        /// The time that the folder was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The display name of the folder.
        public var name: Swift.String?
        /// The sharing scope of the folder.
        public var sharingModel: QuickSightClientTypes.SharingModel?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            folderId: Swift.String? = nil,
            folderType: QuickSightClientTypes.FolderType? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sharingModel: QuickSightClientTypes.SharingModel? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.folderId = folderId
            self.folderType = folderType
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.sharingModel = sharingModel
        }
    }
}

/// The number of minutes specified for the lifetime of a session isn't valid. The session lifetime must be 15-600 minutes.
public struct SessionLifetimeInMinutesInvalidException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SessionLifetimeInMinutesInvalidException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// This error indicates that you are calling an embedding operation in Amazon QuickSight without the required pricing plan on your Amazon Web Services account. Before you can use embedding for anonymous users, a QuickSight administrator needs to add capacity pricing to Amazon QuickSight. You can do this on the Manage Amazon QuickSight page. After capacity pricing is added, you can use the [GetDashboardEmbedUrl](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GetDashboardEmbedUrl.html) API operation with the --identity-type ANONYMOUS option.
public struct UnsupportedPricingPlanException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedPricingPlanException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    /// The key-value pair used for the row-level security tags feature.
    public struct SessionTag: Swift.Sendable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that you want to assign the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension QuickSightClientTypes.SessionTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SessionTag(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

public struct GenerateEmbedUrlForAnonymousUserInput: Swift.Sendable {
    /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
    public var allowedDomains: [Swift.String]?
    /// The Amazon Resource Names (ARNs) for the Amazon QuickSight resources that the user is authorized to access during the lifetime of the session. If you choose Dashboard embedding experience, pass the list of dashboard ARNs in the account that you want the user to be able to view. If you want to make changes to the theme of your embedded content, pass a list of theme ARNs that the anonymous users need access to. Currently, you can pass up to 25 theme ARNs in each API call.
    /// This member is required.
    public var authorizedResourceArns: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The configuration of the experience that you are embedding.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?
    /// The Amazon QuickSight namespace that the anonymous user virtually belongs to. If you are not using an Amazon QuickSight custom namespace, set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The session tags used for row-level security. Before you use this parameter, make sure that you have configured the relevant datasets using the DataSet$RowLevelPermissionTagConfiguration parameter so that session tags can be used to provide row-level security. These are not the tags used for the Amazon Web Services resource tagging feature. For more information, see [Using Row-Level Security (RLS) with Tags](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html)in the Amazon QuickSight User Guide.
    public var sessionTags: [QuickSightClientTypes.SessionTag]?

    public init(
        allowedDomains: [Swift.String]? = nil,
        authorizedResourceArns: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration? = nil,
        namespace: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        sessionTags: [QuickSightClientTypes.SessionTag]? = nil
    )
    {
        self.allowedDomains = allowedDomains
        self.authorizedResourceArns = authorizedResourceArns
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.namespace = namespace
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.sessionTags = sessionTags
    }
}

public struct GenerateEmbedUrlForAnonymousUserOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) to use for the anonymous Amazon QuickSight user.
    /// This member is required.
    public var anonymousUserArn: Swift.String?
    /// The embed URL for the dashboard.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init(
        anonymousUserArn: Swift.String? = nil,
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.anonymousUserArn = anonymousUserArn
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

extension GenerateEmbedUrlForAnonymousUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateEmbedUrlForAnonymousUserOutput(anonymousUserArn: \(Swift.String(describing: anonymousUserArn)), requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

/// The user with the provided name isn't found. This error can happen in any operation that requires finding a user based on a provided user name, such as DeleteUser, DescribeUser, and so on.
public struct QuickSightUserNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QuickSightUserNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension QuickSightClientTypes {

    /// The state perssitence configuration of an embedded dashboard.
    public struct StatePersistenceConfigurations: Swift.Sendable {
        /// Determines if a Amazon QuickSight dashboard's state persistence settings are turned on or off.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }
}

extension QuickSightClientTypes {

    /// The feature configuration for an embedded dashboard.
    public struct RegisteredUserDashboardFeatureConfigurations: Swift.Sendable {
        /// The bookmarks configuration for an embedded dashboard in Amazon QuickSight.
        public var bookmarks: QuickSightClientTypes.BookmarksConfigurations?
        /// The shared view settings of an embedded dashboard.
        public var sharedView: QuickSightClientTypes.SharedViewConfigurations?
        /// The state persistence settings of an embedded dashboard.
        public var statePersistence: QuickSightClientTypes.StatePersistenceConfigurations?

        public init(
            bookmarks: QuickSightClientTypes.BookmarksConfigurations? = nil,
            sharedView: QuickSightClientTypes.SharedViewConfigurations? = nil,
            statePersistence: QuickSightClientTypes.StatePersistenceConfigurations? = nil
        )
        {
            self.bookmarks = bookmarks
            self.sharedView = sharedView
            self.statePersistence = statePersistence
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the dashboard you want to embed.
    public struct RegisteredUserDashboardEmbeddingConfiguration: Swift.Sendable {
        /// The feature configurations of an embbedded Amazon QuickSight dashboard.
        public var featureConfigurations: QuickSightClientTypes.RegisteredUserDashboardFeatureConfigurations?
        /// The dashboard ID for the dashboard that you want the user to see first. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this dashboard if the user has permissions to view it. If the user does not have permission to view this dashboard, they see a permissions error message.
        /// This member is required.
        public var initialDashboardId: Swift.String?

        public init(
            featureConfigurations: QuickSightClientTypes.RegisteredUserDashboardFeatureConfigurations? = nil,
            initialDashboardId: Swift.String? = nil
        )
        {
            self.featureConfigurations = featureConfigurations
            self.initialDashboardId = initialDashboardId
        }
    }
}

extension QuickSightClientTypes {

    /// The experience that you are embedding. You can use this object to generate a url that embeds a visual into your application.
    public struct RegisteredUserDashboardVisualEmbeddingConfiguration: Swift.Sendable {
        /// The visual ID for the visual that you want the user to embed. This ID is included in the output URL. When the URL in response is accessed, Amazon QuickSight renders this visual. The Amazon Resource Name (ARN) of the dashboard that the visual belongs to must be included in the AuthorizedResourceArns parameter. Otherwise, the request will fail with InvalidParameterValueException.
        /// This member is required.
        public var initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId?

        public init(
            initialDashboardVisualId: QuickSightClientTypes.DashboardVisualId? = nil
        )
        {
            self.initialDashboardVisualId = initialDashboardVisualId
        }
    }
}

extension QuickSightClientTypes {

    /// An object that provides information about the configuration of a Generative Q&A experience.
    public struct RegisteredUserGenerativeQnAEmbeddingConfiguration: Swift.Sendable {
        /// The ID of the new Q reader experience topic that you want to make the starting topic in the Generative Q&A experience. You can find a topic ID by navigating to the Topics pane in the Amazon QuickSight application and opening a topic. The ID is in the URL for the topic that you open. If you don't specify an initial topic or you specify a legacy topic, a list of all shared new reader experience topics is shown in the Generative Q&A experience for your readers. When you select an initial new reader experience topic, you can specify whether or not readers are allowed to select other new reader experience topics from the available ones in the list.
        public var initialTopicId: Swift.String?

        public init(
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the Q search bar embedding experience.
    public struct RegisteredUserQSearchBarEmbeddingConfiguration: Swift.Sendable {
        /// The ID of the legacy Q topic that you want to use as the starting topic in the Q search bar. To locate the topic ID of the topic that you want to use, open the [Amazon QuickSight console](https://quicksight.aws.amazon.com/), navigate to the Topics pane, and choose thre topic that you want to use. The TopicID is located in the URL of the topic that opens. When you select an initial topic, you can specify whether or not readers are allowed to select other topics from the list of available topics. If you don't specify an initial topic or if you specify a new reader experience topic, a list of all shared legacy topics is shown in the Q bar.
        public var initialTopicId: Swift.String?

        public init(
            initialTopicId: Swift.String? = nil
        )
        {
            self.initialTopicId = initialTopicId
        }
    }
}

extension QuickSightClientTypes {

    /// The feature configurations of an embedded Amazon QuickSight console.
    public struct RegisteredUserConsoleFeatureConfigurations: Swift.Sendable {
        /// The shared view settings of an embedded dashboard.
        public var sharedView: QuickSightClientTypes.SharedViewConfigurations?
        /// The state persistence configurations of an embedded Amazon QuickSight console.
        public var statePersistence: QuickSightClientTypes.StatePersistenceConfigurations?

        public init(
            sharedView: QuickSightClientTypes.SharedViewConfigurations? = nil,
            statePersistence: QuickSightClientTypes.StatePersistenceConfigurations? = nil
        )
        {
            self.sharedView = sharedView
            self.statePersistence = statePersistence
        }
    }
}

extension QuickSightClientTypes {

    /// Information about the Amazon QuickSight console that you want to embed.
    public struct RegisteredUserQuickSightConsoleEmbeddingConfiguration: Swift.Sendable {
        /// The embedding configuration of an embedded Amazon QuickSight console.
        public var featureConfigurations: QuickSightClientTypes.RegisteredUserConsoleFeatureConfigurations?
        /// The initial URL path for the Amazon QuickSight console. InitialPath is required. The entry point URL is constrained to the following paths:
        ///
        /// * /start
        ///
        /// * /start/analyses
        ///
        /// * /start/dashboards
        ///
        /// * /start/favorites
        ///
        /// * /dashboards/DashboardId. DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard.
        ///
        /// * /analyses/AnalysisId. AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis.
        public var initialPath: Swift.String?

        public init(
            featureConfigurations: QuickSightClientTypes.RegisteredUserConsoleFeatureConfigurations? = nil,
            initialPath: Swift.String? = nil
        )
        {
            self.featureConfigurations = featureConfigurations
            self.initialPath = initialPath
        }
    }
}

extension QuickSightClientTypes {

    /// The type of experience you want to embed. For registered users, you can embed Amazon QuickSight dashboards or the Amazon QuickSight console. Exactly one of the experience configurations is required. You can choose Dashboard or QuickSightConsole. You cannot choose more than one experience configuration.
    public struct RegisteredUserEmbeddingExperienceConfiguration: Swift.Sendable {
        /// The configuration details for providing a dashboard embedding experience.
        public var dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration?
        /// The type of embedding experience. In this case, Amazon QuickSight visuals.
        public var dashboardVisual: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration?
        /// The configuration details for embedding the Generative Q&A experience. For more information about embedding the Generative Q&A experience, see [Embedding Overview](https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html) in the Amazon QuickSight User Guide.
        public var generativeQnA: QuickSightClientTypes.RegisteredUserGenerativeQnAEmbeddingConfiguration?
        /// The configuration details for embedding the Q search bar. For more information about embedding the Q search bar, see [Embedding Overview](https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html) in the Amazon QuickSight User Guide.
        public var qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration?
        /// The configuration details for providing each Amazon QuickSight console embedding experience. This can be used along with custom permissions to restrict access to certain features. For more information, see [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html) in the Amazon QuickSight User Guide. Use [GenerateEmbedUrlForRegisteredUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html) where you want to provide an authoring portal that allows users to create data sources, datasets, analyses, and dashboards. The users who accesses an embedded Amazon QuickSight console needs to belong to the author or admin security cohort. If you want to restrict permissions to some of these features, add a custom permissions profile to the user with the [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) API operation. Use the [RegisterUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html) API operation to add a new user with a custom permission profile attached. For more information, see the following sections in the Amazon QuickSight User Guide:
        ///
        /// * [Embedding the Full Functionality of the Amazon QuickSight Console for Authenticated Users](https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html)
        ///
        /// * [Customizing Access to the Amazon QuickSight Console](https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html)
        ///
        ///
        /// For more information about the high-level steps for embedding and for an interactive demo of the ways you can customize embedding, visit the [Amazon QuickSight Developer Portal](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html).
        public var quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration?

        public init(
            dashboard: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration? = nil,
            dashboardVisual: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration? = nil,
            generativeQnA: QuickSightClientTypes.RegisteredUserGenerativeQnAEmbeddingConfiguration? = nil,
            qSearchBar: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration? = nil,
            quickSightConsole: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration? = nil
        )
        {
            self.dashboard = dashboard
            self.dashboardVisual = dashboardVisual
            self.generativeQnA = generativeQnA
            self.qSearchBar = qSearchBar
            self.quickSightConsole = quickSightConsole
        }
    }
}

public struct GenerateEmbedUrlForRegisteredUserInput: Swift.Sendable {
    /// The domains that you want to add to the allow list for access to the generated URL that is then embedded. This optional parameter overrides the static domains that are configured in the Manage QuickSight menu in the Amazon QuickSight console. Instead, it allows only the domains that you include in this parameter. You can list up to three domains or subdomains in each API call. To include all subdomains under a specific domain to the allow list, use *. For example, https://*.sapp.amazon.com includes all subdomains under https://sapp.amazon.com.
    public var allowedDomains: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The experience that you want to embed. For registered users, you can embed Amazon QuickSight dashboards, Amazon QuickSight visuals, the Amazon QuickSight Q search bar, the Amazon QuickSight Generative Q&A experience, or the entire Amazon QuickSight console.
    /// This member is required.
    public var experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?
    /// How many minutes the session is valid. The session lifetime must be in [15-600] minutes range.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon Resource Name for the registered user.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        allowedDomains: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        experienceConfiguration: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.allowedDomains = allowedDomains
        self.awsAccountId = awsAccountId
        self.experienceConfiguration = experienceConfiguration
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

public struct GenerateEmbedUrlForRegisteredUserOutput: Swift.Sendable {
    /// The embed URL for the Amazon QuickSight dashboard, visual, Q search bar, Generative Q&A experience, or console.
    /// This member is required.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    /// This member is required.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    /// This member is required.
    public var status: Swift.Int

    public init(
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

extension GenerateEmbedUrlForRegisteredUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GenerateEmbedUrlForRegisteredUserOutput(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

/// The identity type specified isn't supported. Supported identity types include IAM and QUICKSIGHT.
public struct IdentityTypeNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdentityTypeNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct GetDashboardEmbedUrlInput: Swift.Sendable {
    /// A list of one or more dashboard IDs that you want anonymous users to have tempporary access to. Currently, the IdentityType parameter must be set to ANONYMOUS because other identity types authenticate as Amazon QuickSight or IAM users. For example, if you set "--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3 identity-type ANONYMOUS", the session can access all three dashboards.
    public var additionalDashboardIds: [Swift.String]?
    /// The ID for the Amazon Web Services account that contains the dashboard that you're embedding.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard, also added to the Identity and Access Management (IAM) policy.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The authentication method that the user uses to sign in.
    /// This member is required.
    public var identityType: QuickSightClientTypes.EmbeddingIdentityType?
    /// The Amazon QuickSight namespace that contains the dashboard IDs in this request. If you're not using a custom namespace, set Namespace = default.
    public var namespace: Swift.String?
    /// Remove the reset button on the embedded dashboard. The default is FALSE, which enables the reset button.
    public var resetDisabled: Swift.Bool?
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// Adds persistence of state for the user session in an embedded dashboard. Persistence applies to the sheet and the parameter settings. These are control settings that the dashboard subscriber (Amazon QuickSight reader) chooses while viewing the dashboard. If this is set to TRUE, the settings are the same when the subscriber reopens the same dashboard URL. The state is stored in Amazon QuickSight, not in a browser cookie. If this is set to FALSE, the state of the user session is not persisted. The default is FALSE.
    public var statePersistenceEnabled: Swift.Bool?
    /// Remove the undo/redo button on the embedded dashboard. The default is FALSE, which enables the undo/redo button.
    public var undoRedoDisabled: Swift.Bool?
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any Amazon QuickSight users in your account (readers, authors, or admins) authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation.
    ///
    ///
    /// Omit this parameter for users in the third group â€“ IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init(
        additionalDashboardIds: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        identityType: QuickSightClientTypes.EmbeddingIdentityType? = nil,
        namespace: Swift.String? = nil,
        resetDisabled: Swift.Bool? = false,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        statePersistenceEnabled: Swift.Bool? = false,
        undoRedoDisabled: Swift.Bool? = false,
        userArn: Swift.String? = nil
    )
    {
        self.additionalDashboardIds = additionalDashboardIds
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.identityType = identityType
        self.namespace = namespace
        self.resetDisabled = resetDisabled
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.statePersistenceEnabled = statePersistenceEnabled
        self.undoRedoDisabled = undoRedoDisabled
        self.userArn = userArn
    }
}

/// Output returned from the GetDashboardEmbedUrl operation.
public struct GetDashboardEmbedUrlOutput: Swift.Sendable {
    /// A single-use URL that you can put into your server-side webpage to embed your dashboard. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

extension GetDashboardEmbedUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDashboardEmbedUrlOutput(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

public struct GetSessionEmbedUrlInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account associated with your Amazon QuickSight subscription.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL you use to access the embedded session. The entry point URL is constrained to the following paths:
    ///
    /// * /start
    ///
    /// * /start/analyses
    ///
    /// * /start/dashboards
    ///
    /// * /start/favorites
    ///
    /// * /dashboards/DashboardId  - where DashboardId is the actual ID key from the Amazon QuickSight console URL of the dashboard
    ///
    /// * /analyses/AnalysisId  - where AnalysisId is the actual ID key from the Amazon QuickSight console URL of the analysis
    public var entryPoint: Swift.String?
    /// How many minutes the session is valid. The session lifetime must be 15-600 minutes.
    public var sessionLifetimeInMinutes: Swift.Int?
    /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with QUICKSIGHT identity type. You can use this for any type of Amazon QuickSight users in your account (readers, authors, or admins). They need to be authenticated as one of the following:
    ///
    /// * Active Directory (AD) users or group members
    ///
    /// * Invited nonfederated users
    ///
    /// * IAM users and IAM role-based sessions authenticated through Federated Single Sign-On using SAML, OpenID Connect, or IAM federation
    ///
    ///
    /// Omit this parameter for users in the third group, IAM users and IAM role-based sessions.
    public var userArn: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        entryPoint: Swift.String? = nil,
        sessionLifetimeInMinutes: Swift.Int? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.entryPoint = entryPoint
        self.sessionLifetimeInMinutes = sessionLifetimeInMinutes
        self.userArn = userArn
    }
}

public struct GetSessionEmbedUrlOutput: Swift.Sendable {
    /// A single-use URL that you can put into your server-side web page to embed your Amazon QuickSight session. This URL is valid for 5 minutes. The API operation provides the URL with an auth_code value that enables one (and only one) sign-on to a user session that is valid for 10 hours.
    public var embedUrl: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        embedUrl: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.embedUrl = embedUrl
        self.requestId = requestId
        self.status = status
    }
}

extension GetSessionEmbedUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionEmbedUrlOutput(requestId: \(Swift.String(describing: requestId)), status: \(Swift.String(describing: status)), embedUrl: \"CONTENT_REDACTED\")"}
}

extension QuickSightClientTypes {

    public enum GroupFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case groupName
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupFilterAttribute] {
            return [
                .groupName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .groupName: return "GROUP_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    public enum GroupFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startswith
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupFilterOperator] {
            return [
                .startswith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startswith: return "StartsWith"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QuickSightClientTypes {

    /// A GroupSearchFilter object that you want to apply to your search.
    public struct GroupSearchFilter: Swift.Sendable {
        /// The name of the value that you want to use as a filter, for example "Name": "GROUP_NAME". Currently, the only supported name is GROUP_NAME.
        /// This member is required.
        public var name: QuickSightClientTypes.GroupFilterAttribute?
        /// The comparison operator that you want to use as a filter, for example "Operator": "StartsWith". Currently, the only supported operator is StartsWith.
        /// This member is required.
        public var `operator`: QuickSightClientTypes.GroupFilterOperator?
        /// The value of the named item, in this case GROUP_NAME, that you want to use as a filter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: QuickSightClientTypes.GroupFilterAttribute? = nil,
            `operator`: QuickSightClientTypes.GroupFilterOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension QuickSightClientTypes {

    /// IAM policy assignment summary.
    public struct IAMPolicyAssignmentSummary: Swift.Sendable {
        /// Assignment name.
        public var assignmentName: Swift.String?
        /// Assignment status.
        public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?

        public init(
            assignmentName: Swift.String? = nil,
            assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil
        )
        {
            self.assignmentName = assignmentName
            self.assignmentStatus = assignmentStatus
        }
    }
}

/// You don't have this feature activated for your account. To fix this issue, contact Amazon Web Services support.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The Amazon Web Services request ID for this request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

public struct ListAnalysesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the analyses.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAnalysesOutput: Swift.Sendable {
    /// Metadata describing each of the analyses that are listed.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListAssetBundleExportJobsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the export jobs were executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetBundleExportJobsOutput: Swift.Sendable {
    /// A list of export job summaries.
    public var assetBundleExportJobSummaryList: [QuickSightClientTypes.AssetBundleExportJobSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        assetBundleExportJobSummaryList: [QuickSightClientTypes.AssetBundleExportJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assetBundleExportJobSummaryList = assetBundleExportJobSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListAssetBundleImportJobsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the import jobs were executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetBundleImportJobsOutput: Swift.Sendable {
    /// A list of import job summaries.
    public var assetBundleImportJobSummaryList: [QuickSightClientTypes.AssetBundleImportJobSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the response.
    public var status: Swift.Int

    public init(
        assetBundleImportJobSummaryList: [QuickSightClientTypes.AssetBundleImportJobSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assetBundleImportJobSummaryList = assetBundleImportJobSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListDashboardsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboards that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDashboardsOutput: Swift.Sendable {
    /// A structure that contains all of the dashboards in your Amazon Web Services account. This structure provides basic information about the dashboards.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListDashboardVersionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're listing versions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDashboardVersionsOutput: Swift.Sendable {
    /// A structure that contains information about each version of the dashboard.
    public var dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardVersionSummaryList: [QuickSightClientTypes.DashboardVersionSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardVersionSummaryList = dashboardVersionSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListDataSetsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDataSetsOutput: Swift.Sendable {
    /// The list of dataset summaries.
    public var dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSetSummaries: [QuickSightClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListDataSourcesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDataSourcesOutput: Swift.Sendable {
    /// A list of data sources.
    public var dataSources: [QuickSightClientTypes.DataSource]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSources: [QuickSightClientTypes.DataSource]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListFolderMembersInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFolderMembersOutput: Swift.Sendable {
    /// A structure that contains all of the folder members (dashboards, analyses, and datasets) in the folder.
    public var folderMemberList: [QuickSightClientTypes.MemberIdArnPair]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folderMemberList: [QuickSightClientTypes.MemberIdArnPair]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderMemberList = folderMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListFoldersInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFoldersOutput: Swift.Sendable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListFoldersForResourceInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the resource.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) the resource whose folders you need to list.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListFoldersForResourceOutput: Swift.Sendable {
    /// A list that contains the Amazon Resource Names (ARNs) of all folders that the resource is a member of.
    public var folders: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folders: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folders = folders
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListGroupMembershipsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the group that you want to see a membership list of.
    /// This member is required.
    public var groupName: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace of the group that you want a list of users from.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        groupName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.groupName = groupName
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct ListGroupMembershipsOutput: Swift.Sendable {
    /// The list of the members of the group.
    public var groupMemberList: [QuickSightClientTypes.GroupMember]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupMemberList: [QuickSightClientTypes.GroupMember]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupMemberList = groupMemberList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListGroupsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The namespace that you want a list of groups from.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct ListGroupsOutput: Swift.Sendable {
    /// The list of the groups.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListIAMPolicyAssignmentsInput: Swift.Sendable {
    /// The status of the assignments.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains these IAM policy assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace for the assignments.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct ListIAMPolicyAssignmentsOutput: Swift.Sendable {
    /// Information describing the IAM policy assignments.
    public var iamPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        iamPolicyAssignments: [QuickSightClientTypes.IAMPolicyAssignmentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.iamPolicyAssignments = iamPolicyAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListIAMPolicyAssignmentsForUserInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the assignments.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The name of the user.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

public struct ListIAMPolicyAssignmentsForUserOutput: Swift.Sendable {
    /// The active assignments for this user.
    public var activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        activeAssignments: [QuickSightClientTypes.ActiveIAMPolicyAssignment]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.activeAssignments = activeAssignments
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListIdentityPropagationConfigsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contain the identity propagation configurations of.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIdentityPropagationConfigsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A list of services and their authorized targets that the Amazon QuickSight IAM Identity Center application can access.
    public var services: [QuickSightClientTypes.AuthorizedTargetsByService]?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        services: [QuickSightClientTypes.AuthorizedTargetsByService]? = nil,
        status: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.services = services
        self.status = status
    }
}

public struct ListIngestionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset used in the ingestion.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListIngestionsOutput: Swift.Sendable {
    /// A list of the ingestions.
    public var ingestions: [QuickSightClientTypes.Ingestion]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        ingestions: [QuickSightClientTypes.Ingestion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListNamespacesInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight namespaces that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A unique pagination token that can be used in a subsequent request. You will receive a pagination token in the response body of a previous ListNameSpaces API call if there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListNamespacesOutput: Swift.Sendable {
    /// The information about the namespaces in this Amazon Web Services account. The response includes the namespace ARN, name, Amazon Web Services Region, notification email address, creation status, and identity store.
    public var namespaces: [QuickSightClientTypes.NamespaceInfoV2]?
    /// A unique pagination token that can be used in a subsequent request. Receiving NextToken in your response inticates that there is more data that can be returned. To receive the data, make another ListNamespaces API call with the returned token to retrieve the next page of data. Each token is valid for 24 hours. If you try to make a ListNamespaces API call with an expired token, you will receive a HTTP 400 InvalidNextTokenException error.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        namespaces: [QuickSightClientTypes.NamespaceInfoV2]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListRefreshSchedulesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
    }
}

public struct ListRefreshSchedulesOutput: Swift.Sendable {
    /// The list of refresh schedules for the dataset.
    public var refreshSchedules: [QuickSightClientTypes.RefreshSchedule]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        refreshSchedules: [QuickSightClientTypes.RefreshSchedule]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.refreshSchedules = refreshSchedules
        self.requestId = requestId
        self.status = status
    }
}

public struct ListRoleMembershipsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The namespace that includes the role.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The name of the role.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.role = role
    }
}

public struct ListRoleMembershipsOutput: Swift.Sendable {
    /// The list of groups associated with a role
    public var membersList: [Swift.String]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        membersList: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.membersList = membersList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want a list of tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.tags = tags
    }
}

public struct ListTemplateAliasesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the template aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

public struct ListTemplateAliasesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the template's aliases.
    public var templateAliasList: [QuickSightClientTypes.TemplateAlias]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAliasList: [QuickSightClientTypes.TemplateAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateAliasList = templateAliasList
    }
}

public struct ListTemplatesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QuickSightClientTypes {

    /// The template summary.
    public struct TemplateSummary: Swift.Sendable {
        /// A summary of a template.
        public var arn: Swift.String?
        /// The last time that this template was created.
        public var createdTime: Foundation.Date?
        /// The last time that this template was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A structure containing a list of version numbers for the template summary.
        public var latestVersionNumber: Swift.Int?
        /// A display name for the template.
        public var name: Swift.String?
        /// The ID of the template. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var templateId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            templateId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.templateId = templateId
        }
    }
}

public struct ListTemplatesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing information about the templates in the list.
    public var templateSummaryList: [QuickSightClientTypes.TemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateSummaryList: [QuickSightClientTypes.TemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateSummaryList = templateSummaryList
    }
}

public struct ListTemplateVersionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the templates that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.templateId = templateId
    }
}

extension QuickSightClientTypes {

    /// The template version.
    public struct TemplateVersionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the template version.
        public var arn: Swift.String?
        /// The time that this template version was created.
        public var createdTime: Foundation.Date?
        /// The description of the template version.
        public var description: Swift.String?
        /// The status of the template version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the template version.
        public var versionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }
}

public struct ListTemplateVersionsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified template.
    public var templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateVersionSummaryList: [QuickSightClientTypes.TemplateVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.templateVersionSummaryList = templateVersionSummaryList
    }
}

public struct ListThemeAliasesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the theme aliases that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

public struct ListThemeAliasesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing the list of the theme's aliases.
    public var themeAliasList: [QuickSightClientTypes.ThemeAlias]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAliasList: [QuickSightClientTypes.ThemeAlias]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeAliasList = themeAliasList
    }
}

public struct ListThemesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The type of themes that you want to list. Valid options include the following:
    ///
    /// * ALL (default)- Display all existing themes.
    ///
    /// * CUSTOM - Display only the themes created by people using Amazon QuickSight.
    ///
    /// * QUICKSIGHT - Display only the starting themes defined by Amazon QuickSight.
    public var type: QuickSightClientTypes.ThemeType?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: QuickSightClientTypes.ThemeType? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension QuickSightClientTypes {

    /// The theme summary.
    public struct ThemeSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The date and time that this theme was created.
        public var createdTime: Foundation.Date?
        /// The last date and time that this theme was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The latest version number for the theme.
        public var latestVersionNumber: Swift.Int?
        /// the display name for the theme.
        public var name: Swift.String?
        /// The ID of the theme. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var themeId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            latestVersionNumber: Swift.Int? = nil,
            name: Swift.String? = nil,
            themeId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.lastUpdatedTime = lastUpdatedTime
            self.latestVersionNumber = latestVersionNumber
            self.name = name
            self.themeId = themeId
        }
    }
}

public struct ListThemesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the themes in the list.
    public var themeSummaryList: [QuickSightClientTypes.ThemeSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeSummaryList: [QuickSightClientTypes.ThemeSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeSummaryList = themeSummaryList
    }
}

public struct ListThemeVersionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the themes that you're listing.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.themeId = themeId
    }
}

extension QuickSightClientTypes {

    /// The theme version.
    public struct ThemeVersionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the theme version.
        public var arn: Swift.String?
        /// The date and time that this theme version was created.
        public var createdTime: Foundation.Date?
        /// The description of the theme version.
        public var description: Swift.String?
        /// The status of the theme version.
        public var status: QuickSightClientTypes.ResourceStatus?
        /// The version number of the theme version.
        public var versionNumber: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            status: QuickSightClientTypes.ResourceStatus? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.status = status
            self.versionNumber = versionNumber
        }
    }
}

public struct ListThemeVersionsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A structure containing a list of all the versions of the specified theme.
    public var themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeVersionSummaryList: [QuickSightClientTypes.ThemeVersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.themeVersionSummaryList = themeVersionSummaryList
    }
}

public struct ListTopicRefreshSchedulesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic whose refresh schedule you want described.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

extension QuickSightClientTypes {

    /// A summary of the refresh schedule details for a dataset.
    public struct TopicRefreshScheduleSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the dataset.
        public var datasetArn: Swift.String?
        /// The ID of the dataset.
        public var datasetId: Swift.String?
        /// The name of the dataset.
        public var datasetName: Swift.String?
        /// The definition of a refresh schedule.
        public var refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule?

        public init(
            datasetArn: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            datasetName: Swift.String? = nil,
            refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule? = nil
        )
        {
            self.datasetArn = datasetArn
            self.datasetId = datasetId
            self.datasetName = datasetName
            self.refreshSchedule = refreshSchedule
        }
    }
}

public struct ListTopicRefreshSchedulesOutput: Swift.Sendable {
    /// The list of topic refresh schedules.
    public var refreshSchedules: [QuickSightClientTypes.TopicRefreshScheduleSummary]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID for the topic that you want to describe. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        refreshSchedules: [QuickSightClientTypes.TopicRefreshScheduleSummary]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.refreshSchedules = refreshSchedules
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct ListTopicReviewedAnswersInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that containd the reviewed answers that you want listed.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the topic that contains the reviewed answer that you want to list. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct ListTopicsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topics that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QuickSightClientTypes {

    /// A topic summary.
    public struct TopicSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the topic.
        public var arn: Swift.String?
        /// The name of the topic.
        public var name: Swift.String?
        /// The ID for the topic. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
        public var topicId: Swift.String?
        /// The user experience version of the topic.
        public var userExperienceVersion: QuickSightClientTypes.TopicUserExperienceVersion?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            topicId: Swift.String? = nil,
            userExperienceVersion: QuickSightClientTypes.TopicUserExperienceVersion? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.topicId = topicId
            self.userExperienceVersion = userExperienceVersion
        }
    }
}

public struct ListTopicsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A list of topic summaries.
    public var topicsSummaries: [QuickSightClientTypes.TopicSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicsSummaries: [QuickSightClientTypes.TopicSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.topicsSummaries = topicsSummaries
    }
}

public struct ListUserGroupsInput: Swift.Sendable {
    /// The Amazon Web Services account ID that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon QuickSight user name that you want to list group memberships for.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.userName = userName
    }
}

public struct ListUserGroupsOutput: Swift.Sendable {
    /// The list of groups the user is a member of.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct ListUsersInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct ListUsersOutput: Swift.Sendable {
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The list of users.
    public var userList: [QuickSightClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        userList: [QuickSightClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.userList = userList
    }
}

public struct ListVPCConnectionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account that contains the VPC connections that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QuickSightClientTypes {

    /// The summary metadata that describes a VPC connection.
    public struct VPCConnectionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the VPC connection.
        public var arn: Swift.String?
        /// The availability status of the VPC connection.
        public var availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus?
        /// The time that the VPC connection was created.
        public var createdTime: Foundation.Date?
        /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
        public var dnsResolvers: [Swift.String]?
        /// The time that the VPC connection was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The display name for the VPC connection.
        public var name: Swift.String?
        /// A list of network interfaces.
        public var networkInterfaces: [QuickSightClientTypes.NetworkInterface]?
        /// The ARN of the IAM role associated with the VPC connection.
        public var roleArn: Swift.String?
        /// The Amazon EC2 security group IDs associated with the VPC connection.
        public var securityGroupIds: [Swift.String]?
        /// The status of the VPC connection.
        public var status: QuickSightClientTypes.VPCConnectionResourceStatus?
        /// The ID of the VPC connection that you're creating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
        public var vpcConnectionId: Swift.String?
        /// The Amazon EC2 VPC ID associated with the VPC connection.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus? = nil,
            createdTime: Foundation.Date? = nil,
            dnsResolvers: [Swift.String]? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            networkInterfaces: [QuickSightClientTypes.NetworkInterface]? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: QuickSightClientTypes.VPCConnectionResourceStatus? = nil,
            vpcConnectionId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.availabilityStatus = availabilityStatus
            self.createdTime = createdTime
            self.dnsResolvers = dnsResolvers
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.vpcConnectionId = vpcConnectionId
            self.vpcId = vpcId
        }
    }
}

public struct ListVPCConnectionsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// A VPCConnectionSummaries object that returns a summary of VPC connection objects.
    public var vpcConnectionSummaries: [QuickSightClientTypes.VPCConnectionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        vpcConnectionSummaries: [QuickSightClientTypes.VPCConnectionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
        self.vpcConnectionSummaries = vpcConnectionSummaries
    }
}

extension QuickSightClientTypes {

    public enum PurchaseMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoPurchase
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [PurchaseMode] {
            return [
                .autoPurchase,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoPurchase: return "AUTO_PURCHASE"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct PutDataSetRefreshPropertiesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The dataset refresh properties.
    /// This member is required.
    public var dataSetRefreshProperties: QuickSightClientTypes.DataSetRefreshProperties?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        dataSetRefreshProperties: QuickSightClientTypes.DataSetRefreshProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.dataSetRefreshProperties = dataSetRefreshProperties
    }
}

public struct PutDataSetRefreshPropertiesOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct RegisterUserInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// To add custom permissions to an existing user, use [UpdateUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html) instead. A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader, admin pro, author pro, reader pro). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to register.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, donâ€™t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The ARN of the IAM user or role that you are registering with Amazon QuickSight.
    public var iamArn: Swift.String?
    /// The identity type that your Amazon QuickSight account uses to manage the identity of users.
    /// This member is required.
    public var identityType: QuickSightClientTypes.IdentityType?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// You need to use this parameter only when you register one or more users using an assumed IAM role. You don't need to provide the session name for other scenarios, for example when you are registering an IAM user or an Amazon QuickSight user. You can register multiple users using the same IAM role if each user has a different session name. For more information on assuming IAM roles, see [assume-role](https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html) in the CLI Reference.
    public var sessionName: Swift.String?
    /// The tags to associate with the user.
    public var tags: [QuickSightClientTypes.Tag]?
    /// The Amazon QuickSight user name that you want to create for the user you are registering.
    public var userName: Swift.String?
    /// The Amazon QuickSight role for the user. The user role can be one of the following:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    /// * READER_PRO: Reader Pro adds Generative BI capabilities to the Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can build stories with Amazon Q, and can generate executive summaries from dashboards.
    ///
    /// * AUTHOR_PRO: Author Pro adds Generative BI capabilities to the Author role. Author Pros can author dashboards with natural language with Amazon Q, build stories with Amazon Q, create Topics for Q&A, and generate executive summaries from dashboards.
    ///
    /// * ADMIN_PRO: Admin Pros are Author Pros who can also manage Amazon QuickSight administrative settings. Admin Pro users are billed at Author Pro pricing.
    ///
    /// * RESTRICTED_READER: This role isn't currently available for use.
    ///
    /// * RESTRICTED_AUTHOR: This role isn't currently available for use.
    /// This member is required.
    public var userRole: QuickSightClientTypes.UserRole?

    public init(
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        iamArn: Swift.String? = nil,
        identityType: QuickSightClientTypes.IdentityType? = nil,
        namespace: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil,
        userName: Swift.String? = nil,
        userRole: QuickSightClientTypes.UserRole? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.iamArn = iamArn
        self.identityType = identityType
        self.namespace = namespace
        self.sessionName = sessionName
        self.tags = tags
        self.userName = userName
        self.userRole = userRole
    }
}

public struct RegisterUserOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The user's user name.
    public var user: QuickSightClientTypes.User?
    /// The URL the user visits to complete registration and provide a password. This is returned only for users with an identity type of QUICKSIGHT.
    public var userInvitationUrl: Swift.String?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil,
        userInvitationUrl: Swift.String? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
        self.userInvitationUrl = userInvitationUrl
    }
}

public struct RestoreAnalysisInput: Swift.Sendable {
    /// The ID of the analysis that you're restoring.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A boolean value that determines if the analysis will be restored to folders that it previously resided in. A True value restores analysis back to all folders that it previously resided in. A False value restores the analysis but does not restore the analysis back to all previously resided folders. Restoring a restricted analysis requires this parameter to be set to True.
    public var restoreToFolders: Swift.Bool?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        restoreToFolders: Swift.Bool? = false
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.restoreToFolders = restoreToFolders
    }
}

public struct RestoreAnalysisOutput: Swift.Sendable {
    /// The ID of the analysis that you're restoring.
    public var analysisId: Swift.String?
    /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A list of folder arns thatthe analysis failed to be restored to.
    public var restorationFailedFolderArns: [Swift.String]?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        restorationFailedFolderArns: [Swift.String]? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.restorationFailedFolderArns = restorationFailedFolderArns
        self.status = status
    }
}

public struct SearchAnalysesInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the analyses that you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The structure for the search filters that you want to apply to your search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.AnalysisSearchFilter]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.AnalysisSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchAnalysesOutput: Swift.Sendable {
    /// Metadata describing the analyses that you searched for.
    public var analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisSummaryList: [QuickSightClientTypes.AnalysisSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisSummaryList = analysisSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct SearchDashboardsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the user whose dashboards you're searching for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by user name, for example, "Filters": [ { "Name": "QUICKSIGHT_USER", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]
    /// This member is required.
    public var filters: [QuickSightClientTypes.DashboardSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DashboardSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchDashboardsOutput: Swift.Sendable {
    /// The list of dashboards owned by the user specified in Filters in your request.
    public var dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardSummaryList: [QuickSightClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardSummaryList = dashboardSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct SearchDataSetsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.DataSetSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DataSetSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchDataSetsOutput: Swift.Sendable {
    /// A DataSetSummaries object that returns a summary of a dataset.
    public var dataSetSummaries: [QuickSightClientTypes.DataSetSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSetSummaries: [QuickSightClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetSummaries = dataSetSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct SearchDataSourcesInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.DataSourceSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.DataSourceSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchDataSourcesOutput: Swift.Sendable {
    /// A DataSourceSummaries object that returns a summary of a data source.
    public var dataSourceSummaries: [QuickSightClientTypes.DataSourceSummary]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSourceSummaries: [QuickSightClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct SearchFoldersInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The filters to apply to the search. Currently, you can search only by the parent folder ARN. For example, "Filters": [ { "Name": "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-1:1:folder/folderId" } ].
    /// This member is required.
    public var filters: [QuickSightClientTypes.FolderSearchFilter]?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.FolderSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct SearchFoldersOutput: Swift.Sendable {
    /// A structure that contains all of the folders in the Amazon Web Services account. This structure provides basic information about the folders.
    public var folderSummaryList: [QuickSightClientTypes.FolderSummary]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        folderSummaryList: [QuickSightClientTypes.FolderSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.folderSummaryList = folderSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct SearchGroupsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The structure for the search filters that you want to apply to your search.
    /// This member is required.
    public var filters: [QuickSightClientTypes.GroupSearchFilter]?
    /// The maximum number of results to return from this request.
    public var maxResults: Swift.Int?
    /// The namespace that you want to search.
    /// This member is required.
    public var namespace: Swift.String?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        filters: [QuickSightClientTypes.GroupSearchFilter]? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.filters = filters
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

public struct SearchGroupsOutput: Swift.Sendable {
    /// A list of groups in a specified namespace that match the filters you set in your SearchGroups request.
    public var groupList: [QuickSightClientTypes.Group]?
    /// A pagination token that can be used in a subsequent request.
    public var nextToken: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        groupList: [QuickSightClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.groupList = groupList
        self.nextToken = nextToken
        self.requestId = requestId
        self.status = status
    }
}

public struct StartAssetBundleExportJobInput: Swift.Sendable {
    /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
    /// This member is required.
    public var assetBundleExportJobId: Swift.String?
    /// The ID of the Amazon Web Services account to export assets from.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An optional collection of structures that generate CloudFormation parameters to override the existing resource property values when the resource is exported to a new CloudFormation template. Use this field if the ExportFormat field of a StartAssetBundleExportJobRequest API call is set to CLOUDFORMATION_JSON.
    public var cloudFormationOverridePropertyConfiguration: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration?
    /// The export data format.
    /// This member is required.
    public var exportFormat: QuickSightClientTypes.AssetBundleExportFormat?
    /// A Boolean that determines whether all dependencies of each resource ARN are recursively exported with the job. For example, say you provided a Dashboard ARN to the ResourceArns parameter. If you set IncludeAllDependencies to TRUE, any theme, dataset, and data source resource that is a dependency of the dashboard is also exported.
    public var includeAllDependencies: Swift.Bool?
    /// A setting that indicates whether you want to include folder assets. You can also use this setting to recusrsively include all subfolders of an exported folder.
    public var includeFolderMembers: QuickSightClientTypes.IncludeFolderMembers?
    /// A Boolean that determines if the exported asset carries over information about the folders that the asset is a member of.
    public var includeFolderMemberships: Swift.Bool?
    /// A Boolean that determines whether all permissions for each resource ARN are exported with the job. If you set IncludePermissions to TRUE, any permissions associated with each resource are exported.
    public var includePermissions: Swift.Bool?
    /// A Boolean that determines whether all tags for each resource ARN are exported with the job. If you set IncludeTags to TRUE, any tags associated with each resource are exported.
    public var includeTags: Swift.Bool?
    /// An array of resource ARNs to export. The following resources are supported.
    ///
    /// * Analysis
    ///
    /// * Dashboard
    ///
    /// * DataSet
    ///
    /// * DataSource
    ///
    /// * RefreshSchedule
    ///
    /// * Theme
    ///
    /// * VPCConnection
    ///
    ///
    /// The API caller must have the necessary permissions in their IAM role to access each resource before the resources can be exported.
    /// This member is required.
    public var resourceArns: [Swift.String]?
    /// An optional parameter that determines which validation strategy to use for the export job. If StrictModeForAllResources is set to TRUE, strict validation for every error is enforced. If it is set to FALSE, validation is skipped for specific UI errors that are shown as warnings. The default value for StrictModeForAllResources is FALSE.
    public var validationStrategy: QuickSightClientTypes.AssetBundleExportJobValidationStrategy?

    public init(
        assetBundleExportJobId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        cloudFormationOverridePropertyConfiguration: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration? = nil,
        exportFormat: QuickSightClientTypes.AssetBundleExportFormat? = nil,
        includeAllDependencies: Swift.Bool? = false,
        includeFolderMembers: QuickSightClientTypes.IncludeFolderMembers? = nil,
        includeFolderMemberships: Swift.Bool? = false,
        includePermissions: Swift.Bool? = false,
        includeTags: Swift.Bool? = false,
        resourceArns: [Swift.String]? = nil,
        validationStrategy: QuickSightClientTypes.AssetBundleExportJobValidationStrategy? = nil
    )
    {
        self.assetBundleExportJobId = assetBundleExportJobId
        self.awsAccountId = awsAccountId
        self.cloudFormationOverridePropertyConfiguration = cloudFormationOverridePropertyConfiguration
        self.exportFormat = exportFormat
        self.includeAllDependencies = includeAllDependencies
        self.includeFolderMembers = includeFolderMembers
        self.includeFolderMemberships = includeFolderMemberships
        self.includePermissions = includePermissions
        self.includeTags = includeTags
        self.resourceArns = resourceArns
        self.validationStrategy = validationStrategy
    }
}

public struct StartAssetBundleExportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the export job.
    public var arn: Swift.String?
    /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
    public var assetBundleExportJobId: Swift.String?
    /// The Amazon Web Services response ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the response.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        assetBundleExportJobId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.assetBundleExportJobId = assetBundleExportJobId
        self.requestId = requestId
        self.status = status
    }
}

public struct StartAssetBundleImportJobInput: Swift.Sendable {
    /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
    /// This member is required.
    public var assetBundleImportJobId: Swift.String?
    /// The source of the asset bundle zip file that contains the data that you want to import. The file must be in QUICKSIGHT_JSON format.
    /// This member is required.
    public var assetBundleImportSource: QuickSightClientTypes.AssetBundleImportSource?
    /// The ID of the Amazon Web Services account to import assets into.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The failure action for the import job. If you choose ROLLBACK, failed import jobs will attempt to undo any asset changes caused by the failed job. If you choose DO_NOTHING, failed import jobs will not attempt to roll back any asset changes caused by the failed job, possibly keeping the Amazon QuickSight account in an inconsistent state.
    public var failureAction: QuickSightClientTypes.AssetBundleImportFailureAction?
    /// Optional overrides that are applied to the resource configuration before import.
    public var overrideParameters: QuickSightClientTypes.AssetBundleImportJobOverrideParameters?
    /// Optional permission overrides that are applied to the resource configuration before import.
    public var overridePermissions: QuickSightClientTypes.AssetBundleImportJobOverridePermissions?
    /// Optional tag overrides that are applied to the resource configuration before import.
    public var overrideTags: QuickSightClientTypes.AssetBundleImportJobOverrideTags?
    /// An optional validation strategy override for all analyses and dashboards that is applied to the resource configuration before import.
    public var overrideValidationStrategy: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy?

    public init(
        assetBundleImportJobId: Swift.String? = nil,
        assetBundleImportSource: QuickSightClientTypes.AssetBundleImportSource? = nil,
        awsAccountId: Swift.String? = nil,
        failureAction: QuickSightClientTypes.AssetBundleImportFailureAction? = nil,
        overrideParameters: QuickSightClientTypes.AssetBundleImportJobOverrideParameters? = nil,
        overridePermissions: QuickSightClientTypes.AssetBundleImportJobOverridePermissions? = nil,
        overrideTags: QuickSightClientTypes.AssetBundleImportJobOverrideTags? = nil,
        overrideValidationStrategy: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy? = nil
    )
    {
        self.assetBundleImportJobId = assetBundleImportJobId
        self.assetBundleImportSource = assetBundleImportSource
        self.awsAccountId = awsAccountId
        self.failureAction = failureAction
        self.overrideParameters = overrideParameters
        self.overridePermissions = overridePermissions
        self.overrideTags = overrideTags
        self.overrideValidationStrategy = overrideValidationStrategy
    }
}

public struct StartAssetBundleImportJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the import job.
    public var arn: Swift.String?
    /// The ID of the job. This ID is unique while the job is running. After the job is completed, you can reuse this ID for another job.
    public var assetBundleImportJobId: Swift.String?
    /// The Amazon Web Services response ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the response.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        assetBundleImportJobId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.assetBundleImportJobId = assetBundleImportJobId
        self.requestId = requestId
        self.status = status
    }
}

extension QuickSightClientTypes {

    /// A structure that contains information on the anonymous user configuration.
    public struct SnapshotAnonymousUser: Swift.Sendable {
        /// The tags to be used for row-level security (RLS). Make sure that the relevant datasets have RLS tags configured before you start a snapshot export job. You can configure the RLS tags of a dataset with a DataSet$RowLevelPermissionTagConfiguration API call. These are not the tags that are used for Amazon Web Services resource tagging. For more information on row level security in Amazon QuickSight, see [Using Row-Level Security (RLS) with Tags](https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html)in the Amazon QuickSight User Guide.
        public var rowLevelPermissionTags: [QuickSightClientTypes.SessionTag]?

        public init(
            rowLevelPermissionTags: [QuickSightClientTypes.SessionTag]? = nil
        )
        {
            self.rowLevelPermissionTags = rowLevelPermissionTags
        }
    }
}

extension QuickSightClientTypes {

    /// A structure that contains information about the users that the dashboard snapshot is generated for.
    public struct SnapshotUserConfiguration: Swift.Sendable {
        /// An array of records that describe the anonymous users that the dashboard snapshot is generated for.
        public var anonymousUsers: [QuickSightClientTypes.SnapshotAnonymousUser]?

        public init(
            anonymousUsers: [QuickSightClientTypes.SnapshotAnonymousUser]? = nil
        )
        {
            self.anonymousUsers = anonymousUsers
        }
    }
}

public struct StartDashboardSnapshotJobInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dashboard that you want to start a snapshot job for.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// A structure that describes the configuration of the dashboard snapshot.
    /// This member is required.
    public var snapshotConfiguration: QuickSightClientTypes.SnapshotConfiguration?
    /// An ID for the dashboard snapshot job. This ID is unique to the dashboard while the job is running. This ID can be used to poll the status of a job with a DescribeDashboardSnapshotJob while the job runs. You can reuse this ID for another job 24 hours after the current job is completed.
    /// This member is required.
    public var snapshotJobId: Swift.String?
    /// A structure that contains information about the anonymous users that the generated snapshot is for. This API will not return information about registered Amazon QuickSight.
    /// This member is required.
    public var userConfiguration: QuickSightClientTypes.SnapshotUserConfiguration?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        snapshotConfiguration: QuickSightClientTypes.SnapshotConfiguration? = nil,
        snapshotJobId: Swift.String? = nil,
        userConfiguration: QuickSightClientTypes.SnapshotUserConfiguration? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.snapshotConfiguration = snapshotConfiguration
        self.snapshotJobId = snapshotJobId
        self.userConfiguration = userConfiguration
    }
}

public struct StartDashboardSnapshotJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the dashboard snapshot job.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The ID of the job. The job ID is set when you start a new job with a StartDashboardSnapshotJob API call.
    public var snapshotJobId: Swift.String?
    /// The HTTP status of the request
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        snapshotJobId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.snapshotJobId = snapshotJobId
        self.status = status
    }
}

public struct StartDashboardSnapshotJobScheduleInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that the dashboard snapshot job is executed in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dashboard that you want to start a snapshot job schedule for.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The ID of the schedule that you want to start a snapshot job schedule for. The schedule ID can be found in the Amazon QuickSight console in the Schedules pane of the dashboard that the schedule is configured for.
    /// This member is required.
    public var scheduleId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        scheduleId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.scheduleId = scheduleId
    }
}

public struct StartDashboardSnapshotJobScheduleOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Contains a map of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tags: [QuickSightClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [QuickSightClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the resource tag or tags assigned to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateAccountCustomizationInput: Swift.Sendable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    /// This member is required.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The namespace that you want to update Amazon QuickSight customizations for.
    public var namespace: Swift.String?

    public init(
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.accountCustomization = accountCustomization
        self.awsAccountId = awsAccountId
        self.namespace = namespace
    }
}

public struct UpdateAccountCustomizationOutput: Swift.Sendable {
    /// The Amazon QuickSight customizations you're updating in the current Amazon Web Services Region.
    public var accountCustomization: QuickSightClientTypes.AccountCustomization?
    /// The Amazon Resource Name (ARN) for the updated customization for this Amazon Web Services account.
    public var arn: Swift.String?
    /// The ID for the Amazon Web Services account that you want to update Amazon QuickSight customizations for.
    public var awsAccountId: Swift.String?
    /// The namespace associated with the customization that you're updating.
    public var namespace: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        accountCustomization: QuickSightClientTypes.AccountCustomization? = nil,
        arn: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.accountCustomization = accountCustomization
        self.arn = arn
        self.awsAccountId = awsAccountId
        self.namespace = namespace
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateAccountSettingsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the Amazon QuickSight settings that you want to list.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The default namespace for this Amazon Web Services account. Currently, the default is default. IAM users that register for the first time with Amazon QuickSight provide an email address that becomes associated with the default namespace.
    /// This member is required.
    public var defaultNamespace: Swift.String?
    /// The email address that you want Amazon QuickSight to send notifications to regarding your Amazon Web Services account or Amazon QuickSight subscription.
    public var notificationEmail: Swift.String?
    /// A boolean value that determines whether or not an Amazon QuickSight account can be deleted. A True value doesn't allow the account to be deleted and results in an error message if a user tries to make a DeleteAccountSubscription request. A False value will allow the account to be deleted.
    public var terminationProtectionEnabled: Swift.Bool?

    public init(
        awsAccountId: Swift.String? = nil,
        defaultNamespace: Swift.String? = nil,
        notificationEmail: Swift.String? = nil,
        terminationProtectionEnabled: Swift.Bool? = false
    )
    {
        self.awsAccountId = awsAccountId
        self.defaultNamespace = defaultNamespace
        self.notificationEmail = notificationEmail
        self.terminationProtectionEnabled = terminationProtectionEnabled
    }
}

public struct UpdateAccountSettingsOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateAnalysisInput: Swift.Sendable {
    /// The ID for the analysis that you're updating. This ID displays in the URL of the analysis.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of an analysis. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.AnalysisDefinition?
    /// A descriptive name for the analysis that you're updating. This name displays for the analysis in the Amazon QuickSight console.
    /// This member is required.
    public var name: Swift.String?
    /// The parameter names and override values that you want to use. An analysis can have any parameter type, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// A source entity to use for the analysis that you're updating. This metadata structure contains details that describe a source template and one or more datasets.
    public var sourceEntity: QuickSightClientTypes.AnalysisSourceEntity?
    /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that you're creating. To see the theme in the Amazon QuickSight console, make sure that you have access to it.
    public var themeArn: Swift.String?
    /// The option to relax the validation needed to update an analysis with definition objects. This skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.AnalysisDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.AnalysisSourceEntity? = nil,
        themeArn: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
        self.validationStrategy = validationStrategy
    }
}

public struct UpdateAnalysisOutput: Swift.Sendable {
    /// The ID of the analysis.
    public var analysisId: Swift.String?
    /// The ARN of the analysis that you're updating.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the last update that was made to the analysis.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init(
        analysisId: Swift.String? = nil,
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.analysisId = analysisId
        self.arn = arn
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

public struct UpdateAnalysisPermissionsInput: Swift.Sendable {
    /// The ID of the analysis whose permissions you're updating. The ID is part of the analysis URL.
    /// This member is required.
    public var analysisId: Swift.String?
    /// The ID of the Amazon Web Services account that contains the analysis whose permissions you're updating. You must be using the Amazon Web Services account that the analysis is in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A structure that describes the permissions to add and the principal to add them to.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A structure that describes the permissions to remove and the principal to remove them from.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init(
        analysisId: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.analysisId = analysisId
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateAnalysisPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the analysis that you updated.
    public var analysisArn: Swift.String?
    /// The ID of the analysis that you updated permissions for.
    public var analysisId: Swift.String?
    /// A structure that describes the principals and the resource-level permissions on an analysis.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        analysisArn: Swift.String? = nil,
        analysisId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.analysisArn = analysisArn
        self.analysisId = analysisId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDashboardInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Options for publishing the dashboard when you create it:
    ///
    /// * AvailabilityStatus for AdHocFilteringOption - This status can be either ENABLED or DISABLED. When this is set to DISABLED, Amazon QuickSight disables the left filter pane on the published dashboard, which can be used for ad hoc (one-time) filtering. This option is ENABLED by default.
    ///
    /// * AvailabilityStatus for ExportToCSVOption - This status can be either ENABLED or DISABLED. The visual option to export data to .CSV format isn't enabled when this is set to DISABLED. This option is ENABLED by default.
    ///
    /// * VisibilityState for SheetControlsOption - This visibility state can be either COLLAPSED or EXPANDED. This option is COLLAPSED by default.
    public var dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions?
    /// The definition of a dashboard. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.DashboardVersionDefinition?
    /// The display name of the dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the parameters of the dashboard. These are parameter overrides for a dashboard. A dashboard can have any type of parameters, and some parameters might accept multiple values.
    public var parameters: QuickSightClientTypes.Parameters?
    /// The entity that you are using as a source when you update the dashboard. In SourceEntity, you specify the type of object you're using as source. You can only update a dashboard from a template, so you use a SourceTemplate entity. If you need to update a dashboard from an analysis, first convert the analysis to a template by using the [CreateTemplate](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html) API operation. For SourceTemplate, specify the Amazon Resource Name (ARN) of the source template. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region. Use the DataSetReferences entity within SourceTemplate to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.DashboardSourceEntity?
    /// The Amazon Resource Name (ARN) of the theme that is being used for this dashboard. If you add a value for this field, it overrides the value that was originally associated with the entity. The theme ARN must exist in the same Amazon Web Services account where you create the dashboard.
    public var themeArn: Swift.String?
    /// The option to relax the validation needed to update a dashboard with definition objects. This skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?
    /// A description for the first version of the dashboard being created.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardPublishOptions: QuickSightClientTypes.DashboardPublishOptions? = nil,
        definition: QuickSightClientTypes.DashboardVersionDefinition? = nil,
        name: Swift.String? = nil,
        parameters: QuickSightClientTypes.Parameters? = nil,
        sourceEntity: QuickSightClientTypes.DashboardSourceEntity? = nil,
        themeArn: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.dashboardPublishOptions = dashboardPublishOptions
        self.definition = definition
        self.name = name
        self.parameters = parameters
        self.sourceEntity = sourceEntity
        self.themeArn = themeArn
        self.validationStrategy = validationStrategy
        self.versionDescription = versionDescription
    }
}

public struct UpdateDashboardOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    public var arn: Swift.String?
    /// The creation status of the request.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ARN of the dashboard, including the version number.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
        self.versionArn = versionArn
    }
}

public struct UpdateDashboardLinksInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard whose links you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
    /// This member is required.
    public var linkEntities: [Swift.String]?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkEntities: [Swift.String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.linkEntities = linkEntities
    }
}

public struct UpdateDashboardLinksOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// A list of analysis Amazon Resource Names (ARNs) to be linked to the dashboard.
    public var linkEntities: [Swift.String]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardArn: Swift.String? = nil,
        linkEntities: [Swift.String]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.linkEntities = linkEntities
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDashboardPermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard whose permissions you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// Grants link permissions to all users in a defined namespace.
    public var grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to grant on this resource.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// Revokes link permissions from all users in a defined namespace.
    public var revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from this resource.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        grantLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokeLinkPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.grantLinkPermissions = grantLinkPermissions
        self.grantPermissions = grantPermissions
        self.revokeLinkPermissions = revokeLinkPermissions
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateDashboardPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
    public var linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration?
    /// Information about the permissions on the dashboard.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        linkSharingConfiguration: QuickSightClientTypes.LinkSharingConfiguration? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.linkSharingConfiguration = linkSharingConfiguration
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDashboardPublishedVersionInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the dashboard that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The version number of the dashboard.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        awsAccountId: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dashboardId = dashboardId
        self.versionNumber = versionNumber
    }
}

public struct UpdateDashboardPublishedVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dashboard.
    public var dashboardArn: Swift.String?
    /// The ID for the dashboard.
    public var dashboardId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDataSetInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Groupings of columns that work together in certain Amazon QuickSight features. Currently, only geospatial hierarchy is supported.
    public var columnGroups: [QuickSightClientTypes.ColumnGroup]?
    /// A set of one or more definitions of a [ColumnLevelPermissionRule](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html).
    public var columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]?
    /// The ID for the dataset that you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The usage configuration to apply to child datasets that reference this dataset as a source.
    public var dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration?
    /// The parameter declarations of the dataset.
    public var datasetParameters: [QuickSightClientTypes.DatasetParameter]?
    /// The folder that contains fields and nested subfolders for your dataset.
    public var fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]?
    /// Indicates whether you want to import the data into SPICE.
    /// This member is required.
    public var importMode: QuickSightClientTypes.DataSetImportMode?
    /// Configures the combination and transformation of the data from the physical tables.
    public var logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]?
    /// The display name for the dataset.
    /// This member is required.
    public var name: Swift.String?
    /// Declares the physical tables that are available in the underlying data sources.
    /// This member is required.
    public var physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]?
    /// The row-level security configuration for the data you want to create.
    public var rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet?
    /// The configuration of tags on a dataset to set row-level security. Row-level security tags are currently supported for anonymous embedding only.
    public var rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration?

    public init(
        awsAccountId: Swift.String? = nil,
        columnGroups: [QuickSightClientTypes.ColumnGroup]? = nil,
        columnLevelPermissionRules: [QuickSightClientTypes.ColumnLevelPermissionRule]? = nil,
        dataSetId: Swift.String? = nil,
        dataSetUsageConfiguration: QuickSightClientTypes.DataSetUsageConfiguration? = nil,
        datasetParameters: [QuickSightClientTypes.DatasetParameter]? = nil,
        fieldFolders: [Swift.String: QuickSightClientTypes.FieldFolder]? = nil,
        importMode: QuickSightClientTypes.DataSetImportMode? = nil,
        logicalTableMap: [Swift.String: QuickSightClientTypes.LogicalTable]? = nil,
        name: Swift.String? = nil,
        physicalTableMap: [Swift.String: QuickSightClientTypes.PhysicalTable]? = nil,
        rowLevelPermissionDataSet: QuickSightClientTypes.RowLevelPermissionDataSet? = nil,
        rowLevelPermissionTagConfiguration: QuickSightClientTypes.RowLevelPermissionTagConfiguration? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.columnGroups = columnGroups
        self.columnLevelPermissionRules = columnLevelPermissionRules
        self.dataSetId = dataSetId
        self.dataSetUsageConfiguration = dataSetUsageConfiguration
        self.datasetParameters = datasetParameters
        self.fieldFolders = fieldFolders
        self.importMode = importMode
        self.logicalTableMap = logicalTableMap
        self.name = name
        self.physicalTableMap = physicalTableMap
        self.rowLevelPermissionDataSet = rowLevelPermissionDataSet
        self.rowLevelPermissionTagConfiguration = rowLevelPermissionTagConfiguration
    }
}

public struct UpdateDataSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var arn: Swift.String?
    /// The ID for the dataset that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The ARN for the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionArn: Swift.String?
    /// The ID of the ingestion, which is triggered as a result of dataset creation if the import mode is SPICE.
    public var ingestionId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        ingestionArn: Swift.String? = nil,
        ingestionId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.dataSetId = dataSetId
        self.ingestionArn = ingestionArn
        self.ingestionId = ingestionId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDataSetPermissionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The resource permissions that you want to grant to the dataset.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The resource permissions that you want to revoke from the dataset.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateDataSetPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var dataSetArn: Swift.String?
    /// The ID for the dataset whose permissions you want to update. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSetId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSetArn: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSetArn = dataSetArn
        self.dataSetId = dataSetId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateDataSourceInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The credentials that Amazon QuickSight that uses to connect to your underlying source. Currently, only credentials based on user name and password are supported.
    public var credentials: QuickSightClientTypes.DataSourceCredentials?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The parameters that Amazon QuickSight uses to connect to your underlying source.
    public var dataSourceParameters: QuickSightClientTypes.DataSourceParameters?
    /// A display name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight connects to your underlying source.
    public var sslProperties: QuickSightClientTypes.SslProperties?
    /// Use this parameter only when you want Amazon QuickSight to use a VPC connection when connecting to your underlying source.
    public var vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties?

    public init(
        awsAccountId: Swift.String? = nil,
        credentials: QuickSightClientTypes.DataSourceCredentials? = nil,
        dataSourceId: Swift.String? = nil,
        dataSourceParameters: QuickSightClientTypes.DataSourceParameters? = nil,
        name: Swift.String? = nil,
        sslProperties: QuickSightClientTypes.SslProperties? = nil,
        vpcConnectionProperties: QuickSightClientTypes.VpcConnectionProperties? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.credentials = credentials
        self.dataSourceId = dataSourceId
        self.dataSourceParameters = dataSourceParameters
        self.name = name
        self.sslProperties = sslProperties
        self.vpcConnectionProperties = vpcConnectionProperties
    }
}

extension UpdateDataSourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataSourceInput(awsAccountId: \(Swift.String(describing: awsAccountId)), dataSourceId: \(Swift.String(describing: dataSourceId)), dataSourceParameters: \(Swift.String(describing: dataSourceParameters)), name: \(Swift.String(describing: name)), sslProperties: \(Swift.String(describing: sslProperties)), vpcConnectionProperties: \(Swift.String(describing: vpcConnectionProperties)), credentials: \"CONTENT_REDACTED\")"}
}

public struct UpdateDataSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var arn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the data source's last update.
    public var updateStatus: QuickSightClientTypes.ResourceStatus?

    public init(
        arn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.ResourceStatus? = nil
    )
    {
        self.arn = arn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
    }
}

public struct UpdateDataSourcePermissionsInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A list of resource permissions that you want to grant on the data source.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions that you want to revoke on the data source.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSourceId = dataSourceId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateDataSourcePermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the data source.
    public var dataSourceArn: Swift.String?
    /// The ID of the data source. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var dataSourceId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        dataSourceArn: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.dataSourceArn = dataSourceArn
        self.dataSourceId = dataSourceId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateFolderInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    /// This member is required.
    public var name: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.name = name
    }
}

public struct UpdateFolderOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateFolderPermissionsInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that contains the folder to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The permissions that you want to grant on a resource. Namespace ARNs are not supported Principal values for folder permissions.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The permissions that you want to revoke from a resource. Namespace ARNs are not supported Principal values for folder permissions.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?

    public init(
        awsAccountId: Swift.String? = nil,
        folderId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.folderId = folderId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
    }
}

public struct UpdateFolderPermissionsOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the folder.
    public var arn: Swift.String?
    /// The ID of the folder.
    public var folderId: Swift.String?
    /// Information about the permissions for the folder.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        folderId: Swift.String? = nil,
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.folderId = folderId
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateGroupInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the group is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The description for the group that you want to update.
    public var description: Swift.String?
    /// The name of the group that you want to update.
    /// This member is required.
    public var groupName: Swift.String?
    /// The namespace of the group that you want to update.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        description: Swift.String? = nil,
        groupName: Swift.String? = nil,
        namespace: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.description = description
        self.groupName = groupName
        self.namespace = namespace
    }
}

public struct UpdateGroupOutput: Swift.Sendable {
    /// The name of the group.
    public var group: QuickSightClientTypes.Group?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        group: QuickSightClientTypes.Group? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.group = group
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateIAMPolicyAssignmentInput: Swift.Sendable {
    /// The name of the assignment, also called a rule. The name must be unique within the Amazon Web Services account.
    /// This member is required.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The ID of the Amazon Web Services account that contains the IAM policy assignment.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The Amazon QuickSight users, groups, or both that you want to assign the policy to.
    public var identities: [Swift.String: [Swift.String]]?
    /// The namespace of the assignment.
    /// This member is required.
    public var namespace: Swift.String?
    /// The ARN for the IAM policy to apply to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?

    public init(
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        awsAccountId: Swift.String? = nil,
        identities: [Swift.String: [Swift.String]]? = nil,
        namespace: Swift.String? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.awsAccountId = awsAccountId
        self.identities = identities
        self.namespace = namespace
        self.policyArn = policyArn
    }
}

public struct UpdateIAMPolicyAssignmentOutput: Swift.Sendable {
    /// The ID of the assignment.
    public var assignmentId: Swift.String?
    /// The name of the assignment or rule.
    public var assignmentName: Swift.String?
    /// The status of the assignment. Possible values are as follows:
    ///
    /// * ENABLED - Anything specified in this assignment is used when creating the data source.
    ///
    /// * DISABLED - This assignment isn't used when creating the data source.
    ///
    /// * DRAFT - This assignment is an unfinished draft and isn't used when creating the data source.
    public var assignmentStatus: QuickSightClientTypes.AssignmentStatus?
    /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned to.
    public var identities: [Swift.String: [Swift.String]]?
    /// The ARN for the IAM policy applied to the Amazon QuickSight users and groups specified in this assignment.
    public var policyArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        assignmentId: Swift.String? = nil,
        assignmentName: Swift.String? = nil,
        assignmentStatus: QuickSightClientTypes.AssignmentStatus? = nil,
        identities: [Swift.String: [Swift.String]]? = nil,
        policyArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.assignmentId = assignmentId
        self.assignmentName = assignmentName
        self.assignmentStatus = assignmentStatus
        self.identities = identities
        self.policyArn = policyArn
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateIdentityPropagationConfigInput: Swift.Sendable {
    /// Specifies a list of application ARNs that represent the authorized targets for a service.
    public var authorizedTargets: [Swift.String]?
    /// The ID of the Amazon Web Services account that contains the identity propagation configuration that you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the Amazon Web Services service that contains the authorized targets that you want to add or update.
    /// This member is required.
    public var service: QuickSightClientTypes.ServiceType?

    public init(
        authorizedTargets: [Swift.String]? = nil,
        awsAccountId: Swift.String? = nil,
        service: QuickSightClientTypes.ServiceType? = nil
    )
    {
        self.authorizedTargets = authorizedTargets
        self.awsAccountId = awsAccountId
        self.service = service
    }
}

public struct UpdateIdentityPropagationConfigOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateIpRestrictionInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A value that specifies whether IP rules are turned on.
    public var enabled: Swift.Bool?
    /// A map that describes the updated IP rules with CIDR ranges and descriptions.
    public var ipRestrictionRuleMap: [Swift.String: Swift.String]?
    /// A map of allowed VPC endpoint IDs and their corresponding rule descriptions.
    public var vpcEndpointIdRestrictionRuleMap: [Swift.String: Swift.String]?
    /// A map of VPC IDs and their corresponding rules. When you configure this parameter, traffic from all VPC endpoints that are present in the specified VPC is allowed.
    public var vpcIdRestrictionRuleMap: [Swift.String: Swift.String]?

    public init(
        awsAccountId: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        ipRestrictionRuleMap: [Swift.String: Swift.String]? = nil,
        vpcEndpointIdRestrictionRuleMap: [Swift.String: Swift.String]? = nil,
        vpcIdRestrictionRuleMap: [Swift.String: Swift.String]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.enabled = enabled
        self.ipRestrictionRuleMap = ipRestrictionRuleMap
        self.vpcEndpointIdRestrictionRuleMap = vpcEndpointIdRestrictionRuleMap
        self.vpcIdRestrictionRuleMap = vpcIdRestrictionRuleMap
    }
}

public struct UpdateIpRestrictionOutput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the IP rules.
    public var awsAccountId: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        awsAccountId: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.awsAccountId = awsAccountId
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateKeyRegistrationInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the customer managed key registration that you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of RegisteredCustomerManagedKey objects to be updated to the Amazon QuickSight account.
    /// This member is required.
    public var keyRegistration: [QuickSightClientTypes.RegisteredCustomerManagedKey]?

    public init(
        awsAccountId: Swift.String? = nil,
        keyRegistration: [QuickSightClientTypes.RegisteredCustomerManagedKey]? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.keyRegistration = keyRegistration
    }
}

extension QuickSightClientTypes {

    /// A success entry that occurs when a KeyRegistration job is successfully applied to the Amazon QuickSight account.
    public struct SuccessfulKeyRegistrationEntry: Swift.Sendable {
        /// The ARN of the KMS key that is associated with the SuccessfulKeyRegistrationEntry entry.
        /// This member is required.
        public var keyArn: Swift.String?
        /// The HTTP status of a SuccessfulKeyRegistrationEntry entry.
        /// This member is required.
        public var statusCode: Swift.Int

        public init(
            keyArn: Swift.String? = nil,
            statusCode: Swift.Int = 0
        )
        {
            self.keyArn = keyArn
            self.statusCode = statusCode
        }
    }
}

public struct UpdateKeyRegistrationOutput: Swift.Sendable {
    /// A list of all customer managed key registrations that failed to update.
    public var failedKeyRegistration: [QuickSightClientTypes.FailedKeyRegistrationEntry]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// A list of all customer managed key registrations that were successfully updated.
    public var successfulKeyRegistration: [QuickSightClientTypes.SuccessfulKeyRegistrationEntry]?

    public init(
        failedKeyRegistration: [QuickSightClientTypes.FailedKeyRegistrationEntry]? = nil,
        requestId: Swift.String? = nil,
        successfulKeyRegistration: [QuickSightClientTypes.SuccessfulKeyRegistrationEntry]? = nil
    )
    {
        self.failedKeyRegistration = failedKeyRegistration
        self.requestId = requestId
        self.successfulKeyRegistration = successfulKeyRegistration
    }
}

public struct UpdatePublicSharingSettingsInput: Swift.Sendable {
    /// The Amazon Web Services account ID associated with your Amazon QuickSight subscription.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A Boolean value that indicates whether public sharing is turned on for an Amazon QuickSight account.
    public var publicSharingEnabled: Swift.Bool?

    public init(
        awsAccountId: Swift.String? = nil,
        publicSharingEnabled: Swift.Bool? = false
    )
    {
        self.awsAccountId = awsAccountId
        self.publicSharingEnabled = publicSharingEnabled
    }
}

public struct UpdatePublicSharingSettingsOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateQPersonalizationConfigurationInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account account that contains the personalization configuration that the user wants to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// An option to allow Amazon QuickSight to customize data stories with user specific metadata, specifically location and job information, in your IAM Identity Center instance.
    /// This member is required.
    public var personalizationMode: QuickSightClientTypes.PersonalizationMode?

    public init(
        awsAccountId: Swift.String? = nil,
        personalizationMode: QuickSightClientTypes.PersonalizationMode? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.personalizationMode = personalizationMode
    }
}

public struct UpdateQPersonalizationConfigurationOutput: Swift.Sendable {
    /// The personalization mode that is used for the personalization configuration.
    public var personalizationMode: QuickSightClientTypes.PersonalizationMode?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        personalizationMode: QuickSightClientTypes.PersonalizationMode? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.personalizationMode = personalizationMode
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateRefreshScheduleInput: Swift.Sendable {
    /// The Amazon Web Services account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var dataSetId: Swift.String?
    /// The refresh schedule.
    /// This member is required.
    public var schedule: QuickSightClientTypes.RefreshSchedule?

    public init(
        awsAccountId: Swift.String? = nil,
        dataSetId: Swift.String? = nil,
        schedule: QuickSightClientTypes.RefreshSchedule? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dataSetId = dataSetId
        self.schedule = schedule
    }
}

public struct UpdateRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the refresh schedule.
    public var arn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The ID of the refresh schedule.
    public var scheduleId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        arn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        scheduleId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.arn = arn
        self.requestId = requestId
        self.scheduleId = scheduleId
        self.status = status
    }
}

public struct UpdateRoleCustomPermissionInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that you want to create a group in. The Amazon Web Services account ID that you provide must be the same Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The name of the custom permission that you want to update the role with.
    /// This member is required.
    public var customPermissionsName: Swift.String?
    /// The namespace that contains the role that you want to update.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of role tht you want to update.
    /// This member is required.
    public var role: QuickSightClientTypes.Role?

    public init(
        awsAccountId: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.Role? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customPermissionsName = customPermissionsName
        self.namespace = namespace
        self.role = role
    }
}

public struct UpdateRoleCustomPermissionOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateSPICECapacityConfigurationInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the SPICE configuration that you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// Determines how SPICE capacity can be purchased. The following options are available.
    ///
    /// * MANUAL: SPICE capacity can only be purchased manually.
    ///
    /// * AUTO_PURCHASE: Extra SPICE capacity is automatically purchased on your behalf as needed. SPICE capacity can also be purchased manually with this option.
    /// This member is required.
    public var purchaseMode: QuickSightClientTypes.PurchaseMode?

    public init(
        awsAccountId: Swift.String? = nil,
        purchaseMode: QuickSightClientTypes.PurchaseMode? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.purchaseMode = purchaseMode
    }
}

public struct UpdateSPICECapacityConfigurationOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0
    )
    {
        self.requestId = requestId
        self.status = status
    }
}

public struct UpdateTemplateInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the template that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of a template. A definition is the data model of all features in a Dashboard, Template, or Analysis.
    public var definition: QuickSightClientTypes.TemplateVersionDefinition?
    /// The name for the template.
    public var name: Swift.String?
    /// The entity that you are using as a source when you update the template. In SourceEntity, you specify the type of object you're using as source: SourceTemplate for a template or SourceAnalysis for an analysis. Both of these require an Amazon Resource Name (ARN). For SourceTemplate, specify the ARN of the source template. For SourceAnalysis, specify the ARN of the source analysis. The SourceTemplate ARN can contain any Amazon Web Services account and any Amazon QuickSight-supported Amazon Web Services Region;. Use the DataSetReferences entity within SourceTemplate or SourceAnalysis to list the replacement datasets for the placeholders listed in the original. The schema in each dataset must match its placeholder.
    public var sourceEntity: QuickSightClientTypes.TemplateSourceEntity?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The option to relax the validation needed to update a template with definition objects. This skips the validation step for specific errors.
    public var validationStrategy: QuickSightClientTypes.ValidationStrategy?
    /// A description of the current template version that is being updated. Every time you call UpdateTemplate, you create a new version of the template. Each version of the template maintains a description of the version in the VersionDescription field.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        definition: QuickSightClientTypes.TemplateVersionDefinition? = nil,
        name: Swift.String? = nil,
        sourceEntity: QuickSightClientTypes.TemplateSourceEntity? = nil,
        templateId: Swift.String? = nil,
        validationStrategy: QuickSightClientTypes.ValidationStrategy? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.definition = definition
        self.name = name
        self.sourceEntity = sourceEntity
        self.templateId = templateId
        self.validationStrategy = validationStrategy
        self.versionDescription = versionDescription
    }
}

public struct UpdateTemplateOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the template.
    public var arn: Swift.String?
    /// The creation status of the template.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the template.
    public var templateId: Swift.String?
    /// The ARN for the template, including the version information of the first version.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.templateId = templateId
        self.versionArn = versionArn
    }
}

public struct UpdateTemplateAliasInput: Swift.Sendable {
    /// The alias of the template that you want to update. If you name a specific alias, you update the version that the alias points to. You can specify the latest version of the template by providing the keyword $LATEST in the AliasName parameter. The keyword $PUBLISHED doesn't apply to templates.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the template alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?
    /// The version number of the template.
    /// This member is required.
    public var templateVersionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        templateId: Swift.String? = nil,
        templateVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.templateId = templateId
        self.templateVersionNumber = templateVersionNumber
    }
}

public struct UpdateTemplateAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The template alias.
    public var templateAlias: QuickSightClientTypes.TemplateAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateAlias: QuickSightClientTypes.TemplateAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.templateAlias = templateAlias
    }
}

public struct UpdateTemplatePermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the template.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted on the template.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the template.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the template.
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.templateId = templateId
    }
}

public struct UpdateTemplatePermissionsOutput: Swift.Sendable {
    /// A list of resource permissions to be set on the template.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the template.
    public var templateArn: Swift.String?
    /// The ID for the template.
    public var templateId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        templateArn: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.templateArn = templateArn
        self.templateId = templateId
    }
}

public struct UpdateThemeInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the theme that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits from. All themes initially inherit from a default Amazon QuickSight theme.
    /// This member is required.
    public var baseThemeId: Swift.String?
    /// The theme configuration, which contains the theme display properties.
    public var configuration: QuickSightClientTypes.ThemeConfiguration?
    /// The name for the theme.
    public var name: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// A description of the theme version that you're updating Every time that you call UpdateTheme, you create a new version of the theme. Each version of the theme maintains a description of the version in VersionDescription.
    public var versionDescription: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        baseThemeId: Swift.String? = nil,
        configuration: QuickSightClientTypes.ThemeConfiguration? = nil,
        name: Swift.String? = nil,
        themeId: Swift.String? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.baseThemeId = baseThemeId
        self.configuration = configuration
        self.name = name
        self.themeId = themeId
        self.versionDescription = versionDescription
    }
}

public struct UpdateThemeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the theme.
    public var arn: Swift.String?
    /// The creation status of the theme.
    public var creationStatus: QuickSightClientTypes.ResourceStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID for the theme.
    public var themeId: Swift.String?
    /// The Amazon Resource Name (ARN) for the new version of the theme.
    public var versionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationStatus: QuickSightClientTypes.ResourceStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeId: Swift.String? = nil,
        versionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationStatus = creationStatus
        self.requestId = requestId
        self.status = status
        self.themeId = themeId
        self.versionArn = versionArn
    }
}

public struct UpdateThemeAliasInput: Swift.Sendable {
    /// The name of the theme alias that you want to update.
    /// This member is required.
    public var aliasName: Swift.String?
    /// The ID of the Amazon Web Services account that contains the theme alias that you're updating.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?
    /// The version number of the theme that the alias should reference.
    /// This member is required.
    public var themeVersionNumber: Swift.Int?

    public init(
        aliasName: Swift.String? = nil,
        awsAccountId: Swift.String? = nil,
        themeId: Swift.String? = nil,
        themeVersionNumber: Swift.Int? = nil
    )
    {
        self.aliasName = aliasName
        self.awsAccountId = awsAccountId
        self.themeId = themeId
        self.themeVersionNumber = themeVersionNumber
    }
}

public struct UpdateThemeAliasOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// Information about the theme alias.
    public var themeAlias: QuickSightClientTypes.ThemeAlias?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeAlias: QuickSightClientTypes.ThemeAlias? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.themeAlias = themeAlias
    }
}

public struct UpdateThemePermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the theme.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of resource permissions to be granted for the theme.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// A list of resource permissions to be revoked from the theme.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID for the theme.
    /// This member is required.
    public var themeId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.themeId = themeId
    }
}

public struct UpdateThemePermissionsOutput: Swift.Sendable {
    /// The resulting list of resource permissions for the theme.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the theme.
    public var themeArn: Swift.String?
    /// The ID for the theme.
    public var themeId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        themeArn: Swift.String? = nil,
        themeId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.themeArn = themeArn
        self.themeId = themeId
    }
}

public struct UpdateTopicInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic that you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The definition of the topic that you want to update.
    /// This member is required.
    public var topic: QuickSightClientTypes.TopicDetails?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        topic: QuickSightClientTypes.TopicDetails? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.topic = topic
        self.topicId = topicId
    }
}

public struct UpdateTopicOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the topic.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the topic refresh.
    public var refreshArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        refreshArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.refreshArn = refreshArn
        self.requestId = requestId
        self.status = status
        self.topicId = topicId
    }
}

public struct UpdateTopicPermissionsInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic that you want to update the permissions for.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The resource permissions that you want to grant to the topic.
    public var grantPermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The resource permissions that you want to revoke from the topic.
    public var revokePermissions: [QuickSightClientTypes.ResourcePermission]?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        grantPermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        revokePermissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.grantPermissions = grantPermissions
        self.revokePermissions = revokePermissions
        self.topicId = topicId
    }
}

public struct UpdateTopicPermissionsOutput: Swift.Sendable {
    /// A list of resource permissions on the topic.
    public var permissions: [QuickSightClientTypes.ResourcePermission]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        permissions: [QuickSightClientTypes.ResourcePermission]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.permissions = permissions
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct UpdateTopicRefreshScheduleInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that contains the topic whose refresh schedule you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID of the dataset.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The definition of a refresh schedule.
    /// This member is required.
    public var refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        refreshSchedule: QuickSightClientTypes.TopicRefreshSchedule? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.datasetId = datasetId
        self.refreshSchedule = refreshSchedule
        self.topicId = topicId
    }
}

public struct UpdateTopicRefreshScheduleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the dataset.
    public var datasetArn: Swift.String?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID of the topic that you want to modify. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        datasetArn: Swift.String? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.datasetArn = datasetArn
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

public struct UpdateUserInput: Swift.Sendable {
    /// The ID for the Amazon Web Services account that the user is in. Currently, you use the ID for the Amazon Web Services account that contains your Amazon QuickSight account.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The URL of the custom OpenID Connect (OIDC) provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. This parameter should only be used when ExternalLoginFederationProviderType parameter is set to CUSTOM_OIDC.
    public var customFederationProviderUrl: Swift.String?
    /// (Enterprise edition only) The name of the custom permissions profile that you want to assign to this user. Customized permissions allows you to control a user's access by restricting access the following operations:
    ///
    /// * Create and update data sources
    ///
    /// * Create and update datasets
    ///
    /// * Create and update email reports
    ///
    /// * Subscribe to email reports
    ///
    ///
    /// A set of custom permissions includes any combination of these restrictions. Currently, you need to create the profile names for custom permission sets by using the Amazon QuickSight console. Then, you use the RegisterUser API operation to assign the named set of permissions to a Amazon QuickSight user. Amazon QuickSight custom permissions are applied through IAM policies. Therefore, they override the permissions typically granted by assigning Amazon QuickSight users to one of the default security cohorts in Amazon QuickSight (admin, author, reader). This feature is available only to Amazon QuickSight Enterprise edition subscriptions.
    public var customPermissionsName: Swift.String?
    /// The email address of the user that you want to update.
    /// This member is required.
    public var email: Swift.String?
    /// The type of supported external login provider that provides identity to let a user federate into Amazon QuickSight with an associated Identity and Access Management(IAM) role. The type of supported external login provider can be one of the following.
    ///
    /// * COGNITO: Amazon Cognito. The provider URL is cognito-identity.amazonaws.com. When choosing the COGNITO provider type, donâ€™t use the "CustomFederationProviderUrl" parameter which is only needed when the external provider is custom.
    ///
    /// * CUSTOM_OIDC: Custom OpenID Connect (OIDC) provider. When choosing CUSTOM_OIDC type, use the CustomFederationProviderUrl parameter to provide the custom OIDC provider URL.
    ///
    /// * NONE: This clears all the previously saved external login information for a user. Use the [DescribeUser](https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeUser.html) API operation to check the external login information.
    public var externalLoginFederationProviderType: Swift.String?
    /// The identity ID for a user in the external login provider.
    public var externalLoginId: Swift.String?
    /// The namespace. Currently, you should set this to default.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon QuickSight role of the user. The role can be one of the following default security cohorts:
    ///
    /// * READER: A user who has read-only access to dashboards.
    ///
    /// * AUTHOR: A user who can create data sources, datasets, analyses, and dashboards.
    ///
    /// * ADMIN: A user who is an author, who can also manage Amazon QuickSight settings.
    ///
    /// * READER_PRO: Reader Pro adds Generative BI capabilities to the Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can build stories with Amazon Q, and can generate executive summaries from dashboards.
    ///
    /// * AUTHOR_PRO: Author Pro adds Generative BI capabilities to the Author role. Author Pros can author dashboards with natural language with Amazon Q, build stories with Amazon Q, create Topics for Q&A, and generate executive summaries from dashboards.
    ///
    /// * ADMIN_PRO: Admin Pros are Author Pros who can also manage Amazon QuickSight administrative settings. Admin Pro users are billed at Author Pro pricing.
    ///
    ///
    /// The name of the Amazon QuickSight role is invisible to the user except for the console screens dealing with permissions.
    /// This member is required.
    public var role: QuickSightClientTypes.UserRole?
    /// A flag that you use to indicate that you want to remove all custom permissions from this user. Using this parameter resets the user to the state it was in before a custom permissions profile was applied. This parameter defaults to NULL and it doesn't accept any other value.
    public var unapplyCustomPermissions: Swift.Bool?
    /// The Amazon QuickSight user name that you want to update.
    /// This member is required.
    public var userName: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        customFederationProviderUrl: Swift.String? = nil,
        customPermissionsName: Swift.String? = nil,
        email: Swift.String? = nil,
        externalLoginFederationProviderType: Swift.String? = nil,
        externalLoginId: Swift.String? = nil,
        namespace: Swift.String? = nil,
        role: QuickSightClientTypes.UserRole? = nil,
        unapplyCustomPermissions: Swift.Bool? = false,
        userName: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.customFederationProviderUrl = customFederationProviderUrl
        self.customPermissionsName = customPermissionsName
        self.email = email
        self.externalLoginFederationProviderType = externalLoginFederationProviderType
        self.externalLoginId = externalLoginId
        self.namespace = namespace
        self.role = role
        self.unapplyCustomPermissions = unapplyCustomPermissions
        self.userName = userName
    }
}

public struct UpdateUserOutput: Swift.Sendable {
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon QuickSight user.
    public var user: QuickSightClientTypes.User?

    public init(
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        user: QuickSightClientTypes.User? = nil
    )
    {
        self.requestId = requestId
        self.status = status
        self.user = user
    }
}

public struct UpdateVPCConnectionInput: Swift.Sendable {
    /// The Amazon Web Services account ID of the account that contains the VPC connection that you want to update.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
    public var dnsResolvers: [Swift.String]?
    /// The display name for the VPC connection.
    /// This member is required.
    public var name: Swift.String?
    /// An IAM role associated with the VPC connection.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of security group IDs for the VPC connection.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// A list of subnet IDs for the VPC connection.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC connection that you're updating. This ID is a unique identifier for each Amazon Web Services Region in an Amazon Web Services account.
    /// This member is required.
    public var vpcConnectionId: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        dnsResolvers: [Swift.String]? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.dnsResolvers = dnsResolvers
        self.name = name
        self.roleArn = roleArn
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcConnectionId = vpcConnectionId
    }
}

public struct UpdateVPCConnectionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the VPC connection.
    public var arn: Swift.String?
    /// The availability status of the VPC connection.
    public var availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The update status of the VPC connection's last update.
    public var updateStatus: QuickSightClientTypes.VPCConnectionResourceStatus?
    /// The ID of the VPC connection that you are updating. This ID is a unique identifier for each Amazon Web Services Region in anAmazon Web Services account.
    public var vpcConnectionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        availabilityStatus: QuickSightClientTypes.VPCConnectionAvailabilityStatus? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        updateStatus: QuickSightClientTypes.VPCConnectionResourceStatus? = nil,
        vpcConnectionId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.availabilityStatus = availabilityStatus
        self.requestId = requestId
        self.status = status
        self.updateStatus = updateStatus
        self.vpcConnectionId = vpcConnectionId
    }
}

extension QuickSightClientTypes {

    /// The definition for a TopicVisual.
    public struct TopicVisual: Swift.Sendable {
        /// The ir for the TopicVisual.
        public var ir: QuickSightClientTypes.TopicIR?
        /// The role for the TopicVisual.
        public var role: QuickSightClientTypes.VisualRole?
        /// The supporting visuals for the TopicVisual.
        public var supportingVisuals: [QuickSightClientTypes.TopicVisual]?
        /// The visual ID for the TopicVisual.
        public var visualId: Swift.String?

        public init(
            ir: QuickSightClientTypes.TopicIR? = nil,
            role: QuickSightClientTypes.VisualRole? = nil,
            supportingVisuals: [QuickSightClientTypes.TopicVisual]? = nil,
            visualId: Swift.String? = nil
        )
        {
            self.ir = ir
            self.role = role
            self.supportingVisuals = supportingVisuals
            self.visualId = visualId
        }
    }
}

extension QuickSightClientTypes {

    /// The definition for a CreateTopicReviewedAnswer.
    public struct CreateTopicReviewedAnswer: Swift.Sendable {
        /// The answer ID for the CreateTopicReviewedAnswer.
        /// This member is required.
        public var answerId: Swift.String?
        /// The Dataset arn for the CreateTopicReviewedAnswer.
        /// This member is required.
        public var datasetArn: Swift.String?
        /// The Mir for the CreateTopicReviewedAnswer.
        public var mir: QuickSightClientTypes.TopicIR?
        /// The PrimaryVisual for the CreateTopicReviewedAnswer.
        public var primaryVisual: QuickSightClientTypes.TopicVisual?
        /// The Question to be created.
        /// This member is required.
        public var question: Swift.String?
        /// The template for the CreateTopicReviewedAnswer.
        public var template: QuickSightClientTypes.TopicTemplate?

        public init(
            answerId: Swift.String? = nil,
            datasetArn: Swift.String? = nil,
            mir: QuickSightClientTypes.TopicIR? = nil,
            primaryVisual: QuickSightClientTypes.TopicVisual? = nil,
            question: Swift.String? = nil,
            template: QuickSightClientTypes.TopicTemplate? = nil
        )
        {
            self.answerId = answerId
            self.datasetArn = datasetArn
            self.mir = mir
            self.primaryVisual = primaryVisual
            self.question = question
            self.template = template
        }
    }
}

extension QuickSightClientTypes {

    /// The deinition for a TopicReviewedAnswer.
    public struct TopicReviewedAnswer: Swift.Sendable {
        /// The answer ID of the reviewed answer.
        /// This member is required.
        public var answerId: Swift.String?
        /// The Amazon Resource Name (ARN) of the reviewed answer.
        public var arn: Swift.String?
        /// The Dataset ARN for the TopicReviewedAnswer.
        /// This member is required.
        public var datasetArn: Swift.String?
        /// The mir for the TopicReviewedAnswer.
        public var mir: QuickSightClientTypes.TopicIR?
        /// The primary visual for the TopicReviewedAnswer.
        public var primaryVisual: QuickSightClientTypes.TopicVisual?
        /// The question for the TopicReviewedAnswer.
        /// This member is required.
        public var question: Swift.String?
        /// The template for the TopicReviewedAnswer.
        public var template: QuickSightClientTypes.TopicTemplate?

        public init(
            answerId: Swift.String? = nil,
            arn: Swift.String? = nil,
            datasetArn: Swift.String? = nil,
            mir: QuickSightClientTypes.TopicIR? = nil,
            primaryVisual: QuickSightClientTypes.TopicVisual? = nil,
            question: Swift.String? = nil,
            template: QuickSightClientTypes.TopicTemplate? = nil
        )
        {
            self.answerId = answerId
            self.arn = arn
            self.datasetArn = datasetArn
            self.mir = mir
            self.primaryVisual = primaryVisual
            self.question = question
            self.template = template
        }
    }
}

public struct BatchCreateTopicReviewedAnswerInput: Swift.Sendable {
    /// The definition of the Answers to be created.
    /// This member is required.
    public var answers: [QuickSightClientTypes.CreateTopicReviewedAnswer]?
    /// The ID of the Amazon Web Services account that you want to create a reviewed answer in.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The ID for the topic reviewed answer that you want to create. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    /// This member is required.
    public var topicId: Swift.String?

    public init(
        answers: [QuickSightClientTypes.CreateTopicReviewedAnswer]? = nil,
        awsAccountId: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.answers = answers
        self.awsAccountId = awsAccountId
        self.topicId = topicId
    }
}

public struct ListTopicReviewedAnswersOutput: Swift.Sendable {
    /// The definition of all Answers in the topic.
    public var answers: [QuickSightClientTypes.TopicReviewedAnswer]?
    /// The Amazon Web Services request ID for this operation.
    public var requestId: Swift.String?
    /// The HTTP status of the request.
    public var status: Swift.Int
    /// The Amazon Resource Name (ARN) of the topic.
    public var topicArn: Swift.String?
    /// The ID for the topic that contains the reviewed answer that you want to list. This ID is unique per Amazon Web Services Region for each Amazon Web Services account.
    public var topicId: Swift.String?

    public init(
        answers: [QuickSightClientTypes.TopicReviewedAnswer]? = nil,
        requestId: Swift.String? = nil,
        status: Swift.Int = 0,
        topicArn: Swift.String? = nil,
        topicId: Swift.String? = nil
    )
    {
        self.answers = answers
        self.requestId = requestId
        self.status = status
        self.topicArn = topicArn
        self.topicId = topicId
    }
}

extension BatchCreateTopicReviewedAnswerInput {

    static func urlPathProvider(_ value: BatchCreateTopicReviewedAnswerInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/batch-create-reviewed-answers"
    }
}

extension BatchDeleteTopicReviewedAnswerInput {

    static func urlPathProvider(_ value: BatchDeleteTopicReviewedAnswerInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/batch-delete-reviewed-answers"
    }
}

extension CancelIngestionInput {

    static func urlPathProvider(_ value: CancelIngestionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let ingestionId = value.ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

extension CreateAccountCustomizationInput {

    static func urlPathProvider(_ value: CreateAccountCustomizationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

extension CreateAccountCustomizationInput {

    static func queryItemProvider(_ value: CreateAccountCustomizationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension CreateAccountSubscriptionInput {

    static func urlPathProvider(_ value: CreateAccountSubscriptionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

extension CreateAnalysisInput {

    static func urlPathProvider(_ value: CreateAnalysisInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

extension CreateDashboardInput {

    static func urlPathProvider(_ value: CreateDashboardInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension CreateDataSetInput {

    static func urlPathProvider(_ value: CreateDataSetInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

extension CreateFolderInput {

    static func urlPathProvider(_ value: CreateFolderInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

extension CreateFolderMembershipInput {

    static func urlPathProvider(_ value: CreateFolderMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        guard let memberType = value.memberType else {
            return nil
        }
        guard let memberId = value.memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

extension CreateGroupMembershipInput {

    static func urlPathProvider(_ value: CreateGroupMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        guard let memberName = value.memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

extension CreateIAMPolicyAssignmentInput {

    static func urlPathProvider(_ value: CreateIAMPolicyAssignmentInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments"
    }
}

extension CreateIngestionInput {

    static func urlPathProvider(_ value: CreateIngestionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let ingestionId = value.ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

extension CreateNamespaceInput {

    static func urlPathProvider(_ value: CreateNamespaceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())"
    }
}

extension CreateRefreshScheduleInput {

    static func urlPathProvider(_ value: CreateRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-schedules"
    }
}

extension CreateRoleMembershipInput {

    static func urlPathProvider(_ value: CreateRoleMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        guard let memberName = value.memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

extension CreateTemplateInput {

    static func urlPathProvider(_ value: CreateTemplateInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension CreateTemplateAliasInput {

    static func urlPathProvider(_ value: CreateTemplateAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension CreateThemeInput {

    static func urlPathProvider(_ value: CreateThemeInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

extension CreateThemeAliasInput {

    static func urlPathProvider(_ value: CreateThemeAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension CreateTopicInput {

    static func urlPathProvider(_ value: CreateTopicInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics"
    }
}

extension CreateTopicRefreshScheduleInput {

    static func urlPathProvider(_ value: CreateTopicRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/schedules"
    }
}

extension CreateVPCConnectionInput {

    static func urlPathProvider(_ value: CreateVPCConnectionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/vpc-connections"
    }
}

extension DeleteAccountCustomizationInput {

    static func urlPathProvider(_ value: DeleteAccountCustomizationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

extension DeleteAccountCustomizationInput {

    static func queryItemProvider(_ value: DeleteAccountCustomizationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DeleteAccountSubscriptionInput {

    static func urlPathProvider(_ value: DeleteAccountSubscriptionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

extension DeleteAnalysisInput {

    static func urlPathProvider(_ value: DeleteAnalysisInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

extension DeleteAnalysisInput {

    static func queryItemProvider(_ value: DeleteAnalysisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let recoveryWindowInDays = value.recoveryWindowInDays {
            let recoveryWindowInDaysQueryItem = Smithy.URIQueryItem(name: "recovery-window-in-days".urlPercentEncoding(), value: Swift.String(recoveryWindowInDays).urlPercentEncoding())
            items.append(recoveryWindowInDaysQueryItem)
        }
        if let forceDeleteWithoutRecovery = value.forceDeleteWithoutRecovery {
            let forceDeleteWithoutRecoveryQueryItem = Smithy.URIQueryItem(name: "force-delete-without-recovery".urlPercentEncoding(), value: Swift.String(forceDeleteWithoutRecovery).urlPercentEncoding())
            items.append(forceDeleteWithoutRecoveryQueryItem)
        }
        return items
    }
}

extension DeleteDashboardInput {

    static func urlPathProvider(_ value: DeleteDashboardInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension DeleteDashboardInput {

    static func queryItemProvider(_ value: DeleteDashboardInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteDataSetInput {

    static func urlPathProvider(_ value: DeleteDataSetInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

extension DeleteDataSetRefreshPropertiesInput {

    static func urlPathProvider(_ value: DeleteDataSetRefreshPropertiesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-properties"
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension DeleteFolderInput {

    static func urlPathProvider(_ value: DeleteFolderInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

extension DeleteFolderMembershipInput {

    static func urlPathProvider(_ value: DeleteFolderMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        guard let memberType = value.memberType else {
            return nil
        }
        guard let memberId = value.memberId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members/\(memberType.rawValue.urlPercentEncoding())/\(memberId.urlPercentEncoding())"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

extension DeleteGroupMembershipInput {

    static func urlPathProvider(_ value: DeleteGroupMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        guard let memberName = value.memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

extension DeleteIAMPolicyAssignmentInput {

    static func urlPathProvider(_ value: DeleteIAMPolicyAssignmentInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let assignmentName = value.assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespace/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

extension DeleteIdentityPropagationConfigInput {

    static func urlPathProvider(_ value: DeleteIdentityPropagationConfigInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let service = value.service else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/identity-propagation-config/\(service.rawValue.urlPercentEncoding())"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

extension DeleteRefreshScheduleInput {

    static func urlPathProvider(_ value: DeleteRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let scheduleId = value.scheduleId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-schedules/\(scheduleId.urlPercentEncoding())"
    }
}

extension DeleteRoleCustomPermissionInput {

    static func urlPathProvider(_ value: DeleteRoleCustomPermissionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/custom-permission"
    }
}

extension DeleteRoleMembershipInput {

    static func urlPathProvider(_ value: DeleteRoleMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        guard let memberName = value.memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

extension DeleteTemplateInput {

    static func urlPathProvider(_ value: DeleteTemplateInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension DeleteTemplateInput {

    static func queryItemProvider(_ value: DeleteTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteTemplateAliasInput {

    static func urlPathProvider(_ value: DeleteTemplateAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension DeleteThemeInput {

    static func urlPathProvider(_ value: DeleteThemeInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

extension DeleteThemeInput {

    static func queryItemProvider(_ value: DeleteThemeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DeleteThemeAliasInput {

    static func urlPathProvider(_ value: DeleteThemeAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension DeleteTopicInput {

    static func urlPathProvider(_ value: DeleteTopicInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())"
    }
}

extension DeleteTopicRefreshScheduleInput {

    static func urlPathProvider(_ value: DeleteTopicRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        guard let datasetId = value.datasetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/schedules/\(datasetId.urlPercentEncoding())"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension DeleteUserByPrincipalIdInput {

    static func urlPathProvider(_ value: DeleteUserByPrincipalIdInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/user-principals/\(principalId.urlPercentEncoding())"
    }
}

extension DeleteVPCConnectionInput {

    static func urlPathProvider(_ value: DeleteVPCConnectionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let vpcConnectionId = value.vpcConnectionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/vpc-connections/\(vpcConnectionId.urlPercentEncoding())"
    }
}

extension DescribeAccountCustomizationInput {

    static func urlPathProvider(_ value: DescribeAccountCustomizationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

extension DescribeAccountCustomizationInput {

    static func queryItemProvider(_ value: DescribeAccountCustomizationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resolved = value.resolved {
            let resolvedQueryItem = Smithy.URIQueryItem(name: "resolved".urlPercentEncoding(), value: Swift.String(resolved).urlPercentEncoding())
            items.append(resolvedQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DescribeAccountSettingsInput {

    static func urlPathProvider(_ value: DescribeAccountSettingsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

extension DescribeAccountSubscriptionInput {

    static func urlPathProvider(_ value: DescribeAccountSubscriptionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/account/\(awsAccountId.urlPercentEncoding())"
    }
}

extension DescribeAnalysisInput {

    static func urlPathProvider(_ value: DescribeAnalysisInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

extension DescribeAnalysisDefinitionInput {

    static func urlPathProvider(_ value: DescribeAnalysisDefinitionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/definition"
    }
}

extension DescribeAnalysisPermissionsInput {

    static func urlPathProvider(_ value: DescribeAnalysisPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

extension DescribeAssetBundleExportJobInput {

    static func urlPathProvider(_ value: DescribeAssetBundleExportJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let assetBundleExportJobId = value.assetBundleExportJobId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-export-jobs/\(assetBundleExportJobId.urlPercentEncoding())"
    }
}

extension DescribeAssetBundleImportJobInput {

    static func urlPathProvider(_ value: DescribeAssetBundleImportJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let assetBundleImportJobId = value.assetBundleImportJobId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-import-jobs/\(assetBundleImportJobId.urlPercentEncoding())"
    }
}

extension DescribeDashboardInput {

    static func urlPathProvider(_ value: DescribeDashboardInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension DescribeDashboardInput {

    static func queryItemProvider(_ value: DescribeDashboardInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aliasName = value.aliasName {
            let aliasNameQueryItem = Smithy.URIQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeDashboardDefinitionInput {

    static func urlPathProvider(_ value: DescribeDashboardDefinitionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/definition"
    }
}

extension DescribeDashboardDefinitionInput {

    static func queryItemProvider(_ value: DescribeDashboardDefinitionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aliasName = value.aliasName {
            let aliasNameQueryItem = Smithy.URIQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeDashboardPermissionsInput {

    static func urlPathProvider(_ value: DescribeDashboardPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

extension DescribeDashboardSnapshotJobInput {

    static func urlPathProvider(_ value: DescribeDashboardSnapshotJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        guard let snapshotJobId = value.snapshotJobId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/snapshot-jobs/\(snapshotJobId.urlPercentEncoding())"
    }
}

extension DescribeDashboardSnapshotJobResultInput {

    static func urlPathProvider(_ value: DescribeDashboardSnapshotJobResultInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        guard let snapshotJobId = value.snapshotJobId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/snapshot-jobs/\(snapshotJobId.urlPercentEncoding())/result"
    }
}

extension DescribeDataSetInput {

    static func urlPathProvider(_ value: DescribeDataSetInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

extension DescribeDataSetPermissionsInput {

    static func urlPathProvider(_ value: DescribeDataSetPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

extension DescribeDataSetRefreshPropertiesInput {

    static func urlPathProvider(_ value: DescribeDataSetRefreshPropertiesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-properties"
    }
}

extension DescribeDataSourceInput {

    static func urlPathProvider(_ value: DescribeDataSourceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension DescribeDataSourcePermissionsInput {

    static func urlPathProvider(_ value: DescribeDataSourcePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

extension DescribeFolderInput {

    static func urlPathProvider(_ value: DescribeFolderInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

extension DescribeFolderPermissionsInput {

    static func urlPathProvider(_ value: DescribeFolderPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

extension DescribeFolderPermissionsInput {

    static func queryItemProvider(_ value: DescribeFolderPermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DescribeFolderResolvedPermissionsInput {

    static func urlPathProvider(_ value: DescribeFolderResolvedPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/resolved-permissions"
    }
}

extension DescribeFolderResolvedPermissionsInput {

    static func queryItemProvider(_ value: DescribeFolderResolvedPermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension DescribeGroupInput {

    static func urlPathProvider(_ value: DescribeGroupInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

extension DescribeGroupMembershipInput {

    static func urlPathProvider(_ value: DescribeGroupMembershipInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        guard let memberName = value.memberName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members/\(memberName.urlPercentEncoding())"
    }
}

extension DescribeIAMPolicyAssignmentInput {

    static func urlPathProvider(_ value: DescribeIAMPolicyAssignmentInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let assignmentName = value.assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

extension DescribeIngestionInput {

    static func urlPathProvider(_ value: DescribeIngestionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let ingestionId = value.ingestionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions/\(ingestionId.urlPercentEncoding())"
    }
}

extension DescribeIpRestrictionInput {

    static func urlPathProvider(_ value: DescribeIpRestrictionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

extension DescribeKeyRegistrationInput {

    static func urlPathProvider(_ value: DescribeKeyRegistrationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/key-registration"
    }
}

extension DescribeKeyRegistrationInput {

    static func queryItemProvider(_ value: DescribeKeyRegistrationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let defaultKeyOnly = value.defaultKeyOnly {
            let defaultKeyOnlyQueryItem = Smithy.URIQueryItem(name: "default-key-only".urlPercentEncoding(), value: Swift.String(defaultKeyOnly).urlPercentEncoding())
            items.append(defaultKeyOnlyQueryItem)
        }
        return items
    }
}

extension DescribeNamespaceInput {

    static func urlPathProvider(_ value: DescribeNamespaceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())"
    }
}

extension DescribeQPersonalizationConfigurationInput {

    static func urlPathProvider(_ value: DescribeQPersonalizationConfigurationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/q-personalization-configuration"
    }
}

extension DescribeRefreshScheduleInput {

    static func urlPathProvider(_ value: DescribeRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        guard let scheduleId = value.scheduleId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-schedules/\(scheduleId.urlPercentEncoding())"
    }
}

extension DescribeRoleCustomPermissionInput {

    static func urlPathProvider(_ value: DescribeRoleCustomPermissionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/custom-permission"
    }
}

extension DescribeTemplateInput {

    static func urlPathProvider(_ value: DescribeTemplateInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension DescribeTemplateInput {

    static func queryItemProvider(_ value: DescribeTemplateInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aliasName = value.aliasName {
            let aliasNameQueryItem = Smithy.URIQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeTemplateAliasInput {

    static func urlPathProvider(_ value: DescribeTemplateAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension DescribeTemplateDefinitionInput {

    static func urlPathProvider(_ value: DescribeTemplateDefinitionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/definition"
    }
}

extension DescribeTemplateDefinitionInput {

    static func queryItemProvider(_ value: DescribeTemplateDefinitionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aliasName = value.aliasName {
            let aliasNameQueryItem = Smithy.URIQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeTemplatePermissionsInput {

    static func urlPathProvider(_ value: DescribeTemplatePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

extension DescribeThemeInput {

    static func urlPathProvider(_ value: DescribeThemeInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

extension DescribeThemeInput {

    static func queryItemProvider(_ value: DescribeThemeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let aliasName = value.aliasName {
            let aliasNameQueryItem = Smithy.URIQueryItem(name: "alias-name".urlPercentEncoding(), value: Swift.String(aliasName).urlPercentEncoding())
            items.append(aliasNameQueryItem)
        }
        if let versionNumber = value.versionNumber {
            let versionNumberQueryItem = Smithy.URIQueryItem(name: "version-number".urlPercentEncoding(), value: Swift.String(versionNumber).urlPercentEncoding())
            items.append(versionNumberQueryItem)
        }
        return items
    }
}

extension DescribeThemeAliasInput {

    static func urlPathProvider(_ value: DescribeThemeAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension DescribeThemePermissionsInput {

    static func urlPathProvider(_ value: DescribeThemePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

extension DescribeTopicInput {

    static func urlPathProvider(_ value: DescribeTopicInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())"
    }
}

extension DescribeTopicPermissionsInput {

    static func urlPathProvider(_ value: DescribeTopicPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/permissions"
    }
}

extension DescribeTopicRefreshInput {

    static func urlPathProvider(_ value: DescribeTopicRefreshInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        guard let refreshId = value.refreshId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/refresh/\(refreshId.urlPercentEncoding())"
    }
}

extension DescribeTopicRefreshScheduleInput {

    static func urlPathProvider(_ value: DescribeTopicRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        guard let datasetId = value.datasetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/schedules/\(datasetId.urlPercentEncoding())"
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension DescribeVPCConnectionInput {

    static func urlPathProvider(_ value: DescribeVPCConnectionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let vpcConnectionId = value.vpcConnectionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/vpc-connections/\(vpcConnectionId.urlPercentEncoding())"
    }
}

extension GenerateEmbedUrlForAnonymousUserInput {

    static func urlPathProvider(_ value: GenerateEmbedUrlForAnonymousUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/anonymous-user"
    }
}

extension GenerateEmbedUrlForRegisteredUserInput {

    static func urlPathProvider(_ value: GenerateEmbedUrlForRegisteredUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/embed-url/registered-user"
    }
}

extension GetDashboardEmbedUrlInput {

    static func urlPathProvider(_ value: GetDashboardEmbedUrlInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/embed-url"
    }
}

extension GetDashboardEmbedUrlInput {

    static func queryItemProvider(_ value: GetDashboardEmbedUrlInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let identityType = value.identityType else {
            let message = "Creating a URL Query Item failed. identityType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let identityTypeQueryItem = Smithy.URIQueryItem(name: "creds-type".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
        items.append(identityTypeQueryItem)
        if let statePersistenceEnabled = value.statePersistenceEnabled {
            let statePersistenceEnabledQueryItem = Smithy.URIQueryItem(name: "state-persistence-enabled".urlPercentEncoding(), value: Swift.String(statePersistenceEnabled).urlPercentEncoding())
            items.append(statePersistenceEnabledQueryItem)
        }
        if let userArn = value.userArn {
            let userArnQueryItem = Smithy.URIQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
            items.append(userArnQueryItem)
        }
        if let undoRedoDisabled = value.undoRedoDisabled {
            let undoRedoDisabledQueryItem = Smithy.URIQueryItem(name: "undo-redo-disabled".urlPercentEncoding(), value: Swift.String(undoRedoDisabled).urlPercentEncoding())
            items.append(undoRedoDisabledQueryItem)
        }
        if let additionalDashboardIds = value.additionalDashboardIds {
            additionalDashboardIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "additional-dashboard-ids".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let sessionLifetimeInMinutes = value.sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = Smithy.URIQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
            items.append(sessionLifetimeInMinutesQueryItem)
        }
        if let resetDisabled = value.resetDisabled {
            let resetDisabledQueryItem = Smithy.URIQueryItem(name: "reset-disabled".urlPercentEncoding(), value: Swift.String(resetDisabled).urlPercentEncoding())
            items.append(resetDisabledQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension GetSessionEmbedUrlInput {

    static func urlPathProvider(_ value: GetSessionEmbedUrlInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/session-embed-url"
    }
}

extension GetSessionEmbedUrlInput {

    static func queryItemProvider(_ value: GetSessionEmbedUrlInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userArn = value.userArn {
            let userArnQueryItem = Smithy.URIQueryItem(name: "user-arn".urlPercentEncoding(), value: Swift.String(userArn).urlPercentEncoding())
            items.append(userArnQueryItem)
        }
        if let entryPoint = value.entryPoint {
            let entryPointQueryItem = Smithy.URIQueryItem(name: "entry-point".urlPercentEncoding(), value: Swift.String(entryPoint).urlPercentEncoding())
            items.append(entryPointQueryItem)
        }
        if let sessionLifetimeInMinutes = value.sessionLifetimeInMinutes {
            let sessionLifetimeInMinutesQueryItem = Smithy.URIQueryItem(name: "session-lifetime".urlPercentEncoding(), value: Swift.String(sessionLifetimeInMinutes).urlPercentEncoding())
            items.append(sessionLifetimeInMinutesQueryItem)
        }
        return items
    }
}

extension ListAnalysesInput {

    static func urlPathProvider(_ value: ListAnalysesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses"
    }
}

extension ListAnalysesInput {

    static func queryItemProvider(_ value: ListAnalysesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssetBundleExportJobsInput {

    static func urlPathProvider(_ value: ListAssetBundleExportJobsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-export-jobs"
    }
}

extension ListAssetBundleExportJobsInput {

    static func queryItemProvider(_ value: ListAssetBundleExportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssetBundleImportJobsInput {

    static func urlPathProvider(_ value: ListAssetBundleImportJobsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-import-jobs"
    }
}

extension ListAssetBundleImportJobsInput {

    static func queryItemProvider(_ value: ListAssetBundleImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDashboardsInput {

    static func urlPathProvider(_ value: ListDashboardsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards"
    }
}

extension ListDashboardsInput {

    static func queryItemProvider(_ value: ListDashboardsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDashboardVersionsInput {

    static func urlPathProvider(_ value: ListDashboardVersionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions"
    }
}

extension ListDashboardVersionsInput {

    static func queryItemProvider(_ value: ListDashboardVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSetsInput {

    static func urlPathProvider(_ value: ListDataSetsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets"
    }
}

extension ListDataSetsInput {

    static func queryItemProvider(_ value: ListDataSetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources"
    }
}

extension ListDataSourcesInput {

    static func queryItemProvider(_ value: ListDataSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFolderMembersInput {

    static func urlPathProvider(_ value: ListFolderMembersInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/members"
    }
}

extension ListFolderMembersInput {

    static func queryItemProvider(_ value: ListFolderMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFoldersInput {

    static func urlPathProvider(_ value: ListFoldersInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders"
    }
}

extension ListFoldersInput {

    static func queryItemProvider(_ value: ListFoldersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFoldersForResourceInput {

    static func urlPathProvider(_ value: ListFoldersForResourceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/resource/\(resourceArn.urlPercentEncoding())/folders"
    }
}

extension ListFoldersForResourceInput {

    static func queryItemProvider(_ value: ListFoldersForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupMembershipsInput {

    static func urlPathProvider(_ value: ListGroupMembershipsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())/members"
    }
}

extension ListGroupMembershipsInput {

    static func queryItemProvider(_ value: ListGroupMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups"
    }
}

extension ListGroupsInput {

    static func queryItemProvider(_ value: ListGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIAMPolicyAssignmentsInput {

    static func urlPathProvider(_ value: ListIAMPolicyAssignmentsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/v2/iam-policy-assignments"
    }
}

extension ListIAMPolicyAssignmentsInput {

    static func queryItemProvider(_ value: ListIAMPolicyAssignmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assignmentStatus = value.assignmentStatus {
            let assignmentStatusQueryItem = Smithy.URIQueryItem(name: "assignment-status".urlPercentEncoding(), value: Swift.String(assignmentStatus.rawValue).urlPercentEncoding())
            items.append(assignmentStatusQueryItem)
        }
        return items
    }
}

extension ListIAMPolicyAssignmentsForUserInput {

    static func urlPathProvider(_ value: ListIAMPolicyAssignmentsForUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/iam-policy-assignments"
    }
}

extension ListIAMPolicyAssignmentsForUserInput {

    static func queryItemProvider(_ value: ListIAMPolicyAssignmentsForUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdentityPropagationConfigsInput {

    static func urlPathProvider(_ value: ListIdentityPropagationConfigsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/identity-propagation-config"
    }
}

extension ListIdentityPropagationConfigsInput {

    static func queryItemProvider(_ value: ListIdentityPropagationConfigsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIngestionsInput {

    static func urlPathProvider(_ value: ListIngestionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/ingestions"
    }
}

extension ListIngestionsInput {

    static func queryItemProvider(_ value: ListIngestionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNamespacesInput {

    static func urlPathProvider(_ value: ListNamespacesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces"
    }
}

extension ListNamespacesInput {

    static func queryItemProvider(_ value: ListNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRefreshSchedulesInput {

    static func urlPathProvider(_ value: ListRefreshSchedulesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-schedules"
    }
}

extension ListRoleMembershipsInput {

    static func urlPathProvider(_ value: ListRoleMembershipsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/members"
    }
}

extension ListRoleMembershipsInput {

    static func queryItemProvider(_ value: ListRoleMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

extension ListTemplateAliasesInput {

    static func urlPathProvider(_ value: ListTemplateAliasesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases"
    }
}

extension ListTemplateAliasesInput {

    static func queryItemProvider(_ value: ListTemplateAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplatesInput {

    static func urlPathProvider(_ value: ListTemplatesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates"
    }
}

extension ListTemplatesInput {

    static func queryItemProvider(_ value: ListTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTemplateVersionsInput {

    static func urlPathProvider(_ value: ListTemplateVersionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/versions"
    }
}

extension ListTemplateVersionsInput {

    static func queryItemProvider(_ value: ListTemplateVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemeAliasesInput {

    static func urlPathProvider(_ value: ListThemeAliasesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases"
    }
}

extension ListThemeAliasesInput {

    static func queryItemProvider(_ value: ListThemeAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-result".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemesInput {

    static func urlPathProvider(_ value: ListThemesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes"
    }
}

extension ListThemesInput {

    static func queryItemProvider(_ value: ListThemesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemeVersionsInput {

    static func urlPathProvider(_ value: ListThemeVersionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/versions"
    }
}

extension ListThemeVersionsInput {

    static func queryItemProvider(_ value: ListThemeVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTopicRefreshSchedulesInput {

    static func urlPathProvider(_ value: ListTopicRefreshSchedulesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/schedules"
    }
}

extension ListTopicReviewedAnswersInput {

    static func urlPathProvider(_ value: ListTopicReviewedAnswersInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/reviewed-answers"
    }
}

extension ListTopicsInput {

    static func urlPathProvider(_ value: ListTopicsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics"
    }
}

extension ListTopicsInput {

    static func queryItemProvider(_ value: ListTopicsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUserGroupsInput {

    static func urlPathProvider(_ value: ListUserGroupsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())/groups"
    }
}

extension ListUserGroupsInput {

    static func queryItemProvider(_ value: ListUserGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

extension ListUsersInput {

    static func queryItemProvider(_ value: ListUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVPCConnectionsInput {

    static func urlPathProvider(_ value: ListVPCConnectionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/vpc-connections"
    }
}

extension ListVPCConnectionsInput {

    static func queryItemProvider(_ value: ListVPCConnectionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutDataSetRefreshPropertiesInput {

    static func urlPathProvider(_ value: PutDataSetRefreshPropertiesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-properties"
    }
}

extension RegisterUserInput {

    static func urlPathProvider(_ value: RegisterUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users"
    }
}

extension RestoreAnalysisInput {

    static func urlPathProvider(_ value: RestoreAnalysisInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/restore/analyses/\(analysisId.urlPercentEncoding())"
    }
}

extension RestoreAnalysisInput {

    static func queryItemProvider(_ value: RestoreAnalysisInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let restoreToFolders = value.restoreToFolders {
            let restoreToFoldersQueryItem = Smithy.URIQueryItem(name: "restore-to-folders".urlPercentEncoding(), value: Swift.String(restoreToFolders).urlPercentEncoding())
            items.append(restoreToFoldersQueryItem)
        }
        return items
    }
}

extension SearchAnalysesInput {

    static func urlPathProvider(_ value: SearchAnalysesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/analyses"
    }
}

extension SearchDashboardsInput {

    static func urlPathProvider(_ value: SearchDashboardsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/dashboards"
    }
}

extension SearchDataSetsInput {

    static func urlPathProvider(_ value: SearchDataSetsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/data-sets"
    }
}

extension SearchDataSourcesInput {

    static func urlPathProvider(_ value: SearchDataSourcesInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/data-sources"
    }
}

extension SearchFoldersInput {

    static func urlPathProvider(_ value: SearchFoldersInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/search/folders"
    }
}

extension SearchGroupsInput {

    static func urlPathProvider(_ value: SearchGroupsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups-search"
    }
}

extension SearchGroupsInput {

    static func queryItemProvider(_ value: SearchGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension StartAssetBundleExportJobInput {

    static func urlPathProvider(_ value: StartAssetBundleExportJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-export-jobs/export"
    }
}

extension StartAssetBundleImportJobInput {

    static func urlPathProvider(_ value: StartAssetBundleImportJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/asset-bundle-import-jobs/import"
    }
}

extension StartDashboardSnapshotJobInput {

    static func urlPathProvider(_ value: StartDashboardSnapshotJobInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/snapshot-jobs"
    }
}

extension StartDashboardSnapshotJobScheduleInput {

    static func urlPathProvider(_ value: StartDashboardSnapshotJobScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        guard let scheduleId = value.scheduleId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/schedules/\(scheduleId.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resources/\(resourceArn.urlPercentEncoding())/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccountCustomizationInput {

    static func urlPathProvider(_ value: UpdateAccountCustomizationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/customizations"
    }
}

extension UpdateAccountCustomizationInput {

    static func queryItemProvider(_ value: UpdateAccountCustomizationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        return items
    }
}

extension UpdateAccountSettingsInput {

    static func urlPathProvider(_ value: UpdateAccountSettingsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/settings"
    }
}

extension UpdateAnalysisInput {

    static func urlPathProvider(_ value: UpdateAnalysisInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())"
    }
}

extension UpdateAnalysisPermissionsInput {

    static func urlPathProvider(_ value: UpdateAnalysisPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let analysisId = value.analysisId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/analyses/\(analysisId.urlPercentEncoding())/permissions"
    }
}

extension UpdateDashboardInput {

    static func urlPathProvider(_ value: UpdateDashboardInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension UpdateDashboardLinksInput {

    static func urlPathProvider(_ value: UpdateDashboardLinksInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/linked-entities"
    }
}

extension UpdateDashboardPermissionsInput {

    static func urlPathProvider(_ value: UpdateDashboardPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/permissions"
    }
}

extension UpdateDashboardPublishedVersionInput {

    static func urlPathProvider(_ value: UpdateDashboardPublishedVersionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        guard let versionNumber = value.versionNumber else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/dashboards/\(dashboardId.urlPercentEncoding())/versions/\(versionNumber)"
    }
}

extension UpdateDataSetInput {

    static func urlPathProvider(_ value: UpdateDataSetInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())"
    }
}

extension UpdateDataSetPermissionsInput {

    static func urlPathProvider(_ value: UpdateDataSetPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/permissions"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension UpdateDataSourcePermissionsInput {

    static func urlPathProvider(_ value: UpdateDataSourcePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sources/\(dataSourceId.urlPercentEncoding())/permissions"
    }
}

extension UpdateFolderInput {

    static func urlPathProvider(_ value: UpdateFolderInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())"
    }
}

extension UpdateFolderPermissionsInput {

    static func urlPathProvider(_ value: UpdateFolderPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let folderId = value.folderId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/folders/\(folderId.urlPercentEncoding())/permissions"
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let groupName = value.groupName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/groups/\(groupName.urlPercentEncoding())"
    }
}

extension UpdateIAMPolicyAssignmentInput {

    static func urlPathProvider(_ value: UpdateIAMPolicyAssignmentInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let assignmentName = value.assignmentName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/iam-policy-assignments/\(assignmentName.urlPercentEncoding())"
    }
}

extension UpdateIdentityPropagationConfigInput {

    static func urlPathProvider(_ value: UpdateIdentityPropagationConfigInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let service = value.service else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/identity-propagation-config/\(service.rawValue.urlPercentEncoding())"
    }
}

extension UpdateIpRestrictionInput {

    static func urlPathProvider(_ value: UpdateIpRestrictionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/ip-restriction"
    }
}

extension UpdateKeyRegistrationInput {

    static func urlPathProvider(_ value: UpdateKeyRegistrationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/key-registration"
    }
}

extension UpdatePublicSharingSettingsInput {

    static func urlPathProvider(_ value: UpdatePublicSharingSettingsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/public-sharing-settings"
    }
}

extension UpdateQPersonalizationConfigurationInput {

    static func urlPathProvider(_ value: UpdateQPersonalizationConfigurationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/q-personalization-configuration"
    }
}

extension UpdateRefreshScheduleInput {

    static func urlPathProvider(_ value: UpdateRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let dataSetId = value.dataSetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/data-sets/\(dataSetId.urlPercentEncoding())/refresh-schedules"
    }
}

extension UpdateRoleCustomPermissionInput {

    static func urlPathProvider(_ value: UpdateRoleCustomPermissionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let role = value.role else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/roles/\(role.rawValue.urlPercentEncoding())/custom-permission"
    }
}

extension UpdateSPICECapacityConfigurationInput {

    static func urlPathProvider(_ value: UpdateSPICECapacityConfigurationInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/spice-capacity-configuration"
    }
}

extension UpdateTemplateInput {

    static func urlPathProvider(_ value: UpdateTemplateInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension UpdateTemplateAliasInput {

    static func urlPathProvider(_ value: UpdateTemplateAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension UpdateTemplatePermissionsInput {

    static func urlPathProvider(_ value: UpdateTemplatePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())/permissions"
    }
}

extension UpdateThemeInput {

    static func urlPathProvider(_ value: UpdateThemeInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())"
    }
}

extension UpdateThemeAliasInput {

    static func urlPathProvider(_ value: UpdateThemeAliasInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        guard let aliasName = value.aliasName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/aliases/\(aliasName.urlPercentEncoding())"
    }
}

extension UpdateThemePermissionsInput {

    static func urlPathProvider(_ value: UpdateThemePermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let themeId = value.themeId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/themes/\(themeId.urlPercentEncoding())/permissions"
    }
}

extension UpdateTopicInput {

    static func urlPathProvider(_ value: UpdateTopicInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())"
    }
}

extension UpdateTopicPermissionsInput {

    static func urlPathProvider(_ value: UpdateTopicPermissionsInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/permissions"
    }
}

extension UpdateTopicRefreshScheduleInput {

    static func urlPathProvider(_ value: UpdateTopicRefreshScheduleInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let topicId = value.topicId else {
            return nil
        }
        guard let datasetId = value.datasetId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/topics/\(topicId.urlPercentEncoding())/schedules/\(datasetId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let userName = value.userName else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/users/\(userName.urlPercentEncoding())"
    }
}

extension UpdateVPCConnectionInput {

    static func urlPathProvider(_ value: UpdateVPCConnectionInput) -> Swift.String? {
        guard let awsAccountId = value.awsAccountId else {
            return nil
        }
        guard let vpcConnectionId = value.vpcConnectionId else {
            return nil
        }
        return "/accounts/\(awsAccountId.urlPercentEncoding())/vpc-connections/\(vpcConnectionId.urlPercentEncoding())"
    }
}

extension BatchCreateTopicReviewedAnswerInput {

    static func write(value: BatchCreateTopicReviewedAnswerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Answers"].writeList(value.answers, memberWritingClosure: QuickSightClientTypes.CreateTopicReviewedAnswer.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteTopicReviewedAnswerInput {

    static func write(value: BatchDeleteTopicReviewedAnswerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnswerIds"].writeList(value.answerIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccountCustomizationInput {

    static func write(value: CreateAccountCustomizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountCustomization"].write(value.accountCustomization, with: QuickSightClientTypes.AccountCustomization.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccountSubscriptionInput {

    static func write(value: CreateAccountSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountName"].write(value.accountName)
        try writer["ActiveDirectoryName"].write(value.activeDirectoryName)
        try writer["AdminGroup"].writeList(value.adminGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AdminProGroup"].writeList(value.adminProGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AuthenticationMethod"].write(value.authenticationMethod)
        try writer["AuthorGroup"].writeList(value.authorGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AuthorProGroup"].writeList(value.authorProGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContactNumber"].write(value.contactNumber)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["Edition"].write(value.edition)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["FirstName"].write(value.firstName)
        try writer["IAMIdentityCenterInstanceArn"].write(value.iamIdentityCenterInstanceArn)
        try writer["LastName"].write(value.lastName)
        try writer["NotificationEmail"].write(value.notificationEmail)
        try writer["ReaderGroup"].writeList(value.readerGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReaderProGroup"].writeList(value.readerProGroup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Realm"].write(value.realm)
    }
}

extension CreateAnalysisInput {

    static func write(value: CreateAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.AnalysisDefinition.write(value:to:))
        try writer["FolderArns"].writeList(value.folderArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Parameters"].write(value.parameters, with: QuickSightClientTypes.Parameters.write(value:to:))
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.AnalysisSourceEntity.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThemeArn"].write(value.themeArn)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
    }
}

extension CreateDashboardInput {

    static func write(value: CreateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardPublishOptions"].write(value.dashboardPublishOptions, with: QuickSightClientTypes.DashboardPublishOptions.write(value:to:))
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.DashboardVersionDefinition.write(value:to:))
        try writer["FolderArns"].writeList(value.folderArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinkEntities"].writeList(value.linkEntities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinkSharingConfiguration"].write(value.linkSharingConfiguration, with: QuickSightClientTypes.LinkSharingConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Parameters"].write(value.parameters, with: QuickSightClientTypes.Parameters.write(value:to:))
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.DashboardSourceEntity.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThemeArn"].write(value.themeArn)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension CreateDataSetInput {

    static func write(value: CreateDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnGroups"].writeList(value.columnGroups, memberWritingClosure: QuickSightClientTypes.ColumnGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnLevelPermissionRules"].writeList(value.columnLevelPermissionRules, memberWritingClosure: QuickSightClientTypes.ColumnLevelPermissionRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetId"].write(value.dataSetId)
        try writer["DataSetUsageConfiguration"].write(value.dataSetUsageConfiguration, with: QuickSightClientTypes.DataSetUsageConfiguration.write(value:to:))
        try writer["DatasetParameters"].writeList(value.datasetParameters, memberWritingClosure: QuickSightClientTypes.DatasetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FieldFolders"].writeMap(value.fieldFolders, valueWritingClosure: QuickSightClientTypes.FieldFolder.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["FolderArns"].writeList(value.folderArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ImportMode"].write(value.importMode)
        try writer["LogicalTableMap"].writeMap(value.logicalTableMap, valueWritingClosure: QuickSightClientTypes.LogicalTable.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PhysicalTableMap"].writeMap(value.physicalTableMap, valueWritingClosure: QuickSightClientTypes.PhysicalTable.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RowLevelPermissionDataSet"].write(value.rowLevelPermissionDataSet, with: QuickSightClientTypes.RowLevelPermissionDataSet.write(value:to:))
        try writer["RowLevelPermissionTagConfiguration"].write(value.rowLevelPermissionTagConfiguration, with: QuickSightClientTypes.RowLevelPermissionTagConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Credentials"].write(value.credentials, with: QuickSightClientTypes.DataSourceCredentials.write(value:to:))
        try writer["DataSourceId"].write(value.dataSourceId)
        try writer["DataSourceParameters"].write(value.dataSourceParameters, with: QuickSightClientTypes.DataSourceParameters.write(value:to:))
        try writer["FolderArns"].writeList(value.folderArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SslProperties"].write(value.sslProperties, with: QuickSightClientTypes.SslProperties.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
        try writer["VpcConnectionProperties"].write(value.vpcConnectionProperties, with: QuickSightClientTypes.VpcConnectionProperties.write(value:to:))
    }
}

extension CreateFolderInput {

    static func write(value: CreateFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FolderType"].write(value.folderType)
        try writer["Name"].write(value.name)
        try writer["ParentFolderArn"].write(value.parentFolderArn)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SharingModel"].write(value.sharingModel)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["GroupName"].write(value.groupName)
    }
}

extension CreateIAMPolicyAssignmentInput {

    static func write(value: CreateIAMPolicyAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssignmentName"].write(value.assignmentName)
        try writer["AssignmentStatus"].write(value.assignmentStatus)
        try writer["Identities"].writeMap(value.identities, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PolicyArn"].write(value.policyArn)
    }
}

extension CreateIngestionInput {

    static func write(value: CreateIngestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngestionType"].write(value.ingestionType)
    }
}

extension CreateNamespaceInput {

    static func write(value: CreateNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityStore"].write(value.identityStore)
        try writer["Namespace"].write(value.namespace)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRefreshScheduleInput {

    static func write(value: CreateRefreshScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Schedule"].write(value.schedule, with: QuickSightClientTypes.RefreshSchedule.write(value:to:))
    }
}

extension CreateTemplateInput {

    static func write(value: CreateTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.TemplateVersionDefinition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.TemplateSourceEntity.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension CreateTemplateAliasInput {

    static func write(value: CreateTemplateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TemplateVersionNumber"].write(value.templateVersionNumber)
    }
}

extension CreateThemeInput {

    static func write(value: CreateThemeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseThemeId"].write(value.baseThemeId)
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.ThemeConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension CreateThemeAliasInput {

    static func write(value: CreateThemeAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThemeVersionNumber"].write(value.themeVersionNumber)
    }
}

extension CreateTopicInput {

    static func write(value: CreateTopicInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Topic"].write(value.topic, with: QuickSightClientTypes.TopicDetails.write(value:to:))
        try writer["TopicId"].write(value.topicId)
    }
}

extension CreateTopicRefreshScheduleInput {

    static func write(value: CreateTopicRefreshScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetArn"].write(value.datasetArn)
        try writer["DatasetName"].write(value.datasetName)
        try writer["RefreshSchedule"].write(value.refreshSchedule, with: QuickSightClientTypes.TopicRefreshSchedule.write(value:to:))
    }
}

extension CreateVPCConnectionInput {

    static func write(value: CreateVPCConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsResolvers"].writeList(value.dnsResolvers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnectionId"].write(value.vpcConnectionId)
    }
}

extension GenerateEmbedUrlForAnonymousUserInput {

    static func write(value: GenerateEmbedUrlForAnonymousUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedDomains"].writeList(value.allowedDomains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AuthorizedResourceArns"].writeList(value.authorizedResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExperienceConfiguration"].write(value.experienceConfiguration, with: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration.write(value:to:))
        try writer["Namespace"].write(value.namespace)
        try writer["SessionLifetimeInMinutes"].write(value.sessionLifetimeInMinutes)
        try writer["SessionTags"].writeList(value.sessionTags, memberWritingClosure: QuickSightClientTypes.SessionTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GenerateEmbedUrlForRegisteredUserInput {

    static func write(value: GenerateEmbedUrlForRegisteredUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowedDomains"].writeList(value.allowedDomains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExperienceConfiguration"].write(value.experienceConfiguration, with: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration.write(value:to:))
        try writer["SessionLifetimeInMinutes"].write(value.sessionLifetimeInMinutes)
        try writer["UserArn"].write(value.userArn)
    }
}

extension PutDataSetRefreshPropertiesInput {

    static func write(value: PutDataSetRefreshPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetRefreshProperties"].write(value.dataSetRefreshProperties, with: QuickSightClientTypes.DataSetRefreshProperties.write(value:to:))
    }
}

extension RegisterUserInput {

    static func write(value: RegisterUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomFederationProviderUrl"].write(value.customFederationProviderUrl)
        try writer["CustomPermissionsName"].write(value.customPermissionsName)
        try writer["Email"].write(value.email)
        try writer["ExternalLoginFederationProviderType"].write(value.externalLoginFederationProviderType)
        try writer["ExternalLoginId"].write(value.externalLoginId)
        try writer["IamArn"].write(value.iamArn)
        try writer["IdentityType"].write(value.identityType)
        try writer["SessionName"].write(value.sessionName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserName"].write(value.userName)
        try writer["UserRole"].write(value.userRole)
    }
}

extension SearchAnalysesInput {

    static func write(value: SearchAnalysesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.AnalysisSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchDashboardsInput {

    static func write(value: SearchDashboardsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.DashboardSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchDataSetsInput {

    static func write(value: SearchDataSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.DataSetSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchDataSourcesInput {

    static func write(value: SearchDataSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.DataSourceSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchFoldersInput {

    static func write(value: SearchFoldersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.FolderSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension SearchGroupsInput {

    static func write(value: SearchGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.GroupSearchFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartAssetBundleExportJobInput {

    static func write(value: StartAssetBundleExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssetBundleExportJobId"].write(value.assetBundleExportJobId)
        try writer["CloudFormationOverridePropertyConfiguration"].write(value.cloudFormationOverridePropertyConfiguration, with: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration.write(value:to:))
        try writer["ExportFormat"].write(value.exportFormat)
        try writer["IncludeAllDependencies"].write(value.includeAllDependencies)
        try writer["IncludeFolderMembers"].write(value.includeFolderMembers)
        try writer["IncludeFolderMemberships"].write(value.includeFolderMemberships)
        try writer["IncludePermissions"].write(value.includePermissions)
        try writer["IncludeTags"].write(value.includeTags)
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.AssetBundleExportJobValidationStrategy.write(value:to:))
    }
}

extension StartAssetBundleImportJobInput {

    static func write(value: StartAssetBundleImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssetBundleImportJobId"].write(value.assetBundleImportJobId)
        try writer["AssetBundleImportSource"].write(value.assetBundleImportSource, with: QuickSightClientTypes.AssetBundleImportSource.write(value:to:))
        try writer["FailureAction"].write(value.failureAction)
        try writer["OverrideParameters"].write(value.overrideParameters, with: QuickSightClientTypes.AssetBundleImportJobOverrideParameters.write(value:to:))
        try writer["OverridePermissions"].write(value.overridePermissions, with: QuickSightClientTypes.AssetBundleImportJobOverridePermissions.write(value:to:))
        try writer["OverrideTags"].write(value.overrideTags, with: QuickSightClientTypes.AssetBundleImportJobOverrideTags.write(value:to:))
        try writer["OverrideValidationStrategy"].write(value.overrideValidationStrategy, with: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy.write(value:to:))
    }
}

extension StartDashboardSnapshotJobInput {

    static func write(value: StartDashboardSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnapshotConfiguration"].write(value.snapshotConfiguration, with: QuickSightClientTypes.SnapshotConfiguration.write(value:to:))
        try writer["SnapshotJobId"].write(value.snapshotJobId)
        try writer["UserConfiguration"].write(value.userConfiguration, with: QuickSightClientTypes.SnapshotUserConfiguration.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccountCustomizationInput {

    static func write(value: UpdateAccountCustomizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountCustomization"].write(value.accountCustomization, with: QuickSightClientTypes.AccountCustomization.write(value:to:))
    }
}

extension UpdateAccountSettingsInput {

    static func write(value: UpdateAccountSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultNamespace"].write(value.defaultNamespace)
        try writer["NotificationEmail"].write(value.notificationEmail)
        try writer["TerminationProtectionEnabled"].write(value.terminationProtectionEnabled)
    }
}

extension UpdateAnalysisInput {

    static func write(value: UpdateAnalysisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.AnalysisDefinition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Parameters"].write(value.parameters, with: QuickSightClientTypes.Parameters.write(value:to:))
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.AnalysisSourceEntity.write(value:to:))
        try writer["ThemeArn"].write(value.themeArn)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
    }
}

extension UpdateAnalysisPermissionsInput {

    static func write(value: UpdateAnalysisPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDashboardInput {

    static func write(value: UpdateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardPublishOptions"].write(value.dashboardPublishOptions, with: QuickSightClientTypes.DashboardPublishOptions.write(value:to:))
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.DashboardVersionDefinition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["Parameters"].write(value.parameters, with: QuickSightClientTypes.Parameters.write(value:to:))
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.DashboardSourceEntity.write(value:to:))
        try writer["ThemeArn"].write(value.themeArn)
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension UpdateDashboardLinksInput {

    static func write(value: UpdateDashboardLinksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkEntities"].writeList(value.linkEntities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDashboardPermissionsInput {

    static func write(value: UpdateDashboardPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantLinkPermissions"].writeList(value.grantLinkPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokeLinkPermissions"].writeList(value.revokeLinkPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDataSetInput {

    static func write(value: UpdateDataSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnGroups"].writeList(value.columnGroups, memberWritingClosure: QuickSightClientTypes.ColumnGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnLevelPermissionRules"].writeList(value.columnLevelPermissionRules, memberWritingClosure: QuickSightClientTypes.ColumnLevelPermissionRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetUsageConfiguration"].write(value.dataSetUsageConfiguration, with: QuickSightClientTypes.DataSetUsageConfiguration.write(value:to:))
        try writer["DatasetParameters"].writeList(value.datasetParameters, memberWritingClosure: QuickSightClientTypes.DatasetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FieldFolders"].writeMap(value.fieldFolders, valueWritingClosure: QuickSightClientTypes.FieldFolder.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ImportMode"].write(value.importMode)
        try writer["LogicalTableMap"].writeMap(value.logicalTableMap, valueWritingClosure: QuickSightClientTypes.LogicalTable.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PhysicalTableMap"].writeMap(value.physicalTableMap, valueWritingClosure: QuickSightClientTypes.PhysicalTable.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RowLevelPermissionDataSet"].write(value.rowLevelPermissionDataSet, with: QuickSightClientTypes.RowLevelPermissionDataSet.write(value:to:))
        try writer["RowLevelPermissionTagConfiguration"].write(value.rowLevelPermissionTagConfiguration, with: QuickSightClientTypes.RowLevelPermissionTagConfiguration.write(value:to:))
    }
}

extension UpdateDataSetPermissionsInput {

    static func write(value: UpdateDataSetPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Credentials"].write(value.credentials, with: QuickSightClientTypes.DataSourceCredentials.write(value:to:))
        try writer["DataSourceParameters"].write(value.dataSourceParameters, with: QuickSightClientTypes.DataSourceParameters.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SslProperties"].write(value.sslProperties, with: QuickSightClientTypes.SslProperties.write(value:to:))
        try writer["VpcConnectionProperties"].write(value.vpcConnectionProperties, with: QuickSightClientTypes.VpcConnectionProperties.write(value:to:))
    }
}

extension UpdateDataSourcePermissionsInput {

    static func write(value: UpdateDataSourcePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFolderInput {

    static func write(value: UpdateFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateFolderPermissionsInput {

    static func write(value: UpdateFolderPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension UpdateIAMPolicyAssignmentInput {

    static func write(value: UpdateIAMPolicyAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssignmentStatus"].write(value.assignmentStatus)
        try writer["Identities"].writeMap(value.identities, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PolicyArn"].write(value.policyArn)
    }
}

extension UpdateIdentityPropagationConfigInput {

    static func write(value: UpdateIdentityPropagationConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedTargets"].writeList(value.authorizedTargets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateIpRestrictionInput {

    static func write(value: UpdateIpRestrictionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["IpRestrictionRuleMap"].writeMap(value.ipRestrictionRuleMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VpcEndpointIdRestrictionRuleMap"].writeMap(value.vpcEndpointIdRestrictionRuleMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VpcIdRestrictionRuleMap"].writeMap(value.vpcIdRestrictionRuleMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateKeyRegistrationInput {

    static func write(value: UpdateKeyRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyRegistration"].writeList(value.keyRegistration, memberWritingClosure: QuickSightClientTypes.RegisteredCustomerManagedKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePublicSharingSettingsInput {

    static func write(value: UpdatePublicSharingSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PublicSharingEnabled"].write(value.publicSharingEnabled)
    }
}

extension UpdateQPersonalizationConfigurationInput {

    static func write(value: UpdateQPersonalizationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PersonalizationMode"].write(value.personalizationMode)
    }
}

extension UpdateRefreshScheduleInput {

    static func write(value: UpdateRefreshScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Schedule"].write(value.schedule, with: QuickSightClientTypes.RefreshSchedule.write(value:to:))
    }
}

extension UpdateRoleCustomPermissionInput {

    static func write(value: UpdateRoleCustomPermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomPermissionsName"].write(value.customPermissionsName)
    }
}

extension UpdateSPICECapacityConfigurationInput {

    static func write(value: UpdateSPICECapacityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PurchaseMode"].write(value.purchaseMode)
    }
}

extension UpdateTemplateInput {

    static func write(value: UpdateTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].write(value.definition, with: QuickSightClientTypes.TemplateVersionDefinition.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SourceEntity"].write(value.sourceEntity, with: QuickSightClientTypes.TemplateSourceEntity.write(value:to:))
        try writer["ValidationStrategy"].write(value.validationStrategy, with: QuickSightClientTypes.ValidationStrategy.write(value:to:))
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension UpdateTemplateAliasInput {

    static func write(value: UpdateTemplateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TemplateVersionNumber"].write(value.templateVersionNumber)
    }
}

extension UpdateTemplatePermissionsInput {

    static func write(value: UpdateTemplatePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateThemeInput {

    static func write(value: UpdateThemeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseThemeId"].write(value.baseThemeId)
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.ThemeConfiguration.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["VersionDescription"].write(value.versionDescription)
    }
}

extension UpdateThemeAliasInput {

    static func write(value: UpdateThemeAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThemeVersionNumber"].write(value.themeVersionNumber)
    }
}

extension UpdateThemePermissionsInput {

    static func write(value: UpdateThemePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTopicInput {

    static func write(value: UpdateTopicInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Topic"].write(value.topic, with: QuickSightClientTypes.TopicDetails.write(value:to:))
    }
}

extension UpdateTopicPermissionsInput {

    static func write(value: UpdateTopicPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GrantPermissions"].writeList(value.grantPermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RevokePermissions"].writeList(value.revokePermissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTopicRefreshScheduleInput {

    static func write(value: UpdateTopicRefreshScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RefreshSchedule"].write(value.refreshSchedule, with: QuickSightClientTypes.TopicRefreshSchedule.write(value:to:))
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomFederationProviderUrl"].write(value.customFederationProviderUrl)
        try writer["CustomPermissionsName"].write(value.customPermissionsName)
        try writer["Email"].write(value.email)
        try writer["ExternalLoginFederationProviderType"].write(value.externalLoginFederationProviderType)
        try writer["ExternalLoginId"].write(value.externalLoginId)
        try writer["Role"].write(value.role)
        try writer["UnapplyCustomPermissions"].write(value.unapplyCustomPermissions)
    }
}

extension UpdateVPCConnectionInput {

    static func write(value: UpdateVPCConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsResolvers"].writeList(value.dnsResolvers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateTopicReviewedAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateTopicReviewedAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateTopicReviewedAnswerOutput()
        value.invalidAnswers = try reader["InvalidAnswers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.InvalidTopicReviewedAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.succeededAnswers = try reader["SucceededAnswers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SucceededTopicReviewedAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension BatchDeleteTopicReviewedAnswerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteTopicReviewedAnswerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteTopicReviewedAnswerOutput()
        value.invalidAnswers = try reader["InvalidAnswers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.InvalidTopicReviewedAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.succeededAnswers = try reader["SucceededAnswers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SucceededTopicReviewedAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CancelIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelIngestionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.ingestionId = try reader["IngestionId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateAccountCustomizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountCustomizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountCustomizationOutput()
        value.accountCustomization = try reader["AccountCustomization"].readIfPresent(with: QuickSightClientTypes.AccountCustomization.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateAccountSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountSubscriptionOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.signupResponse = try reader["SignupResponse"].readIfPresent(with: QuickSightClientTypes.SignupResponse.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnalysisOutput()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDashboardOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.versionArn = try reader["VersionArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSetOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.ingestionArn = try reader["IngestionArn"].readIfPresent()
        value.ingestionId = try reader["IngestionId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFolderOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateFolderMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFolderMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFolderMembershipOutput()
        value.folderMember = try reader["FolderMember"].readIfPresent(with: QuickSightClientTypes.FolderMember.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: QuickSightClientTypes.Group.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateGroupMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupMembershipOutput()
        value.groupMember = try reader["GroupMember"].readIfPresent(with: QuickSightClientTypes.GroupMember.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateIAMPolicyAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIAMPolicyAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIAMPolicyAssignmentOutput()
        value.assignmentId = try reader["AssignmentId"].readIfPresent()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.assignmentStatus = try reader["AssignmentStatus"].readIfPresent()
        value.identities = try reader["Identities"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.ingestionId = try reader["IngestionId"].readIfPresent()
        value.ingestionStatus = try reader["IngestionStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNamespaceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.capacityRegion = try reader["CapacityRegion"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.identityStore = try reader["IdentityStore"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRefreshScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.scheduleId = try reader["ScheduleId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateRoleMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRoleMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoleMembershipOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.versionArn = try reader["VersionArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateTemplateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTemplateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTemplateAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateAlias = try reader["TemplateAlias"].readIfPresent(with: QuickSightClientTypes.TemplateAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateThemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThemeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.versionArn = try reader["VersionArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateThemeAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateThemeAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateThemeAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeAlias = try reader["ThemeAlias"].readIfPresent(with: QuickSightClientTypes.ThemeAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTopicOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.refreshArn = try reader["RefreshArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateTopicRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTopicRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTopicRefreshScheduleOutput()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension CreateVPCConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVPCConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVPCConnectionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteAccountCustomizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountCustomizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccountCustomizationOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteAccountSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccountSubscriptionOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAnalysisOutput()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.deletionTime = try reader["DeletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDashboardOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSetOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteDataSetRefreshPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSetRefreshPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSetRefreshPropertiesOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFolderOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteFolderMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFolderMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFolderMembershipOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGroupOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteGroupMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGroupMembershipOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteIAMPolicyAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIAMPolicyAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIAMPolicyAssignmentOutput()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteIdentityPropagationConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdentityPropagationConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteIdentityPropagationConfigOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNamespaceOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRefreshScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.scheduleId = try reader["ScheduleId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteRoleCustomPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoleCustomPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRoleCustomPermissionOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteRoleMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRoleMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRoleMembershipOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteTemplateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTemplateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTemplateAliasOutput()
        value.aliasName = try reader["AliasName"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteThemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteThemeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteThemeAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteThemeAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteThemeAliasOutput()
        value.aliasName = try reader["AliasName"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTopicOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteTopicRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTopicRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTopicRefreshScheduleOutput()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUserOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteUserByPrincipalIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserByPrincipalIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteUserByPrincipalIdOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DeleteVPCConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVPCConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVPCConnectionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        value.deletionStatus = try reader["DeletionStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAccountCustomizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountCustomizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountCustomizationOutput()
        value.accountCustomization = try reader["AccountCustomization"].readIfPresent(with: QuickSightClientTypes.AccountCustomization.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountSettingsOutput()
        value.accountSettings = try reader["AccountSettings"].readIfPresent(with: QuickSightClientTypes.AccountSettings.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAccountSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountSubscriptionOutput()
        value.accountInfo = try reader["AccountInfo"].readIfPresent(with: QuickSightClientTypes.AccountInfo.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnalysisOutput()
        value.analysis = try reader["Analysis"].readIfPresent(with: QuickSightClientTypes.Analysis.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAnalysisDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnalysisDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnalysisDefinitionOutput()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: QuickSightClientTypes.AnalysisDefinition.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AnalysisError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.resourceStatus = try reader["ResourceStatus"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAnalysisPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAnalysisPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAnalysisPermissionsOutput()
        value.analysisArn = try reader["AnalysisArn"].readIfPresent()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAssetBundleExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetBundleExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetBundleExportJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.assetBundleExportJobId = try reader["AssetBundleExportJobId"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.cloudFormationOverridePropertyConfiguration = try reader["CloudFormationOverridePropertyConfiguration"].readIfPresent(with: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.downloadUrl = try reader["DownloadUrl"].readIfPresent()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.exportFormat = try reader["ExportFormat"].readIfPresent()
        value.includeAllDependencies = try reader["IncludeAllDependencies"].readIfPresent() ?? false
        value.includeFolderMembers = try reader["IncludeFolderMembers"].readIfPresent()
        value.includeFolderMemberships = try reader["IncludeFolderMemberships"].readIfPresent() ?? false
        value.includePermissions = try reader["IncludePermissions"].readIfPresent() ?? false
        value.includeTags = try reader["IncludeTags"].readIfPresent() ?? false
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.resourceArns = try reader["ResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.validationStrategy = try reader["ValidationStrategy"].readIfPresent(with: QuickSightClientTypes.AssetBundleExportJobValidationStrategy.read(from:))
        value.warnings = try reader["Warnings"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobWarning.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeAssetBundleImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetBundleImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetBundleImportJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.assetBundleImportJobId = try reader["AssetBundleImportJobId"].readIfPresent()
        value.assetBundleImportSource = try reader["AssetBundleImportSource"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportSourceDescription.read(from:))
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureAction = try reader["FailureAction"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.overrideParameters = try reader["OverrideParameters"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobOverrideParameters.read(from:))
        value.overridePermissions = try reader["OverridePermissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobOverridePermissions.read(from:))
        value.overrideTags = try reader["OverrideTags"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobOverrideTags.read(from:))
        value.overrideValidationStrategy = try reader["OverrideValidationStrategy"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.rollbackErrors = try reader["RollbackErrors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.warnings = try reader["Warnings"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobWarning.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardOutput()
        value.dashboard = try reader["Dashboard"].readIfPresent(with: QuickSightClientTypes.Dashboard.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDashboardDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardDefinitionOutput()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.dashboardPublishOptions = try reader["DashboardPublishOptions"].readIfPresent(with: QuickSightClientTypes.DashboardPublishOptions.read(from:))
        value.definition = try reader["Definition"].readIfPresent(with: QuickSightClientTypes.DashboardVersionDefinition.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DashboardError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.resourceStatus = try reader["ResourceStatus"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDashboardPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardPermissionsOutput()
        value.dashboardArn = try reader["DashboardArn"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.linkSharingConfiguration = try reader["LinkSharingConfiguration"].readIfPresent(with: QuickSightClientTypes.LinkSharingConfiguration.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDashboardSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardSnapshotJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardSnapshotJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.snapshotConfiguration = try reader["SnapshotConfiguration"].readIfPresent(with: QuickSightClientTypes.SnapshotConfiguration.read(from:))
        value.snapshotJobId = try reader["SnapshotJobId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        value.userConfiguration = try reader["UserConfiguration"].readIfPresent(with: QuickSightClientTypes.SnapshotUserConfigurationRedacted.read(from:))
        return value
    }
}

extension DescribeDashboardSnapshotJobResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardSnapshotJobResultOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardSnapshotJobResultOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorInfo = try reader["ErrorInfo"].readIfPresent(with: QuickSightClientTypes.SnapshotJobErrorInfo.read(from:))
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.result = try reader["Result"].readIfPresent(with: QuickSightClientTypes.SnapshotJobResult.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataSetOutput()
        value.dataSet = try reader["DataSet"].readIfPresent(with: QuickSightClientTypes.DataSet.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDataSetPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataSetPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataSetPermissionsOutput()
        value.dataSetArn = try reader["DataSetArn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDataSetRefreshPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataSetRefreshPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataSetRefreshPropertiesOutput()
        value.dataSetRefreshProperties = try reader["DataSetRefreshProperties"].readIfPresent(with: QuickSightClientTypes.DataSetRefreshProperties.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataSourceOutput()
        value.dataSource = try reader["DataSource"].readIfPresent(with: QuickSightClientTypes.DataSource.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeDataSourcePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDataSourcePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDataSourcePermissionsOutput()
        value.dataSourceArn = try reader["DataSourceArn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFolderOutput()
        value.folder = try reader["Folder"].readIfPresent(with: QuickSightClientTypes.Folder.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeFolderPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFolderPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFolderPermissionsOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeFolderResolvedPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFolderResolvedPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFolderResolvedPermissionsOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: QuickSightClientTypes.Group.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeGroupMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGroupMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGroupMembershipOutput()
        value.groupMember = try reader["GroupMember"].readIfPresent(with: QuickSightClientTypes.GroupMember.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeIAMPolicyAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIAMPolicyAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIAMPolicyAssignmentOutput()
        value.iamPolicyAssignment = try reader["IAMPolicyAssignment"].readIfPresent(with: QuickSightClientTypes.IAMPolicyAssignment.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIngestionOutput()
        value.ingestion = try reader["Ingestion"].readIfPresent(with: QuickSightClientTypes.Ingestion.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeIpRestrictionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeIpRestrictionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeIpRestrictionOutput()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.ipRestrictionRuleMap = try reader["IpRestrictionRuleMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.vpcEndpointIdRestrictionRuleMap = try reader["VpcEndpointIdRestrictionRuleMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcIdRestrictionRuleMap = try reader["VpcIdRestrictionRuleMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeKeyRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeKeyRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeKeyRegistrationOutput()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.keyRegistration = try reader["KeyRegistration"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.RegisteredCustomerManagedKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNamespaceOutput()
        value.namespace = try reader["Namespace"].readIfPresent(with: QuickSightClientTypes.NamespaceInfoV2.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeQPersonalizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeQPersonalizationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeQPersonalizationConfigurationOutput()
        value.personalizationMode = try reader["PersonalizationMode"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRefreshScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.refreshSchedule = try reader["RefreshSchedule"].readIfPresent(with: QuickSightClientTypes.RefreshSchedule.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeRoleCustomPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRoleCustomPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRoleCustomPermissionOutput()
        value.customPermissionsName = try reader["CustomPermissionsName"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTemplateOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.template = try reader["Template"].readIfPresent(with: QuickSightClientTypes.Template.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTemplateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTemplateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTemplateAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateAlias = try reader["TemplateAlias"].readIfPresent(with: QuickSightClientTypes.TemplateAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTemplateDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTemplateDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTemplateDefinitionOutput()
        value.definition = try reader["Definition"].readIfPresent(with: QuickSightClientTypes.TemplateVersionDefinition.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TemplateError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.resourceStatus = try reader["ResourceStatus"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTemplatePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTemplatePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTemplatePermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeThemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThemeOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.theme = try reader["Theme"].readIfPresent(with: QuickSightClientTypes.Theme.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeThemeAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThemeAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThemeAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeAlias = try reader["ThemeAlias"].readIfPresent(with: QuickSightClientTypes.ThemeAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeThemePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeThemePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeThemePermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTopicOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topic = try reader["Topic"].readIfPresent(with: QuickSightClientTypes.TopicDetails.read(from:))
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTopicPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTopicPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTopicPermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTopicRefreshOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTopicRefreshOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTopicRefreshOutput()
        value.refreshDetails = try reader["RefreshDetails"].readIfPresent(with: QuickSightClientTypes.TopicRefreshDetails.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeTopicRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTopicRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTopicRefreshScheduleOutput()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.refreshSchedule = try reader["RefreshSchedule"].readIfPresent(with: QuickSightClientTypes.TopicRefreshSchedule.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.user = try reader["User"].readIfPresent(with: QuickSightClientTypes.User.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension DescribeVPCConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVPCConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVPCConnectionOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        value.vpcConnection = try reader["VPCConnection"].readIfPresent(with: QuickSightClientTypes.VPCConnection.read(from:))
        return value
    }
}

extension GenerateEmbedUrlForAnonymousUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateEmbedUrlForAnonymousUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateEmbedUrlForAnonymousUserOutput()
        value.anonymousUserArn = try reader["AnonymousUserArn"].readIfPresent() ?? ""
        value.embedUrl = try reader["EmbedUrl"].readIfPresent() ?? ""
        value.requestId = try reader["RequestId"].readIfPresent() ?? ""
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension GenerateEmbedUrlForRegisteredUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateEmbedUrlForRegisteredUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateEmbedUrlForRegisteredUserOutput()
        value.embedUrl = try reader["EmbedUrl"].readIfPresent() ?? ""
        value.requestId = try reader["RequestId"].readIfPresent() ?? ""
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetDashboardEmbedUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDashboardEmbedUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDashboardEmbedUrlOutput()
        value.embedUrl = try reader["EmbedUrl"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension GetSessionEmbedUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionEmbedUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionEmbedUrlOutput()
        value.embedUrl = try reader["EmbedUrl"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListAnalysesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalysesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalysesOutput()
        value.analysisSummaryList = try reader["AnalysisSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AnalysisSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListAssetBundleExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetBundleExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetBundleExportJobsOutput()
        value.assetBundleExportJobSummaryList = try reader["AssetBundleExportJobSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListAssetBundleImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetBundleImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetBundleImportJobsOutput()
        value.assetBundleImportJobSummaryList = try reader["AssetBundleImportJobSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListDashboardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDashboardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDashboardsOutput()
        value.dashboardSummaryList = try reader["DashboardSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DashboardSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListDashboardVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDashboardVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDashboardVersionsOutput()
        value.dashboardVersionSummaryList = try reader["DashboardVersionSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DashboardVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListDataSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSetsOutput()
        value.dataSetSummaries = try reader["DataSetSummaries"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListFolderMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFolderMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFolderMembersOutput()
        value.folderMemberList = try reader["FolderMemberList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MemberIdArnPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListFoldersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoldersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoldersOutput()
        value.folderSummaryList = try reader["FolderSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FolderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListFoldersForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFoldersForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFoldersForResourceOutput()
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListGroupMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupMembershipsOutput()
        value.groupMemberList = try reader["GroupMemberList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.GroupMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsOutput()
        value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListIAMPolicyAssignmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIAMPolicyAssignmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIAMPolicyAssignmentsOutput()
        value.iamPolicyAssignments = try reader["IAMPolicyAssignments"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.IAMPolicyAssignmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListIAMPolicyAssignmentsForUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIAMPolicyAssignmentsForUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIAMPolicyAssignmentsForUserOutput()
        value.activeAssignments = try reader["ActiveAssignments"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ActiveIAMPolicyAssignment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListIdentityPropagationConfigsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentityPropagationConfigsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentityPropagationConfigsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AuthorizedTargetsByService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListIngestionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngestionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionsOutput()
        value.ingestions = try reader["Ingestions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Ingestion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamespacesOutput()
        value.namespaces = try reader["Namespaces"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.NamespaceInfoV2.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListRefreshSchedulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRefreshSchedulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRefreshSchedulesOutput()
        value.refreshSchedules = try reader["RefreshSchedules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.RefreshSchedule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListRoleMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoleMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoleMembershipsOutput()
        value.membersList = try reader["MembersList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTemplateAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplateAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplateAliasesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateAliasList = try reader["TemplateAliasList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TemplateAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplatesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateSummaryList = try reader["TemplateSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTemplateVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTemplateVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTemplateVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateVersionSummaryList = try reader["TemplateVersionSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TemplateVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListThemeAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThemeAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThemeAliasesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeAliasList = try reader["ThemeAliasList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ThemeAlias.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListThemesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThemesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThemesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeSummaryList = try reader["ThemeSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ThemeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListThemeVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThemeVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThemeVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeVersionSummaryList = try reader["ThemeVersionSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ThemeVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTopicRefreshSchedulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicRefreshSchedulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTopicRefreshSchedulesOutput()
        value.refreshSchedules = try reader["RefreshSchedules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicRefreshScheduleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTopicReviewedAnswersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicReviewedAnswersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTopicReviewedAnswersOutput()
        value.answers = try reader["Answers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicReviewedAnswer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListTopicsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTopicsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicsSummaries = try reader["TopicsSummaries"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListUserGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUserGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUserGroupsOutput()
        value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.userList = try reader["UserList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension ListVPCConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVPCConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVPCConnectionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.vpcConnectionSummaries = try reader["VPCConnectionSummaries"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VPCConnectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension PutDataSetRefreshPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDataSetRefreshPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutDataSetRefreshPropertiesOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension RegisterUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterUserOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.user = try reader["User"].readIfPresent(with: QuickSightClientTypes.User.read(from:))
        value.userInvitationUrl = try reader["UserInvitationUrl"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension RestoreAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RestoreAnalysisOutput()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.restorationFailedFolderArns = try reader["RestorationFailedFolderArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchAnalysesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchAnalysesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchAnalysesOutput()
        value.analysisSummaryList = try reader["AnalysisSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AnalysisSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchDashboardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDashboardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDashboardsOutput()
        value.dashboardSummaryList = try reader["DashboardSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DashboardSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchDataSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDataSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDataSetsOutput()
        value.dataSetSummaries = try reader["DataSetSummaries"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchDataSourcesOutput()
        value.dataSourceSummaries = try reader["DataSourceSummaries"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchFoldersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchFoldersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchFoldersOutput()
        value.folderSummaryList = try reader["FolderSummaryList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FolderSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension SearchGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchGroupsOutput()
        value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension StartAssetBundleExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssetBundleExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAssetBundleExportJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.assetBundleExportJobId = try reader["AssetBundleExportJobId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension StartAssetBundleImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssetBundleImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAssetBundleImportJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.assetBundleImportJobId = try reader["AssetBundleImportJobId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension StartDashboardSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDashboardSnapshotJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDashboardSnapshotJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.snapshotJobId = try reader["SnapshotJobId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension StartDashboardSnapshotJobScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDashboardSnapshotJobScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDashboardSnapshotJobScheduleOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagResourceOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UntagResourceOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateAccountCustomizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountCustomizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountCustomizationOutput()
        value.accountCustomization = try reader["AccountCustomization"].readIfPresent(with: QuickSightClientTypes.AccountCustomization.read(from:))
        value.arn = try reader["Arn"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountSettingsOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateAnalysisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnalysisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnalysisOutput()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateAnalysisPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnalysisPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnalysisPermissionsOutput()
        value.analysisArn = try reader["AnalysisArn"].readIfPresent()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDashboardOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        value.versionArn = try reader["VersionArn"].readIfPresent()
        return value
    }
}

extension UpdateDashboardLinksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardLinksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDashboardLinksOutput()
        value.dashboardArn = try reader["DashboardArn"].readIfPresent()
        value.linkEntities = try reader["LinkEntities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDashboardPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDashboardPermissionsOutput()
        value.dashboardArn = try reader["DashboardArn"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.linkSharingConfiguration = try reader["LinkSharingConfiguration"].readIfPresent(with: QuickSightClientTypes.LinkSharingConfiguration.read(from:))
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDashboardPublishedVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardPublishedVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDashboardPublishedVersionOutput()
        value.dashboardArn = try reader["DashboardArn"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDataSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSetOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.ingestionArn = try reader["IngestionArn"].readIfPresent()
        value.ingestionId = try reader["IngestionId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDataSetPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSetPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSetPermissionsOutput()
        value.dataSetArn = try reader["DataSetArn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateDataSourcePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourcePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourcePermissionsOutput()
        value.dataSourceArn = try reader["DataSourceArn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFolderOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateFolderPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFolderPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFolderPermissionsOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupOutput()
        value.group = try reader["Group"].readIfPresent(with: QuickSightClientTypes.Group.read(from:))
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateIAMPolicyAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIAMPolicyAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIAMPolicyAssignmentOutput()
        value.assignmentId = try reader["AssignmentId"].readIfPresent()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.assignmentStatus = try reader["AssignmentStatus"].readIfPresent()
        value.identities = try reader["Identities"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateIdentityPropagationConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdentityPropagationConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdentityPropagationConfigOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateIpRestrictionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIpRestrictionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIpRestrictionOutput()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateKeyRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKeyRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKeyRegistrationOutput()
        value.failedKeyRegistration = try reader["FailedKeyRegistration"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FailedKeyRegistrationEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.successfulKeyRegistration = try reader["SuccessfulKeyRegistration"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SuccessfulKeyRegistrationEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdatePublicSharingSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePublicSharingSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePublicSharingSettingsOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateQPersonalizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQPersonalizationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateQPersonalizationConfigurationOutput()
        value.personalizationMode = try reader["PersonalizationMode"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRefreshScheduleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.scheduleId = try reader["ScheduleId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateRoleCustomPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRoleCustomPermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoleCustomPermissionOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateSPICECapacityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSPICECapacityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSPICECapacityConfigurationOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTemplateOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.versionArn = try reader["VersionArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTemplateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTemplateAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTemplateAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateAlias = try reader["TemplateAlias"].readIfPresent(with: QuickSightClientTypes.TemplateAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTemplatePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTemplatePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTemplatePermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.templateArn = try reader["TemplateArn"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateThemeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThemeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateThemeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.versionArn = try reader["VersionArn"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateThemeAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThemeAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateThemeAliasOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeAlias = try reader["ThemeAlias"].readIfPresent(with: QuickSightClientTypes.ThemeAlias.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateThemePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThemePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateThemePermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTopicOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.refreshArn = try reader["RefreshArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTopicPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTopicPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTopicPermissionsOutput()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateTopicRefreshScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTopicRefreshScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTopicRefreshScheduleOutput()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.user = try reader["User"].readIfPresent(with: QuickSightClientTypes.User.read(from:))
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

extension UpdateVPCConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVPCConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVPCConnectionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent()
        value.status = httpResponse.statusCode.rawValue
        return value
    }
}

enum BatchCreateTopicReviewedAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteTopicReviewedAnswerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountCustomizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CustomerManagedKeyUnavailableException": return try CustomerManagedKeyUnavailableException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFolderMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIAMPolicyAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentUpdatingException": return try ConcurrentUpdatingException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRoleMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTemplateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateThemeAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTopicRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVPCConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountCustomizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSetRefreshPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFolderMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIAMPolicyAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentUpdatingException": return try ConcurrentUpdatingException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdentityPropagationConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoleCustomPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRoleMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTemplateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteThemeAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTopicRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserByPrincipalIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVPCConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountCustomizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnalysisDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAnalysisPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetBundleExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetBundleImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardSnapshotJobResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataSetPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataSetRefreshPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDataSourcePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFolderPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFolderResolvedPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGroupMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIAMPolicyAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeIpRestrictionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeKeyRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeQPersonalizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRoleCustomPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTemplateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTemplateDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTemplatePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThemeAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeThemePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTopicPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTopicRefreshOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTopicRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVPCConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateEmbedUrlForAnonymousUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SessionLifetimeInMinutesInvalidException": return try SessionLifetimeInMinutesInvalidException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedPricingPlanException": return try UnsupportedPricingPlanException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateEmbedUrlForRegisteredUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "QuickSightUserNotFoundException": return try QuickSightUserNotFoundException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SessionLifetimeInMinutesInvalidException": return try SessionLifetimeInMinutesInvalidException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedPricingPlanException": return try UnsupportedPricingPlanException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDashboardEmbedUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DomainNotWhitelistedException": return try DomainNotWhitelistedException.makeError(baseError: baseError)
            case "IdentityTypeNotSupportedException": return try IdentityTypeNotSupportedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "QuickSightUserNotFoundException": return try QuickSightUserNotFoundException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SessionLifetimeInMinutesInvalidException": return try SessionLifetimeInMinutesInvalidException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedPricingPlanException": return try UnsupportedPricingPlanException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionEmbedUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "QuickSightUserNotFoundException": return try QuickSightUserNotFoundException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SessionLifetimeInMinutesInvalidException": return try SessionLifetimeInMinutesInvalidException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalysesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetBundleExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetBundleImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDashboardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDashboardVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFolderMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoldersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFoldersForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIAMPolicyAssignmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIAMPolicyAssignmentsForUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentUpdatingException": return try ConcurrentUpdatingException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentityPropagationConfigsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngestionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRefreshSchedulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoleMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplateAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTemplateVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThemeAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThemesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThemeVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicRefreshSchedulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicReviewedAnswersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUserGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVPCConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDataSetRefreshPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchAnalysesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDashboardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDataSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchFoldersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssetBundleExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssetBundleImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDashboardSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedPricingPlanException": return try UnsupportedPricingPlanException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDashboardSnapshotJobScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountCustomizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnalysisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnalysisPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardLinksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardPublishedVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSetPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "CustomerManagedKeyUnavailableException": return try CustomerManagedKeyUnavailableException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourcePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFolderPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIAMPolicyAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentUpdatingException": return try ConcurrentUpdatingException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdentityPropagationConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIpRestrictionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKeyRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePublicSharingSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedPricingPlanException": return try UnsupportedPricingPlanException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQPersonalizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRoleCustomPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSPICECapacityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTemplateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTemplatePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThemeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThemeAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThemePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTopicPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTopicRefreshScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceExistsException": return try ResourceExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "PreconditionNotMetException": return try PreconditionNotMetException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVPCConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidParameterValueException": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnsupportedUserEditionException": return try UnsupportedUserEditionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionNotMetException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionNotMetException {
        let reader = baseError.errorBodyReader
        var value = PreconditionNotMetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedUserEditionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedUserEditionException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedUserEditionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomerManagedKeyUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CustomerManagedKeyUnavailableException {
        let reader = baseError.errorBodyReader
        var value = CustomerManagedKeyUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentUpdatingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentUpdatingException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentUpdatingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SessionLifetimeInMinutesInvalidException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SessionLifetimeInMinutesInvalidException {
        let reader = baseError.errorBodyReader
        var value = SessionLifetimeInMinutesInvalidException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedPricingPlanException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedPricingPlanException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedPricingPlanException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QuickSightUserNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QuickSightUserNotFoundException {
        let reader = baseError.errorBodyReader
        var value = QuickSightUserNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdentityTypeNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IdentityTypeNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = IdentityTypeNotSupportedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DomainNotWhitelistedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DomainNotWhitelistedException {
        let reader = baseError.errorBodyReader
        var value = DomainNotWhitelistedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QuickSightClientTypes.SucceededTopicReviewedAnswer {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SucceededTopicReviewedAnswer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SucceededTopicReviewedAnswer()
        value.answerId = try reader["AnswerId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.InvalidTopicReviewedAnswer {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.InvalidTopicReviewedAnswer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.InvalidTopicReviewedAnswer()
        value.answerId = try reader["AnswerId"].readIfPresent()
        value.error = try reader["Error"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AccountCustomization {

    static func write(value: QuickSightClientTypes.AccountCustomization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultEmailCustomizationTemplate"].write(value.defaultEmailCustomizationTemplate)
        try writer["DefaultTheme"].write(value.defaultTheme)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AccountCustomization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AccountCustomization()
        value.defaultTheme = try reader["DefaultTheme"].readIfPresent()
        value.defaultEmailCustomizationTemplate = try reader["DefaultEmailCustomizationTemplate"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SignupResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SignupResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SignupResponse()
        value.iamUser = try reader["IAMUser"].readIfPresent() ?? false
        value.userLoginName = try reader["userLoginName"].readIfPresent()
        value.accountName = try reader["accountName"].readIfPresent()
        value.directoryType = try reader["directoryType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FolderMember {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FolderMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FolderMember()
        value.memberId = try reader["MemberId"].readIfPresent()
        value.memberType = try reader["MemberType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Group {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Group()
        value.arn = try reader["Arn"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GroupMember {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GroupMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GroupMember()
        value.arn = try reader["Arn"].readIfPresent()
        value.memberName = try reader["MemberName"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TemplateAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateAlias()
        value.aliasName = try reader["AliasName"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.templateVersionNumber = try reader["TemplateVersionNumber"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ThemeAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeAlias()
        value.arn = try reader["Arn"].readIfPresent()
        value.aliasName = try reader["AliasName"].readIfPresent()
        value.themeVersionNumber = try reader["ThemeVersionNumber"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AccountSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AccountSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AccountSettings()
        value.accountName = try reader["AccountName"].readIfPresent()
        value.edition = try reader["Edition"].readIfPresent()
        value.defaultNamespace = try reader["DefaultNamespace"].readIfPresent()
        value.notificationEmail = try reader["NotificationEmail"].readIfPresent()
        value.publicSharingEnabled = try reader["PublicSharingEnabled"].readIfPresent() ?? false
        value.terminationProtectionEnabled = try reader["TerminationProtectionEnabled"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.AccountInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AccountInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AccountInfo()
        value.accountName = try reader["AccountName"].readIfPresent()
        value.edition = try reader["Edition"].readIfPresent()
        value.notificationEmail = try reader["NotificationEmail"].readIfPresent()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.accountSubscriptionStatus = try reader["AccountSubscriptionStatus"].readIfPresent()
        value.iamIdentityCenterInstanceArn = try reader["IAMIdentityCenterInstanceArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Analysis {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Analysis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Analysis()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AnalysisError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSetArns = try reader["DataSetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Sheet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.Sheet {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Sheet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Sheet()
        value.sheetId = try reader["SheetId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AnalysisError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnalysisError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnalysisError()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.violatedEntities = try reader["ViolatedEntities"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Entity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.Entity {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Entity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Entity()
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AnalysisDefinition {

    static func write(value: QuickSightClientTypes.AnalysisDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisDefaults"].write(value.analysisDefaults, with: QuickSightClientTypes.AnalysisDefaults.write(value:to:))
        try writer["CalculatedFields"].writeList(value.calculatedFields, memberWritingClosure: QuickSightClientTypes.CalculatedField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnConfigurations"].writeList(value.columnConfigurations, memberWritingClosure: QuickSightClientTypes.ColumnConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetIdentifierDeclarations"].writeList(value.dataSetIdentifierDeclarations, memberWritingClosure: QuickSightClientTypes.DataSetIdentifierDeclaration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterGroups"].writeList(value.filterGroups, memberWritingClosure: QuickSightClientTypes.FilterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Options"].write(value.options, with: QuickSightClientTypes.AssetOptions.write(value:to:))
        try writer["ParameterDeclarations"].writeList(value.parameterDeclarations, memberWritingClosure: QuickSightClientTypes.ParameterDeclaration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryExecutionOptions"].write(value.queryExecutionOptions, with: QuickSightClientTypes.QueryExecutionOptions.write(value:to:))
        try writer["Sheets"].writeList(value.sheets, memberWritingClosure: QuickSightClientTypes.SheetDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnalysisDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnalysisDefinition()
        value.dataSetIdentifierDeclarations = try reader["DataSetIdentifierDeclarations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetIdentifierDeclaration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.calculatedFields = try reader["CalculatedFields"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CalculatedField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterDeclarations = try reader["ParameterDeclarations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ParameterDeclaration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterGroups = try reader["FilterGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnConfigurations = try reader["ColumnConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analysisDefaults = try reader["AnalysisDefaults"].readIfPresent(with: QuickSightClientTypes.AnalysisDefaults.read(from:))
        value.options = try reader["Options"].readIfPresent(with: QuickSightClientTypes.AssetOptions.read(from:))
        value.queryExecutionOptions = try reader["QueryExecutionOptions"].readIfPresent(with: QuickSightClientTypes.QueryExecutionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.QueryExecutionOptions {

    static func write(value: QuickSightClientTypes.QueryExecutionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QueryExecutionMode"].write(value.queryExecutionMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.QueryExecutionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.QueryExecutionOptions()
        value.queryExecutionMode = try reader["QueryExecutionMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetOptions {

    static func write(value: QuickSightClientTypes.AssetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Timezone"].write(value.timezone)
        try writer["WeekStart"].write(value.weekStart)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetOptions()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.weekStart = try reader["WeekStart"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AnalysisDefaults {

    static func write(value: QuickSightClientTypes.AnalysisDefaults?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultNewSheetConfiguration"].write(value.defaultNewSheetConfiguration, with: QuickSightClientTypes.DefaultNewSheetConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnalysisDefaults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnalysisDefaults()
        value.defaultNewSheetConfiguration = try reader["DefaultNewSheetConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultNewSheetConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultNewSheetConfiguration {

    static func write(value: QuickSightClientTypes.DefaultNewSheetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InteractiveLayoutConfiguration"].write(value.interactiveLayoutConfiguration, with: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration.write(value:to:))
        try writer["PaginatedLayoutConfiguration"].write(value.paginatedLayoutConfiguration, with: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration.write(value:to:))
        try writer["SheetContentType"].write(value.sheetContentType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultNewSheetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultNewSheetConfiguration()
        value.interactiveLayoutConfiguration = try reader["InteractiveLayoutConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration.read(from:))
        value.paginatedLayoutConfiguration = try reader["PaginatedLayoutConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration.read(from:))
        value.sheetContentType = try reader["SheetContentType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultPaginatedLayoutConfiguration {

    static func write(value: QuickSightClientTypes.DefaultPaginatedLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SectionBased"].write(value.sectionBased, with: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultPaginatedLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultPaginatedLayoutConfiguration()
        value.sectionBased = try reader["SectionBased"].readIfPresent(with: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration {

    static func write(value: QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultSectionBasedLayoutConfiguration()
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PaperCanvasSizeOptions"].write(value.paperCanvasSizeOptions, with: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions()
        value.paperCanvasSizeOptions = try reader["PaperCanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PaperMargin"].write(value.paperMargin, with: QuickSightClientTypes.Spacing.write(value:to:))
        try writer["PaperOrientation"].write(value.paperOrientation)
        try writer["PaperSize"].write(value.paperSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionBasedLayoutPaperCanvasSizeOptions()
        value.paperSize = try reader["PaperSize"].readIfPresent()
        value.paperOrientation = try reader["PaperOrientation"].readIfPresent()
        value.paperMargin = try reader["PaperMargin"].readIfPresent(with: QuickSightClientTypes.Spacing.read(from:))
        return value
    }
}

extension QuickSightClientTypes.Spacing {

    static func write(value: QuickSightClientTypes.Spacing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bottom"].write(value.bottom)
        try writer["Left"].write(value.`left`)
        try writer["Right"].write(value.`right`)
        try writer["Top"].write(value.top)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Spacing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Spacing()
        value.top = try reader["Top"].readIfPresent()
        value.bottom = try reader["Bottom"].readIfPresent()
        value.`left` = try reader["Left"].readIfPresent()
        value.`right` = try reader["Right"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultInteractiveLayoutConfiguration {

    static func write(value: QuickSightClientTypes.DefaultInteractiveLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FreeForm"].write(value.freeForm, with: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration.write(value:to:))
        try writer["Grid"].write(value.grid, with: QuickSightClientTypes.DefaultGridLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultInteractiveLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultInteractiveLayoutConfiguration()
        value.grid = try reader["Grid"].readIfPresent(with: QuickSightClientTypes.DefaultGridLayoutConfiguration.read(from:))
        value.freeForm = try reader["FreeForm"].readIfPresent(with: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultFreeFormLayoutConfiguration {

    static func write(value: QuickSightClientTypes.DefaultFreeFormLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFreeFormLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFreeFormLayoutConfiguration()
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScreenCanvasSizeOptions"].write(value.screenCanvasSizeOptions, with: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions()
        value.screenCanvasSizeOptions = try reader["ScreenCanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptimizedViewPortWidth"].write(value.optimizedViewPortWidth)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutScreenCanvasSizeOptions()
        value.optimizedViewPortWidth = try reader["OptimizedViewPortWidth"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.DefaultGridLayoutConfiguration {

    static func write(value: QuickSightClientTypes.DefaultGridLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.GridLayoutCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultGridLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultGridLayoutConfiguration()
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.GridLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GridLayoutCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.GridLayoutCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScreenCanvasSizeOptions"].write(value.screenCanvasSizeOptions, with: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GridLayoutCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GridLayoutCanvasSizeOptions()
        value.screenCanvasSizeOptions = try reader["ScreenCanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions {

    static func write(value: QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptimizedViewPortWidth"].write(value.optimizedViewPortWidth)
        try writer["ResizeOption"].write(value.resizeOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GridLayoutScreenCanvasSizeOptions()
        value.resizeOption = try reader["ResizeOption"].readIfPresent() ?? .sdkUnknown("")
        value.optimizedViewPortWidth = try reader["OptimizedViewPortWidth"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ColumnConfiguration {

    static func write(value: QuickSightClientTypes.ColumnConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColorsConfiguration"].write(value.colorsConfiguration, with: QuickSightClientTypes.ColorsConfiguration.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.FormatConfiguration.write(value:to:))
        try writer["Role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnConfiguration()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.FormatConfiguration.read(from:))
        value.role = try reader["Role"].readIfPresent()
        value.colorsConfiguration = try reader["ColorsConfiguration"].readIfPresent(with: QuickSightClientTypes.ColorsConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ColorsConfiguration {

    static func write(value: QuickSightClientTypes.ColorsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomColors"].writeList(value.customColors, memberWritingClosure: QuickSightClientTypes.CustomColor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColorsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColorsConfiguration()
        value.customColors = try reader["CustomColors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CustomColor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CustomColor {

    static func write(value: QuickSightClientTypes.CustomColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["FieldValue"].write(value.fieldValue)
        try writer["SpecialValue"].write(value.specialValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomColor()
        value.fieldValue = try reader["FieldValue"].readIfPresent()
        value.color = try reader["Color"].readIfPresent() ?? ""
        value.specialValue = try reader["SpecialValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FormatConfiguration {

    static func write(value: QuickSightClientTypes.FormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeFormatConfiguration"].write(value.dateTimeFormatConfiguration, with: QuickSightClientTypes.DateTimeFormatConfiguration.write(value:to:))
        try writer["NumberFormatConfiguration"].write(value.numberFormatConfiguration, with: QuickSightClientTypes.NumberFormatConfiguration.write(value:to:))
        try writer["StringFormatConfiguration"].write(value.stringFormatConfiguration, with: QuickSightClientTypes.StringFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FormatConfiguration()
        value.stringFormatConfiguration = try reader["StringFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.StringFormatConfiguration.read(from:))
        value.numberFormatConfiguration = try reader["NumberFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumberFormatConfiguration.read(from:))
        value.dateTimeFormatConfiguration = try reader["DateTimeFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.DateTimeFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateTimeFormatConfiguration {

    static func write(value: QuickSightClientTypes.DateTimeFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeFormat"].write(value.dateTimeFormat)
        try writer["NullValueFormatConfiguration"].write(value.nullValueFormatConfiguration, with: QuickSightClientTypes.NullValueFormatConfiguration.write(value:to:))
        try writer["NumericFormatConfiguration"].write(value.numericFormatConfiguration, with: QuickSightClientTypes.NumericFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeFormatConfiguration()
        value.dateTimeFormat = try reader["DateTimeFormat"].readIfPresent()
        value.nullValueFormatConfiguration = try reader["NullValueFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NullValueFormatConfiguration.read(from:))
        value.numericFormatConfiguration = try reader["NumericFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericFormatConfiguration {

    static func write(value: QuickSightClientTypes.NumericFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrencyDisplayFormatConfiguration"].write(value.currencyDisplayFormatConfiguration, with: QuickSightClientTypes.CurrencyDisplayFormatConfiguration.write(value:to:))
        try writer["NumberDisplayFormatConfiguration"].write(value.numberDisplayFormatConfiguration, with: QuickSightClientTypes.NumberDisplayFormatConfiguration.write(value:to:))
        try writer["PercentageDisplayFormatConfiguration"].write(value.percentageDisplayFormatConfiguration, with: QuickSightClientTypes.PercentageDisplayFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericFormatConfiguration()
        value.numberDisplayFormatConfiguration = try reader["NumberDisplayFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumberDisplayFormatConfiguration.read(from:))
        value.currencyDisplayFormatConfiguration = try reader["CurrencyDisplayFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.CurrencyDisplayFormatConfiguration.read(from:))
        value.percentageDisplayFormatConfiguration = try reader["PercentageDisplayFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.PercentageDisplayFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PercentageDisplayFormatConfiguration {

    static func write(value: QuickSightClientTypes.PercentageDisplayFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalPlacesConfiguration"].write(value.decimalPlacesConfiguration, with: QuickSightClientTypes.DecimalPlacesConfiguration.write(value:to:))
        try writer["NegativeValueConfiguration"].write(value.negativeValueConfiguration, with: QuickSightClientTypes.NegativeValueConfiguration.write(value:to:))
        try writer["NullValueFormatConfiguration"].write(value.nullValueFormatConfiguration, with: QuickSightClientTypes.NullValueFormatConfiguration.write(value:to:))
        try writer["Prefix"].write(value.`prefix`)
        try writer["SeparatorConfiguration"].write(value.separatorConfiguration, with: QuickSightClientTypes.NumericSeparatorConfiguration.write(value:to:))
        try writer["Suffix"].write(value.suffix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PercentageDisplayFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PercentageDisplayFormatConfiguration()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.separatorConfiguration = try reader["SeparatorConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericSeparatorConfiguration.read(from:))
        value.decimalPlacesConfiguration = try reader["DecimalPlacesConfiguration"].readIfPresent(with: QuickSightClientTypes.DecimalPlacesConfiguration.read(from:))
        value.negativeValueConfiguration = try reader["NegativeValueConfiguration"].readIfPresent(with: QuickSightClientTypes.NegativeValueConfiguration.read(from:))
        value.nullValueFormatConfiguration = try reader["NullValueFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NullValueFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NullValueFormatConfiguration {

    static func write(value: QuickSightClientTypes.NullValueFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NullString"].write(value.nullString)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NullValueFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NullValueFormatConfiguration()
        value.nullString = try reader["NullString"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.NegativeValueConfiguration {

    static func write(value: QuickSightClientTypes.NegativeValueConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayMode"].write(value.displayMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NegativeValueConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NegativeValueConfiguration()
        value.displayMode = try reader["DisplayMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.DecimalPlacesConfiguration {

    static func write(value: QuickSightClientTypes.DecimalPlacesConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalPlaces"].write(value.decimalPlaces)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalPlacesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalPlacesConfiguration()
        value.decimalPlaces = try reader["DecimalPlaces"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.NumericSeparatorConfiguration {

    static func write(value: QuickSightClientTypes.NumericSeparatorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalSeparator"].write(value.decimalSeparator)
        try writer["ThousandsSeparator"].write(value.thousandsSeparator, with: QuickSightClientTypes.ThousandSeparatorOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericSeparatorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericSeparatorConfiguration()
        value.decimalSeparator = try reader["DecimalSeparator"].readIfPresent()
        value.thousandsSeparator = try reader["ThousandsSeparator"].readIfPresent(with: QuickSightClientTypes.ThousandSeparatorOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ThousandSeparatorOptions {

    static func write(value: QuickSightClientTypes.ThousandSeparatorOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Symbol"].write(value.symbol)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThousandSeparatorOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThousandSeparatorOptions()
        value.symbol = try reader["Symbol"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CurrencyDisplayFormatConfiguration {

    static func write(value: QuickSightClientTypes.CurrencyDisplayFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalPlacesConfiguration"].write(value.decimalPlacesConfiguration, with: QuickSightClientTypes.DecimalPlacesConfiguration.write(value:to:))
        try writer["NegativeValueConfiguration"].write(value.negativeValueConfiguration, with: QuickSightClientTypes.NegativeValueConfiguration.write(value:to:))
        try writer["NullValueFormatConfiguration"].write(value.nullValueFormatConfiguration, with: QuickSightClientTypes.NullValueFormatConfiguration.write(value:to:))
        try writer["NumberScale"].write(value.numberScale)
        try writer["Prefix"].write(value.`prefix`)
        try writer["SeparatorConfiguration"].write(value.separatorConfiguration, with: QuickSightClientTypes.NumericSeparatorConfiguration.write(value:to:))
        try writer["Suffix"].write(value.suffix)
        try writer["Symbol"].write(value.symbol)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CurrencyDisplayFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CurrencyDisplayFormatConfiguration()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.separatorConfiguration = try reader["SeparatorConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericSeparatorConfiguration.read(from:))
        value.symbol = try reader["Symbol"].readIfPresent()
        value.decimalPlacesConfiguration = try reader["DecimalPlacesConfiguration"].readIfPresent(with: QuickSightClientTypes.DecimalPlacesConfiguration.read(from:))
        value.numberScale = try reader["NumberScale"].readIfPresent()
        value.negativeValueConfiguration = try reader["NegativeValueConfiguration"].readIfPresent(with: QuickSightClientTypes.NegativeValueConfiguration.read(from:))
        value.nullValueFormatConfiguration = try reader["NullValueFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NullValueFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumberDisplayFormatConfiguration {

    static func write(value: QuickSightClientTypes.NumberDisplayFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DecimalPlacesConfiguration"].write(value.decimalPlacesConfiguration, with: QuickSightClientTypes.DecimalPlacesConfiguration.write(value:to:))
        try writer["NegativeValueConfiguration"].write(value.negativeValueConfiguration, with: QuickSightClientTypes.NegativeValueConfiguration.write(value:to:))
        try writer["NullValueFormatConfiguration"].write(value.nullValueFormatConfiguration, with: QuickSightClientTypes.NullValueFormatConfiguration.write(value:to:))
        try writer["NumberScale"].write(value.numberScale)
        try writer["Prefix"].write(value.`prefix`)
        try writer["SeparatorConfiguration"].write(value.separatorConfiguration, with: QuickSightClientTypes.NumericSeparatorConfiguration.write(value:to:))
        try writer["Suffix"].write(value.suffix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumberDisplayFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumberDisplayFormatConfiguration()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.separatorConfiguration = try reader["SeparatorConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericSeparatorConfiguration.read(from:))
        value.decimalPlacesConfiguration = try reader["DecimalPlacesConfiguration"].readIfPresent(with: QuickSightClientTypes.DecimalPlacesConfiguration.read(from:))
        value.numberScale = try reader["NumberScale"].readIfPresent()
        value.negativeValueConfiguration = try reader["NegativeValueConfiguration"].readIfPresent(with: QuickSightClientTypes.NegativeValueConfiguration.read(from:))
        value.nullValueFormatConfiguration = try reader["NullValueFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NullValueFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumberFormatConfiguration {

    static func write(value: QuickSightClientTypes.NumberFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.NumericFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumberFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumberFormatConfiguration()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.StringFormatConfiguration {

    static func write(value: QuickSightClientTypes.StringFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NullValueFormatConfiguration"].write(value.nullValueFormatConfiguration, with: QuickSightClientTypes.NullValueFormatConfiguration.write(value:to:))
        try writer["NumericFormatConfiguration"].write(value.numericFormatConfiguration, with: QuickSightClientTypes.NumericFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringFormatConfiguration()
        value.nullValueFormatConfiguration = try reader["NullValueFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NullValueFormatConfiguration.read(from:))
        value.numericFormatConfiguration = try reader["NumericFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ColumnIdentifier {

    static func write(value: QuickSightClientTypes.ColumnIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnIdentifier()
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.FilterGroup {

    static func write(value: QuickSightClientTypes.FilterGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossDataset"].write(value.crossDataset)
        try writer["FilterGroupId"].write(value.filterGroupId)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ScopeConfiguration"].write(value.scopeConfiguration, with: QuickSightClientTypes.FilterScopeConfiguration.write(value:to:))
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterGroup()
        value.filterGroupId = try reader["FilterGroupId"].readIfPresent() ?? ""
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Filter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.scopeConfiguration = try reader["ScopeConfiguration"].readIfPresent(with: QuickSightClientTypes.FilterScopeConfiguration.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.crossDataset = try reader["CrossDataset"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.FilterScopeConfiguration {

    static func write(value: QuickSightClientTypes.FilterScopeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllSheets"].write(value.allSheets, with: QuickSightClientTypes.AllSheetsFilterScopeConfiguration.write(value:to:))
        try writer["SelectedSheets"].write(value.selectedSheets, with: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterScopeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterScopeConfiguration()
        value.selectedSheets = try reader["SelectedSheets"].readIfPresent(with: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration.read(from:))
        value.allSheets = try reader["AllSheets"].readIfPresent(with: QuickSightClientTypes.AllSheetsFilterScopeConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AllSheetsFilterScopeConfiguration {

    static func write(value: QuickSightClientTypes.AllSheetsFilterScopeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AllSheetsFilterScopeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return QuickSightClientTypes.AllSheetsFilterScopeConfiguration()
    }
}

extension QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration {

    static func write(value: QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SheetVisualScopingConfigurations"].writeList(value.sheetVisualScopingConfigurations, memberWritingClosure: QuickSightClientTypes.SheetVisualScopingConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SelectedSheetsFilterScopeConfiguration()
        value.sheetVisualScopingConfigurations = try reader["SheetVisualScopingConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetVisualScopingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SheetVisualScopingConfiguration {

    static func write(value: QuickSightClientTypes.SheetVisualScopingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Scope"].write(value.scope)
        try writer["SheetId"].write(value.sheetId)
        try writer["VisualIds"].writeList(value.visualIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetVisualScopingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetVisualScopingConfiguration()
        value.sheetId = try reader["SheetId"].readIfPresent() ?? ""
        value.scope = try reader["Scope"].readIfPresent() ?? .sdkUnknown("")
        value.visualIds = try reader["VisualIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.Filter {

    static func write(value: QuickSightClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryFilter"].write(value.categoryFilter, with: QuickSightClientTypes.CategoryFilter.write(value:to:))
        try writer["NestedFilter"].write(value.nestedFilter, with: QuickSightClientTypes.NestedFilter.write(value:to:))
        try writer["NumericEqualityFilter"].write(value.numericEqualityFilter, with: QuickSightClientTypes.NumericEqualityFilter.write(value:to:))
        try writer["NumericRangeFilter"].write(value.numericRangeFilter, with: QuickSightClientTypes.NumericRangeFilter.write(value:to:))
        try writer["RelativeDatesFilter"].write(value.relativeDatesFilter, with: QuickSightClientTypes.RelativeDatesFilter.write(value:to:))
        try writer["TimeEqualityFilter"].write(value.timeEqualityFilter, with: QuickSightClientTypes.TimeEqualityFilter.write(value:to:))
        try writer["TimeRangeFilter"].write(value.timeRangeFilter, with: QuickSightClientTypes.TimeRangeFilter.write(value:to:))
        try writer["TopBottomFilter"].write(value.topBottomFilter, with: QuickSightClientTypes.TopBottomFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Filter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Filter()
        value.categoryFilter = try reader["CategoryFilter"].readIfPresent(with: QuickSightClientTypes.CategoryFilter.read(from:))
        value.numericRangeFilter = try reader["NumericRangeFilter"].readIfPresent(with: QuickSightClientTypes.NumericRangeFilter.read(from:))
        value.numericEqualityFilter = try reader["NumericEqualityFilter"].readIfPresent(with: QuickSightClientTypes.NumericEqualityFilter.read(from:))
        value.timeEqualityFilter = try reader["TimeEqualityFilter"].readIfPresent(with: QuickSightClientTypes.TimeEqualityFilter.read(from:))
        value.timeRangeFilter = try reader["TimeRangeFilter"].readIfPresent(with: QuickSightClientTypes.TimeRangeFilter.read(from:))
        value.relativeDatesFilter = try reader["RelativeDatesFilter"].readIfPresent(with: QuickSightClientTypes.RelativeDatesFilter.read(from:))
        value.topBottomFilter = try reader["TopBottomFilter"].readIfPresent(with: QuickSightClientTypes.TopBottomFilter.read(from:))
        value.nestedFilter = try reader["NestedFilter"].readIfPresent(with: QuickSightClientTypes.NestedFilter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NestedFilter {

    static func write(value: QuickSightClientTypes.NestedFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["IncludeInnerSet"].write(value.includeInnerSet)
        try writer["InnerFilter"].write(value.innerFilter, with: QuickSightClientTypes.InnerFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NestedFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NestedFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.includeInnerSet = try reader["IncludeInnerSet"].readIfPresent() ?? false
        value.innerFilter = try reader["InnerFilter"].readIfPresent(with: QuickSightClientTypes.InnerFilter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.InnerFilter {

    static func write(value: QuickSightClientTypes.InnerFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryInnerFilter"].write(value.categoryInnerFilter, with: QuickSightClientTypes.CategoryInnerFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.InnerFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.InnerFilter()
        value.categoryInnerFilter = try reader["CategoryInnerFilter"].readIfPresent(with: QuickSightClientTypes.CategoryInnerFilter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CategoryInnerFilter {

    static func write(value: QuickSightClientTypes.CategoryInnerFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.CategoryFilterConfiguration.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoryInnerFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoryInnerFilter()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.configuration = try reader["Configuration"].readIfPresent(with: QuickSightClientTypes.CategoryFilterConfiguration.read(from:))
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultFilterControlConfiguration {

    static func write(value: QuickSightClientTypes.DefaultFilterControlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlOptions"].write(value.controlOptions, with: QuickSightClientTypes.DefaultFilterControlOptions.write(value:to:))
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFilterControlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFilterControlConfiguration()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.controlOptions = try reader["ControlOptions"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultFilterControlOptions {

    static func write(value: QuickSightClientTypes.DefaultFilterControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultDateTimePickerOptions"].write(value.defaultDateTimePickerOptions, with: QuickSightClientTypes.DefaultDateTimePickerControlOptions.write(value:to:))
        try writer["DefaultDropdownOptions"].write(value.defaultDropdownOptions, with: QuickSightClientTypes.DefaultFilterDropDownControlOptions.write(value:to:))
        try writer["DefaultListOptions"].write(value.defaultListOptions, with: QuickSightClientTypes.DefaultFilterListControlOptions.write(value:to:))
        try writer["DefaultRelativeDateTimeOptions"].write(value.defaultRelativeDateTimeOptions, with: QuickSightClientTypes.DefaultRelativeDateTimeControlOptions.write(value:to:))
        try writer["DefaultSliderOptions"].write(value.defaultSliderOptions, with: QuickSightClientTypes.DefaultSliderControlOptions.write(value:to:))
        try writer["DefaultTextAreaOptions"].write(value.defaultTextAreaOptions, with: QuickSightClientTypes.DefaultTextAreaControlOptions.write(value:to:))
        try writer["DefaultTextFieldOptions"].write(value.defaultTextFieldOptions, with: QuickSightClientTypes.DefaultTextFieldControlOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFilterControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFilterControlOptions()
        value.defaultDateTimePickerOptions = try reader["DefaultDateTimePickerOptions"].readIfPresent(with: QuickSightClientTypes.DefaultDateTimePickerControlOptions.read(from:))
        value.defaultListOptions = try reader["DefaultListOptions"].readIfPresent(with: QuickSightClientTypes.DefaultFilterListControlOptions.read(from:))
        value.defaultDropdownOptions = try reader["DefaultDropdownOptions"].readIfPresent(with: QuickSightClientTypes.DefaultFilterDropDownControlOptions.read(from:))
        value.defaultTextFieldOptions = try reader["DefaultTextFieldOptions"].readIfPresent(with: QuickSightClientTypes.DefaultTextFieldControlOptions.read(from:))
        value.defaultTextAreaOptions = try reader["DefaultTextAreaOptions"].readIfPresent(with: QuickSightClientTypes.DefaultTextAreaControlOptions.read(from:))
        value.defaultSliderOptions = try reader["DefaultSliderOptions"].readIfPresent(with: QuickSightClientTypes.DefaultSliderControlOptions.read(from:))
        value.defaultRelativeDateTimeOptions = try reader["DefaultRelativeDateTimeOptions"].readIfPresent(with: QuickSightClientTypes.DefaultRelativeDateTimeControlOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultRelativeDateTimeControlOptions {

    static func write(value: QuickSightClientTypes.DefaultRelativeDateTimeControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultRelativeDateTimeControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultRelativeDateTimeControlOptions()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RelativeDateTimeControlDisplayOptions {

    static func write(value: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeFormat"].write(value.dateTimeFormat)
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RelativeDateTimeControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RelativeDateTimeControlDisplayOptions()
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.dateTimeFormat = try reader["DateTimeFormat"].readIfPresent()
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SheetControlInfoIconLabelOptions {

    static func write(value: QuickSightClientTypes.SheetControlInfoIconLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconText"].write(value.infoIconText)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetControlInfoIconLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetControlInfoIconLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.infoIconText = try reader["InfoIconText"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LabelOptions {

    static func write(value: QuickSightClientTypes.LabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FontConfiguration {

    static func write(value: QuickSightClientTypes.FontConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FontColor"].write(value.fontColor)
        try writer["FontDecoration"].write(value.fontDecoration)
        try writer["FontSize"].write(value.fontSize, with: QuickSightClientTypes.FontSize.write(value:to:))
        try writer["FontStyle"].write(value.fontStyle)
        try writer["FontWeight"].write(value.fontWeight, with: QuickSightClientTypes.FontWeight.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FontConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FontConfiguration()
        value.fontSize = try reader["FontSize"].readIfPresent(with: QuickSightClientTypes.FontSize.read(from:))
        value.fontDecoration = try reader["FontDecoration"].readIfPresent()
        value.fontColor = try reader["FontColor"].readIfPresent()
        value.fontWeight = try reader["FontWeight"].readIfPresent(with: QuickSightClientTypes.FontWeight.read(from:))
        value.fontStyle = try reader["FontStyle"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FontWeight {

    static func write(value: QuickSightClientTypes.FontWeight?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FontWeight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FontWeight()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FontSize {

    static func write(value: QuickSightClientTypes.FontSize?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Relative"].write(value.relative)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FontSize {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FontSize()
        value.relative = try reader["Relative"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultSliderControlOptions {

    static func write(value: QuickSightClientTypes.DefaultSliderControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.SliderControlDisplayOptions.write(value:to:))
        try writer["MaximumValue"].write(value.maximumValue)
        try writer["MinimumValue"].write(value.minimumValue)
        try writer["StepSize"].write(value.stepSize)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultSliderControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultSliderControlOptions()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.SliderControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.maximumValue = try reader["MaximumValue"].readIfPresent() ?? 0
        value.minimumValue = try reader["MinimumValue"].readIfPresent() ?? 0
        value.stepSize = try reader["StepSize"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.SliderControlDisplayOptions {

    static func write(value: QuickSightClientTypes.SliderControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SliderControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SliderControlDisplayOptions()
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultTextAreaControlOptions {

    static func write(value: QuickSightClientTypes.DefaultTextAreaControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Delimiter"].write(value.delimiter)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextAreaControlDisplayOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultTextAreaControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultTextAreaControlOptions()
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextAreaControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TextAreaControlDisplayOptions {

    static func write(value: QuickSightClientTypes.TextAreaControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["PlaceholderOptions"].write(value.placeholderOptions, with: QuickSightClientTypes.TextControlPlaceholderOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TextAreaControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TextAreaControlDisplayOptions()
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.placeholderOptions = try reader["PlaceholderOptions"].readIfPresent(with: QuickSightClientTypes.TextControlPlaceholderOptions.read(from:))
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TextControlPlaceholderOptions {

    static func write(value: QuickSightClientTypes.TextControlPlaceholderOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TextControlPlaceholderOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TextControlPlaceholderOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultTextFieldControlOptions {

    static func write(value: QuickSightClientTypes.DefaultTextFieldControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextFieldControlDisplayOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultTextFieldControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultTextFieldControlOptions()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextFieldControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TextFieldControlDisplayOptions {

    static func write(value: QuickSightClientTypes.TextFieldControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["PlaceholderOptions"].write(value.placeholderOptions, with: QuickSightClientTypes.TextControlPlaceholderOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TextFieldControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TextFieldControlDisplayOptions()
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.placeholderOptions = try reader["PlaceholderOptions"].readIfPresent(with: QuickSightClientTypes.TextControlPlaceholderOptions.read(from:))
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DefaultFilterDropDownControlOptions {

    static func write(value: QuickSightClientTypes.DefaultFilterDropDownControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DropDownControlDisplayOptions.write(value:to:))
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.FilterSelectableValues.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFilterDropDownControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFilterDropDownControlOptions()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DropDownControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.FilterSelectableValues.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilterSelectableValues {

    static func write(value: QuickSightClientTypes.FilterSelectableValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterSelectableValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterSelectableValues()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DropDownControlDisplayOptions {

    static func write(value: QuickSightClientTypes.DropDownControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["SelectAllOptions"].write(value.selectAllOptions, with: QuickSightClientTypes.ListControlSelectAllOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DropDownControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DropDownControlDisplayOptions()
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent(with: QuickSightClientTypes.ListControlSelectAllOptions.read(from:))
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ListControlSelectAllOptions {

    static func write(value: QuickSightClientTypes.ListControlSelectAllOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ListControlSelectAllOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ListControlSelectAllOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultFilterListControlOptions {

    static func write(value: QuickSightClientTypes.DefaultFilterListControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.ListControlDisplayOptions.write(value:to:))
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.FilterSelectableValues.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFilterListControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFilterListControlOptions()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.ListControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.FilterSelectableValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ListControlDisplayOptions {

    static func write(value: QuickSightClientTypes.ListControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["SearchOptions"].write(value.searchOptions, with: QuickSightClientTypes.ListControlSearchOptions.write(value:to:))
        try writer["SelectAllOptions"].write(value.selectAllOptions, with: QuickSightClientTypes.ListControlSelectAllOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ListControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ListControlDisplayOptions()
        value.searchOptions = try reader["SearchOptions"].readIfPresent(with: QuickSightClientTypes.ListControlSearchOptions.read(from:))
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent(with: QuickSightClientTypes.ListControlSelectAllOptions.read(from:))
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ListControlSearchOptions {

    static func write(value: QuickSightClientTypes.ListControlSearchOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ListControlSearchOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ListControlSearchOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultDateTimePickerControlOptions {

    static func write(value: QuickSightClientTypes.DefaultDateTimePickerControlOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultDateTimePickerControlOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultDateTimePickerControlOptions()
        value.type = try reader["Type"].readIfPresent()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DateTimePickerControlDisplayOptions {

    static func write(value: QuickSightClientTypes.DateTimePickerControlDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateIconVisibility"].write(value.dateIconVisibility)
        try writer["DateTimeFormat"].write(value.dateTimeFormat)
        try writer["HelperTextVisibility"].write(value.helperTextVisibility)
        try writer["InfoIconLabelOptions"].write(value.infoIconLabelOptions, with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.write(value:to:))
        try writer["TitleOptions"].write(value.titleOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimePickerControlDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimePickerControlDisplayOptions()
        value.titleOptions = try reader["TitleOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.dateTimeFormat = try reader["DateTimeFormat"].readIfPresent()
        value.infoIconLabelOptions = try reader["InfoIconLabelOptions"].readIfPresent(with: QuickSightClientTypes.SheetControlInfoIconLabelOptions.read(from:))
        value.helperTextVisibility = try reader["HelperTextVisibility"].readIfPresent()
        value.dateIconVisibility = try reader["DateIconVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CategoryFilterConfiguration {

    static func write(value: QuickSightClientTypes.CategoryFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomFilterConfiguration"].write(value.customFilterConfiguration, with: QuickSightClientTypes.CustomFilterConfiguration.write(value:to:))
        try writer["CustomFilterListConfiguration"].write(value.customFilterListConfiguration, with: QuickSightClientTypes.CustomFilterListConfiguration.write(value:to:))
        try writer["FilterListConfiguration"].write(value.filterListConfiguration, with: QuickSightClientTypes.FilterListConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoryFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoryFilterConfiguration()
        value.filterListConfiguration = try reader["FilterListConfiguration"].readIfPresent(with: QuickSightClientTypes.FilterListConfiguration.read(from:))
        value.customFilterListConfiguration = try reader["CustomFilterListConfiguration"].readIfPresent(with: QuickSightClientTypes.CustomFilterListConfiguration.read(from:))
        value.customFilterConfiguration = try reader["CustomFilterConfiguration"].readIfPresent(with: QuickSightClientTypes.CustomFilterConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CustomFilterConfiguration {

    static func write(value: QuickSightClientTypes.CustomFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryValue"].write(value.categoryValue)
        try writer["MatchOperator"].write(value.matchOperator)
        try writer["NullOption"].write(value.nullOption)
        try writer["ParameterName"].write(value.parameterName)
        try writer["SelectAllOptions"].write(value.selectAllOptions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomFilterConfiguration()
        value.matchOperator = try reader["MatchOperator"].readIfPresent() ?? .sdkUnknown("")
        value.categoryValue = try reader["CategoryValue"].readIfPresent()
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.CustomFilterListConfiguration {

    static func write(value: QuickSightClientTypes.CustomFilterListConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryValues"].writeList(value.categoryValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchOperator"].write(value.matchOperator)
        try writer["NullOption"].write(value.nullOption)
        try writer["SelectAllOptions"].write(value.selectAllOptions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomFilterListConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomFilterListConfiguration()
        value.matchOperator = try reader["MatchOperator"].readIfPresent() ?? .sdkUnknown("")
        value.categoryValues = try reader["CategoryValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent()
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.FilterListConfiguration {

    static func write(value: QuickSightClientTypes.FilterListConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryValues"].writeList(value.categoryValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchOperator"].write(value.matchOperator)
        try writer["NullOption"].write(value.nullOption)
        try writer["SelectAllOptions"].write(value.selectAllOptions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterListConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterListConfiguration()
        value.matchOperator = try reader["MatchOperator"].readIfPresent() ?? .sdkUnknown("")
        value.categoryValues = try reader["CategoryValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent()
        value.nullOption = try reader["NullOption"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopBottomFilter {

    static func write(value: QuickSightClientTypes.TopBottomFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationSortConfigurations"].writeList(value.aggregationSortConfigurations, memberWritingClosure: QuickSightClientTypes.AggregationSortConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["Limit"].write(value.limit)
        try writer["ParameterName"].write(value.parameterName)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopBottomFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopBottomFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.limit = try reader["Limit"].readIfPresent()
        value.aggregationSortConfigurations = try reader["AggregationSortConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AggregationSortConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AggregationSortConfiguration {

    static func write(value: QuickSightClientTypes.AggregationSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["SortDirection"].write(value.sortDirection)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AggregationSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AggregationSortConfiguration()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.sortDirection = try reader["SortDirection"].readIfPresent() ?? .sdkUnknown("")
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AggregationFunction {

    static func write(value: QuickSightClientTypes.AggregationFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeAggregationFunction"].write(value.attributeAggregationFunction, with: QuickSightClientTypes.AttributeAggregationFunction.write(value:to:))
        try writer["CategoricalAggregationFunction"].write(value.categoricalAggregationFunction)
        try writer["DateAggregationFunction"].write(value.dateAggregationFunction)
        try writer["NumericalAggregationFunction"].write(value.numericalAggregationFunction, with: QuickSightClientTypes.NumericalAggregationFunction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AggregationFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AggregationFunction()
        value.numericalAggregationFunction = try reader["NumericalAggregationFunction"].readIfPresent(with: QuickSightClientTypes.NumericalAggregationFunction.read(from:))
        value.categoricalAggregationFunction = try reader["CategoricalAggregationFunction"].readIfPresent()
        value.dateAggregationFunction = try reader["DateAggregationFunction"].readIfPresent()
        value.attributeAggregationFunction = try reader["AttributeAggregationFunction"].readIfPresent(with: QuickSightClientTypes.AttributeAggregationFunction.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AttributeAggregationFunction {

    static func write(value: QuickSightClientTypes.AttributeAggregationFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SimpleAttributeAggregation"].write(value.simpleAttributeAggregation)
        try writer["ValueForMultipleValues"].write(value.valueForMultipleValues)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AttributeAggregationFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AttributeAggregationFunction()
        value.simpleAttributeAggregation = try reader["SimpleAttributeAggregation"].readIfPresent()
        value.valueForMultipleValues = try reader["ValueForMultipleValues"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.NumericalAggregationFunction {

    static func write(value: QuickSightClientTypes.NumericalAggregationFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PercentileAggregation"].write(value.percentileAggregation, with: QuickSightClientTypes.PercentileAggregation.write(value:to:))
        try writer["SimpleNumericalAggregation"].write(value.simpleNumericalAggregation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericalAggregationFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericalAggregationFunction()
        value.simpleNumericalAggregation = try reader["SimpleNumericalAggregation"].readIfPresent()
        value.percentileAggregation = try reader["PercentileAggregation"].readIfPresent(with: QuickSightClientTypes.PercentileAggregation.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PercentileAggregation {

    static func write(value: QuickSightClientTypes.PercentileAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PercentileValue"].write(value.percentileValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PercentileAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PercentileAggregation()
        value.percentileValue = try reader["PercentileValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RelativeDatesFilter {

    static func write(value: QuickSightClientTypes.RelativeDatesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnchorDateConfiguration"].write(value.anchorDateConfiguration, with: QuickSightClientTypes.AnchorDateConfiguration.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["ExcludePeriodConfiguration"].write(value.excludePeriodConfiguration, with: QuickSightClientTypes.ExcludePeriodConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["MinimumGranularity"].write(value.minimumGranularity)
        try writer["NullOption"].write(value.nullOption)
        try writer["ParameterName"].write(value.parameterName)
        try writer["RelativeDateType"].write(value.relativeDateType)
        try writer["RelativeDateValue"].write(value.relativeDateValue)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RelativeDatesFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RelativeDatesFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.anchorDateConfiguration = try reader["AnchorDateConfiguration"].readIfPresent(with: QuickSightClientTypes.AnchorDateConfiguration.read(from:))
        value.minimumGranularity = try reader["MinimumGranularity"].readIfPresent()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent() ?? .sdkUnknown("")
        value.relativeDateType = try reader["RelativeDateType"].readIfPresent() ?? .sdkUnknown("")
        value.relativeDateValue = try reader["RelativeDateValue"].readIfPresent()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        value.excludePeriodConfiguration = try reader["ExcludePeriodConfiguration"].readIfPresent(with: QuickSightClientTypes.ExcludePeriodConfiguration.read(from:))
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ExcludePeriodConfiguration {

    static func write(value: QuickSightClientTypes.ExcludePeriodConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amount"].write(value.amount)
        try writer["Granularity"].write(value.granularity)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExcludePeriodConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExcludePeriodConfiguration()
        value.amount = try reader["Amount"].readIfPresent()
        value.granularity = try reader["Granularity"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AnchorDateConfiguration {

    static func write(value: QuickSightClientTypes.AnchorDateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnchorOption"].write(value.anchorOption)
        try writer["ParameterName"].write(value.parameterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnchorDateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnchorDateConfiguration()
        value.anchorOption = try reader["AnchorOption"].readIfPresent()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TimeRangeFilter {

    static func write(value: QuickSightClientTypes.TimeRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["ExcludePeriodConfiguration"].write(value.excludePeriodConfiguration, with: QuickSightClientTypes.ExcludePeriodConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["IncludeMaximum"].write(value.includeMaximum)
        try writer["IncludeMinimum"].write(value.includeMinimum)
        try writer["NullOption"].write(value.nullOption)
        try writer["RangeMaximumValue"].write(value.rangeMaximumValue, with: QuickSightClientTypes.TimeRangeFilterValue.write(value:to:))
        try writer["RangeMinimumValue"].write(value.rangeMinimumValue, with: QuickSightClientTypes.TimeRangeFilterValue.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TimeRangeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TimeRangeFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.includeMinimum = try reader["IncludeMinimum"].readIfPresent()
        value.includeMaximum = try reader["IncludeMaximum"].readIfPresent()
        value.rangeMinimumValue = try reader["RangeMinimumValue"].readIfPresent(with: QuickSightClientTypes.TimeRangeFilterValue.read(from:))
        value.rangeMaximumValue = try reader["RangeMaximumValue"].readIfPresent(with: QuickSightClientTypes.TimeRangeFilterValue.read(from:))
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        value.excludePeriodConfiguration = try reader["ExcludePeriodConfiguration"].readIfPresent(with: QuickSightClientTypes.ExcludePeriodConfiguration.read(from:))
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TimeRangeFilterValue {

    static func write(value: QuickSightClientTypes.TimeRangeFilterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Parameter"].write(value.parameter)
        try writer["RollingDate"].write(value.rollingDate, with: QuickSightClientTypes.RollingDateConfiguration.write(value:to:))
        try writer["StaticValue"].writeTimestamp(value.staticValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TimeRangeFilterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TimeRangeFilterValue()
        value.staticValue = try reader["StaticValue"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rollingDate = try reader["RollingDate"].readIfPresent(with: QuickSightClientTypes.RollingDateConfiguration.read(from:))
        value.parameter = try reader["Parameter"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RollingDateConfiguration {

    static func write(value: QuickSightClientTypes.RollingDateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RollingDateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RollingDateConfiguration()
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.TimeEqualityFilter {

    static func write(value: QuickSightClientTypes.TimeEqualityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["ParameterName"].write(value.parameterName)
        try writer["RollingDate"].write(value.rollingDate, with: QuickSightClientTypes.RollingDateConfiguration.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
        try writer["Value"].writeTimestamp(value.value, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TimeEqualityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TimeEqualityFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.value = try reader["Value"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.rollingDate = try reader["RollingDate"].readIfPresent(with: QuickSightClientTypes.RollingDateConfiguration.read(from:))
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericEqualityFilter {

    static func write(value: QuickSightClientTypes.NumericEqualityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["MatchOperator"].write(value.matchOperator)
        try writer["NullOption"].write(value.nullOption)
        try writer["ParameterName"].write(value.parameterName)
        try writer["SelectAllOptions"].write(value.selectAllOptions)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericEqualityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericEqualityFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.value = try reader["Value"].readIfPresent()
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent()
        value.matchOperator = try reader["MatchOperator"].readIfPresent() ?? .sdkUnknown("")
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericRangeFilter {

    static func write(value: QuickSightClientTypes.NumericRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
        try writer["IncludeMaximum"].write(value.includeMaximum)
        try writer["IncludeMinimum"].write(value.includeMinimum)
        try writer["NullOption"].write(value.nullOption)
        try writer["RangeMaximum"].write(value.rangeMaximum, with: QuickSightClientTypes.NumericRangeFilterValue.write(value:to:))
        try writer["RangeMinimum"].write(value.rangeMinimum, with: QuickSightClientTypes.NumericRangeFilterValue.write(value:to:))
        try writer["SelectAllOptions"].write(value.selectAllOptions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericRangeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericRangeFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.includeMinimum = try reader["IncludeMinimum"].readIfPresent()
        value.includeMaximum = try reader["IncludeMaximum"].readIfPresent()
        value.rangeMinimum = try reader["RangeMinimum"].readIfPresent(with: QuickSightClientTypes.NumericRangeFilterValue.read(from:))
        value.rangeMaximum = try reader["RangeMaximum"].readIfPresent(with: QuickSightClientTypes.NumericRangeFilterValue.read(from:))
        value.selectAllOptions = try reader["SelectAllOptions"].readIfPresent()
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        value.nullOption = try reader["NullOption"].readIfPresent() ?? .sdkUnknown("")
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericRangeFilterValue {

    static func write(value: QuickSightClientTypes.NumericRangeFilterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Parameter"].write(value.parameter)
        try writer["StaticValue"].write(value.staticValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericRangeFilterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericRangeFilterValue()
        value.staticValue = try reader["StaticValue"].readIfPresent()
        value.parameter = try reader["Parameter"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CategoryFilter {

    static func write(value: QuickSightClientTypes.CategoryFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.CategoryFilterConfiguration.write(value:to:))
        try writer["DefaultFilterControlConfiguration"].write(value.defaultFilterControlConfiguration, with: QuickSightClientTypes.DefaultFilterControlConfiguration.write(value:to:))
        try writer["FilterId"].write(value.filterId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoryFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoryFilter()
        value.filterId = try reader["FilterId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.configuration = try reader["Configuration"].readIfPresent(with: QuickSightClientTypes.CategoryFilterConfiguration.read(from:))
        value.defaultFilterControlConfiguration = try reader["DefaultFilterControlConfiguration"].readIfPresent(with: QuickSightClientTypes.DefaultFilterControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterDeclaration {

    static func write(value: QuickSightClientTypes.ParameterDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeParameterDeclaration"].write(value.dateTimeParameterDeclaration, with: QuickSightClientTypes.DateTimeParameterDeclaration.write(value:to:))
        try writer["DecimalParameterDeclaration"].write(value.decimalParameterDeclaration, with: QuickSightClientTypes.DecimalParameterDeclaration.write(value:to:))
        try writer["IntegerParameterDeclaration"].write(value.integerParameterDeclaration, with: QuickSightClientTypes.IntegerParameterDeclaration.write(value:to:))
        try writer["StringParameterDeclaration"].write(value.stringParameterDeclaration, with: QuickSightClientTypes.StringParameterDeclaration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterDeclaration()
        value.stringParameterDeclaration = try reader["StringParameterDeclaration"].readIfPresent(with: QuickSightClientTypes.StringParameterDeclaration.read(from:))
        value.decimalParameterDeclaration = try reader["DecimalParameterDeclaration"].readIfPresent(with: QuickSightClientTypes.DecimalParameterDeclaration.read(from:))
        value.integerParameterDeclaration = try reader["IntegerParameterDeclaration"].readIfPresent(with: QuickSightClientTypes.IntegerParameterDeclaration.read(from:))
        value.dateTimeParameterDeclaration = try reader["DateTimeParameterDeclaration"].readIfPresent(with: QuickSightClientTypes.DateTimeParameterDeclaration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateTimeParameterDeclaration {

    static func write(value: QuickSightClientTypes.DateTimeParameterDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.DateTimeDefaultValues.write(value:to:))
        try writer["MappedDataSetParameters"].writeList(value.mappedDataSetParameters, memberWritingClosure: QuickSightClientTypes.MappedDataSetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["TimeGranularity"].write(value.timeGranularity)
        try writer["ValueWhenUnset"].write(value.valueWhenUnset, with: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeParameterDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeParameterDeclaration()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.DateTimeDefaultValues.read(from:))
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.valueWhenUnset = try reader["ValueWhenUnset"].readIfPresent(with: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration.read(from:))
        value.mappedDataSetParameters = try reader["MappedDataSetParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MappedDataSetParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.MappedDataSetParameter {

    static func write(value: QuickSightClientTypes.MappedDataSetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["DataSetParameterName"].write(value.dataSetParameterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MappedDataSetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MappedDataSetParameter()
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        value.dataSetParameterName = try reader["DataSetParameterName"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration {

    static func write(value: QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValue"].writeTimestamp(value.customValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ValueWhenUnsetOption"].write(value.valueWhenUnsetOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeValueWhenUnsetConfiguration()
        value.valueWhenUnsetOption = try reader["ValueWhenUnsetOption"].readIfPresent()
        value.customValue = try reader["CustomValue"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.DateTimeDefaultValues {

    static func write(value: QuickSightClientTypes.DateTimeDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicValue"].write(value.dynamicValue, with: QuickSightClientTypes.DynamicDefaultValue.write(value:to:))
        try writer["RollingDate"].write(value.rollingDate, with: QuickSightClientTypes.RollingDateConfiguration.write(value:to:))
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.timestampWritingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeDefaultValues()
        value.dynamicValue = try reader["DynamicValue"].readIfPresent(with: QuickSightClientTypes.DynamicDefaultValue.read(from:))
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        value.rollingDate = try reader["RollingDate"].readIfPresent(with: QuickSightClientTypes.RollingDateConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DynamicDefaultValue {

    static func write(value: QuickSightClientTypes.DynamicDefaultValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValueColumn"].write(value.defaultValueColumn, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["GroupNameColumn"].write(value.groupNameColumn, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["UserNameColumn"].write(value.userNameColumn, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DynamicDefaultValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DynamicDefaultValue()
        value.userNameColumn = try reader["UserNameColumn"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.groupNameColumn = try reader["GroupNameColumn"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.defaultValueColumn = try reader["DefaultValueColumn"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        return value
    }
}

extension QuickSightClientTypes.IntegerParameterDeclaration {

    static func write(value: QuickSightClientTypes.IntegerParameterDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.IntegerDefaultValues.write(value:to:))
        try writer["MappedDataSetParameters"].writeList(value.mappedDataSetParameters, memberWritingClosure: QuickSightClientTypes.MappedDataSetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterValueType"].write(value.parameterValueType)
        try writer["ValueWhenUnset"].write(value.valueWhenUnset, with: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerParameterDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerParameterDeclaration()
        value.parameterValueType = try reader["ParameterValueType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.IntegerDefaultValues.read(from:))
        value.valueWhenUnset = try reader["ValueWhenUnset"].readIfPresent(with: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration.read(from:))
        value.mappedDataSetParameters = try reader["MappedDataSetParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MappedDataSetParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.IntegerValueWhenUnsetConfiguration {

    static func write(value: QuickSightClientTypes.IntegerValueWhenUnsetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValue"].write(value.customValue)
        try writer["ValueWhenUnsetOption"].write(value.valueWhenUnsetOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerValueWhenUnsetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerValueWhenUnsetConfiguration()
        value.valueWhenUnsetOption = try reader["ValueWhenUnsetOption"].readIfPresent()
        value.customValue = try reader["CustomValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.IntegerDefaultValues {

    static func write(value: QuickSightClientTypes.IntegerDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicValue"].write(value.dynamicValue, with: QuickSightClientTypes.DynamicDefaultValue.write(value:to:))
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerDefaultValues()
        value.dynamicValue = try reader["DynamicValue"].readIfPresent(with: QuickSightClientTypes.DynamicDefaultValue.read(from:))
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DecimalParameterDeclaration {

    static func write(value: QuickSightClientTypes.DecimalParameterDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.DecimalDefaultValues.write(value:to:))
        try writer["MappedDataSetParameters"].writeList(value.mappedDataSetParameters, memberWritingClosure: QuickSightClientTypes.MappedDataSetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterValueType"].write(value.parameterValueType)
        try writer["ValueWhenUnset"].write(value.valueWhenUnset, with: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalParameterDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalParameterDeclaration()
        value.parameterValueType = try reader["ParameterValueType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.DecimalDefaultValues.read(from:))
        value.valueWhenUnset = try reader["ValueWhenUnset"].readIfPresent(with: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration.read(from:))
        value.mappedDataSetParameters = try reader["MappedDataSetParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MappedDataSetParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DecimalValueWhenUnsetConfiguration {

    static func write(value: QuickSightClientTypes.DecimalValueWhenUnsetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValue"].write(value.customValue)
        try writer["ValueWhenUnsetOption"].write(value.valueWhenUnsetOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalValueWhenUnsetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalValueWhenUnsetConfiguration()
        value.valueWhenUnsetOption = try reader["ValueWhenUnsetOption"].readIfPresent()
        value.customValue = try reader["CustomValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DecimalDefaultValues {

    static func write(value: QuickSightClientTypes.DecimalDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicValue"].write(value.dynamicValue, with: QuickSightClientTypes.DynamicDefaultValue.write(value:to:))
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalDefaultValues()
        value.dynamicValue = try reader["DynamicValue"].readIfPresent(with: QuickSightClientTypes.DynamicDefaultValue.read(from:))
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.StringParameterDeclaration {

    static func write(value: QuickSightClientTypes.StringParameterDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.StringDefaultValues.write(value:to:))
        try writer["MappedDataSetParameters"].writeList(value.mappedDataSetParameters, memberWritingClosure: QuickSightClientTypes.MappedDataSetParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterValueType"].write(value.parameterValueType)
        try writer["ValueWhenUnset"].write(value.valueWhenUnset, with: QuickSightClientTypes.StringValueWhenUnsetConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringParameterDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringParameterDeclaration()
        value.parameterValueType = try reader["ParameterValueType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.StringDefaultValues.read(from:))
        value.valueWhenUnset = try reader["ValueWhenUnset"].readIfPresent(with: QuickSightClientTypes.StringValueWhenUnsetConfiguration.read(from:))
        value.mappedDataSetParameters = try reader["MappedDataSetParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MappedDataSetParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.StringValueWhenUnsetConfiguration {

    static func write(value: QuickSightClientTypes.StringValueWhenUnsetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValue"].write(value.customValue)
        try writer["ValueWhenUnsetOption"].write(value.valueWhenUnsetOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringValueWhenUnsetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringValueWhenUnsetConfiguration()
        value.valueWhenUnsetOption = try reader["ValueWhenUnsetOption"].readIfPresent()
        value.customValue = try reader["CustomValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.StringDefaultValues {

    static func write(value: QuickSightClientTypes.StringDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicValue"].write(value.dynamicValue, with: QuickSightClientTypes.DynamicDefaultValue.write(value:to:))
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringDefaultValues()
        value.dynamicValue = try reader["DynamicValue"].readIfPresent(with: QuickSightClientTypes.DynamicDefaultValue.read(from:))
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CalculatedField {

    static func write(value: QuickSightClientTypes.CalculatedField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["Expression"].write(value.expression)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CalculatedField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CalculatedField()
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.SheetDefinition {

    static func write(value: QuickSightClientTypes.SheetDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["Description"].write(value.description)
        try writer["FilterControls"].writeList(value.filterControls, memberWritingClosure: QuickSightClientTypes.FilterControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Layouts"].writeList(value.layouts, memberWritingClosure: QuickSightClientTypes.Layout.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ParameterControls"].writeList(value.parameterControls, memberWritingClosure: QuickSightClientTypes.ParameterControl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SheetControlLayouts"].writeList(value.sheetControlLayouts, memberWritingClosure: QuickSightClientTypes.SheetControlLayout.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SheetId"].write(value.sheetId)
        try writer["TextBoxes"].writeList(value.textBoxes, memberWritingClosure: QuickSightClientTypes.SheetTextBox.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].write(value.title)
        try writer["Visuals"].writeList(value.visuals, memberWritingClosure: QuickSightClientTypes.Visual.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetDefinition()
        value.sheetId = try reader["SheetId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.parameterControls = try reader["ParameterControls"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ParameterControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterControls = try reader["FilterControls"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilterControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.visuals = try reader["Visuals"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Visual.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.textBoxes = try reader["TextBoxes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetTextBox.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.layouts = try reader["Layouts"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Layout.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sheetControlLayouts = try reader["SheetControlLayouts"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetControlLayout.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contentType = try reader["ContentType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SheetControlLayout {

    static func write(value: QuickSightClientTypes.SheetControlLayout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.SheetControlLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetControlLayout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetControlLayout()
        value.configuration = try reader["Configuration"].readIfPresent(with: QuickSightClientTypes.SheetControlLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SheetControlLayoutConfiguration {

    static func write(value: QuickSightClientTypes.SheetControlLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GridLayout"].write(value.gridLayout, with: QuickSightClientTypes.GridLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetControlLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetControlLayoutConfiguration()
        value.gridLayout = try reader["GridLayout"].readIfPresent(with: QuickSightClientTypes.GridLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GridLayoutConfiguration {

    static func write(value: QuickSightClientTypes.GridLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.GridLayoutCanvasSizeOptions.write(value:to:))
        try writer["Elements"].writeList(value.elements, memberWritingClosure: QuickSightClientTypes.GridLayoutElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GridLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GridLayoutConfiguration()
        value.elements = try reader["Elements"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.GridLayoutElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.GridLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GridLayoutElement {

    static func write(value: QuickSightClientTypes.GridLayoutElement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnIndex"].write(value.columnIndex)
        try writer["ColumnSpan"].write(value.columnSpan)
        try writer["ElementId"].write(value.elementId)
        try writer["ElementType"].write(value.elementType)
        try writer["RowIndex"].write(value.rowIndex)
        try writer["RowSpan"].write(value.rowSpan)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GridLayoutElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GridLayoutElement()
        value.elementId = try reader["ElementId"].readIfPresent() ?? ""
        value.elementType = try reader["ElementType"].readIfPresent() ?? .sdkUnknown("")
        value.columnIndex = try reader["ColumnIndex"].readIfPresent()
        value.columnSpan = try reader["ColumnSpan"].readIfPresent() ?? 0
        value.rowIndex = try reader["RowIndex"].readIfPresent()
        value.rowSpan = try reader["RowSpan"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.Layout {

    static func write(value: QuickSightClientTypes.Layout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: QuickSightClientTypes.LayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Layout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Layout()
        value.configuration = try reader["Configuration"].readIfPresent(with: QuickSightClientTypes.LayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LayoutConfiguration {

    static func write(value: QuickSightClientTypes.LayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FreeFormLayout"].write(value.freeFormLayout, with: QuickSightClientTypes.FreeFormLayoutConfiguration.write(value:to:))
        try writer["GridLayout"].write(value.gridLayout, with: QuickSightClientTypes.GridLayoutConfiguration.write(value:to:))
        try writer["SectionBasedLayout"].write(value.sectionBasedLayout, with: QuickSightClientTypes.SectionBasedLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LayoutConfiguration()
        value.gridLayout = try reader["GridLayout"].readIfPresent(with: QuickSightClientTypes.GridLayoutConfiguration.read(from:))
        value.freeFormLayout = try reader["FreeFormLayout"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutConfiguration.read(from:))
        value.sectionBasedLayout = try reader["SectionBasedLayout"].readIfPresent(with: QuickSightClientTypes.SectionBasedLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionBasedLayoutConfiguration {

    static func write(value: QuickSightClientTypes.SectionBasedLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BodySections"].writeList(value.bodySections, memberWritingClosure: QuickSightClientTypes.BodySectionConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.write(value:to:))
        try writer["FooterSections"].writeList(value.footerSections, memberWritingClosure: QuickSightClientTypes.HeaderFooterSectionConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HeaderSections"].writeList(value.headerSections, memberWritingClosure: QuickSightClientTypes.HeaderFooterSectionConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionBasedLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionBasedLayoutConfiguration()
        value.headerSections = try reader["HeaderSections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.HeaderFooterSectionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.bodySections = try reader["BodySections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.BodySectionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.footerSections = try reader["FooterSections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.HeaderFooterSectionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.SectionBasedLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.HeaderFooterSectionConfiguration {

    static func write(value: QuickSightClientTypes.HeaderFooterSectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Layout"].write(value.layout, with: QuickSightClientTypes.SectionLayoutConfiguration.write(value:to:))
        try writer["SectionId"].write(value.sectionId)
        try writer["Style"].write(value.style, with: QuickSightClientTypes.SectionStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeaderFooterSectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeaderFooterSectionConfiguration()
        value.sectionId = try reader["SectionId"].readIfPresent() ?? ""
        value.layout = try reader["Layout"].readIfPresent(with: QuickSightClientTypes.SectionLayoutConfiguration.read(from:))
        value.style = try reader["Style"].readIfPresent(with: QuickSightClientTypes.SectionStyle.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionStyle {

    static func write(value: QuickSightClientTypes.SectionStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Height"].write(value.height)
        try writer["Padding"].write(value.padding, with: QuickSightClientTypes.Spacing.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionStyle()
        value.height = try reader["Height"].readIfPresent()
        value.padding = try reader["Padding"].readIfPresent(with: QuickSightClientTypes.Spacing.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionLayoutConfiguration {

    static func write(value: QuickSightClientTypes.SectionLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FreeFormLayout"].write(value.freeFormLayout, with: QuickSightClientTypes.FreeFormSectionLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionLayoutConfiguration()
        value.freeFormLayout = try reader["FreeFormLayout"].readIfPresent(with: QuickSightClientTypes.FreeFormSectionLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FreeFormSectionLayoutConfiguration {

    static func write(value: QuickSightClientTypes.FreeFormSectionLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Elements"].writeList(value.elements, memberWritingClosure: QuickSightClientTypes.FreeFormLayoutElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormSectionLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormSectionLayoutConfiguration()
        value.elements = try reader["Elements"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FreeFormLayoutElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutElement {

    static func write(value: QuickSightClientTypes.FreeFormLayoutElement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundStyle"].write(value.backgroundStyle, with: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle.write(value:to:))
        try writer["BorderStyle"].write(value.borderStyle, with: QuickSightClientTypes.FreeFormLayoutElementBorderStyle.write(value:to:))
        try writer["ElementId"].write(value.elementId)
        try writer["ElementType"].write(value.elementType)
        try writer["Height"].write(value.height)
        try writer["LoadingAnimation"].write(value.loadingAnimation, with: QuickSightClientTypes.LoadingAnimation.write(value:to:))
        try writer["RenderingRules"].writeList(value.renderingRules, memberWritingClosure: QuickSightClientTypes.SheetElementRenderingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelectedBorderStyle"].write(value.selectedBorderStyle, with: QuickSightClientTypes.FreeFormLayoutElementBorderStyle.write(value:to:))
        try writer["Visibility"].write(value.visibility)
        try writer["Width"].write(value.width)
        try writer["XAxisLocation"].write(value.xAxisLocation)
        try writer["YAxisLocation"].write(value.yAxisLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutElement()
        value.elementId = try reader["ElementId"].readIfPresent() ?? ""
        value.elementType = try reader["ElementType"].readIfPresent() ?? .sdkUnknown("")
        value.xAxisLocation = try reader["XAxisLocation"].readIfPresent() ?? ""
        value.yAxisLocation = try reader["YAxisLocation"].readIfPresent() ?? ""
        value.width = try reader["Width"].readIfPresent() ?? ""
        value.height = try reader["Height"].readIfPresent() ?? ""
        value.visibility = try reader["Visibility"].readIfPresent()
        value.renderingRules = try reader["RenderingRules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetElementRenderingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.borderStyle = try reader["BorderStyle"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutElementBorderStyle.read(from:))
        value.selectedBorderStyle = try reader["SelectedBorderStyle"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutElementBorderStyle.read(from:))
        value.backgroundStyle = try reader["BackgroundStyle"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle.read(from:))
        value.loadingAnimation = try reader["LoadingAnimation"].readIfPresent(with: QuickSightClientTypes.LoadingAnimation.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LoadingAnimation {

    static func write(value: QuickSightClientTypes.LoadingAnimation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LoadingAnimation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LoadingAnimation()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle {

    static func write(value: QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutElementBackgroundStyle()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutElementBorderStyle {

    static func write(value: QuickSightClientTypes.FreeFormLayoutElementBorderStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutElementBorderStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutElementBorderStyle()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SheetElementRenderingRule {

    static func write(value: QuickSightClientTypes.SheetElementRenderingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationOverrides"].write(value.configurationOverrides, with: QuickSightClientTypes.SheetElementConfigurationOverrides.write(value:to:))
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetElementRenderingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetElementRenderingRule()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.configurationOverrides = try reader["ConfigurationOverrides"].readIfPresent(with: QuickSightClientTypes.SheetElementConfigurationOverrides.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SheetElementConfigurationOverrides {

    static func write(value: QuickSightClientTypes.SheetElementConfigurationOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetElementConfigurationOverrides {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetElementConfigurationOverrides()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BodySectionConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content, with: QuickSightClientTypes.BodySectionContent.write(value:to:))
        try writer["PageBreakConfiguration"].write(value.pageBreakConfiguration, with: QuickSightClientTypes.SectionPageBreakConfiguration.write(value:to:))
        try writer["RepeatConfiguration"].write(value.repeatConfiguration, with: QuickSightClientTypes.BodySectionRepeatConfiguration.write(value:to:))
        try writer["SectionId"].write(value.sectionId)
        try writer["Style"].write(value.style, with: QuickSightClientTypes.SectionStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionConfiguration()
        value.sectionId = try reader["SectionId"].readIfPresent() ?? ""
        value.content = try reader["Content"].readIfPresent(with: QuickSightClientTypes.BodySectionContent.read(from:))
        value.style = try reader["Style"].readIfPresent(with: QuickSightClientTypes.SectionStyle.read(from:))
        value.pageBreakConfiguration = try reader["PageBreakConfiguration"].readIfPresent(with: QuickSightClientTypes.SectionPageBreakConfiguration.read(from:))
        value.repeatConfiguration = try reader["RepeatConfiguration"].readIfPresent(with: QuickSightClientTypes.BodySectionRepeatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BodySectionRepeatConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionRepeatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionConfigurations"].writeList(value.dimensionConfigurations, memberWritingClosure: QuickSightClientTypes.BodySectionRepeatDimensionConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NonRepeatingVisuals"].writeList(value.nonRepeatingVisuals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PageBreakConfiguration"].write(value.pageBreakConfiguration, with: QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionRepeatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionRepeatConfiguration()
        value.dimensionConfigurations = try reader["DimensionConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.BodySectionRepeatDimensionConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pageBreakConfiguration = try reader["PageBreakConfiguration"].readIfPresent(with: QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration.read(from:))
        value.nonRepeatingVisuals = try reader["NonRepeatingVisuals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["After"].write(value.after, with: QuickSightClientTypes.SectionAfterPageBreak.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionRepeatPageBreakConfiguration()
        value.after = try reader["After"].readIfPresent(with: QuickSightClientTypes.SectionAfterPageBreak.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SectionAfterPageBreak {

    static func write(value: QuickSightClientTypes.SectionAfterPageBreak?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionAfterPageBreak {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionAfterPageBreak()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BodySectionRepeatDimensionConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionRepeatDimensionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DynamicCategoryDimensionConfiguration"].write(value.dynamicCategoryDimensionConfiguration, with: QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration.write(value:to:))
        try writer["DynamicNumericDimensionConfiguration"].write(value.dynamicNumericDimensionConfiguration, with: QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionRepeatDimensionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionRepeatDimensionConfiguration()
        value.dynamicCategoryDimensionConfiguration = try reader["DynamicCategoryDimensionConfiguration"].readIfPresent(with: QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration.read(from:))
        value.dynamicNumericDimensionConfiguration = try reader["DynamicNumericDimensionConfiguration"].readIfPresent(with: QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["SortByMetrics"].writeList(value.sortByMetrics, memberWritingClosure: QuickSightClientTypes.ColumnSort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionDynamicNumericDimensionConfiguration()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.limit = try reader["Limit"].readIfPresent()
        value.sortByMetrics = try reader["SortByMetrics"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnSort.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnSort {

    static func write(value: QuickSightClientTypes.ColumnSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
        try writer["Direction"].write(value.direction)
        try writer["SortBy"].write(value.sortBy, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnSort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnSort()
        value.sortBy = try reader["SortBy"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.direction = try reader["Direction"].readIfPresent() ?? .sdkUnknown("")
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration {

    static func write(value: QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["SortByMetrics"].writeList(value.sortByMetrics, memberWritingClosure: QuickSightClientTypes.ColumnSort.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionDynamicCategoryDimensionConfiguration()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.limit = try reader["Limit"].readIfPresent()
        value.sortByMetrics = try reader["SortByMetrics"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnSort.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SectionPageBreakConfiguration {

    static func write(value: QuickSightClientTypes.SectionPageBreakConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["After"].write(value.after, with: QuickSightClientTypes.SectionAfterPageBreak.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SectionPageBreakConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SectionPageBreakConfiguration()
        value.after = try reader["After"].readIfPresent(with: QuickSightClientTypes.SectionAfterPageBreak.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BodySectionContent {

    static func write(value: QuickSightClientTypes.BodySectionContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Layout"].write(value.layout, with: QuickSightClientTypes.SectionLayoutConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BodySectionContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BodySectionContent()
        value.layout = try reader["Layout"].readIfPresent(with: QuickSightClientTypes.SectionLayoutConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FreeFormLayoutConfiguration {

    static func write(value: QuickSightClientTypes.FreeFormLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CanvasSizeOptions"].write(value.canvasSizeOptions, with: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.write(value:to:))
        try writer["Elements"].writeList(value.elements, memberWritingClosure: QuickSightClientTypes.FreeFormLayoutElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FreeFormLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FreeFormLayoutConfiguration()
        value.elements = try reader["Elements"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FreeFormLayoutElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.canvasSizeOptions = try reader["CanvasSizeOptions"].readIfPresent(with: QuickSightClientTypes.FreeFormLayoutCanvasSizeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SheetTextBox {

    static func write(value: QuickSightClientTypes.SheetTextBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["SheetTextBoxId"].write(value.sheetTextBoxId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetTextBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetTextBox()
        value.sheetTextBoxId = try reader["SheetTextBoxId"].readIfPresent() ?? ""
        value.content = try reader["Content"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Visual {

    static func write(value: QuickSightClientTypes.Visual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BarChartVisual"].write(value.barChartVisual, with: QuickSightClientTypes.BarChartVisual.write(value:to:))
        try writer["BoxPlotVisual"].write(value.boxPlotVisual, with: QuickSightClientTypes.BoxPlotVisual.write(value:to:))
        try writer["ComboChartVisual"].write(value.comboChartVisual, with: QuickSightClientTypes.ComboChartVisual.write(value:to:))
        try writer["CustomContentVisual"].write(value.customContentVisual, with: QuickSightClientTypes.CustomContentVisual.write(value:to:))
        try writer["EmptyVisual"].write(value.emptyVisual, with: QuickSightClientTypes.EmptyVisual.write(value:to:))
        try writer["FilledMapVisual"].write(value.filledMapVisual, with: QuickSightClientTypes.FilledMapVisual.write(value:to:))
        try writer["FunnelChartVisual"].write(value.funnelChartVisual, with: QuickSightClientTypes.FunnelChartVisual.write(value:to:))
        try writer["GaugeChartVisual"].write(value.gaugeChartVisual, with: QuickSightClientTypes.GaugeChartVisual.write(value:to:))
        try writer["GeospatialMapVisual"].write(value.geospatialMapVisual, with: QuickSightClientTypes.GeospatialMapVisual.write(value:to:))
        try writer["HeatMapVisual"].write(value.heatMapVisual, with: QuickSightClientTypes.HeatMapVisual.write(value:to:))
        try writer["HistogramVisual"].write(value.histogramVisual, with: QuickSightClientTypes.HistogramVisual.write(value:to:))
        try writer["InsightVisual"].write(value.insightVisual, with: QuickSightClientTypes.InsightVisual.write(value:to:))
        try writer["KPIVisual"].write(value.kpiVisual, with: QuickSightClientTypes.KPIVisual.write(value:to:))
        try writer["LineChartVisual"].write(value.lineChartVisual, with: QuickSightClientTypes.LineChartVisual.write(value:to:))
        try writer["PieChartVisual"].write(value.pieChartVisual, with: QuickSightClientTypes.PieChartVisual.write(value:to:))
        try writer["PivotTableVisual"].write(value.pivotTableVisual, with: QuickSightClientTypes.PivotTableVisual.write(value:to:))
        try writer["RadarChartVisual"].write(value.radarChartVisual, with: QuickSightClientTypes.RadarChartVisual.write(value:to:))
        try writer["SankeyDiagramVisual"].write(value.sankeyDiagramVisual, with: QuickSightClientTypes.SankeyDiagramVisual.write(value:to:))
        try writer["ScatterPlotVisual"].write(value.scatterPlotVisual, with: QuickSightClientTypes.ScatterPlotVisual.write(value:to:))
        try writer["TableVisual"].write(value.tableVisual, with: QuickSightClientTypes.TableVisual.write(value:to:))
        try writer["TreeMapVisual"].write(value.treeMapVisual, with: QuickSightClientTypes.TreeMapVisual.write(value:to:))
        try writer["WaterfallVisual"].write(value.waterfallVisual, with: QuickSightClientTypes.WaterfallVisual.write(value:to:))
        try writer["WordCloudVisual"].write(value.wordCloudVisual, with: QuickSightClientTypes.WordCloudVisual.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Visual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Visual()
        value.tableVisual = try reader["TableVisual"].readIfPresent(with: QuickSightClientTypes.TableVisual.read(from:))
        value.pivotTableVisual = try reader["PivotTableVisual"].readIfPresent(with: QuickSightClientTypes.PivotTableVisual.read(from:))
        value.barChartVisual = try reader["BarChartVisual"].readIfPresent(with: QuickSightClientTypes.BarChartVisual.read(from:))
        value.kpiVisual = try reader["KPIVisual"].readIfPresent(with: QuickSightClientTypes.KPIVisual.read(from:))
        value.pieChartVisual = try reader["PieChartVisual"].readIfPresent(with: QuickSightClientTypes.PieChartVisual.read(from:))
        value.gaugeChartVisual = try reader["GaugeChartVisual"].readIfPresent(with: QuickSightClientTypes.GaugeChartVisual.read(from:))
        value.lineChartVisual = try reader["LineChartVisual"].readIfPresent(with: QuickSightClientTypes.LineChartVisual.read(from:))
        value.heatMapVisual = try reader["HeatMapVisual"].readIfPresent(with: QuickSightClientTypes.HeatMapVisual.read(from:))
        value.treeMapVisual = try reader["TreeMapVisual"].readIfPresent(with: QuickSightClientTypes.TreeMapVisual.read(from:))
        value.geospatialMapVisual = try reader["GeospatialMapVisual"].readIfPresent(with: QuickSightClientTypes.GeospatialMapVisual.read(from:))
        value.filledMapVisual = try reader["FilledMapVisual"].readIfPresent(with: QuickSightClientTypes.FilledMapVisual.read(from:))
        value.funnelChartVisual = try reader["FunnelChartVisual"].readIfPresent(with: QuickSightClientTypes.FunnelChartVisual.read(from:))
        value.scatterPlotVisual = try reader["ScatterPlotVisual"].readIfPresent(with: QuickSightClientTypes.ScatterPlotVisual.read(from:))
        value.comboChartVisual = try reader["ComboChartVisual"].readIfPresent(with: QuickSightClientTypes.ComboChartVisual.read(from:))
        value.boxPlotVisual = try reader["BoxPlotVisual"].readIfPresent(with: QuickSightClientTypes.BoxPlotVisual.read(from:))
        value.waterfallVisual = try reader["WaterfallVisual"].readIfPresent(with: QuickSightClientTypes.WaterfallVisual.read(from:))
        value.histogramVisual = try reader["HistogramVisual"].readIfPresent(with: QuickSightClientTypes.HistogramVisual.read(from:))
        value.wordCloudVisual = try reader["WordCloudVisual"].readIfPresent(with: QuickSightClientTypes.WordCloudVisual.read(from:))
        value.insightVisual = try reader["InsightVisual"].readIfPresent(with: QuickSightClientTypes.InsightVisual.read(from:))
        value.sankeyDiagramVisual = try reader["SankeyDiagramVisual"].readIfPresent(with: QuickSightClientTypes.SankeyDiagramVisual.read(from:))
        value.customContentVisual = try reader["CustomContentVisual"].readIfPresent(with: QuickSightClientTypes.CustomContentVisual.read(from:))
        value.emptyVisual = try reader["EmptyVisual"].readIfPresent(with: QuickSightClientTypes.EmptyVisual.read(from:))
        value.radarChartVisual = try reader["RadarChartVisual"].readIfPresent(with: QuickSightClientTypes.RadarChartVisual.read(from:))
        return value
    }
}

extension QuickSightClientTypes.RadarChartVisual {

    static func write(value: QuickSightClientTypes.RadarChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.RadarChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.RadarChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnHierarchy {

    static func write(value: QuickSightClientTypes.ColumnHierarchy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeHierarchy"].write(value.dateTimeHierarchy, with: QuickSightClientTypes.DateTimeHierarchy.write(value:to:))
        try writer["ExplicitHierarchy"].write(value.explicitHierarchy, with: QuickSightClientTypes.ExplicitHierarchy.write(value:to:))
        try writer["PredefinedHierarchy"].write(value.predefinedHierarchy, with: QuickSightClientTypes.PredefinedHierarchy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnHierarchy()
        value.explicitHierarchy = try reader["ExplicitHierarchy"].readIfPresent(with: QuickSightClientTypes.ExplicitHierarchy.read(from:))
        value.dateTimeHierarchy = try reader["DateTimeHierarchy"].readIfPresent(with: QuickSightClientTypes.DateTimeHierarchy.read(from:))
        value.predefinedHierarchy = try reader["PredefinedHierarchy"].readIfPresent(with: QuickSightClientTypes.PredefinedHierarchy.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PredefinedHierarchy {

    static func write(value: QuickSightClientTypes.PredefinedHierarchy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.ColumnIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DrillDownFilters"].writeList(value.drillDownFilters, memberWritingClosure: QuickSightClientTypes.DrillDownFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PredefinedHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PredefinedHierarchy()
        value.hierarchyId = try reader["HierarchyId"].readIfPresent() ?? ""
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.drillDownFilters = try reader["DrillDownFilters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DrillDownFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DrillDownFilter {

    static func write(value: QuickSightClientTypes.DrillDownFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryFilter"].write(value.categoryFilter, with: QuickSightClientTypes.CategoryDrillDownFilter.write(value:to:))
        try writer["NumericEqualityFilter"].write(value.numericEqualityFilter, with: QuickSightClientTypes.NumericEqualityDrillDownFilter.write(value:to:))
        try writer["TimeRangeFilter"].write(value.timeRangeFilter, with: QuickSightClientTypes.TimeRangeDrillDownFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DrillDownFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DrillDownFilter()
        value.numericEqualityFilter = try reader["NumericEqualityFilter"].readIfPresent(with: QuickSightClientTypes.NumericEqualityDrillDownFilter.read(from:))
        value.categoryFilter = try reader["CategoryFilter"].readIfPresent(with: QuickSightClientTypes.CategoryDrillDownFilter.read(from:))
        value.timeRangeFilter = try reader["TimeRangeFilter"].readIfPresent(with: QuickSightClientTypes.TimeRangeDrillDownFilter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TimeRangeDrillDownFilter {

    static func write(value: QuickSightClientTypes.TimeRangeDrillDownFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["RangeMaximum"].writeTimestamp(value.rangeMaximum, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["RangeMinimum"].writeTimestamp(value.rangeMinimum, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TimeRangeDrillDownFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TimeRangeDrillDownFilter()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.rangeMinimum = try reader["RangeMinimum"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.rangeMaximum = try reader["RangeMaximum"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.CategoryDrillDownFilter {

    static func write(value: QuickSightClientTypes.CategoryDrillDownFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryValues"].writeList(value.categoryValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoryDrillDownFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoryDrillDownFilter()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.categoryValues = try reader["CategoryValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.NumericEqualityDrillDownFilter {

    static func write(value: QuickSightClientTypes.NumericEqualityDrillDownFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericEqualityDrillDownFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericEqualityDrillDownFilter()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.DateTimeHierarchy {

    static func write(value: QuickSightClientTypes.DateTimeHierarchy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DrillDownFilters"].writeList(value.drillDownFilters, memberWritingClosure: QuickSightClientTypes.DrillDownFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeHierarchy()
        value.hierarchyId = try reader["HierarchyId"].readIfPresent() ?? ""
        value.drillDownFilters = try reader["DrillDownFilters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DrillDownFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ExplicitHierarchy {

    static func write(value: QuickSightClientTypes.ExplicitHierarchy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.ColumnIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DrillDownFilters"].writeList(value.drillDownFilters, memberWritingClosure: QuickSightClientTypes.DrillDownFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExplicitHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExplicitHierarchy()
        value.hierarchyId = try reader["HierarchyId"].readIfPresent() ?? ""
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.drillDownFilters = try reader["DrillDownFilters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DrillDownFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.VisualCustomAction {

    static func write(value: QuickSightClientTypes.VisualCustomAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionOperations"].writeList(value.actionOperations, memberWritingClosure: QuickSightClientTypes.VisualCustomActionOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomActionId"].write(value.customActionId)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
        try writer["Trigger"].write(value.trigger)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualCustomAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualCustomAction()
        value.customActionId = try reader["CustomActionId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent()
        value.trigger = try reader["Trigger"].readIfPresent() ?? .sdkUnknown("")
        value.actionOperations = try reader["ActionOperations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomActionOperation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.VisualCustomActionOperation {

    static func write(value: QuickSightClientTypes.VisualCustomActionOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterOperation"].write(value.filterOperation, with: QuickSightClientTypes.CustomActionFilterOperation.write(value:to:))
        try writer["NavigationOperation"].write(value.navigationOperation, with: QuickSightClientTypes.CustomActionNavigationOperation.write(value:to:))
        try writer["SetParametersOperation"].write(value.setParametersOperation, with: QuickSightClientTypes.CustomActionSetParametersOperation.write(value:to:))
        try writer["URLOperation"].write(value.urlOperation, with: QuickSightClientTypes.CustomActionURLOperation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualCustomActionOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualCustomActionOperation()
        value.filterOperation = try reader["FilterOperation"].readIfPresent(with: QuickSightClientTypes.CustomActionFilterOperation.read(from:))
        value.navigationOperation = try reader["NavigationOperation"].readIfPresent(with: QuickSightClientTypes.CustomActionNavigationOperation.read(from:))
        value.urlOperation = try reader["URLOperation"].readIfPresent(with: QuickSightClientTypes.CustomActionURLOperation.read(from:))
        value.setParametersOperation = try reader["SetParametersOperation"].readIfPresent(with: QuickSightClientTypes.CustomActionSetParametersOperation.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CustomActionSetParametersOperation {

    static func write(value: QuickSightClientTypes.CustomActionSetParametersOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterValueConfigurations"].writeList(value.parameterValueConfigurations, memberWritingClosure: QuickSightClientTypes.SetParameterValueConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomActionSetParametersOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomActionSetParametersOperation()
        value.parameterValueConfigurations = try reader["ParameterValueConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SetParameterValueConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.SetParameterValueConfiguration {

    static func write(value: QuickSightClientTypes.SetParameterValueConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationParameterName"].write(value.destinationParameterName)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.DestinationParameterValueConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SetParameterValueConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SetParameterValueConfiguration()
        value.destinationParameterName = try reader["DestinationParameterName"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.DestinationParameterValueConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DestinationParameterValueConfiguration {

    static func write(value: QuickSightClientTypes.DestinationParameterValueConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValuesConfiguration"].write(value.customValuesConfiguration, with: QuickSightClientTypes.CustomValuesConfiguration.write(value:to:))
        try writer["SelectAllValueOptions"].write(value.selectAllValueOptions)
        try writer["SourceColumn"].write(value.sourceColumn, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["SourceField"].write(value.sourceField)
        try writer["SourceParameterName"].write(value.sourceParameterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DestinationParameterValueConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DestinationParameterValueConfiguration()
        value.customValuesConfiguration = try reader["CustomValuesConfiguration"].readIfPresent(with: QuickSightClientTypes.CustomValuesConfiguration.read(from:))
        value.selectAllValueOptions = try reader["SelectAllValueOptions"].readIfPresent()
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent()
        value.sourceField = try reader["SourceField"].readIfPresent()
        value.sourceColumn = try reader["SourceColumn"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CustomValuesConfiguration {

    static func write(value: QuickSightClientTypes.CustomValuesConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomValues"].write(value.customValues, with: QuickSightClientTypes.CustomParameterValues.write(value:to:))
        try writer["IncludeNullValue"].write(value.includeNullValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomValuesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomValuesConfiguration()
        value.includeNullValue = try reader["IncludeNullValue"].readIfPresent()
        value.customValues = try reader["CustomValues"].readIfPresent(with: QuickSightClientTypes.CustomParameterValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CustomParameterValues {

    static func write(value: QuickSightClientTypes.CustomParameterValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeValues"].writeList(value.dateTimeValues, memberWritingClosure: SmithyReadWrite.timestampWritingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        try writer["DecimalValues"].writeList(value.decimalValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IntegerValues"].writeList(value.integerValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringValues"].writeList(value.stringValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomParameterValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomParameterValues()
        value.stringValues = try reader["StringValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.integerValues = try reader["IntegerValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.decimalValues = try reader["DecimalValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateTimeValues = try reader["DateTimeValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CustomActionURLOperation {

    static func write(value: QuickSightClientTypes.CustomActionURLOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["URLTarget"].write(value.urlTarget)
        try writer["URLTemplate"].write(value.urlTemplate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomActionURLOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomActionURLOperation()
        value.urlTemplate = try reader["URLTemplate"].readIfPresent() ?? ""
        value.urlTarget = try reader["URLTarget"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.CustomActionNavigationOperation {

    static func write(value: QuickSightClientTypes.CustomActionNavigationOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LocalNavigationConfiguration"].write(value.localNavigationConfiguration, with: QuickSightClientTypes.LocalNavigationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomActionNavigationOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomActionNavigationOperation()
        value.localNavigationConfiguration = try reader["LocalNavigationConfiguration"].readIfPresent(with: QuickSightClientTypes.LocalNavigationConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LocalNavigationConfiguration {

    static func write(value: QuickSightClientTypes.LocalNavigationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetSheetId"].write(value.targetSheetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LocalNavigationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LocalNavigationConfiguration()
        value.targetSheetId = try reader["TargetSheetId"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.CustomActionFilterOperation {

    static func write(value: QuickSightClientTypes.CustomActionFilterOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectedFieldsConfiguration"].write(value.selectedFieldsConfiguration, with: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration.write(value:to:))
        try writer["TargetVisualsConfiguration"].write(value.targetVisualsConfiguration, with: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomActionFilterOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomActionFilterOperation()
        value.selectedFieldsConfiguration = try reader["SelectedFieldsConfiguration"].readIfPresent(with: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration.read(from:))
        value.targetVisualsConfiguration = try reader["TargetVisualsConfiguration"].readIfPresent(with: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterOperationTargetVisualsConfiguration {

    static func write(value: QuickSightClientTypes.FilterOperationTargetVisualsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SameSheetTargetVisualConfiguration"].write(value.sameSheetTargetVisualConfiguration, with: QuickSightClientTypes.SameSheetTargetVisualConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterOperationTargetVisualsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterOperationTargetVisualsConfiguration()
        value.sameSheetTargetVisualConfiguration = try reader["SameSheetTargetVisualConfiguration"].readIfPresent(with: QuickSightClientTypes.SameSheetTargetVisualConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SameSheetTargetVisualConfiguration {

    static func write(value: QuickSightClientTypes.SameSheetTargetVisualConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetVisualOptions"].write(value.targetVisualOptions)
        try writer["TargetVisuals"].writeList(value.targetVisuals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SameSheetTargetVisualConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SameSheetTargetVisualConfiguration()
        value.targetVisuals = try reader["TargetVisuals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetVisualOptions = try reader["TargetVisualOptions"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration {

    static func write(value: QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectedColumns"].writeList(value.selectedColumns, memberWritingClosure: QuickSightClientTypes.ColumnIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelectedFieldOptions"].write(value.selectedFieldOptions)
        try writer["SelectedFields"].writeList(value.selectedFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterOperationSelectedFieldsConfiguration()
        value.selectedFields = try reader["SelectedFields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.selectedFieldOptions = try reader["SelectedFieldOptions"].readIfPresent()
        value.selectedColumns = try reader["SelectedColumns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.RadarChartConfiguration {

    static func write(value: QuickSightClientTypes.RadarChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlternateBandColorsVisibility"].write(value.alternateBandColorsVisibility)
        try writer["AlternateBandEvenColor"].write(value.alternateBandEvenColor)
        try writer["AlternateBandOddColor"].write(value.alternateBandOddColor)
        try writer["AxesRangeScale"].write(value.axesRangeScale)
        try writer["BaseSeriesSettings"].write(value.baseSeriesSettings, with: QuickSightClientTypes.RadarChartSeriesSettings.write(value:to:))
        try writer["CategoryAxis"].write(value.categoryAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ColorAxis"].write(value.colorAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["ColorLabelOptions"].write(value.colorLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.RadarChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["Shape"].write(value.shape)
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.RadarChartSortConfiguration.write(value:to:))
        try writer["StartAngle"].write(value.startAngle)
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.RadarChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.RadarChartSortConfiguration.read(from:))
        value.shape = try reader["Shape"].readIfPresent()
        value.baseSeriesSettings = try reader["BaseSeriesSettings"].readIfPresent(with: QuickSightClientTypes.RadarChartSeriesSettings.read(from:))
        value.startAngle = try reader["StartAngle"].readIfPresent()
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.alternateBandColorsVisibility = try reader["AlternateBandColorsVisibility"].readIfPresent()
        value.alternateBandEvenColor = try reader["AlternateBandEvenColor"].readIfPresent()
        value.alternateBandOddColor = try reader["AlternateBandOddColor"].readIfPresent()
        value.categoryAxis = try reader["CategoryAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.colorAxis = try reader["ColorAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.colorLabelOptions = try reader["ColorLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.axesRangeScale = try reader["AxesRangeScale"].readIfPresent()
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.VisualInteractionOptions {

    static func write(value: QuickSightClientTypes.VisualInteractionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContextMenuOption"].write(value.contextMenuOption, with: QuickSightClientTypes.ContextMenuOption.write(value:to:))
        try writer["VisualMenuOption"].write(value.visualMenuOption, with: QuickSightClientTypes.VisualMenuOption.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualInteractionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualInteractionOptions()
        value.visualMenuOption = try reader["VisualMenuOption"].readIfPresent(with: QuickSightClientTypes.VisualMenuOption.read(from:))
        value.contextMenuOption = try reader["ContextMenuOption"].readIfPresent(with: QuickSightClientTypes.ContextMenuOption.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ContextMenuOption {

    static func write(value: QuickSightClientTypes.ContextMenuOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ContextMenuOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ContextMenuOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VisualMenuOption {

    static func write(value: QuickSightClientTypes.VisualMenuOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualMenuOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualMenuOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LegendOptions {

    static func write(value: QuickSightClientTypes.LegendOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Height"].write(value.height)
        try writer["Position"].write(value.position)
        try writer["Title"].write(value.title, with: QuickSightClientTypes.LabelOptions.write(value:to:))
        try writer["Visibility"].write(value.visibility)
        try writer["Width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LegendOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LegendOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.position = try reader["Position"].readIfPresent()
        value.width = try reader["Width"].readIfPresent()
        value.height = try reader["Height"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ChartAxisLabelOptions {

    static func write(value: QuickSightClientTypes.ChartAxisLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisLabelOptions"].writeList(value.axisLabelOptions, memberWritingClosure: QuickSightClientTypes.AxisLabelOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SortIconVisibility"].write(value.sortIconVisibility)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ChartAxisLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ChartAxisLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.sortIconVisibility = try reader["SortIconVisibility"].readIfPresent()
        value.axisLabelOptions = try reader["AxisLabelOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AxisLabelOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AxisLabelOptions {

    static func write(value: QuickSightClientTypes.AxisLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyTo"].write(value.applyTo, with: QuickSightClientTypes.AxisLabelReferenceOptions.write(value:to:))
        try writer["CustomLabel"].write(value.customLabel)
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisLabelOptions()
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.applyTo = try reader["ApplyTo"].readIfPresent(with: QuickSightClientTypes.AxisLabelReferenceOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AxisLabelReferenceOptions {

    static func write(value: QuickSightClientTypes.AxisLabelReferenceOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisLabelReferenceOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisLabelReferenceOptions()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AxisDisplayOptions {

    static func write(value: QuickSightClientTypes.AxisDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisLineVisibility"].write(value.axisLineVisibility)
        try writer["AxisOffset"].write(value.axisOffset)
        try writer["DataOptions"].write(value.dataOptions, with: QuickSightClientTypes.AxisDataOptions.write(value:to:))
        try writer["GridLineVisibility"].write(value.gridLineVisibility)
        try writer["ScrollbarOptions"].write(value.scrollbarOptions, with: QuickSightClientTypes.ScrollBarOptions.write(value:to:))
        try writer["TickLabelOptions"].write(value.tickLabelOptions, with: QuickSightClientTypes.AxisTickLabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisDisplayOptions()
        value.tickLabelOptions = try reader["TickLabelOptions"].readIfPresent(with: QuickSightClientTypes.AxisTickLabelOptions.read(from:))
        value.axisLineVisibility = try reader["AxisLineVisibility"].readIfPresent()
        value.gridLineVisibility = try reader["GridLineVisibility"].readIfPresent()
        value.dataOptions = try reader["DataOptions"].readIfPresent(with: QuickSightClientTypes.AxisDataOptions.read(from:))
        value.scrollbarOptions = try reader["ScrollbarOptions"].readIfPresent(with: QuickSightClientTypes.ScrollBarOptions.read(from:))
        value.axisOffset = try reader["AxisOffset"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ScrollBarOptions {

    static func write(value: QuickSightClientTypes.ScrollBarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
        try writer["VisibleRange"].write(value.visibleRange, with: QuickSightClientTypes.VisibleRangeOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScrollBarOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScrollBarOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.visibleRange = try reader["VisibleRange"].readIfPresent(with: QuickSightClientTypes.VisibleRangeOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.VisibleRangeOptions {

    static func write(value: QuickSightClientTypes.VisibleRangeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PercentRange"].write(value.percentRange, with: QuickSightClientTypes.PercentVisibleRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisibleRangeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisibleRangeOptions()
        value.percentRange = try reader["PercentRange"].readIfPresent(with: QuickSightClientTypes.PercentVisibleRange.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PercentVisibleRange {

    static func write(value: QuickSightClientTypes.PercentVisibleRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from)
        try writer["To"].write(value.to)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PercentVisibleRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PercentVisibleRange()
        value.from = try reader["From"].readIfPresent()
        value.to = try reader["To"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AxisDataOptions {

    static func write(value: QuickSightClientTypes.AxisDataOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateAxisOptions"].write(value.dateAxisOptions, with: QuickSightClientTypes.DateAxisOptions.write(value:to:))
        try writer["NumericAxisOptions"].write(value.numericAxisOptions, with: QuickSightClientTypes.NumericAxisOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisDataOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisDataOptions()
        value.numericAxisOptions = try reader["NumericAxisOptions"].readIfPresent(with: QuickSightClientTypes.NumericAxisOptions.read(from:))
        value.dateAxisOptions = try reader["DateAxisOptions"].readIfPresent(with: QuickSightClientTypes.DateAxisOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateAxisOptions {

    static func write(value: QuickSightClientTypes.DateAxisOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MissingDateVisibility"].write(value.missingDateVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateAxisOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateAxisOptions()
        value.missingDateVisibility = try reader["MissingDateVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.NumericAxisOptions {

    static func write(value: QuickSightClientTypes.NumericAxisOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Range"].write(value.range, with: QuickSightClientTypes.AxisDisplayRange.write(value:to:))
        try writer["Scale"].write(value.scale, with: QuickSightClientTypes.AxisScale.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericAxisOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericAxisOptions()
        value.scale = try reader["Scale"].readIfPresent(with: QuickSightClientTypes.AxisScale.read(from:))
        value.range = try reader["Range"].readIfPresent(with: QuickSightClientTypes.AxisDisplayRange.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AxisDisplayRange {

    static func write(value: QuickSightClientTypes.AxisDisplayRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataDriven"].write(value.dataDriven, with: QuickSightClientTypes.AxisDisplayDataDrivenRange.write(value:to:))
        try writer["MinMax"].write(value.minMax, with: QuickSightClientTypes.AxisDisplayMinMaxRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisDisplayRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisDisplayRange()
        value.minMax = try reader["MinMax"].readIfPresent(with: QuickSightClientTypes.AxisDisplayMinMaxRange.read(from:))
        value.dataDriven = try reader["DataDriven"].readIfPresent(with: QuickSightClientTypes.AxisDisplayDataDrivenRange.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AxisDisplayDataDrivenRange {

    static func write(value: QuickSightClientTypes.AxisDisplayDataDrivenRange?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisDisplayDataDrivenRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return QuickSightClientTypes.AxisDisplayDataDrivenRange()
    }
}

extension QuickSightClientTypes.AxisDisplayMinMaxRange {

    static func write(value: QuickSightClientTypes.AxisDisplayMinMaxRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Maximum"].write(value.maximum)
        try writer["Minimum"].write(value.minimum)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisDisplayMinMaxRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisDisplayMinMaxRange()
        value.minimum = try reader["Minimum"].readIfPresent()
        value.maximum = try reader["Maximum"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AxisScale {

    static func write(value: QuickSightClientTypes.AxisScale?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Linear"].write(value.linear, with: QuickSightClientTypes.AxisLinearScale.write(value:to:))
        try writer["Logarithmic"].write(value.logarithmic, with: QuickSightClientTypes.AxisLogarithmicScale.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisScale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisScale()
        value.linear = try reader["Linear"].readIfPresent(with: QuickSightClientTypes.AxisLinearScale.read(from:))
        value.logarithmic = try reader["Logarithmic"].readIfPresent(with: QuickSightClientTypes.AxisLogarithmicScale.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AxisLogarithmicScale {

    static func write(value: QuickSightClientTypes.AxisLogarithmicScale?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Base"].write(value.base)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisLogarithmicScale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisLogarithmicScale()
        value.base = try reader["Base"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AxisLinearScale {

    static func write(value: QuickSightClientTypes.AxisLinearScale?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StepCount"].write(value.stepCount)
        try writer["StepSize"].write(value.stepSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisLinearScale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisLinearScale()
        value.stepCount = try reader["StepCount"].readIfPresent()
        value.stepSize = try reader["StepSize"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AxisTickLabelOptions {

    static func write(value: QuickSightClientTypes.AxisTickLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LabelOptions"].write(value.labelOptions, with: QuickSightClientTypes.LabelOptions.write(value:to:))
        try writer["RotationAngle"].write(value.rotationAngle)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AxisTickLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AxisTickLabelOptions()
        value.labelOptions = try reader["LabelOptions"].readIfPresent(with: QuickSightClientTypes.LabelOptions.read(from:))
        value.rotationAngle = try reader["RotationAngle"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VisualPalette {

    static func write(value: QuickSightClientTypes.VisualPalette?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChartColor"].write(value.chartColor)
        try writer["ColorMap"].writeList(value.colorMap, memberWritingClosure: QuickSightClientTypes.DataPathColor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualPalette {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualPalette()
        value.chartColor = try reader["ChartColor"].readIfPresent()
        value.colorMap = try reader["ColorMap"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataPathColor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DataPathColor {

    static func write(value: QuickSightClientTypes.DataPathColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Element"].write(value.element, with: QuickSightClientTypes.DataPathValue.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPathColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPathColor()
        value.element = try reader["Element"].readIfPresent(with: QuickSightClientTypes.DataPathValue.read(from:))
        value.color = try reader["Color"].readIfPresent() ?? ""
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataPathValue {

    static func write(value: QuickSightClientTypes.DataPathValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPathType"].write(value.dataPathType, with: QuickSightClientTypes.DataPathType.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FieldValue"].write(value.fieldValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPathValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPathValue()
        value.fieldId = try reader["FieldId"].readIfPresent()
        value.fieldValue = try reader["FieldValue"].readIfPresent()
        value.dataPathType = try reader["DataPathType"].readIfPresent(with: QuickSightClientTypes.DataPathType.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataPathType {

    static func write(value: QuickSightClientTypes.DataPathType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PivotTableDataPathType"].write(value.pivotTableDataPathType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPathType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPathType()
        value.pivotTableDataPathType = try reader["PivotTableDataPathType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RadarChartSeriesSettings {

    static func write(value: QuickSightClientTypes.RadarChartSeriesSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AreaStyleSettings"].write(value.areaStyleSettings, with: QuickSightClientTypes.RadarChartAreaStyleSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartSeriesSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartSeriesSettings()
        value.areaStyleSettings = try reader["AreaStyleSettings"].readIfPresent(with: QuickSightClientTypes.RadarChartAreaStyleSettings.read(from:))
        return value
    }
}

extension QuickSightClientTypes.RadarChartAreaStyleSettings {

    static func write(value: QuickSightClientTypes.RadarChartAreaStyleSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartAreaStyleSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartAreaStyleSettings()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RadarChartSortConfiguration {

    static func write(value: QuickSightClientTypes.RadarChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColorItemsLimit"].write(value.colorItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["ColorSort"].writeList(value.colorSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.colorSort = try reader["ColorSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colorItemsLimit = try reader["ColorItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ItemsLimitConfiguration {

    static func write(value: QuickSightClientTypes.ItemsLimitConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ItemsLimit"].write(value.itemsLimit)
        try writer["OtherCategories"].write(value.otherCategories)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ItemsLimitConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ItemsLimitConfiguration()
        value.itemsLimit = try reader["ItemsLimit"].readIfPresent()
        value.otherCategories = try reader["OtherCategories"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FieldSortOptions {

    static func write(value: QuickSightClientTypes.FieldSortOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnSort"].write(value.columnSort, with: QuickSightClientTypes.ColumnSort.write(value:to:))
        try writer["FieldSort"].write(value.fieldSort, with: QuickSightClientTypes.FieldSort.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldSortOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldSortOptions()
        value.fieldSort = try reader["FieldSort"].readIfPresent(with: QuickSightClientTypes.FieldSort.read(from:))
        value.columnSort = try reader["ColumnSort"].readIfPresent(with: QuickSightClientTypes.ColumnSort.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FieldSort {

    static func write(value: QuickSightClientTypes.FieldSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Direction"].write(value.direction)
        try writer["FieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldSort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldSort()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.direction = try reader["Direction"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.RadarChartFieldWells {

    static func write(value: QuickSightClientTypes.RadarChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RadarChartAggregatedFieldWells"].write(value.radarChartAggregatedFieldWells, with: QuickSightClientTypes.RadarChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartFieldWells()
        value.radarChartAggregatedFieldWells = try reader["RadarChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.RadarChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.RadarChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.RadarChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Color"].writeList(value.color, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RadarChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RadarChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.color = try reader["Color"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.MeasureField {

    static func write(value: QuickSightClientTypes.MeasureField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculatedMeasureField"].write(value.calculatedMeasureField, with: QuickSightClientTypes.CalculatedMeasureField.write(value:to:))
        try writer["CategoricalMeasureField"].write(value.categoricalMeasureField, with: QuickSightClientTypes.CategoricalMeasureField.write(value:to:))
        try writer["DateMeasureField"].write(value.dateMeasureField, with: QuickSightClientTypes.DateMeasureField.write(value:to:))
        try writer["NumericalMeasureField"].write(value.numericalMeasureField, with: QuickSightClientTypes.NumericalMeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MeasureField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MeasureField()
        value.numericalMeasureField = try reader["NumericalMeasureField"].readIfPresent(with: QuickSightClientTypes.NumericalMeasureField.read(from:))
        value.categoricalMeasureField = try reader["CategoricalMeasureField"].readIfPresent(with: QuickSightClientTypes.CategoricalMeasureField.read(from:))
        value.dateMeasureField = try reader["DateMeasureField"].readIfPresent(with: QuickSightClientTypes.DateMeasureField.read(from:))
        value.calculatedMeasureField = try reader["CalculatedMeasureField"].readIfPresent(with: QuickSightClientTypes.CalculatedMeasureField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CalculatedMeasureField {

    static func write(value: QuickSightClientTypes.CalculatedMeasureField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expression"].write(value.expression)
        try writer["FieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CalculatedMeasureField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CalculatedMeasureField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.DateMeasureField {

    static func write(value: QuickSightClientTypes.DateMeasureField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction)
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.DateTimeFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateMeasureField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateMeasureField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.DateTimeFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CategoricalMeasureField {

    static func write(value: QuickSightClientTypes.CategoricalMeasureField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction)
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.StringFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoricalMeasureField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoricalMeasureField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.StringFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericalMeasureField {

    static func write(value: QuickSightClientTypes.NumericalMeasureField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationFunction"].write(value.aggregationFunction, with: QuickSightClientTypes.NumericalAggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.NumberFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericalMeasureField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericalMeasureField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.aggregationFunction = try reader["AggregationFunction"].readIfPresent(with: QuickSightClientTypes.NumericalAggregationFunction.read(from:))
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumberFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DimensionField {

    static func write(value: QuickSightClientTypes.DimensionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoricalDimensionField"].write(value.categoricalDimensionField, with: QuickSightClientTypes.CategoricalDimensionField.write(value:to:))
        try writer["DateDimensionField"].write(value.dateDimensionField, with: QuickSightClientTypes.DateDimensionField.write(value:to:))
        try writer["NumericalDimensionField"].write(value.numericalDimensionField, with: QuickSightClientTypes.NumericalDimensionField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DimensionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DimensionField()
        value.numericalDimensionField = try reader["NumericalDimensionField"].readIfPresent(with: QuickSightClientTypes.NumericalDimensionField.read(from:))
        value.categoricalDimensionField = try reader["CategoricalDimensionField"].readIfPresent(with: QuickSightClientTypes.CategoricalDimensionField.read(from:))
        value.dateDimensionField = try reader["DateDimensionField"].readIfPresent(with: QuickSightClientTypes.DateDimensionField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateDimensionField {

    static func write(value: QuickSightClientTypes.DateDimensionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["DateGranularity"].write(value.dateGranularity)
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.DateTimeFormatConfiguration.write(value:to:))
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateDimensionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateDimensionField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.dateGranularity = try reader["DateGranularity"].readIfPresent()
        value.hierarchyId = try reader["HierarchyId"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.DateTimeFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CategoricalDimensionField {

    static func write(value: QuickSightClientTypes.CategoricalDimensionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.StringFormatConfiguration.write(value:to:))
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CategoricalDimensionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CategoricalDimensionField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.hierarchyId = try reader["HierarchyId"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.StringFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NumericalDimensionField {

    static func write(value: QuickSightClientTypes.NumericalDimensionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.NumberFormatConfiguration.write(value:to:))
        try writer["HierarchyId"].write(value.hierarchyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NumericalDimensionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NumericalDimensionField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.hierarchyId = try reader["HierarchyId"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumberFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.VisualSubtitleLabelOptions {

    static func write(value: QuickSightClientTypes.VisualSubtitleLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatText"].write(value.formatText, with: QuickSightClientTypes.LongFormatText.write(value:to:))
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualSubtitleLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualSubtitleLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.formatText = try reader["FormatText"].readIfPresent(with: QuickSightClientTypes.LongFormatText.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LongFormatText {

    static func write(value: QuickSightClientTypes.LongFormatText?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PlainText"].write(value.plainText)
        try writer["RichText"].write(value.richText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LongFormatText {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LongFormatText()
        value.plainText = try reader["PlainText"].readIfPresent()
        value.richText = try reader["RichText"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VisualTitleLabelOptions {

    static func write(value: QuickSightClientTypes.VisualTitleLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatText"].write(value.formatText, with: QuickSightClientTypes.ShortFormatText.write(value:to:))
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualTitleLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualTitleLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.formatText = try reader["FormatText"].readIfPresent(with: QuickSightClientTypes.ShortFormatText.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ShortFormatText {

    static func write(value: QuickSightClientTypes.ShortFormatText?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PlainText"].write(value.plainText)
        try writer["RichText"].write(value.richText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ShortFormatText {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ShortFormatText()
        value.plainText = try reader["PlainText"].readIfPresent()
        value.richText = try reader["RichText"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.EmptyVisual {

    static func write(value: QuickSightClientTypes.EmptyVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.EmptyVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.EmptyVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CustomContentVisual {

    static func write(value: QuickSightClientTypes.CustomContentVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.CustomContentConfiguration.write(value:to:))
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomContentVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomContentVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.CustomContentConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.CustomContentConfiguration {

    static func write(value: QuickSightClientTypes.CustomContentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["ContentUrl"].write(value.contentUrl)
        try writer["ImageScaling"].write(value.imageScaling)
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomContentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomContentConfiguration()
        value.contentUrl = try reader["ContentUrl"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        value.imageScaling = try reader["ImageScaling"].readIfPresent()
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SankeyDiagramVisual {

    static func write(value: QuickSightClientTypes.SankeyDiagramVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.SankeyDiagramChartConfiguration.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SankeyDiagramVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SankeyDiagramVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.SankeyDiagramChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SankeyDiagramChartConfiguration {

    static func write(value: QuickSightClientTypes.SankeyDiagramChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.SankeyDiagramFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.SankeyDiagramSortConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SankeyDiagramChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SankeyDiagramChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.SankeyDiagramFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.SankeyDiagramSortConfiguration.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataLabelOptions {

    static func write(value: QuickSightClientTypes.DataLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryLabelVisibility"].write(value.categoryLabelVisibility)
        try writer["DataLabelTypes"].writeList(value.dataLabelTypes, memberWritingClosure: QuickSightClientTypes.DataLabelType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LabelColor"].write(value.labelColor)
        try writer["LabelContent"].write(value.labelContent)
        try writer["LabelFontConfiguration"].write(value.labelFontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["MeasureLabelVisibility"].write(value.measureLabelVisibility)
        try writer["Overlap"].write(value.overlap)
        try writer["Position"].write(value.position)
        try writer["TotalsVisibility"].write(value.totalsVisibility)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.categoryLabelVisibility = try reader["CategoryLabelVisibility"].readIfPresent()
        value.measureLabelVisibility = try reader["MeasureLabelVisibility"].readIfPresent()
        value.dataLabelTypes = try reader["DataLabelTypes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataLabelType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.position = try reader["Position"].readIfPresent()
        value.labelContent = try reader["LabelContent"].readIfPresent()
        value.labelFontConfiguration = try reader["LabelFontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.labelColor = try reader["LabelColor"].readIfPresent()
        value.overlap = try reader["Overlap"].readIfPresent()
        value.totalsVisibility = try reader["TotalsVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataLabelType {

    static func write(value: QuickSightClientTypes.DataLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPathLabelType"].write(value.dataPathLabelType, with: QuickSightClientTypes.DataPathLabelType.write(value:to:))
        try writer["FieldLabelType"].write(value.fieldLabelType, with: QuickSightClientTypes.FieldLabelType.write(value:to:))
        try writer["MaximumLabelType"].write(value.maximumLabelType, with: QuickSightClientTypes.MaximumLabelType.write(value:to:))
        try writer["MinimumLabelType"].write(value.minimumLabelType, with: QuickSightClientTypes.MinimumLabelType.write(value:to:))
        try writer["RangeEndsLabelType"].write(value.rangeEndsLabelType, with: QuickSightClientTypes.RangeEndsLabelType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataLabelType()
        value.fieldLabelType = try reader["FieldLabelType"].readIfPresent(with: QuickSightClientTypes.FieldLabelType.read(from:))
        value.dataPathLabelType = try reader["DataPathLabelType"].readIfPresent(with: QuickSightClientTypes.DataPathLabelType.read(from:))
        value.rangeEndsLabelType = try reader["RangeEndsLabelType"].readIfPresent(with: QuickSightClientTypes.RangeEndsLabelType.read(from:))
        value.minimumLabelType = try reader["MinimumLabelType"].readIfPresent(with: QuickSightClientTypes.MinimumLabelType.read(from:))
        value.maximumLabelType = try reader["MaximumLabelType"].readIfPresent(with: QuickSightClientTypes.MaximumLabelType.read(from:))
        return value
    }
}

extension QuickSightClientTypes.MaximumLabelType {

    static func write(value: QuickSightClientTypes.MaximumLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MaximumLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MaximumLabelType()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.MinimumLabelType {

    static func write(value: QuickSightClientTypes.MinimumLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MinimumLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MinimumLabelType()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RangeEndsLabelType {

    static func write(value: QuickSightClientTypes.RangeEndsLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RangeEndsLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RangeEndsLabelType()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataPathLabelType {

    static func write(value: QuickSightClientTypes.DataPathLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["FieldValue"].write(value.fieldValue)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPathLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPathLabelType()
        value.fieldId = try reader["FieldId"].readIfPresent()
        value.fieldValue = try reader["FieldValue"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FieldLabelType {

    static func write(value: QuickSightClientTypes.FieldLabelType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldLabelType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldLabelType()
        value.fieldId = try reader["FieldId"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SankeyDiagramSortConfiguration {

    static func write(value: QuickSightClientTypes.SankeyDiagramSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationItemsLimit"].write(value.destinationItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["SourceItemsLimit"].write(value.sourceItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["WeightSort"].writeList(value.weightSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SankeyDiagramSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SankeyDiagramSortConfiguration()
        value.weightSort = try reader["WeightSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceItemsLimit = try reader["SourceItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.destinationItemsLimit = try reader["DestinationItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SankeyDiagramFieldWells {

    static func write(value: QuickSightClientTypes.SankeyDiagramFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SankeyDiagramAggregatedFieldWells"].write(value.sankeyDiagramAggregatedFieldWells, with: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SankeyDiagramFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SankeyDiagramFieldWells()
        value.sankeyDiagramAggregatedFieldWells = try reader["SankeyDiagramAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SankeyDiagramAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.SankeyDiagramAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].writeList(value.destination, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].writeList(value.source, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Weight"].writeList(value.weight, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SankeyDiagramAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SankeyDiagramAggregatedFieldWells()
        value.source = try reader["Source"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.destination = try reader["Destination"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.weight = try reader["Weight"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.InsightVisual {

    static func write(value: QuickSightClientTypes.InsightVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetIdentifier"].write(value.dataSetIdentifier)
        try writer["InsightConfiguration"].write(value.insightConfiguration, with: QuickSightClientTypes.InsightConfiguration.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.InsightVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.InsightVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.insightConfiguration = try reader["InsightConfiguration"].readIfPresent(with: QuickSightClientTypes.InsightConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSetIdentifier = try reader["DataSetIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.InsightConfiguration {

    static func write(value: QuickSightClientTypes.InsightConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Computations"].writeList(value.computations, memberWritingClosure: QuickSightClientTypes.Computation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CustomNarrative"].write(value.customNarrative, with: QuickSightClientTypes.CustomNarrativeOptions.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.InsightConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.InsightConfiguration()
        value.computations = try reader["Computations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Computation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customNarrative = try reader["CustomNarrative"].readIfPresent(with: QuickSightClientTypes.CustomNarrativeOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CustomNarrativeOptions {

    static func write(value: QuickSightClientTypes.CustomNarrativeOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Narrative"].write(value.narrative)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomNarrativeOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomNarrativeOptions()
        value.narrative = try reader["Narrative"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.Computation {

    static func write(value: QuickSightClientTypes.Computation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Forecast"].write(value.forecast, with: QuickSightClientTypes.ForecastComputation.write(value:to:))
        try writer["GrowthRate"].write(value.growthRate, with: QuickSightClientTypes.GrowthRateComputation.write(value:to:))
        try writer["MaximumMinimum"].write(value.maximumMinimum, with: QuickSightClientTypes.MaximumMinimumComputation.write(value:to:))
        try writer["MetricComparison"].write(value.metricComparison, with: QuickSightClientTypes.MetricComparisonComputation.write(value:to:))
        try writer["PeriodOverPeriod"].write(value.periodOverPeriod, with: QuickSightClientTypes.PeriodOverPeriodComputation.write(value:to:))
        try writer["PeriodToDate"].write(value.periodToDate, with: QuickSightClientTypes.PeriodToDateComputation.write(value:to:))
        try writer["TopBottomMovers"].write(value.topBottomMovers, with: QuickSightClientTypes.TopBottomMoversComputation.write(value:to:))
        try writer["TopBottomRanked"].write(value.topBottomRanked, with: QuickSightClientTypes.TopBottomRankedComputation.write(value:to:))
        try writer["TotalAggregation"].write(value.totalAggregation, with: QuickSightClientTypes.TotalAggregationComputation.write(value:to:))
        try writer["UniqueValues"].write(value.uniqueValues, with: QuickSightClientTypes.UniqueValuesComputation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Computation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Computation()
        value.topBottomRanked = try reader["TopBottomRanked"].readIfPresent(with: QuickSightClientTypes.TopBottomRankedComputation.read(from:))
        value.topBottomMovers = try reader["TopBottomMovers"].readIfPresent(with: QuickSightClientTypes.TopBottomMoversComputation.read(from:))
        value.totalAggregation = try reader["TotalAggregation"].readIfPresent(with: QuickSightClientTypes.TotalAggregationComputation.read(from:))
        value.maximumMinimum = try reader["MaximumMinimum"].readIfPresent(with: QuickSightClientTypes.MaximumMinimumComputation.read(from:))
        value.metricComparison = try reader["MetricComparison"].readIfPresent(with: QuickSightClientTypes.MetricComparisonComputation.read(from:))
        value.periodOverPeriod = try reader["PeriodOverPeriod"].readIfPresent(with: QuickSightClientTypes.PeriodOverPeriodComputation.read(from:))
        value.periodToDate = try reader["PeriodToDate"].readIfPresent(with: QuickSightClientTypes.PeriodToDateComputation.read(from:))
        value.growthRate = try reader["GrowthRate"].readIfPresent(with: QuickSightClientTypes.GrowthRateComputation.read(from:))
        value.uniqueValues = try reader["UniqueValues"].readIfPresent(with: QuickSightClientTypes.UniqueValuesComputation.read(from:))
        value.forecast = try reader["Forecast"].readIfPresent(with: QuickSightClientTypes.ForecastComputation.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ForecastComputation {

    static func write(value: QuickSightClientTypes.ForecastComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["CustomSeasonalityValue"].write(value.customSeasonalityValue)
        try writer["LowerBoundary"].write(value.lowerBoundary)
        try writer["Name"].write(value.name)
        try writer["PeriodsBackward"].write(value.periodsBackward)
        try writer["PeriodsForward"].write(value.periodsForward)
        try writer["PredictionInterval"].write(value.predictionInterval)
        try writer["Seasonality"].write(value.seasonality)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["UpperBoundary"].write(value.upperBoundary)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ForecastComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ForecastComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.periodsForward = try reader["PeriodsForward"].readIfPresent()
        value.periodsBackward = try reader["PeriodsBackward"].readIfPresent()
        value.upperBoundary = try reader["UpperBoundary"].readIfPresent()
        value.lowerBoundary = try reader["LowerBoundary"].readIfPresent()
        value.predictionInterval = try reader["PredictionInterval"].readIfPresent()
        value.seasonality = try reader["Seasonality"].readIfPresent()
        value.customSeasonalityValue = try reader["CustomSeasonalityValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.UniqueValuesComputation {

    static func write(value: QuickSightClientTypes.UniqueValuesComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.UniqueValuesComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.UniqueValuesComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.category = try reader["Category"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GrowthRateComputation {

    static func write(value: QuickSightClientTypes.GrowthRateComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["PeriodSize"].write(value.periodSize)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GrowthRateComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GrowthRateComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.periodSize = try reader["PeriodSize"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PeriodToDateComputation {

    static func write(value: QuickSightClientTypes.PeriodToDateComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["PeriodTimeGranularity"].write(value.periodTimeGranularity)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PeriodToDateComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PeriodToDateComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.periodTimeGranularity = try reader["PeriodTimeGranularity"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PeriodOverPeriodComputation {

    static func write(value: QuickSightClientTypes.PeriodOverPeriodComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PeriodOverPeriodComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PeriodOverPeriodComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.MetricComparisonComputation {

    static func write(value: QuickSightClientTypes.MetricComparisonComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["FromValue"].write(value.fromValue, with: QuickSightClientTypes.MeasureField.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["TargetValue"].write(value.targetValue, with: QuickSightClientTypes.MeasureField.write(value:to:))
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MetricComparisonComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MetricComparisonComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.fromValue = try reader["FromValue"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.targetValue = try reader["TargetValue"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.MaximumMinimumComputation {

    static func write(value: QuickSightClientTypes.MaximumMinimumComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MaximumMinimumComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MaximumMinimumComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.TotalAggregationComputation {

    static func write(value: QuickSightClientTypes.TotalAggregationComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TotalAggregationComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TotalAggregationComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopBottomMoversComputation {

    static func write(value: QuickSightClientTypes.TopBottomMoversComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["ComputationId"].write(value.computationId)
        try writer["MoverSize"].write(value.moverSize)
        try writer["Name"].write(value.name)
        try writer["SortOrder"].write(value.sortOrder)
        try writer["Time"].write(value.time, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopBottomMoversComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopBottomMoversComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.time = try reader["Time"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.category = try reader["Category"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.moverSize = try reader["MoverSize"].readIfPresent()
        value.sortOrder = try reader["SortOrder"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.TopBottomRankedComputation {

    static func write(value: QuickSightClientTypes.TopBottomRankedComputation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category, with: QuickSightClientTypes.DimensionField.write(value:to:))
        try writer["ComputationId"].write(value.computationId)
        try writer["Name"].write(value.name)
        try writer["ResultSize"].write(value.resultSize)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value, with: QuickSightClientTypes.MeasureField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopBottomRankedComputation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopBottomRankedComputation()
        value.computationId = try reader["ComputationId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.category = try reader["Category"].readIfPresent(with: QuickSightClientTypes.DimensionField.read(from:))
        value.value = try reader["Value"].readIfPresent(with: QuickSightClientTypes.MeasureField.read(from:))
        value.resultSize = try reader["ResultSize"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.WordCloudVisual {

    static func write(value: QuickSightClientTypes.WordCloudVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.WordCloudChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.WordCloudChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.WordCloudChartConfiguration {

    static func write(value: QuickSightClientTypes.WordCloudChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.WordCloudFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.WordCloudSortConfiguration.write(value:to:))
        try writer["WordCloudOptions"].write(value.wordCloudOptions, with: QuickSightClientTypes.WordCloudOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.WordCloudFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.WordCloudSortConfiguration.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.wordCloudOptions = try reader["WordCloudOptions"].readIfPresent(with: QuickSightClientTypes.WordCloudOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WordCloudOptions {

    static func write(value: QuickSightClientTypes.WordCloudOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudLayout"].write(value.cloudLayout)
        try writer["MaximumStringLength"].write(value.maximumStringLength)
        try writer["WordCasing"].write(value.wordCasing)
        try writer["WordOrientation"].write(value.wordOrientation)
        try writer["WordPadding"].write(value.wordPadding)
        try writer["WordScaling"].write(value.wordScaling)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudOptions()
        value.wordOrientation = try reader["WordOrientation"].readIfPresent()
        value.wordScaling = try reader["WordScaling"].readIfPresent()
        value.cloudLayout = try reader["CloudLayout"].readIfPresent()
        value.wordCasing = try reader["WordCasing"].readIfPresent()
        value.wordPadding = try reader["WordPadding"].readIfPresent()
        value.maximumStringLength = try reader["MaximumStringLength"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.WordCloudSortConfiguration {

    static func write(value: QuickSightClientTypes.WordCloudSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudSortConfiguration()
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.WordCloudFieldWells {

    static func write(value: QuickSightClientTypes.WordCloudFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WordCloudAggregatedFieldWells"].write(value.wordCloudAggregatedFieldWells, with: QuickSightClientTypes.WordCloudAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudFieldWells()
        value.wordCloudAggregatedFieldWells = try reader["WordCloudAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.WordCloudAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WordCloudAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.WordCloudAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Size"].writeList(value.size, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WordCloudAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WordCloudAggregatedFieldWells()
        value.groupBy = try reader["GroupBy"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.size = try reader["Size"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.HistogramVisual {

    static func write(value: QuickSightClientTypes.HistogramVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.HistogramConfiguration.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HistogramVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HistogramVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.HistogramConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.HistogramConfiguration {

    static func write(value: QuickSightClientTypes.HistogramConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BinOptions"].write(value.binOptions, with: QuickSightClientTypes.HistogramBinOptions.write(value:to:))
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.HistogramFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
        try writer["XAxisDisplayOptions"].write(value.xAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["XAxisLabelOptions"].write(value.xAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["YAxisDisplayOptions"].write(value.yAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HistogramConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HistogramConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.HistogramFieldWells.read(from:))
        value.xAxisDisplayOptions = try reader["XAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.xAxisLabelOptions = try reader["XAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.yAxisDisplayOptions = try reader["YAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.binOptions = try reader["BinOptions"].readIfPresent(with: QuickSightClientTypes.HistogramBinOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TooltipOptions {

    static func write(value: QuickSightClientTypes.TooltipOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldBasedTooltip"].write(value.fieldBasedTooltip, with: QuickSightClientTypes.FieldBasedTooltip.write(value:to:))
        try writer["SelectedTooltipType"].write(value.selectedTooltipType)
        try writer["TooltipVisibility"].write(value.tooltipVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TooltipOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TooltipOptions()
        value.tooltipVisibility = try reader["TooltipVisibility"].readIfPresent()
        value.selectedTooltipType = try reader["SelectedTooltipType"].readIfPresent()
        value.fieldBasedTooltip = try reader["FieldBasedTooltip"].readIfPresent(with: QuickSightClientTypes.FieldBasedTooltip.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FieldBasedTooltip {

    static func write(value: QuickSightClientTypes.FieldBasedTooltip?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationVisibility"].write(value.aggregationVisibility)
        try writer["TooltipFields"].writeList(value.tooltipFields, memberWritingClosure: QuickSightClientTypes.TooltipItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TooltipTitleType"].write(value.tooltipTitleType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldBasedTooltip {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldBasedTooltip()
        value.aggregationVisibility = try reader["AggregationVisibility"].readIfPresent()
        value.tooltipTitleType = try reader["TooltipTitleType"].readIfPresent()
        value.tooltipFields = try reader["TooltipFields"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TooltipItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TooltipItem {

    static func write(value: QuickSightClientTypes.TooltipItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnTooltipItem"].write(value.columnTooltipItem, with: QuickSightClientTypes.ColumnTooltipItem.write(value:to:))
        try writer["FieldTooltipItem"].write(value.fieldTooltipItem, with: QuickSightClientTypes.FieldTooltipItem.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TooltipItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TooltipItem()
        value.fieldTooltipItem = try reader["FieldTooltipItem"].readIfPresent(with: QuickSightClientTypes.FieldTooltipItem.read(from:))
        value.columnTooltipItem = try reader["ColumnTooltipItem"].readIfPresent(with: QuickSightClientTypes.ColumnTooltipItem.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ColumnTooltipItem {

    static func write(value: QuickSightClientTypes.ColumnTooltipItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Label"].write(value.label)
        try writer["TooltipTarget"].write(value.tooltipTarget)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnTooltipItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnTooltipItem()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.label = try reader["Label"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.aggregation = try reader["Aggregation"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        value.tooltipTarget = try reader["TooltipTarget"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FieldTooltipItem {

    static func write(value: QuickSightClientTypes.FieldTooltipItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["Label"].write(value.label)
        try writer["TooltipTarget"].write(value.tooltipTarget)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldTooltipItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldTooltipItem()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.label = try reader["Label"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.tooltipTarget = try reader["TooltipTarget"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.HistogramBinOptions {

    static func write(value: QuickSightClientTypes.HistogramBinOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BinCount"].write(value.binCount, with: QuickSightClientTypes.BinCountOptions.write(value:to:))
        try writer["BinWidth"].write(value.binWidth, with: QuickSightClientTypes.BinWidthOptions.write(value:to:))
        try writer["SelectedBinType"].write(value.selectedBinType)
        try writer["StartValue"].write(value.startValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HistogramBinOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HistogramBinOptions()
        value.selectedBinType = try reader["SelectedBinType"].readIfPresent()
        value.binCount = try reader["BinCount"].readIfPresent(with: QuickSightClientTypes.BinCountOptions.read(from:))
        value.binWidth = try reader["BinWidth"].readIfPresent(with: QuickSightClientTypes.BinWidthOptions.read(from:))
        value.startValue = try reader["StartValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BinWidthOptions {

    static func write(value: QuickSightClientTypes.BinWidthOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BinCountLimit"].write(value.binCountLimit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BinWidthOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BinWidthOptions()
        value.value = try reader["Value"].readIfPresent()
        value.binCountLimit = try reader["BinCountLimit"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BinCountOptions {

    static func write(value: QuickSightClientTypes.BinCountOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BinCountOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BinCountOptions()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.HistogramFieldWells {

    static func write(value: QuickSightClientTypes.HistogramFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HistogramAggregatedFieldWells"].write(value.histogramAggregatedFieldWells, with: QuickSightClientTypes.HistogramAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HistogramFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HistogramFieldWells()
        value.histogramAggregatedFieldWells = try reader["HistogramAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.HistogramAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.HistogramAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.HistogramAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HistogramAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HistogramAggregatedFieldWells()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.WaterfallVisual {

    static func write(value: QuickSightClientTypes.WaterfallVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.WaterfallChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.WaterfallChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartConfiguration {

    static func write(value: QuickSightClientTypes.WaterfallChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryAxisDisplayOptions"].write(value.categoryAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["CategoryAxisLabelOptions"].write(value.categoryAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ColorConfiguration"].write(value.colorConfiguration, with: QuickSightClientTypes.WaterfallChartColorConfiguration.write(value:to:))
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.WaterfallChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["PrimaryYAxisDisplayOptions"].write(value.primaryYAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["PrimaryYAxisLabelOptions"].write(value.primaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.WaterfallChartSortConfiguration.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
        try writer["WaterfallChartOptions"].write(value.waterfallChartOptions, with: QuickSightClientTypes.WaterfallChartOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.WaterfallChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.WaterfallChartSortConfiguration.read(from:))
        value.waterfallChartOptions = try reader["WaterfallChartOptions"].readIfPresent(with: QuickSightClientTypes.WaterfallChartOptions.read(from:))
        value.categoryAxisLabelOptions = try reader["CategoryAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.categoryAxisDisplayOptions = try reader["CategoryAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.primaryYAxisLabelOptions = try reader["PrimaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.primaryYAxisDisplayOptions = try reader["PrimaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.colorConfiguration = try reader["ColorConfiguration"].readIfPresent(with: QuickSightClientTypes.WaterfallChartColorConfiguration.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartColorConfiguration {

    static func write(value: QuickSightClientTypes.WaterfallChartColorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupColorConfiguration"].write(value.groupColorConfiguration, with: QuickSightClientTypes.WaterfallChartGroupColorConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartColorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartColorConfiguration()
        value.groupColorConfiguration = try reader["GroupColorConfiguration"].readIfPresent(with: QuickSightClientTypes.WaterfallChartGroupColorConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartGroupColorConfiguration {

    static func write(value: QuickSightClientTypes.WaterfallChartGroupColorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NegativeBarColor"].write(value.negativeBarColor)
        try writer["PositiveBarColor"].write(value.positiveBarColor)
        try writer["TotalBarColor"].write(value.totalBarColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartGroupColorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartGroupColorConfiguration()
        value.positiveBarColor = try reader["PositiveBarColor"].readIfPresent()
        value.negativeBarColor = try reader["NegativeBarColor"].readIfPresent()
        value.totalBarColor = try reader["TotalBarColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartOptions {

    static func write(value: QuickSightClientTypes.WaterfallChartOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TotalBarLabel"].write(value.totalBarLabel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartOptions()
        value.totalBarLabel = try reader["TotalBarLabel"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartSortConfiguration {

    static func write(value: QuickSightClientTypes.WaterfallChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BreakdownItemsLimit"].write(value.breakdownItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.breakdownItemsLimit = try reader["BreakdownItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartFieldWells {

    static func write(value: QuickSightClientTypes.WaterfallChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WaterfallChartAggregatedFieldWells"].write(value.waterfallChartAggregatedFieldWells, with: QuickSightClientTypes.WaterfallChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartFieldWells()
        value.waterfallChartAggregatedFieldWells = try reader["WaterfallChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.WaterfallChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WaterfallChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.WaterfallChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Breakdowns"].writeList(value.breakdowns, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Categories"].writeList(value.categories, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WaterfallChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WaterfallChartAggregatedFieldWells()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.breakdowns = try reader["Breakdowns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.BoxPlotVisual {

    static func write(value: QuickSightClientTypes.BoxPlotVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.BoxPlotChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.BoxPlotChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.BoxPlotChartConfiguration {

    static func write(value: QuickSightClientTypes.BoxPlotChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoxPlotOptions"].write(value.boxPlotOptions, with: QuickSightClientTypes.BoxPlotOptions.write(value:to:))
        try writer["CategoryAxis"].write(value.categoryAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.BoxPlotFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["PrimaryYAxisDisplayOptions"].write(value.primaryYAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["PrimaryYAxisLabelOptions"].write(value.primaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ReferenceLines"].writeList(value.referenceLines, memberWritingClosure: QuickSightClientTypes.ReferenceLine.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.BoxPlotSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.BoxPlotFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.BoxPlotSortConfiguration.read(from:))
        value.boxPlotOptions = try reader["BoxPlotOptions"].readIfPresent(with: QuickSightClientTypes.BoxPlotOptions.read(from:))
        value.categoryAxis = try reader["CategoryAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.primaryYAxisDisplayOptions = try reader["PrimaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.primaryYAxisLabelOptions = try reader["PrimaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.referenceLines = try reader["ReferenceLines"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ReferenceLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ReferenceLine {

    static func write(value: QuickSightClientTypes.ReferenceLine?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataConfiguration"].write(value.dataConfiguration, with: QuickSightClientTypes.ReferenceLineDataConfiguration.write(value:to:))
        try writer["LabelConfiguration"].write(value.labelConfiguration, with: QuickSightClientTypes.ReferenceLineLabelConfiguration.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["StyleConfiguration"].write(value.styleConfiguration, with: QuickSightClientTypes.ReferenceLineStyleConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLine()
        value.status = try reader["Status"].readIfPresent()
        value.dataConfiguration = try reader["DataConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineDataConfiguration.read(from:))
        value.styleConfiguration = try reader["StyleConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineStyleConfiguration.read(from:))
        value.labelConfiguration = try reader["LabelConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineLabelConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineLabelConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineLabelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabelConfiguration"].write(value.customLabelConfiguration, with: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration.write(value:to:))
        try writer["FontColor"].write(value.fontColor)
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["HorizontalPosition"].write(value.horizontalPosition)
        try writer["ValueLabelConfiguration"].write(value.valueLabelConfiguration, with: QuickSightClientTypes.ReferenceLineValueLabelConfiguration.write(value:to:))
        try writer["VerticalPosition"].write(value.verticalPosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineLabelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineLabelConfiguration()
        value.valueLabelConfiguration = try reader["ValueLabelConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineValueLabelConfiguration.read(from:))
        value.customLabelConfiguration = try reader["CustomLabelConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration.read(from:))
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.fontColor = try reader["FontColor"].readIfPresent()
        value.horizontalPosition = try reader["HorizontalPosition"].readIfPresent()
        value.verticalPosition = try reader["VerticalPosition"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineCustomLabelConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineCustomLabelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineCustomLabelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineCustomLabelConfiguration()
        value.customLabel = try reader["CustomLabel"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineValueLabelConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineValueLabelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.NumericFormatConfiguration.write(value:to:))
        try writer["RelativePosition"].write(value.relativePosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineValueLabelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineValueLabelConfiguration()
        value.relativePosition = try reader["RelativePosition"].readIfPresent()
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumericFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineStyleConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineStyleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Pattern"].write(value.pattern)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineStyleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineStyleConfiguration()
        value.pattern = try reader["Pattern"].readIfPresent()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineDataConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineDataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisBinding"].write(value.axisBinding)
        try writer["DynamicConfiguration"].write(value.dynamicConfiguration, with: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration.write(value:to:))
        try writer["SeriesType"].write(value.seriesType)
        try writer["StaticConfiguration"].write(value.staticConfiguration, with: QuickSightClientTypes.ReferenceLineStaticDataConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineDataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineDataConfiguration()
        value.staticConfiguration = try reader["StaticConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineStaticDataConfiguration.read(from:))
        value.dynamicConfiguration = try reader["DynamicConfiguration"].readIfPresent(with: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration.read(from:))
        value.axisBinding = try reader["AxisBinding"].readIfPresent()
        value.seriesType = try reader["SeriesType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineDynamicDataConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineDynamicDataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Calculation"].write(value.calculation, with: QuickSightClientTypes.NumericalAggregationFunction.write(value:to:))
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["MeasureAggregationFunction"].write(value.measureAggregationFunction, with: QuickSightClientTypes.AggregationFunction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineDynamicDataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineDynamicDataConfiguration()
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.measureAggregationFunction = try reader["MeasureAggregationFunction"].readIfPresent(with: QuickSightClientTypes.AggregationFunction.read(from:))
        value.calculation = try reader["Calculation"].readIfPresent(with: QuickSightClientTypes.NumericalAggregationFunction.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ReferenceLineStaticDataConfiguration {

    static func write(value: QuickSightClientTypes.ReferenceLineStaticDataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ReferenceLineStaticDataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ReferenceLineStaticDataConfiguration()
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.BoxPlotOptions {

    static func write(value: QuickSightClientTypes.BoxPlotOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllDataPointsVisibility"].write(value.allDataPointsVisibility)
        try writer["OutlierVisibility"].write(value.outlierVisibility)
        try writer["StyleOptions"].write(value.styleOptions, with: QuickSightClientTypes.BoxPlotStyleOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotOptions()
        value.styleOptions = try reader["StyleOptions"].readIfPresent(with: QuickSightClientTypes.BoxPlotStyleOptions.read(from:))
        value.outlierVisibility = try reader["OutlierVisibility"].readIfPresent()
        value.allDataPointsVisibility = try reader["AllDataPointsVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BoxPlotStyleOptions {

    static func write(value: QuickSightClientTypes.BoxPlotStyleOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FillStyle"].write(value.fillStyle)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotStyleOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotStyleOptions()
        value.fillStyle = try reader["FillStyle"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.BoxPlotSortConfiguration {

    static func write(value: QuickSightClientTypes.BoxPlotSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PaginationConfiguration"].write(value.paginationConfiguration, with: QuickSightClientTypes.PaginationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.paginationConfiguration = try reader["PaginationConfiguration"].readIfPresent(with: QuickSightClientTypes.PaginationConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PaginationConfiguration {

    static func write(value: QuickSightClientTypes.PaginationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PageNumber"].write(value.pageNumber)
        try writer["PageSize"].write(value.pageSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PaginationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PaginationConfiguration()
        value.pageSize = try reader["PageSize"].readIfPresent()
        value.pageNumber = try reader["PageNumber"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.BoxPlotFieldWells {

    static func write(value: QuickSightClientTypes.BoxPlotFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BoxPlotAggregatedFieldWells"].write(value.boxPlotAggregatedFieldWells, with: QuickSightClientTypes.BoxPlotAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotFieldWells()
        value.boxPlotAggregatedFieldWells = try reader["BoxPlotAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.BoxPlotAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BoxPlotAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.BoxPlotAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BoxPlotAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BoxPlotAggregatedFieldWells()
        value.groupBy = try reader["GroupBy"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ComboChartVisual {

    static func write(value: QuickSightClientTypes.ComboChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.ComboChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComboChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComboChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.ComboChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ComboChartConfiguration {

    static func write(value: QuickSightClientTypes.ComboChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BarDataLabels"].write(value.barDataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["BarsArrangement"].write(value.barsArrangement)
        try writer["CategoryAxis"].write(value.categoryAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ColorLabelOptions"].write(value.colorLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.ComboChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["LineDataLabels"].write(value.lineDataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["PrimaryYAxisDisplayOptions"].write(value.primaryYAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["PrimaryYAxisLabelOptions"].write(value.primaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ReferenceLines"].writeList(value.referenceLines, memberWritingClosure: QuickSightClientTypes.ReferenceLine.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecondaryYAxisDisplayOptions"].write(value.secondaryYAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["SecondaryYAxisLabelOptions"].write(value.secondaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["SingleAxisOptions"].write(value.singleAxisOptions, with: QuickSightClientTypes.SingleAxisOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.ComboChartSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComboChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComboChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.ComboChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.ComboChartSortConfiguration.read(from:))
        value.barsArrangement = try reader["BarsArrangement"].readIfPresent()
        value.categoryAxis = try reader["CategoryAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.primaryYAxisDisplayOptions = try reader["PrimaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.primaryYAxisLabelOptions = try reader["PrimaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.secondaryYAxisDisplayOptions = try reader["SecondaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.secondaryYAxisLabelOptions = try reader["SecondaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.singleAxisOptions = try reader["SingleAxisOptions"].readIfPresent(with: QuickSightClientTypes.SingleAxisOptions.read(from:))
        value.colorLabelOptions = try reader["ColorLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.barDataLabels = try reader["BarDataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.lineDataLabels = try reader["LineDataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.referenceLines = try reader["ReferenceLines"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ReferenceLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SingleAxisOptions {

    static func write(value: QuickSightClientTypes.SingleAxisOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["YAxisOptions"].write(value.yAxisOptions, with: QuickSightClientTypes.YAxisOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SingleAxisOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SingleAxisOptions()
        value.yAxisOptions = try reader["YAxisOptions"].readIfPresent(with: QuickSightClientTypes.YAxisOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.YAxisOptions {

    static func write(value: QuickSightClientTypes.YAxisOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["YAxis"].write(value.yAxis)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.YAxisOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.YAxisOptions()
        value.yAxis = try reader["YAxis"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.ComboChartSortConfiguration {

    static func write(value: QuickSightClientTypes.ComboChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColorItemsLimit"].write(value.colorItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["ColorSort"].writeList(value.colorSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComboChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComboChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.colorSort = try reader["ColorSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colorItemsLimit = try reader["ColorItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ComboChartFieldWells {

    static func write(value: QuickSightClientTypes.ComboChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComboChartAggregatedFieldWells"].write(value.comboChartAggregatedFieldWells, with: QuickSightClientTypes.ComboChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComboChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComboChartFieldWells()
        value.comboChartAggregatedFieldWells = try reader["ComboChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.ComboChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ComboChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.ComboChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BarValues"].writeList(value.barValues, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LineValues"].writeList(value.lineValues, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComboChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComboChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.barValues = try reader["BarValues"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lineValues = try reader["LineValues"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotVisual {

    static func write(value: QuickSightClientTypes.ScatterPlotVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.ScatterPlotConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.ScatterPlotConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotConfiguration {

    static func write(value: QuickSightClientTypes.ScatterPlotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.ScatterPlotFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.ScatterPlotSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
        try writer["XAxisDisplayOptions"].write(value.xAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["XAxisLabelOptions"].write(value.xAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["YAxisDisplayOptions"].write(value.yAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["YAxisLabelOptions"].write(value.yAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.ScatterPlotFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.ScatterPlotSortConfiguration.read(from:))
        value.xAxisLabelOptions = try reader["XAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.xAxisDisplayOptions = try reader["XAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.yAxisLabelOptions = try reader["YAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.yAxisDisplayOptions = try reader["YAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotSortConfiguration {

    static func write(value: QuickSightClientTypes.ScatterPlotSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScatterPlotLimitConfiguration"].write(value.scatterPlotLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotSortConfiguration()
        value.scatterPlotLimitConfiguration = try reader["ScatterPlotLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotFieldWells {

    static func write(value: QuickSightClientTypes.ScatterPlotFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScatterPlotCategoricallyAggregatedFieldWells"].write(value.scatterPlotCategoricallyAggregatedFieldWells, with: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells.write(value:to:))
        try writer["ScatterPlotUnaggregatedFieldWells"].write(value.scatterPlotUnaggregatedFieldWells, with: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotFieldWells()
        value.scatterPlotCategoricallyAggregatedFieldWells = try reader["ScatterPlotCategoricallyAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells.read(from:))
        value.scatterPlotUnaggregatedFieldWells = try reader["ScatterPlotUnaggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells {

    static func write(value: QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Label"].writeList(value.label, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Size"].writeList(value.size, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["XAxis"].writeList(value.xAxis, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["YAxis"].writeList(value.yAxis, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotUnaggregatedFieldWells()
        value.xAxis = try reader["XAxis"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.yAxis = try reader["YAxis"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.size = try reader["Size"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Label"].writeList(value.label, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Size"].writeList(value.size, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["XAxis"].writeList(value.xAxis, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["YAxis"].writeList(value.yAxis, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScatterPlotCategoricallyAggregatedFieldWells()
        value.xAxis = try reader["XAxis"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.yAxis = try reader["YAxis"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.size = try reader["Size"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.label = try reader["Label"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FunnelChartVisual {

    static func write(value: QuickSightClientTypes.FunnelChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.FunnelChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.FunnelChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FunnelChartConfiguration {

    static func write(value: QuickSightClientTypes.FunnelChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["DataLabelOptions"].write(value.dataLabelOptions, with: QuickSightClientTypes.FunnelChartDataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.FunnelChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.FunnelChartSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["ValueLabelOptions"].write(value.valueLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.FunnelChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.FunnelChartSortConfiguration.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.valueLabelOptions = try reader["ValueLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.dataLabelOptions = try reader["DataLabelOptions"].readIfPresent(with: QuickSightClientTypes.FunnelChartDataLabelOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FunnelChartDataLabelOptions {

    static func write(value: QuickSightClientTypes.FunnelChartDataLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryLabelVisibility"].write(value.categoryLabelVisibility)
        try writer["LabelColor"].write(value.labelColor)
        try writer["LabelFontConfiguration"].write(value.labelFontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["MeasureDataLabelStyle"].write(value.measureDataLabelStyle)
        try writer["MeasureLabelVisibility"].write(value.measureLabelVisibility)
        try writer["Position"].write(value.position)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartDataLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartDataLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.categoryLabelVisibility = try reader["CategoryLabelVisibility"].readIfPresent()
        value.measureLabelVisibility = try reader["MeasureLabelVisibility"].readIfPresent()
        value.position = try reader["Position"].readIfPresent()
        value.labelFontConfiguration = try reader["LabelFontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.labelColor = try reader["LabelColor"].readIfPresent()
        value.measureDataLabelStyle = try reader["MeasureDataLabelStyle"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FunnelChartSortConfiguration {

    static func write(value: QuickSightClientTypes.FunnelChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FunnelChartFieldWells {

    static func write(value: QuickSightClientTypes.FunnelChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunnelChartAggregatedFieldWells"].write(value.funnelChartAggregatedFieldWells, with: QuickSightClientTypes.FunnelChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartFieldWells()
        value.funnelChartAggregatedFieldWells = try reader["FunnelChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.FunnelChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FunnelChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.FunnelChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FunnelChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FunnelChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FilledMapVisual {

    static func write(value: QuickSightClientTypes.FilledMapVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.FilledMapConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConditionalFormatting"].write(value.conditionalFormatting, with: QuickSightClientTypes.FilledMapConditionalFormatting.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.FilledMapConfiguration.read(from:))
        value.conditionalFormatting = try reader["ConditionalFormatting"].readIfPresent(with: QuickSightClientTypes.FilledMapConditionalFormatting.read(from:))
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FilledMapConditionalFormatting {

    static func write(value: QuickSightClientTypes.FilledMapConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionalFormattingOptions"].writeList(value.conditionalFormattingOptions, memberWritingClosure: QuickSightClientTypes.FilledMapConditionalFormattingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapConditionalFormatting()
        value.conditionalFormattingOptions = try reader["ConditionalFormattingOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilledMapConditionalFormattingOption.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.FilledMapConditionalFormattingOption {

    static func write(value: QuickSightClientTypes.FilledMapConditionalFormattingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Shape"].write(value.shape, with: QuickSightClientTypes.FilledMapShapeConditionalFormatting.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapConditionalFormattingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapConditionalFormattingOption()
        value.shape = try reader["Shape"].readIfPresent(with: QuickSightClientTypes.FilledMapShapeConditionalFormatting.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilledMapShapeConditionalFormatting {

    static func write(value: QuickSightClientTypes.FilledMapShapeConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["Format"].write(value.format, with: QuickSightClientTypes.ShapeConditionalFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapShapeConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapShapeConditionalFormatting()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.format = try reader["Format"].readIfPresent(with: QuickSightClientTypes.ShapeConditionalFormat.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ShapeConditionalFormat {

    static func write(value: QuickSightClientTypes.ShapeConditionalFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ShapeConditionalFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ShapeConditionalFormat()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingColor {

    static func write(value: QuickSightClientTypes.ConditionalFormattingColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gradient"].write(value.gradient, with: QuickSightClientTypes.ConditionalFormattingGradientColor.write(value:to:))
        try writer["Solid"].write(value.solid, with: QuickSightClientTypes.ConditionalFormattingSolidColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingColor()
        value.solid = try reader["Solid"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingSolidColor.read(from:))
        value.gradient = try reader["Gradient"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingGradientColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingGradientColor {

    static func write(value: QuickSightClientTypes.ConditionalFormattingGradientColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color, with: QuickSightClientTypes.GradientColor.write(value:to:))
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingGradientColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingGradientColor()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.color = try reader["Color"].readIfPresent(with: QuickSightClientTypes.GradientColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GradientColor {

    static func write(value: QuickSightClientTypes.GradientColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Stops"].writeList(value.stops, memberWritingClosure: QuickSightClientTypes.GradientStop.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GradientColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GradientColor()
        value.stops = try reader["Stops"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.GradientStop.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GradientStop {

    static func write(value: QuickSightClientTypes.GradientStop?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["DataValue"].write(value.dataValue)
        try writer["GradientOffset"].write(value.gradientOffset)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GradientStop {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GradientStop()
        value.gradientOffset = try reader["GradientOffset"].readIfPresent() ?? 0
        value.dataValue = try reader["DataValue"].readIfPresent()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingSolidColor {

    static func write(value: QuickSightClientTypes.ConditionalFormattingSolidColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingSolidColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingSolidColor()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilledMapConfiguration {

    static func write(value: QuickSightClientTypes.FilledMapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.FilledMapFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["MapStyleOptions"].write(value.mapStyleOptions, with: QuickSightClientTypes.GeospatialMapStyleOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.FilledMapSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["WindowOptions"].write(value.windowOptions, with: QuickSightClientTypes.GeospatialWindowOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.FilledMapFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.FilledMapSortConfiguration.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.windowOptions = try reader["WindowOptions"].readIfPresent(with: QuickSightClientTypes.GeospatialWindowOptions.read(from:))
        value.mapStyleOptions = try reader["MapStyleOptions"].readIfPresent(with: QuickSightClientTypes.GeospatialMapStyleOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeospatialMapStyleOptions {

    static func write(value: QuickSightClientTypes.GeospatialMapStyleOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BaseMapStyle"].write(value.baseMapStyle)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialMapStyleOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialMapStyleOptions()
        value.baseMapStyle = try reader["BaseMapStyle"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GeospatialWindowOptions {

    static func write(value: QuickSightClientTypes.GeospatialWindowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bounds"].write(value.bounds, with: QuickSightClientTypes.GeospatialCoordinateBounds.write(value:to:))
        try writer["MapZoomMode"].write(value.mapZoomMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialWindowOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialWindowOptions()
        value.bounds = try reader["Bounds"].readIfPresent(with: QuickSightClientTypes.GeospatialCoordinateBounds.read(from:))
        value.mapZoomMode = try reader["MapZoomMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GeospatialCoordinateBounds {

    static func write(value: QuickSightClientTypes.GeospatialCoordinateBounds?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["East"].write(value.east)
        try writer["North"].write(value.north)
        try writer["South"].write(value.south)
        try writer["West"].write(value.west)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialCoordinateBounds {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialCoordinateBounds()
        value.north = try reader["North"].readIfPresent() ?? 0.0
        value.south = try reader["South"].readIfPresent() ?? 0.0
        value.west = try reader["West"].readIfPresent() ?? 0.0
        value.east = try reader["East"].readIfPresent() ?? 0.0
        return value
    }
}

extension QuickSightClientTypes.FilledMapSortConfiguration {

    static func write(value: QuickSightClientTypes.FilledMapSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FilledMapFieldWells {

    static func write(value: QuickSightClientTypes.FilledMapFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilledMapAggregatedFieldWells"].write(value.filledMapAggregatedFieldWells, with: QuickSightClientTypes.FilledMapAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapFieldWells()
        value.filledMapAggregatedFieldWells = try reader["FilledMapAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.FilledMapAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilledMapAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.FilledMapAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Geospatial"].writeList(value.geospatial, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilledMapAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilledMapAggregatedFieldWells()
        value.geospatial = try reader["Geospatial"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GeospatialMapVisual {

    static func write(value: QuickSightClientTypes.GeospatialMapVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.GeospatialMapConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialMapVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialMapVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.GeospatialMapConfiguration.read(from:))
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GeospatialMapConfiguration {

    static func write(value: QuickSightClientTypes.GeospatialMapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.GeospatialMapFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["MapStyleOptions"].write(value.mapStyleOptions, with: QuickSightClientTypes.GeospatialMapStyleOptions.write(value:to:))
        try writer["PointStyleOptions"].write(value.pointStyleOptions, with: QuickSightClientTypes.GeospatialPointStyleOptions.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
        try writer["WindowOptions"].write(value.windowOptions, with: QuickSightClientTypes.GeospatialWindowOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialMapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialMapConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.GeospatialMapFieldWells.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.windowOptions = try reader["WindowOptions"].readIfPresent(with: QuickSightClientTypes.GeospatialWindowOptions.read(from:))
        value.mapStyleOptions = try reader["MapStyleOptions"].readIfPresent(with: QuickSightClientTypes.GeospatialMapStyleOptions.read(from:))
        value.pointStyleOptions = try reader["PointStyleOptions"].readIfPresent(with: QuickSightClientTypes.GeospatialPointStyleOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeospatialPointStyleOptions {

    static func write(value: QuickSightClientTypes.GeospatialPointStyleOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterMarkerConfiguration"].write(value.clusterMarkerConfiguration, with: QuickSightClientTypes.ClusterMarkerConfiguration.write(value:to:))
        try writer["HeatmapConfiguration"].write(value.heatmapConfiguration, with: QuickSightClientTypes.GeospatialHeatmapConfiguration.write(value:to:))
        try writer["SelectedPointStyle"].write(value.selectedPointStyle)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialPointStyleOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialPointStyleOptions()
        value.selectedPointStyle = try reader["SelectedPointStyle"].readIfPresent()
        value.clusterMarkerConfiguration = try reader["ClusterMarkerConfiguration"].readIfPresent(with: QuickSightClientTypes.ClusterMarkerConfiguration.read(from:))
        value.heatmapConfiguration = try reader["HeatmapConfiguration"].readIfPresent(with: QuickSightClientTypes.GeospatialHeatmapConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeospatialHeatmapConfiguration {

    static func write(value: QuickSightClientTypes.GeospatialHeatmapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeatmapColor"].write(value.heatmapColor, with: QuickSightClientTypes.GeospatialHeatmapColorScale.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialHeatmapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialHeatmapConfiguration()
        value.heatmapColor = try reader["HeatmapColor"].readIfPresent(with: QuickSightClientTypes.GeospatialHeatmapColorScale.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeospatialHeatmapColorScale {

    static func write(value: QuickSightClientTypes.GeospatialHeatmapColorScale?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.GeospatialHeatmapDataColor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialHeatmapColorScale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialHeatmapColorScale()
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.GeospatialHeatmapDataColor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GeospatialHeatmapDataColor {

    static func write(value: QuickSightClientTypes.GeospatialHeatmapDataColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialHeatmapDataColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialHeatmapDataColor()
        value.color = try reader["Color"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.ClusterMarkerConfiguration {

    static func write(value: QuickSightClientTypes.ClusterMarkerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterMarker"].write(value.clusterMarker, with: QuickSightClientTypes.ClusterMarker.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ClusterMarkerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ClusterMarkerConfiguration()
        value.clusterMarker = try reader["ClusterMarker"].readIfPresent(with: QuickSightClientTypes.ClusterMarker.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ClusterMarker {

    static func write(value: QuickSightClientTypes.ClusterMarker?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SimpleClusterMarker"].write(value.simpleClusterMarker, with: QuickSightClientTypes.SimpleClusterMarker.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ClusterMarker {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ClusterMarker()
        value.simpleClusterMarker = try reader["SimpleClusterMarker"].readIfPresent(with: QuickSightClientTypes.SimpleClusterMarker.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SimpleClusterMarker {

    static func write(value: QuickSightClientTypes.SimpleClusterMarker?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SimpleClusterMarker {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SimpleClusterMarker()
        value.color = try reader["Color"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GeospatialMapFieldWells {

    static func write(value: QuickSightClientTypes.GeospatialMapFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeospatialMapAggregatedFieldWells"].write(value.geospatialMapAggregatedFieldWells, with: QuickSightClientTypes.GeospatialMapAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialMapFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialMapFieldWells()
        value.geospatialMapAggregatedFieldWells = try reader["GeospatialMapAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.GeospatialMapAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeospatialMapAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.GeospatialMapAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Geospatial"].writeList(value.geospatial, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeospatialMapAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeospatialMapAggregatedFieldWells()
        value.geospatial = try reader["Geospatial"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TreeMapVisual {

    static func write(value: QuickSightClientTypes.TreeMapVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.TreeMapConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TreeMapVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TreeMapVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.TreeMapConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TreeMapConfiguration {

    static func write(value: QuickSightClientTypes.TreeMapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColorLabelOptions"].write(value.colorLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ColorScale"].write(value.colorScale, with: QuickSightClientTypes.ColorScale.write(value:to:))
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.TreeMapFieldWells.write(value:to:))
        try writer["GroupLabelOptions"].write(value.groupLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["SizeLabelOptions"].write(value.sizeLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.TreeMapSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TreeMapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TreeMapConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.TreeMapFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.TreeMapSortConfiguration.read(from:))
        value.groupLabelOptions = try reader["GroupLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.sizeLabelOptions = try reader["SizeLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.colorLabelOptions = try reader["ColorLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.colorScale = try reader["ColorScale"].readIfPresent(with: QuickSightClientTypes.ColorScale.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ColorScale {

    static func write(value: QuickSightClientTypes.ColorScale?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColorFillType"].write(value.colorFillType)
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.DataColor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NullValueColor"].write(value.nullValueColor, with: QuickSightClientTypes.DataColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColorScale {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColorScale()
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataColor.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.colorFillType = try reader["ColorFillType"].readIfPresent() ?? .sdkUnknown("")
        value.nullValueColor = try reader["NullValueColor"].readIfPresent(with: QuickSightClientTypes.DataColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataColor {

    static func write(value: QuickSightClientTypes.DataColor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["DataValue"].write(value.dataValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataColor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataColor()
        value.color = try reader["Color"].readIfPresent()
        value.dataValue = try reader["DataValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TreeMapSortConfiguration {

    static func write(value: QuickSightClientTypes.TreeMapSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TreeMapGroupItemsLimitConfiguration"].write(value.treeMapGroupItemsLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["TreeMapSort"].writeList(value.treeMapSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TreeMapSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TreeMapSortConfiguration()
        value.treeMapSort = try reader["TreeMapSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.treeMapGroupItemsLimitConfiguration = try reader["TreeMapGroupItemsLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TreeMapFieldWells {

    static func write(value: QuickSightClientTypes.TreeMapFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TreeMapAggregatedFieldWells"].write(value.treeMapAggregatedFieldWells, with: QuickSightClientTypes.TreeMapAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TreeMapFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TreeMapFieldWells()
        value.treeMapAggregatedFieldWells = try reader["TreeMapAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.TreeMapAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TreeMapAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.TreeMapAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Groups"].writeList(value.groups, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sizes"].writeList(value.sizes, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TreeMapAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TreeMapAggregatedFieldWells()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sizes = try reader["Sizes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.HeatMapVisual {

    static func write(value: QuickSightClientTypes.HeatMapVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.HeatMapConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeatMapVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeatMapVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.HeatMapConfiguration.read(from:))
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.HeatMapConfiguration {

    static func write(value: QuickSightClientTypes.HeatMapConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColorScale"].write(value.colorScale, with: QuickSightClientTypes.ColorScale.write(value:to:))
        try writer["ColumnLabelOptions"].write(value.columnLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.HeatMapFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["RowLabelOptions"].write(value.rowLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.HeatMapSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeatMapConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeatMapConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.HeatMapFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.HeatMapSortConfiguration.read(from:))
        value.rowLabelOptions = try reader["RowLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.columnLabelOptions = try reader["ColumnLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.colorScale = try reader["ColorScale"].readIfPresent(with: QuickSightClientTypes.ColorScale.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.HeatMapSortConfiguration {

    static func write(value: QuickSightClientTypes.HeatMapSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeatMapColumnItemsLimitConfiguration"].write(value.heatMapColumnItemsLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["HeatMapColumnSort"].writeList(value.heatMapColumnSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["HeatMapRowItemsLimitConfiguration"].write(value.heatMapRowItemsLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["HeatMapRowSort"].writeList(value.heatMapRowSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeatMapSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeatMapSortConfiguration()
        value.heatMapRowSort = try reader["HeatMapRowSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.heatMapColumnSort = try reader["HeatMapColumnSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.heatMapRowItemsLimitConfiguration = try reader["HeatMapRowItemsLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.heatMapColumnItemsLimitConfiguration = try reader["HeatMapColumnItemsLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.HeatMapFieldWells {

    static func write(value: QuickSightClientTypes.HeatMapFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HeatMapAggregatedFieldWells"].write(value.heatMapAggregatedFieldWells, with: QuickSightClientTypes.HeatMapAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeatMapFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeatMapFieldWells()
        value.heatMapAggregatedFieldWells = try reader["HeatMapAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.HeatMapAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.HeatMapAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.HeatMapAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Rows"].writeList(value.rows, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.HeatMapAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.HeatMapAggregatedFieldWells()
        value.rows = try reader["Rows"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.LineChartVisual {

    static func write(value: QuickSightClientTypes.LineChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.LineChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.LineChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.LineChartConfiguration {

    static func write(value: QuickSightClientTypes.LineChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContributionAnalysisDefaults"].writeList(value.contributionAnalysisDefaults, memberWritingClosure: QuickSightClientTypes.ContributionAnalysisDefault.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["DefaultSeriesSettings"].write(value.defaultSeriesSettings, with: QuickSightClientTypes.LineChartDefaultSeriesSettings.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.LineChartFieldWells.write(value:to:))
        try writer["ForecastConfigurations"].writeList(value.forecastConfigurations, memberWritingClosure: QuickSightClientTypes.ForecastConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["PrimaryYAxisDisplayOptions"].write(value.primaryYAxisDisplayOptions, with: QuickSightClientTypes.LineSeriesAxisDisplayOptions.write(value:to:))
        try writer["PrimaryYAxisLabelOptions"].write(value.primaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ReferenceLines"].writeList(value.referenceLines, memberWritingClosure: QuickSightClientTypes.ReferenceLine.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecondaryYAxisDisplayOptions"].write(value.secondaryYAxisDisplayOptions, with: QuickSightClientTypes.LineSeriesAxisDisplayOptions.write(value:to:))
        try writer["SecondaryYAxisLabelOptions"].write(value.secondaryYAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["Series"].writeList(value.series, memberWritingClosure: QuickSightClientTypes.SeriesItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SingleAxisOptions"].write(value.singleAxisOptions, with: QuickSightClientTypes.SingleAxisOptions.write(value:to:))
        try writer["SmallMultiplesOptions"].write(value.smallMultiplesOptions, with: QuickSightClientTypes.SmallMultiplesOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.LineChartSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
        try writer["XAxisDisplayOptions"].write(value.xAxisDisplayOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["XAxisLabelOptions"].write(value.xAxisLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.LineChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.LineChartSortConfiguration.read(from:))
        value.forecastConfigurations = try reader["ForecastConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ForecastConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.smallMultiplesOptions = try reader["SmallMultiplesOptions"].readIfPresent(with: QuickSightClientTypes.SmallMultiplesOptions.read(from:))
        value.xAxisDisplayOptions = try reader["XAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.xAxisLabelOptions = try reader["XAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.primaryYAxisDisplayOptions = try reader["PrimaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.LineSeriesAxisDisplayOptions.read(from:))
        value.primaryYAxisLabelOptions = try reader["PrimaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.secondaryYAxisDisplayOptions = try reader["SecondaryYAxisDisplayOptions"].readIfPresent(with: QuickSightClientTypes.LineSeriesAxisDisplayOptions.read(from:))
        value.secondaryYAxisLabelOptions = try reader["SecondaryYAxisLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.singleAxisOptions = try reader["SingleAxisOptions"].readIfPresent(with: QuickSightClientTypes.SingleAxisOptions.read(from:))
        value.defaultSeriesSettings = try reader["DefaultSeriesSettings"].readIfPresent(with: QuickSightClientTypes.LineChartDefaultSeriesSettings.read(from:))
        value.series = try reader["Series"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SeriesItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.referenceLines = try reader["ReferenceLines"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ReferenceLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.contributionAnalysisDefaults = try reader["ContributionAnalysisDefaults"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ContributionAnalysisDefault.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ContributionAnalysisDefault {

    static func write(value: QuickSightClientTypes.ContributionAnalysisDefault?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContributorDimensions"].writeList(value.contributorDimensions, memberWritingClosure: QuickSightClientTypes.ColumnIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MeasureFieldId"].write(value.measureFieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ContributionAnalysisDefault {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ContributionAnalysisDefault()
        value.measureFieldId = try reader["MeasureFieldId"].readIfPresent() ?? ""
        value.contributorDimensions = try reader["ContributorDimensions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.SeriesItem {

    static func write(value: QuickSightClientTypes.SeriesItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataFieldSeriesItem"].write(value.dataFieldSeriesItem, with: QuickSightClientTypes.DataFieldSeriesItem.write(value:to:))
        try writer["FieldSeriesItem"].write(value.fieldSeriesItem, with: QuickSightClientTypes.FieldSeriesItem.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SeriesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SeriesItem()
        value.fieldSeriesItem = try reader["FieldSeriesItem"].readIfPresent(with: QuickSightClientTypes.FieldSeriesItem.read(from:))
        value.dataFieldSeriesItem = try reader["DataFieldSeriesItem"].readIfPresent(with: QuickSightClientTypes.DataFieldSeriesItem.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataFieldSeriesItem {

    static func write(value: QuickSightClientTypes.DataFieldSeriesItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisBinding"].write(value.axisBinding)
        try writer["FieldId"].write(value.fieldId)
        try writer["FieldValue"].write(value.fieldValue)
        try writer["Settings"].write(value.settings, with: QuickSightClientTypes.LineChartSeriesSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataFieldSeriesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataFieldSeriesItem()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.fieldValue = try reader["FieldValue"].readIfPresent()
        value.axisBinding = try reader["AxisBinding"].readIfPresent() ?? .sdkUnknown("")
        value.settings = try reader["Settings"].readIfPresent(with: QuickSightClientTypes.LineChartSeriesSettings.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineChartSeriesSettings {

    static func write(value: QuickSightClientTypes.LineChartSeriesSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineStyleSettings"].write(value.lineStyleSettings, with: QuickSightClientTypes.LineChartLineStyleSettings.write(value:to:))
        try writer["MarkerStyleSettings"].write(value.markerStyleSettings, with: QuickSightClientTypes.LineChartMarkerStyleSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartSeriesSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartSeriesSettings()
        value.lineStyleSettings = try reader["LineStyleSettings"].readIfPresent(with: QuickSightClientTypes.LineChartLineStyleSettings.read(from:))
        value.markerStyleSettings = try reader["MarkerStyleSettings"].readIfPresent(with: QuickSightClientTypes.LineChartMarkerStyleSettings.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineChartMarkerStyleSettings {

    static func write(value: QuickSightClientTypes.LineChartMarkerStyleSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarkerColor"].write(value.markerColor)
        try writer["MarkerShape"].write(value.markerShape)
        try writer["MarkerSize"].write(value.markerSize)
        try writer["MarkerVisibility"].write(value.markerVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartMarkerStyleSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartMarkerStyleSettings()
        value.markerVisibility = try reader["MarkerVisibility"].readIfPresent()
        value.markerShape = try reader["MarkerShape"].readIfPresent()
        value.markerSize = try reader["MarkerSize"].readIfPresent()
        value.markerColor = try reader["MarkerColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LineChartLineStyleSettings {

    static func write(value: QuickSightClientTypes.LineChartLineStyleSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineInterpolation"].write(value.lineInterpolation)
        try writer["LineStyle"].write(value.lineStyle)
        try writer["LineVisibility"].write(value.lineVisibility)
        try writer["LineWidth"].write(value.lineWidth)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartLineStyleSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartLineStyleSettings()
        value.lineVisibility = try reader["LineVisibility"].readIfPresent()
        value.lineInterpolation = try reader["LineInterpolation"].readIfPresent()
        value.lineStyle = try reader["LineStyle"].readIfPresent()
        value.lineWidth = try reader["LineWidth"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FieldSeriesItem {

    static func write(value: QuickSightClientTypes.FieldSeriesItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisBinding"].write(value.axisBinding)
        try writer["FieldId"].write(value.fieldId)
        try writer["Settings"].write(value.settings, with: QuickSightClientTypes.LineChartSeriesSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldSeriesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldSeriesItem()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.axisBinding = try reader["AxisBinding"].readIfPresent() ?? .sdkUnknown("")
        value.settings = try reader["Settings"].readIfPresent(with: QuickSightClientTypes.LineChartSeriesSettings.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineChartDefaultSeriesSettings {

    static func write(value: QuickSightClientTypes.LineChartDefaultSeriesSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisBinding"].write(value.axisBinding)
        try writer["LineStyleSettings"].write(value.lineStyleSettings, with: QuickSightClientTypes.LineChartLineStyleSettings.write(value:to:))
        try writer["MarkerStyleSettings"].write(value.markerStyleSettings, with: QuickSightClientTypes.LineChartMarkerStyleSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartDefaultSeriesSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartDefaultSeriesSettings()
        value.axisBinding = try reader["AxisBinding"].readIfPresent()
        value.lineStyleSettings = try reader["LineStyleSettings"].readIfPresent(with: QuickSightClientTypes.LineChartLineStyleSettings.read(from:))
        value.markerStyleSettings = try reader["MarkerStyleSettings"].readIfPresent(with: QuickSightClientTypes.LineChartMarkerStyleSettings.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineSeriesAxisDisplayOptions {

    static func write(value: QuickSightClientTypes.LineSeriesAxisDisplayOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AxisOptions"].write(value.axisOptions, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["MissingDataConfigurations"].writeList(value.missingDataConfigurations, memberWritingClosure: QuickSightClientTypes.MissingDataConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineSeriesAxisDisplayOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineSeriesAxisDisplayOptions()
        value.axisOptions = try reader["AxisOptions"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.missingDataConfigurations = try reader["MissingDataConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MissingDataConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.MissingDataConfiguration {

    static func write(value: QuickSightClientTypes.MissingDataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TreatmentOption"].write(value.treatmentOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MissingDataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MissingDataConfiguration()
        value.treatmentOption = try reader["TreatmentOption"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SmallMultiplesOptions {

    static func write(value: QuickSightClientTypes.SmallMultiplesOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxVisibleColumns"].write(value.maxVisibleColumns)
        try writer["MaxVisibleRows"].write(value.maxVisibleRows)
        try writer["PanelConfiguration"].write(value.panelConfiguration, with: QuickSightClientTypes.PanelConfiguration.write(value:to:))
        try writer["XAxis"].write(value.xAxis, with: QuickSightClientTypes.SmallMultiplesAxisProperties.write(value:to:))
        try writer["YAxis"].write(value.yAxis, with: QuickSightClientTypes.SmallMultiplesAxisProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SmallMultiplesOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SmallMultiplesOptions()
        value.maxVisibleRows = try reader["MaxVisibleRows"].readIfPresent()
        value.maxVisibleColumns = try reader["MaxVisibleColumns"].readIfPresent()
        value.panelConfiguration = try reader["PanelConfiguration"].readIfPresent(with: QuickSightClientTypes.PanelConfiguration.read(from:))
        value.xAxis = try reader["XAxis"].readIfPresent(with: QuickSightClientTypes.SmallMultiplesAxisProperties.read(from:))
        value.yAxis = try reader["YAxis"].readIfPresent(with: QuickSightClientTypes.SmallMultiplesAxisProperties.read(from:))
        return value
    }
}

extension QuickSightClientTypes.SmallMultiplesAxisProperties {

    static func write(value: QuickSightClientTypes.SmallMultiplesAxisProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Placement"].write(value.placement)
        try writer["Scale"].write(value.scale)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SmallMultiplesAxisProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SmallMultiplesAxisProperties()
        value.scale = try reader["Scale"].readIfPresent()
        value.placement = try reader["Placement"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PanelConfiguration {

    static func write(value: QuickSightClientTypes.PanelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor)
        try writer["BackgroundVisibility"].write(value.backgroundVisibility)
        try writer["BorderColor"].write(value.borderColor)
        try writer["BorderStyle"].write(value.borderStyle)
        try writer["BorderThickness"].write(value.borderThickness)
        try writer["BorderVisibility"].write(value.borderVisibility)
        try writer["GutterSpacing"].write(value.gutterSpacing)
        try writer["GutterVisibility"].write(value.gutterVisibility)
        try writer["Title"].write(value.title, with: QuickSightClientTypes.PanelTitleOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PanelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PanelConfiguration()
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.PanelTitleOptions.read(from:))
        value.borderVisibility = try reader["BorderVisibility"].readIfPresent()
        value.borderThickness = try reader["BorderThickness"].readIfPresent()
        value.borderStyle = try reader["BorderStyle"].readIfPresent()
        value.borderColor = try reader["BorderColor"].readIfPresent()
        value.gutterVisibility = try reader["GutterVisibility"].readIfPresent()
        value.gutterSpacing = try reader["GutterSpacing"].readIfPresent()
        value.backgroundVisibility = try reader["BackgroundVisibility"].readIfPresent()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PanelTitleOptions {

    static func write(value: QuickSightClientTypes.PanelTitleOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["HorizontalTextAlignment"].write(value.horizontalTextAlignment)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PanelTitleOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PanelTitleOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.horizontalTextAlignment = try reader["HorizontalTextAlignment"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ForecastConfiguration {

    static func write(value: QuickSightClientTypes.ForecastConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForecastProperties"].write(value.forecastProperties, with: QuickSightClientTypes.TimeBasedForecastProperties.write(value:to:))
        try writer["Scenario"].write(value.scenario, with: QuickSightClientTypes.ForecastScenario.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ForecastConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ForecastConfiguration()
        value.forecastProperties = try reader["ForecastProperties"].readIfPresent(with: QuickSightClientTypes.TimeBasedForecastProperties.read(from:))
        value.scenario = try reader["Scenario"].readIfPresent(with: QuickSightClientTypes.ForecastScenario.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ForecastScenario {

    static func write(value: QuickSightClientTypes.ForecastScenario?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WhatIfPointScenario"].write(value.whatIfPointScenario, with: QuickSightClientTypes.WhatIfPointScenario.write(value:to:))
        try writer["WhatIfRangeScenario"].write(value.whatIfRangeScenario, with: QuickSightClientTypes.WhatIfRangeScenario.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ForecastScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ForecastScenario()
        value.whatIfPointScenario = try reader["WhatIfPointScenario"].readIfPresent(with: QuickSightClientTypes.WhatIfPointScenario.read(from:))
        value.whatIfRangeScenario = try reader["WhatIfRangeScenario"].readIfPresent(with: QuickSightClientTypes.WhatIfRangeScenario.read(from:))
        return value
    }
}

extension QuickSightClientTypes.WhatIfRangeScenario {

    static func write(value: QuickSightClientTypes.WhatIfRangeScenario?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartDate"].writeTimestamp(value.startDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WhatIfRangeScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WhatIfRangeScenario()
        value.startDate = try reader["StartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endDate = try reader["EndDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.WhatIfPointScenario {

    static func write(value: QuickSightClientTypes.WhatIfPointScenario?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Date"].writeTimestamp(value.date, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.WhatIfPointScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.WhatIfPointScenario()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.TimeBasedForecastProperties {

    static func write(value: QuickSightClientTypes.TimeBasedForecastProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LowerBoundary"].write(value.lowerBoundary)
        try writer["PeriodsBackward"].write(value.periodsBackward)
        try writer["PeriodsForward"].write(value.periodsForward)
        try writer["PredictionInterval"].write(value.predictionInterval)
        try writer["Seasonality"].write(value.seasonality)
        try writer["UpperBoundary"].write(value.upperBoundary)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TimeBasedForecastProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TimeBasedForecastProperties()
        value.periodsForward = try reader["PeriodsForward"].readIfPresent()
        value.periodsBackward = try reader["PeriodsBackward"].readIfPresent()
        value.upperBoundary = try reader["UpperBoundary"].readIfPresent()
        value.lowerBoundary = try reader["LowerBoundary"].readIfPresent()
        value.predictionInterval = try reader["PredictionInterval"].readIfPresent()
        value.seasonality = try reader["Seasonality"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LineChartSortConfiguration {

    static func write(value: QuickSightClientTypes.LineChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimitConfiguration"].write(value.categoryItemsLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColorItemsLimitConfiguration"].write(value.colorItemsLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["SmallMultiplesLimitConfiguration"].write(value.smallMultiplesLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["SmallMultiplesSort"].writeList(value.smallMultiplesSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimitConfiguration = try reader["CategoryItemsLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.colorItemsLimitConfiguration = try reader["ColorItemsLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.smallMultiplesSort = try reader["SmallMultiplesSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiplesLimitConfiguration = try reader["SmallMultiplesLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineChartFieldWells {

    static func write(value: QuickSightClientTypes.LineChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineChartAggregatedFieldWells"].write(value.lineChartAggregatedFieldWells, with: QuickSightClientTypes.LineChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartFieldWells()
        value.lineChartAggregatedFieldWells = try reader["LineChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.LineChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LineChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.LineChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiples"].writeList(value.smallMultiples, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LineChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LineChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiples = try reader["SmallMultiples"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GaugeChartVisual {

    static func write(value: QuickSightClientTypes.GaugeChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.GaugeChartConfiguration.write(value:to:))
        try writer["ConditionalFormatting"].write(value.conditionalFormatting, with: QuickSightClientTypes.GaugeChartConditionalFormatting.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.GaugeChartConfiguration.read(from:))
        value.conditionalFormatting = try reader["ConditionalFormatting"].readIfPresent(with: QuickSightClientTypes.GaugeChartConditionalFormatting.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GaugeChartConditionalFormatting {

    static func write(value: QuickSightClientTypes.GaugeChartConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionalFormattingOptions"].writeList(value.conditionalFormattingOptions, memberWritingClosure: QuickSightClientTypes.GaugeChartConditionalFormattingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartConditionalFormatting()
        value.conditionalFormattingOptions = try reader["ConditionalFormattingOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.GaugeChartConditionalFormattingOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.GaugeChartConditionalFormattingOption {

    static func write(value: QuickSightClientTypes.GaugeChartConditionalFormattingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arc"].write(value.arc, with: QuickSightClientTypes.GaugeChartArcConditionalFormatting.write(value:to:))
        try writer["PrimaryValue"].write(value.primaryValue, with: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartConditionalFormattingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartConditionalFormattingOption()
        value.primaryValue = try reader["PrimaryValue"].readIfPresent(with: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting.read(from:))
        value.arc = try reader["Arc"].readIfPresent(with: QuickSightClientTypes.GaugeChartArcConditionalFormatting.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GaugeChartArcConditionalFormatting {

    static func write(value: QuickSightClientTypes.GaugeChartArcConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForegroundColor"].write(value.foregroundColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartArcConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartArcConditionalFormatting()
        value.foregroundColor = try reader["ForegroundColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting {

    static func write(value: QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon, with: QuickSightClientTypes.ConditionalFormattingIcon.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartPrimaryValueConditionalFormatting()
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.icon = try reader["Icon"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIcon.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingIcon {

    static func write(value: QuickSightClientTypes.ConditionalFormattingIcon?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomCondition"].write(value.customCondition, with: QuickSightClientTypes.ConditionalFormattingCustomIconCondition.write(value:to:))
        try writer["IconSet"].write(value.iconSet, with: QuickSightClientTypes.ConditionalFormattingIconSet.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingIcon {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingIcon()
        value.iconSet = try reader["IconSet"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIconSet.read(from:))
        value.customCondition = try reader["CustomCondition"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingCustomIconCondition.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingCustomIconCondition {

    static func write(value: QuickSightClientTypes.ConditionalFormattingCustomIconCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["DisplayConfiguration"].write(value.displayConfiguration, with: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration.write(value:to:))
        try writer["Expression"].write(value.expression)
        try writer["IconOptions"].write(value.iconOptions, with: QuickSightClientTypes.ConditionalFormattingCustomIconOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingCustomIconCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingCustomIconCondition()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.iconOptions = try reader["IconOptions"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingCustomIconOptions.read(from:))
        value.color = try reader["Color"].readIfPresent()
        value.displayConfiguration = try reader["DisplayConfiguration"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration {

    static func write(value: QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IconDisplayOption"].write(value.iconDisplayOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingIconDisplayConfiguration()
        value.iconDisplayOption = try reader["IconDisplayOption"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingCustomIconOptions {

    static func write(value: QuickSightClientTypes.ConditionalFormattingCustomIconOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon)
        try writer["UnicodeIcon"].write(value.unicodeIcon)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingCustomIconOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingCustomIconOptions()
        value.icon = try reader["Icon"].readIfPresent()
        value.unicodeIcon = try reader["UnicodeIcon"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ConditionalFormattingIconSet {

    static func write(value: QuickSightClientTypes.ConditionalFormattingIconSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expression"].write(value.expression)
        try writer["IconSetType"].write(value.iconSetType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ConditionalFormattingIconSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ConditionalFormattingIconSet()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.iconSetType = try reader["IconSetType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GaugeChartConfiguration {

    static func write(value: QuickSightClientTypes.GaugeChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColorConfiguration"].write(value.colorConfiguration, with: QuickSightClientTypes.GaugeChartColorConfiguration.write(value:to:))
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.GaugeChartFieldWells.write(value:to:))
        try writer["GaugeChartOptions"].write(value.gaugeChartOptions, with: QuickSightClientTypes.GaugeChartOptions.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["TooltipOptions"].write(value.tooltipOptions, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.GaugeChartFieldWells.read(from:))
        value.gaugeChartOptions = try reader["GaugeChartOptions"].readIfPresent(with: QuickSightClientTypes.GaugeChartOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltipOptions = try reader["TooltipOptions"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.colorConfiguration = try reader["ColorConfiguration"].readIfPresent(with: QuickSightClientTypes.GaugeChartColorConfiguration.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GaugeChartColorConfiguration {

    static func write(value: QuickSightClientTypes.GaugeChartColorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor)
        try writer["ForegroundColor"].write(value.foregroundColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartColorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartColorConfiguration()
        value.foregroundColor = try reader["ForegroundColor"].readIfPresent()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GaugeChartOptions {

    static func write(value: QuickSightClientTypes.GaugeChartOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arc"].write(value.arc, with: QuickSightClientTypes.ArcConfiguration.write(value:to:))
        try writer["ArcAxis"].write(value.arcAxis, with: QuickSightClientTypes.ArcAxisConfiguration.write(value:to:))
        try writer["Comparison"].write(value.comparison, with: QuickSightClientTypes.ComparisonConfiguration.write(value:to:))
        try writer["PrimaryValueDisplayType"].write(value.primaryValueDisplayType)
        try writer["PrimaryValueFontConfiguration"].write(value.primaryValueFontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartOptions()
        value.primaryValueDisplayType = try reader["PrimaryValueDisplayType"].readIfPresent()
        value.comparison = try reader["Comparison"].readIfPresent(with: QuickSightClientTypes.ComparisonConfiguration.read(from:))
        value.arcAxis = try reader["ArcAxis"].readIfPresent(with: QuickSightClientTypes.ArcAxisConfiguration.read(from:))
        value.arc = try reader["Arc"].readIfPresent(with: QuickSightClientTypes.ArcConfiguration.read(from:))
        value.primaryValueFontConfiguration = try reader["PrimaryValueFontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ArcConfiguration {

    static func write(value: QuickSightClientTypes.ArcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArcAngle"].write(value.arcAngle)
        try writer["ArcThickness"].write(value.arcThickness)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ArcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ArcConfiguration()
        value.arcAngle = try reader["ArcAngle"].readIfPresent()
        value.arcThickness = try reader["ArcThickness"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ArcAxisConfiguration {

    static func write(value: QuickSightClientTypes.ArcAxisConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Range"].write(value.range, with: QuickSightClientTypes.ArcAxisDisplayRange.write(value:to:))
        try writer["ReserveRange"].write(value.reserveRange)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ArcAxisConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ArcAxisConfiguration()
        value.range = try reader["Range"].readIfPresent(with: QuickSightClientTypes.ArcAxisDisplayRange.read(from:))
        value.reserveRange = try reader["ReserveRange"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.ArcAxisDisplayRange {

    static func write(value: QuickSightClientTypes.ArcAxisDisplayRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ArcAxisDisplayRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ArcAxisDisplayRange()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ComparisonConfiguration {

    static func write(value: QuickSightClientTypes.ComparisonConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonFormat"].write(value.comparisonFormat, with: QuickSightClientTypes.ComparisonFormatConfiguration.write(value:to:))
        try writer["ComparisonMethod"].write(value.comparisonMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComparisonConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComparisonConfiguration()
        value.comparisonMethod = try reader["ComparisonMethod"].readIfPresent()
        value.comparisonFormat = try reader["ComparisonFormat"].readIfPresent(with: QuickSightClientTypes.ComparisonFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ComparisonFormatConfiguration {

    static func write(value: QuickSightClientTypes.ComparisonFormatConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NumberDisplayFormatConfiguration"].write(value.numberDisplayFormatConfiguration, with: QuickSightClientTypes.NumberDisplayFormatConfiguration.write(value:to:))
        try writer["PercentageDisplayFormatConfiguration"].write(value.percentageDisplayFormatConfiguration, with: QuickSightClientTypes.PercentageDisplayFormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComparisonFormatConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComparisonFormatConfiguration()
        value.numberDisplayFormatConfiguration = try reader["NumberDisplayFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.NumberDisplayFormatConfiguration.read(from:))
        value.percentageDisplayFormatConfiguration = try reader["PercentageDisplayFormatConfiguration"].readIfPresent(with: QuickSightClientTypes.PercentageDisplayFormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GaugeChartFieldWells {

    static func write(value: QuickSightClientTypes.GaugeChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetValues"].writeList(value.targetValues, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GaugeChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GaugeChartFieldWells()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetValues = try reader["TargetValues"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PieChartVisual {

    static func write(value: QuickSightClientTypes.PieChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.PieChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PieChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PieChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.PieChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PieChartConfiguration {

    static func write(value: QuickSightClientTypes.PieChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ContributionAnalysisDefaults"].writeList(value.contributionAnalysisDefaults, memberWritingClosure: QuickSightClientTypes.ContributionAnalysisDefault.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["DonutOptions"].write(value.donutOptions, with: QuickSightClientTypes.DonutOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.PieChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["SmallMultiplesOptions"].write(value.smallMultiplesOptions, with: QuickSightClientTypes.SmallMultiplesOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.PieChartSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["ValueLabelOptions"].write(value.valueLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PieChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PieChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.PieChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.PieChartSortConfiguration.read(from:))
        value.donutOptions = try reader["DonutOptions"].readIfPresent(with: QuickSightClientTypes.DonutOptions.read(from:))
        value.smallMultiplesOptions = try reader["SmallMultiplesOptions"].readIfPresent(with: QuickSightClientTypes.SmallMultiplesOptions.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.valueLabelOptions = try reader["ValueLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.contributionAnalysisDefaults = try reader["ContributionAnalysisDefaults"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ContributionAnalysisDefault.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DonutOptions {

    static func write(value: QuickSightClientTypes.DonutOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArcOptions"].write(value.arcOptions, with: QuickSightClientTypes.ArcOptions.write(value:to:))
        try writer["DonutCenterOptions"].write(value.donutCenterOptions, with: QuickSightClientTypes.DonutCenterOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DonutOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DonutOptions()
        value.arcOptions = try reader["ArcOptions"].readIfPresent(with: QuickSightClientTypes.ArcOptions.read(from:))
        value.donutCenterOptions = try reader["DonutCenterOptions"].readIfPresent(with: QuickSightClientTypes.DonutCenterOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DonutCenterOptions {

    static func write(value: QuickSightClientTypes.DonutCenterOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LabelVisibility"].write(value.labelVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DonutCenterOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DonutCenterOptions()
        value.labelVisibility = try reader["LabelVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ArcOptions {

    static func write(value: QuickSightClientTypes.ArcOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArcThickness"].write(value.arcThickness)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ArcOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ArcOptions()
        value.arcThickness = try reader["ArcThickness"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PieChartSortConfiguration {

    static func write(value: QuickSightClientTypes.PieChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiplesLimitConfiguration"].write(value.smallMultiplesLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["SmallMultiplesSort"].writeList(value.smallMultiplesSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PieChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PieChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.smallMultiplesSort = try reader["SmallMultiplesSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiplesLimitConfiguration = try reader["SmallMultiplesLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PieChartFieldWells {

    static func write(value: QuickSightClientTypes.PieChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PieChartAggregatedFieldWells"].write(value.pieChartAggregatedFieldWells, with: QuickSightClientTypes.PieChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PieChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PieChartFieldWells()
        value.pieChartAggregatedFieldWells = try reader["PieChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.PieChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PieChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.PieChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiples"].writeList(value.smallMultiples, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PieChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PieChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiples = try reader["SmallMultiples"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.KPIVisual {

    static func write(value: QuickSightClientTypes.KPIVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.KPIConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConditionalFormatting"].write(value.conditionalFormatting, with: QuickSightClientTypes.KPIConditionalFormatting.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.KPIConfiguration.read(from:))
        value.conditionalFormatting = try reader["ConditionalFormatting"].readIfPresent(with: QuickSightClientTypes.KPIConditionalFormatting.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.KPIConditionalFormatting {

    static func write(value: QuickSightClientTypes.KPIConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionalFormattingOptions"].writeList(value.conditionalFormattingOptions, memberWritingClosure: QuickSightClientTypes.KPIConditionalFormattingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIConditionalFormatting()
        value.conditionalFormattingOptions = try reader["ConditionalFormattingOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.KPIConditionalFormattingOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.KPIConditionalFormattingOption {

    static func write(value: QuickSightClientTypes.KPIConditionalFormattingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActualValue"].write(value.actualValue, with: QuickSightClientTypes.KPIActualValueConditionalFormatting.write(value:to:))
        try writer["ComparisonValue"].write(value.comparisonValue, with: QuickSightClientTypes.KPIComparisonValueConditionalFormatting.write(value:to:))
        try writer["PrimaryValue"].write(value.primaryValue, with: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting.write(value:to:))
        try writer["ProgressBar"].write(value.progressBar, with: QuickSightClientTypes.KPIProgressBarConditionalFormatting.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIConditionalFormattingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIConditionalFormattingOption()
        value.primaryValue = try reader["PrimaryValue"].readIfPresent(with: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting.read(from:))
        value.progressBar = try reader["ProgressBar"].readIfPresent(with: QuickSightClientTypes.KPIProgressBarConditionalFormatting.read(from:))
        value.actualValue = try reader["ActualValue"].readIfPresent(with: QuickSightClientTypes.KPIActualValueConditionalFormatting.read(from:))
        value.comparisonValue = try reader["ComparisonValue"].readIfPresent(with: QuickSightClientTypes.KPIComparisonValueConditionalFormatting.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIComparisonValueConditionalFormatting {

    static func write(value: QuickSightClientTypes.KPIComparisonValueConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon, with: QuickSightClientTypes.ConditionalFormattingIcon.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIComparisonValueConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIComparisonValueConditionalFormatting()
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.icon = try reader["Icon"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIcon.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIActualValueConditionalFormatting {

    static func write(value: QuickSightClientTypes.KPIActualValueConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon, with: QuickSightClientTypes.ConditionalFormattingIcon.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIActualValueConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIActualValueConditionalFormatting()
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.icon = try reader["Icon"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIcon.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIProgressBarConditionalFormatting {

    static func write(value: QuickSightClientTypes.KPIProgressBarConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForegroundColor"].write(value.foregroundColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIProgressBarConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIProgressBarConditionalFormatting()
        value.foregroundColor = try reader["ForegroundColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIPrimaryValueConditionalFormatting {

    static func write(value: QuickSightClientTypes.KPIPrimaryValueConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon, with: QuickSightClientTypes.ConditionalFormattingIcon.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIPrimaryValueConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIPrimaryValueConditionalFormatting()
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.icon = try reader["Icon"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIcon.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIConfiguration {

    static func write(value: QuickSightClientTypes.KPIConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.KPIFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["KPIOptions"].write(value.kpiOptions, with: QuickSightClientTypes.KPIOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.KPISortConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.KPIFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.KPISortConfiguration.read(from:))
        value.kpiOptions = try reader["KPIOptions"].readIfPresent(with: QuickSightClientTypes.KPIOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIOptions {

    static func write(value: QuickSightClientTypes.KPIOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparison"].write(value.comparison, with: QuickSightClientTypes.ComparisonConfiguration.write(value:to:))
        try writer["PrimaryValueDisplayType"].write(value.primaryValueDisplayType)
        try writer["PrimaryValueFontConfiguration"].write(value.primaryValueFontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["ProgressBar"].write(value.progressBar, with: QuickSightClientTypes.ProgressBarOptions.write(value:to:))
        try writer["SecondaryValue"].write(value.secondaryValue, with: QuickSightClientTypes.SecondaryValueOptions.write(value:to:))
        try writer["SecondaryValueFontConfiguration"].write(value.secondaryValueFontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["Sparkline"].write(value.sparkline, with: QuickSightClientTypes.KPISparklineOptions.write(value:to:))
        try writer["TrendArrows"].write(value.trendArrows, with: QuickSightClientTypes.TrendArrowOptions.write(value:to:))
        try writer["VisualLayoutOptions"].write(value.visualLayoutOptions, with: QuickSightClientTypes.KPIVisualLayoutOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIOptions()
        value.progressBar = try reader["ProgressBar"].readIfPresent(with: QuickSightClientTypes.ProgressBarOptions.read(from:))
        value.trendArrows = try reader["TrendArrows"].readIfPresent(with: QuickSightClientTypes.TrendArrowOptions.read(from:))
        value.secondaryValue = try reader["SecondaryValue"].readIfPresent(with: QuickSightClientTypes.SecondaryValueOptions.read(from:))
        value.comparison = try reader["Comparison"].readIfPresent(with: QuickSightClientTypes.ComparisonConfiguration.read(from:))
        value.primaryValueDisplayType = try reader["PrimaryValueDisplayType"].readIfPresent()
        value.primaryValueFontConfiguration = try reader["PrimaryValueFontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.secondaryValueFontConfiguration = try reader["SecondaryValueFontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.sparkline = try reader["Sparkline"].readIfPresent(with: QuickSightClientTypes.KPISparklineOptions.read(from:))
        value.visualLayoutOptions = try reader["VisualLayoutOptions"].readIfPresent(with: QuickSightClientTypes.KPIVisualLayoutOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIVisualLayoutOptions {

    static func write(value: QuickSightClientTypes.KPIVisualLayoutOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardLayout"].write(value.standardLayout, with: QuickSightClientTypes.KPIVisualStandardLayout.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIVisualLayoutOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIVisualLayoutOptions()
        value.standardLayout = try reader["StandardLayout"].readIfPresent(with: QuickSightClientTypes.KPIVisualStandardLayout.read(from:))
        return value
    }
}

extension QuickSightClientTypes.KPIVisualStandardLayout {

    static func write(value: QuickSightClientTypes.KPIVisualStandardLayout?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIVisualStandardLayout {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIVisualStandardLayout()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.KPISparklineOptions {

    static func write(value: QuickSightClientTypes.KPISparklineOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["TooltipVisibility"].write(value.tooltipVisibility)
        try writer["Type"].write(value.type)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPISparklineOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPISparklineOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.color = try reader["Color"].readIfPresent()
        value.tooltipVisibility = try reader["TooltipVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SecondaryValueOptions {

    static func write(value: QuickSightClientTypes.SecondaryValueOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SecondaryValueOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SecondaryValueOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TrendArrowOptions {

    static func write(value: QuickSightClientTypes.TrendArrowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TrendArrowOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TrendArrowOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ProgressBarOptions {

    static func write(value: QuickSightClientTypes.ProgressBarOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ProgressBarOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ProgressBarOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.KPISortConfiguration {

    static func write(value: QuickSightClientTypes.KPISortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrendGroupSort"].writeList(value.trendGroupSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPISortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPISortConfiguration()
        value.trendGroupSort = try reader["TrendGroupSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.KPIFieldWells {

    static func write(value: QuickSightClientTypes.KPIFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetValues"].writeList(value.targetValues, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrendGroups"].writeList(value.trendGroups, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.KPIFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.KPIFieldWells()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.targetValues = try reader["TargetValues"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.trendGroups = try reader["TrendGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.BarChartVisual {

    static func write(value: QuickSightClientTypes.BarChartVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.BarChartConfiguration.write(value:to:))
        try writer["ColumnHierarchies"].writeList(value.columnHierarchies, memberWritingClosure: QuickSightClientTypes.ColumnHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BarChartVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BarChartVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.BarChartConfiguration.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnHierarchies = try reader["ColumnHierarchies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.BarChartConfiguration {

    static func write(value: QuickSightClientTypes.BarChartConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BarsArrangement"].write(value.barsArrangement)
        try writer["CategoryAxis"].write(value.categoryAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["CategoryLabelOptions"].write(value.categoryLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ColorLabelOptions"].write(value.colorLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["ContributionAnalysisDefaults"].writeList(value.contributionAnalysisDefaults, memberWritingClosure: QuickSightClientTypes.ContributionAnalysisDefault.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataLabels"].write(value.dataLabels, with: QuickSightClientTypes.DataLabelOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.BarChartFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["Legend"].write(value.legend, with: QuickSightClientTypes.LegendOptions.write(value:to:))
        try writer["Orientation"].write(value.orientation)
        try writer["ReferenceLines"].writeList(value.referenceLines, memberWritingClosure: QuickSightClientTypes.ReferenceLine.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiplesOptions"].write(value.smallMultiplesOptions, with: QuickSightClientTypes.SmallMultiplesOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.BarChartSortConfiguration.write(value:to:))
        try writer["Tooltip"].write(value.tooltip, with: QuickSightClientTypes.TooltipOptions.write(value:to:))
        try writer["ValueAxis"].write(value.valueAxis, with: QuickSightClientTypes.AxisDisplayOptions.write(value:to:))
        try writer["ValueLabelOptions"].write(value.valueLabelOptions, with: QuickSightClientTypes.ChartAxisLabelOptions.write(value:to:))
        try writer["VisualPalette"].write(value.visualPalette, with: QuickSightClientTypes.VisualPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BarChartConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BarChartConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.BarChartFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.BarChartSortConfiguration.read(from:))
        value.orientation = try reader["Orientation"].readIfPresent()
        value.barsArrangement = try reader["BarsArrangement"].readIfPresent()
        value.visualPalette = try reader["VisualPalette"].readIfPresent(with: QuickSightClientTypes.VisualPalette.read(from:))
        value.smallMultiplesOptions = try reader["SmallMultiplesOptions"].readIfPresent(with: QuickSightClientTypes.SmallMultiplesOptions.read(from:))
        value.categoryAxis = try reader["CategoryAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.categoryLabelOptions = try reader["CategoryLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.valueAxis = try reader["ValueAxis"].readIfPresent(with: QuickSightClientTypes.AxisDisplayOptions.read(from:))
        value.valueLabelOptions = try reader["ValueLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.colorLabelOptions = try reader["ColorLabelOptions"].readIfPresent(with: QuickSightClientTypes.ChartAxisLabelOptions.read(from:))
        value.legend = try reader["Legend"].readIfPresent(with: QuickSightClientTypes.LegendOptions.read(from:))
        value.dataLabels = try reader["DataLabels"].readIfPresent(with: QuickSightClientTypes.DataLabelOptions.read(from:))
        value.tooltip = try reader["Tooltip"].readIfPresent(with: QuickSightClientTypes.TooltipOptions.read(from:))
        value.referenceLines = try reader["ReferenceLines"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ReferenceLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.contributionAnalysisDefaults = try reader["ContributionAnalysisDefaults"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ContributionAnalysisDefault.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BarChartSortConfiguration {

    static func write(value: QuickSightClientTypes.BarChartSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryItemsLimit"].write(value.categoryItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["CategorySort"].writeList(value.categorySort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColorItemsLimit"].write(value.colorItemsLimit, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["ColorSort"].writeList(value.colorSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiplesLimitConfiguration"].write(value.smallMultiplesLimitConfiguration, with: QuickSightClientTypes.ItemsLimitConfiguration.write(value:to:))
        try writer["SmallMultiplesSort"].writeList(value.smallMultiplesSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BarChartSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BarChartSortConfiguration()
        value.categorySort = try reader["CategorySort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.categoryItemsLimit = try reader["CategoryItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.colorSort = try reader["ColorSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colorItemsLimit = try reader["ColorItemsLimit"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        value.smallMultiplesSort = try reader["SmallMultiplesSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiplesLimitConfiguration = try reader["SmallMultiplesLimitConfiguration"].readIfPresent(with: QuickSightClientTypes.ItemsLimitConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BarChartFieldWells {

    static func write(value: QuickSightClientTypes.BarChartFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BarChartAggregatedFieldWells"].write(value.barChartAggregatedFieldWells, with: QuickSightClientTypes.BarChartAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BarChartFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BarChartFieldWells()
        value.barChartAggregatedFieldWells = try reader["BarChartAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.BarChartAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BarChartAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.BarChartAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].writeList(value.category, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Colors"].writeList(value.colors, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SmallMultiples"].writeList(value.smallMultiples, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BarChartAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BarChartAggregatedFieldWells()
        value.category = try reader["Category"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.smallMultiples = try reader["SmallMultiples"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableVisual {

    static func write(value: QuickSightClientTypes.PivotTableVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.PivotTableConfiguration.write(value:to:))
        try writer["ConditionalFormatting"].write(value.conditionalFormatting, with: QuickSightClientTypes.PivotTableConditionalFormatting.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.PivotTableConfiguration.read(from:))
        value.conditionalFormatting = try reader["ConditionalFormatting"].readIfPresent(with: QuickSightClientTypes.PivotTableConditionalFormatting.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableConditionalFormatting {

    static func write(value: QuickSightClientTypes.PivotTableConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionalFormattingOptions"].writeList(value.conditionalFormattingOptions, memberWritingClosure: QuickSightClientTypes.PivotTableConditionalFormattingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableConditionalFormatting()
        value.conditionalFormattingOptions = try reader["ConditionalFormattingOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableConditionalFormattingOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableConditionalFormattingOption {

    static func write(value: QuickSightClientTypes.PivotTableConditionalFormattingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cell"].write(value.cell, with: QuickSightClientTypes.PivotTableCellConditionalFormatting.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableConditionalFormattingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableConditionalFormattingOption()
        value.cell = try reader["Cell"].readIfPresent(with: QuickSightClientTypes.PivotTableCellConditionalFormatting.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTableCellConditionalFormatting {

    static func write(value: QuickSightClientTypes.PivotTableCellConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["Scope"].write(value.scope, with: QuickSightClientTypes.PivotTableConditionalFormattingScope.write(value:to:))
        try writer["Scopes"].writeList(value.scopes, memberWritingClosure: QuickSightClientTypes.PivotTableConditionalFormattingScope.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TextFormat"].write(value.textFormat, with: QuickSightClientTypes.TextConditionalFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableCellConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableCellConditionalFormatting()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.textFormat = try reader["TextFormat"].readIfPresent(with: QuickSightClientTypes.TextConditionalFormat.read(from:))
        value.scope = try reader["Scope"].readIfPresent(with: QuickSightClientTypes.PivotTableConditionalFormattingScope.read(from:))
        value.scopes = try reader["Scopes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableConditionalFormattingScope.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableConditionalFormattingScope {

    static func write(value: QuickSightClientTypes.PivotTableConditionalFormattingScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableConditionalFormattingScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableConditionalFormattingScope()
        value.role = try reader["Role"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TextConditionalFormat {

    static func write(value: QuickSightClientTypes.TextConditionalFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
        try writer["Icon"].write(value.icon, with: QuickSightClientTypes.ConditionalFormattingIcon.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TextConditionalFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TextConditionalFormat()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.icon = try reader["Icon"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingIcon.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTableConfiguration {

    static func write(value: QuickSightClientTypes.PivotTableConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldOptions"].write(value.fieldOptions, with: QuickSightClientTypes.PivotTableFieldOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.PivotTableFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["PaginatedReportOptions"].write(value.paginatedReportOptions, with: QuickSightClientTypes.PivotTablePaginatedReportOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.PivotTableSortConfiguration.write(value:to:))
        try writer["TableOptions"].write(value.tableOptions, with: QuickSightClientTypes.PivotTableOptions.write(value:to:))
        try writer["TotalOptions"].write(value.totalOptions, with: QuickSightClientTypes.PivotTableTotalOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.PivotTableFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.PivotTableSortConfiguration.read(from:))
        value.tableOptions = try reader["TableOptions"].readIfPresent(with: QuickSightClientTypes.PivotTableOptions.read(from:))
        value.totalOptions = try reader["TotalOptions"].readIfPresent(with: QuickSightClientTypes.PivotTableTotalOptions.read(from:))
        value.fieldOptions = try reader["FieldOptions"].readIfPresent(with: QuickSightClientTypes.PivotTableFieldOptions.read(from:))
        value.paginatedReportOptions = try reader["PaginatedReportOptions"].readIfPresent(with: QuickSightClientTypes.PivotTablePaginatedReportOptions.read(from:))
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTablePaginatedReportOptions {

    static func write(value: QuickSightClientTypes.PivotTablePaginatedReportOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OverflowColumnHeaderVisibility"].write(value.overflowColumnHeaderVisibility)
        try writer["VerticalOverflowVisibility"].write(value.verticalOverflowVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTablePaginatedReportOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTablePaginatedReportOptions()
        value.verticalOverflowVisibility = try reader["VerticalOverflowVisibility"].readIfPresent()
        value.overflowColumnHeaderVisibility = try reader["OverflowColumnHeaderVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldOptions {

    static func write(value: QuickSightClientTypes.PivotTableFieldOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollapseStateOptions"].writeList(value.collapseStateOptions, memberWritingClosure: QuickSightClientTypes.PivotTableFieldCollapseStateOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataPathOptions"].writeList(value.dataPathOptions, memberWritingClosure: QuickSightClientTypes.PivotTableDataPathOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelectedFieldOptions"].writeList(value.selectedFieldOptions, memberWritingClosure: QuickSightClientTypes.PivotTableFieldOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldOptions()
        value.selectedFieldOptions = try reader["SelectedFieldOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableFieldOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataPathOptions = try reader["DataPathOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableDataPathOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.collapseStateOptions = try reader["CollapseStateOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableFieldCollapseStateOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldCollapseStateOption {

    static func write(value: QuickSightClientTypes.PivotTableFieldCollapseStateOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
        try writer["Target"].write(value.target, with: QuickSightClientTypes.PivotTableFieldCollapseStateTarget.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldCollapseStateOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldCollapseStateOption()
        value.target = try reader["Target"].readIfPresent(with: QuickSightClientTypes.PivotTableFieldCollapseStateTarget.read(from:))
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldCollapseStateTarget {

    static func write(value: QuickSightClientTypes.PivotTableFieldCollapseStateTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldDataPathValues"].writeList(value.fieldDataPathValues, memberWritingClosure: QuickSightClientTypes.DataPathValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldCollapseStateTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldCollapseStateTarget()
        value.fieldId = try reader["FieldId"].readIfPresent()
        value.fieldDataPathValues = try reader["FieldDataPathValues"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataPathValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotTableDataPathOption {

    static func write(value: QuickSightClientTypes.PivotTableDataPathOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataPathList"].writeList(value.dataPathList, memberWritingClosure: QuickSightClientTypes.DataPathValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableDataPathOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableDataPathOption()
        value.dataPathList = try reader["DataPathList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataPathValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.width = try reader["Width"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldOption {

    static func write(value: QuickSightClientTypes.PivotTableFieldOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["FieldId"].write(value.fieldId)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldOption()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableTotalOptions {

    static func write(value: QuickSightClientTypes.PivotTableTotalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnSubtotalOptions"].write(value.columnSubtotalOptions, with: QuickSightClientTypes.SubtotalOptions.write(value:to:))
        try writer["ColumnTotalOptions"].write(value.columnTotalOptions, with: QuickSightClientTypes.PivotTotalOptions.write(value:to:))
        try writer["RowSubtotalOptions"].write(value.rowSubtotalOptions, with: QuickSightClientTypes.SubtotalOptions.write(value:to:))
        try writer["RowTotalOptions"].write(value.rowTotalOptions, with: QuickSightClientTypes.PivotTotalOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableTotalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableTotalOptions()
        value.rowSubtotalOptions = try reader["RowSubtotalOptions"].readIfPresent(with: QuickSightClientTypes.SubtotalOptions.read(from:))
        value.columnSubtotalOptions = try reader["ColumnSubtotalOptions"].readIfPresent(with: QuickSightClientTypes.SubtotalOptions.read(from:))
        value.rowTotalOptions = try reader["RowTotalOptions"].readIfPresent(with: QuickSightClientTypes.PivotTotalOptions.read(from:))
        value.columnTotalOptions = try reader["ColumnTotalOptions"].readIfPresent(with: QuickSightClientTypes.PivotTotalOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTotalOptions {

    static func write(value: QuickSightClientTypes.PivotTotalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["MetricHeaderCellStyle"].write(value.metricHeaderCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["Placement"].write(value.placement)
        try writer["ScrollStatus"].write(value.scrollStatus)
        try writer["TotalAggregationOptions"].writeList(value.totalAggregationOptions, memberWritingClosure: QuickSightClientTypes.TotalAggregationOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TotalCellStyle"].write(value.totalCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["TotalsVisibility"].write(value.totalsVisibility)
        try writer["ValueCellStyle"].write(value.valueCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTotalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTotalOptions()
        value.totalsVisibility = try reader["TotalsVisibility"].readIfPresent()
        value.placement = try reader["Placement"].readIfPresent()
        value.scrollStatus = try reader["ScrollStatus"].readIfPresent()
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.totalCellStyle = try reader["TotalCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.valueCellStyle = try reader["ValueCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.metricHeaderCellStyle = try reader["MetricHeaderCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.totalAggregationOptions = try reader["TotalAggregationOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TotalAggregationOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TotalAggregationOption {

    static func write(value: QuickSightClientTypes.TotalAggregationOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["TotalAggregationFunction"].write(value.totalAggregationFunction, with: QuickSightClientTypes.TotalAggregationFunction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TotalAggregationOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TotalAggregationOption()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.totalAggregationFunction = try reader["TotalAggregationFunction"].readIfPresent(with: QuickSightClientTypes.TotalAggregationFunction.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TotalAggregationFunction {

    static func write(value: QuickSightClientTypes.TotalAggregationFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SimpleTotalAggregationFunction"].write(value.simpleTotalAggregationFunction)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TotalAggregationFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TotalAggregationFunction()
        value.simpleTotalAggregationFunction = try reader["SimpleTotalAggregationFunction"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TableCellStyle {

    static func write(value: QuickSightClientTypes.TableCellStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor)
        try writer["Border"].write(value.border, with: QuickSightClientTypes.GlobalTableBorderOptions.write(value:to:))
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["Height"].write(value.height)
        try writer["HorizontalTextAlignment"].write(value.horizontalTextAlignment)
        try writer["TextWrap"].write(value.textWrap)
        try writer["VerticalTextAlignment"].write(value.verticalTextAlignment)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableCellStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableCellStyle()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        value.textWrap = try reader["TextWrap"].readIfPresent()
        value.horizontalTextAlignment = try reader["HorizontalTextAlignment"].readIfPresent()
        value.verticalTextAlignment = try reader["VerticalTextAlignment"].readIfPresent()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent()
        value.height = try reader["Height"].readIfPresent()
        value.border = try reader["Border"].readIfPresent(with: QuickSightClientTypes.GlobalTableBorderOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GlobalTableBorderOptions {

    static func write(value: QuickSightClientTypes.GlobalTableBorderOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SideSpecificBorder"].write(value.sideSpecificBorder, with: QuickSightClientTypes.TableSideBorderOptions.write(value:to:))
        try writer["UniformBorder"].write(value.uniformBorder, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GlobalTableBorderOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GlobalTableBorderOptions()
        value.uniformBorder = try reader["UniformBorder"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.sideSpecificBorder = try reader["SideSpecificBorder"].readIfPresent(with: QuickSightClientTypes.TableSideBorderOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableSideBorderOptions {

    static func write(value: QuickSightClientTypes.TableSideBorderOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bottom"].write(value.bottom, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
        try writer["InnerHorizontal"].write(value.innerHorizontal, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
        try writer["InnerVertical"].write(value.innerVertical, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
        try writer["Left"].write(value.`left`, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
        try writer["Right"].write(value.`right`, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
        try writer["Top"].write(value.top, with: QuickSightClientTypes.TableBorderOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableSideBorderOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableSideBorderOptions()
        value.innerVertical = try reader["InnerVertical"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.innerHorizontal = try reader["InnerHorizontal"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.`left` = try reader["Left"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.`right` = try reader["Right"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.top = try reader["Top"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        value.bottom = try reader["Bottom"].readIfPresent(with: QuickSightClientTypes.TableBorderOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableBorderOptions {

    static func write(value: QuickSightClientTypes.TableBorderOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Color"].write(value.color)
        try writer["Style"].write(value.style)
        try writer["Thickness"].write(value.thickness)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableBorderOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableBorderOptions()
        value.color = try reader["Color"].readIfPresent()
        value.thickness = try reader["Thickness"].readIfPresent()
        value.style = try reader["Style"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SubtotalOptions {

    static func write(value: QuickSightClientTypes.SubtotalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["FieldLevel"].write(value.fieldLevel)
        try writer["FieldLevelOptions"].writeList(value.fieldLevelOptions, memberWritingClosure: QuickSightClientTypes.PivotTableFieldSubtotalOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricHeaderCellStyle"].write(value.metricHeaderCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["StyleTargets"].writeList(value.styleTargets, memberWritingClosure: QuickSightClientTypes.TableStyleTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TotalCellStyle"].write(value.totalCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["TotalsVisibility"].write(value.totalsVisibility)
        try writer["ValueCellStyle"].write(value.valueCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SubtotalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SubtotalOptions()
        value.totalsVisibility = try reader["TotalsVisibility"].readIfPresent()
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.fieldLevel = try reader["FieldLevel"].readIfPresent()
        value.fieldLevelOptions = try reader["FieldLevelOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotTableFieldSubtotalOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCellStyle = try reader["TotalCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.valueCellStyle = try reader["ValueCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.metricHeaderCellStyle = try reader["MetricHeaderCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.styleTargets = try reader["StyleTargets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TableStyleTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableStyleTarget {

    static func write(value: QuickSightClientTypes.TableStyleTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellType"].write(value.cellType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableStyleTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableStyleTarget()
        value.cellType = try reader["CellType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldSubtotalOptions {

    static func write(value: QuickSightClientTypes.PivotTableFieldSubtotalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldSubtotalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldSubtotalOptions()
        value.fieldId = try reader["FieldId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableOptions {

    static func write(value: QuickSightClientTypes.PivotTableOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellStyle"].write(value.cellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["CollapsedRowDimensionsVisibility"].write(value.collapsedRowDimensionsVisibility)
        try writer["ColumnHeaderStyle"].write(value.columnHeaderStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["ColumnNamesVisibility"].write(value.columnNamesVisibility)
        try writer["DefaultCellWidth"].write(value.defaultCellWidth)
        try writer["MetricPlacement"].write(value.metricPlacement)
        try writer["RowAlternateColorOptions"].write(value.rowAlternateColorOptions, with: QuickSightClientTypes.RowAlternateColorOptions.write(value:to:))
        try writer["RowFieldNamesStyle"].write(value.rowFieldNamesStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["RowHeaderStyle"].write(value.rowHeaderStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["RowsLabelOptions"].write(value.rowsLabelOptions, with: QuickSightClientTypes.PivotTableRowsLabelOptions.write(value:to:))
        try writer["RowsLayout"].write(value.rowsLayout)
        try writer["SingleMetricVisibility"].write(value.singleMetricVisibility)
        try writer["ToggleButtonsVisibility"].write(value.toggleButtonsVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableOptions()
        value.metricPlacement = try reader["MetricPlacement"].readIfPresent()
        value.singleMetricVisibility = try reader["SingleMetricVisibility"].readIfPresent()
        value.columnNamesVisibility = try reader["ColumnNamesVisibility"].readIfPresent()
        value.toggleButtonsVisibility = try reader["ToggleButtonsVisibility"].readIfPresent()
        value.columnHeaderStyle = try reader["ColumnHeaderStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.rowHeaderStyle = try reader["RowHeaderStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.cellStyle = try reader["CellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.rowFieldNamesStyle = try reader["RowFieldNamesStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.rowAlternateColorOptions = try reader["RowAlternateColorOptions"].readIfPresent(with: QuickSightClientTypes.RowAlternateColorOptions.read(from:))
        value.collapsedRowDimensionsVisibility = try reader["CollapsedRowDimensionsVisibility"].readIfPresent()
        value.rowsLayout = try reader["RowsLayout"].readIfPresent()
        value.rowsLabelOptions = try reader["RowsLabelOptions"].readIfPresent(with: QuickSightClientTypes.PivotTableRowsLabelOptions.read(from:))
        value.defaultCellWidth = try reader["DefaultCellWidth"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableRowsLabelOptions {

    static func write(value: QuickSightClientTypes.PivotTableRowsLabelOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableRowsLabelOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableRowsLabelOptions()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RowAlternateColorOptions {

    static func write(value: QuickSightClientTypes.RowAlternateColorOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RowAlternateColors"].writeList(value.rowAlternateColors, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["UsePrimaryBackgroundColor"].write(value.usePrimaryBackgroundColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RowAlternateColorOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RowAlternateColorOptions()
        value.status = try reader["Status"].readIfPresent()
        value.rowAlternateColors = try reader["RowAlternateColors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.usePrimaryBackgroundColor = try reader["UsePrimaryBackgroundColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.PivotTableSortConfiguration {

    static func write(value: QuickSightClientTypes.PivotTableSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldSortOptions"].writeList(value.fieldSortOptions, memberWritingClosure: QuickSightClientTypes.PivotFieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableSortConfiguration()
        value.fieldSortOptions = try reader["FieldSortOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.PivotFieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.PivotFieldSortOptions {

    static func write(value: QuickSightClientTypes.PivotFieldSortOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["SortBy"].write(value.sortBy, with: QuickSightClientTypes.PivotTableSortBy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotFieldSortOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotFieldSortOptions()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.sortBy = try reader["SortBy"].readIfPresent(with: QuickSightClientTypes.PivotTableSortBy.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTableSortBy {

    static func write(value: QuickSightClientTypes.PivotTableSortBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnSort.write(value:to:))
        try writer["DataPath"].write(value.dataPath, with: QuickSightClientTypes.DataPathSort.write(value:to:))
        try writer["Field"].write(value.field, with: QuickSightClientTypes.FieldSort.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableSortBy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableSortBy()
        value.field = try reader["Field"].readIfPresent(with: QuickSightClientTypes.FieldSort.read(from:))
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnSort.read(from:))
        value.dataPath = try reader["DataPath"].readIfPresent(with: QuickSightClientTypes.DataPathSort.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataPathSort {

    static func write(value: QuickSightClientTypes.DataPathSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Direction"].write(value.direction)
        try writer["SortPaths"].writeList(value.sortPaths, memberWritingClosure: QuickSightClientTypes.DataPathValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPathSort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPathSort()
        value.direction = try reader["Direction"].readIfPresent() ?? .sdkUnknown("")
        value.sortPaths = try reader["SortPaths"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataPathValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.PivotTableFieldWells {

    static func write(value: QuickSightClientTypes.PivotTableFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PivotTableAggregatedFieldWells"].write(value.pivotTableAggregatedFieldWells, with: QuickSightClientTypes.PivotTableAggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableFieldWells()
        value.pivotTableAggregatedFieldWells = try reader["PivotTableAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.PivotTableAggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.PivotTableAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.PivotTableAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Rows"].writeList(value.rows, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PivotTableAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PivotTableAggregatedFieldWells()
        value.rows = try reader["Rows"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableVisual {

    static func write(value: QuickSightClientTypes.TableVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: QuickSightClientTypes.VisualCustomAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChartConfiguration"].write(value.chartConfiguration, with: QuickSightClientTypes.TableConfiguration.write(value:to:))
        try writer["ConditionalFormatting"].write(value.conditionalFormatting, with: QuickSightClientTypes.TableConditionalFormatting.write(value:to:))
        try writer["Subtitle"].write(value.subtitle, with: QuickSightClientTypes.VisualSubtitleLabelOptions.write(value:to:))
        try writer["Title"].write(value.title, with: QuickSightClientTypes.VisualTitleLabelOptions.write(value:to:))
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableVisual()
        value.visualId = try reader["VisualId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent(with: QuickSightClientTypes.VisualTitleLabelOptions.read(from:))
        value.subtitle = try reader["Subtitle"].readIfPresent(with: QuickSightClientTypes.VisualSubtitleLabelOptions.read(from:))
        value.chartConfiguration = try reader["ChartConfiguration"].readIfPresent(with: QuickSightClientTypes.TableConfiguration.read(from:))
        value.conditionalFormatting = try reader["ConditionalFormatting"].readIfPresent(with: QuickSightClientTypes.TableConditionalFormatting.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.VisualCustomAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableConditionalFormatting {

    static func write(value: QuickSightClientTypes.TableConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionalFormattingOptions"].writeList(value.conditionalFormattingOptions, memberWritingClosure: QuickSightClientTypes.TableConditionalFormattingOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableConditionalFormatting()
        value.conditionalFormattingOptions = try reader["ConditionalFormattingOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TableConditionalFormattingOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableConditionalFormattingOption {

    static func write(value: QuickSightClientTypes.TableConditionalFormattingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cell"].write(value.cell, with: QuickSightClientTypes.TableCellConditionalFormatting.write(value:to:))
        try writer["Row"].write(value.row, with: QuickSightClientTypes.TableRowConditionalFormatting.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableConditionalFormattingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableConditionalFormattingOption()
        value.cell = try reader["Cell"].readIfPresent(with: QuickSightClientTypes.TableCellConditionalFormatting.read(from:))
        value.row = try reader["Row"].readIfPresent(with: QuickSightClientTypes.TableRowConditionalFormatting.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableRowConditionalFormatting {

    static func write(value: QuickSightClientTypes.TableRowConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackgroundColor"].write(value.backgroundColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
        try writer["TextColor"].write(value.textColor, with: QuickSightClientTypes.ConditionalFormattingColor.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableRowConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableRowConditionalFormatting()
        value.backgroundColor = try reader["BackgroundColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        value.textColor = try reader["TextColor"].readIfPresent(with: QuickSightClientTypes.ConditionalFormattingColor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableCellConditionalFormatting {

    static func write(value: QuickSightClientTypes.TableCellConditionalFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["TextFormat"].write(value.textFormat, with: QuickSightClientTypes.TextConditionalFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableCellConditionalFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableCellConditionalFormatting()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.textFormat = try reader["TextFormat"].readIfPresent(with: QuickSightClientTypes.TextConditionalFormat.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableConfiguration {

    static func write(value: QuickSightClientTypes.TableConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldOptions"].write(value.fieldOptions, with: QuickSightClientTypes.TableFieldOptions.write(value:to:))
        try writer["FieldWells"].write(value.fieldWells, with: QuickSightClientTypes.TableFieldWells.write(value:to:))
        try writer["Interactions"].write(value.interactions, with: QuickSightClientTypes.VisualInteractionOptions.write(value:to:))
        try writer["PaginatedReportOptions"].write(value.paginatedReportOptions, with: QuickSightClientTypes.TablePaginatedReportOptions.write(value:to:))
        try writer["SortConfiguration"].write(value.sortConfiguration, with: QuickSightClientTypes.TableSortConfiguration.write(value:to:))
        try writer["TableInlineVisualizations"].writeList(value.tableInlineVisualizations, memberWritingClosure: QuickSightClientTypes.TableInlineVisualization.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TableOptions"].write(value.tableOptions, with: QuickSightClientTypes.TableOptions.write(value:to:))
        try writer["TotalOptions"].write(value.totalOptions, with: QuickSightClientTypes.TotalOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableConfiguration()
        value.fieldWells = try reader["FieldWells"].readIfPresent(with: QuickSightClientTypes.TableFieldWells.read(from:))
        value.sortConfiguration = try reader["SortConfiguration"].readIfPresent(with: QuickSightClientTypes.TableSortConfiguration.read(from:))
        value.tableOptions = try reader["TableOptions"].readIfPresent(with: QuickSightClientTypes.TableOptions.read(from:))
        value.totalOptions = try reader["TotalOptions"].readIfPresent(with: QuickSightClientTypes.TotalOptions.read(from:))
        value.fieldOptions = try reader["FieldOptions"].readIfPresent(with: QuickSightClientTypes.TableFieldOptions.read(from:))
        value.paginatedReportOptions = try reader["PaginatedReportOptions"].readIfPresent(with: QuickSightClientTypes.TablePaginatedReportOptions.read(from:))
        value.tableInlineVisualizations = try reader["TableInlineVisualizations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TableInlineVisualization.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.interactions = try reader["Interactions"].readIfPresent(with: QuickSightClientTypes.VisualInteractionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableInlineVisualization {

    static func write(value: QuickSightClientTypes.TableInlineVisualization?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataBars"].write(value.dataBars, with: QuickSightClientTypes.DataBarsOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableInlineVisualization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableInlineVisualization()
        value.dataBars = try reader["DataBars"].readIfPresent(with: QuickSightClientTypes.DataBarsOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataBarsOptions {

    static func write(value: QuickSightClientTypes.DataBarsOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldId"].write(value.fieldId)
        try writer["NegativeColor"].write(value.negativeColor)
        try writer["PositiveColor"].write(value.positiveColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataBarsOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataBarsOptions()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.positiveColor = try reader["PositiveColor"].readIfPresent()
        value.negativeColor = try reader["NegativeColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TablePaginatedReportOptions {

    static func write(value: QuickSightClientTypes.TablePaginatedReportOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OverflowColumnHeaderVisibility"].write(value.overflowColumnHeaderVisibility)
        try writer["VerticalOverflowVisibility"].write(value.verticalOverflowVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TablePaginatedReportOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TablePaginatedReportOptions()
        value.verticalOverflowVisibility = try reader["VerticalOverflowVisibility"].readIfPresent()
        value.overflowColumnHeaderVisibility = try reader["OverflowColumnHeaderVisibility"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TableFieldOptions {

    static func write(value: QuickSightClientTypes.TableFieldOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Order"].writeList(value.order, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PinnedFieldOptions"].write(value.pinnedFieldOptions, with: QuickSightClientTypes.TablePinnedFieldOptions.write(value:to:))
        try writer["SelectedFieldOptions"].writeList(value.selectedFieldOptions, memberWritingClosure: QuickSightClientTypes.TableFieldOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldOptions()
        value.selectedFieldOptions = try reader["SelectedFieldOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TableFieldOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.order = try reader["Order"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pinnedFieldOptions = try reader["PinnedFieldOptions"].readIfPresent(with: QuickSightClientTypes.TablePinnedFieldOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TablePinnedFieldOptions {

    static func write(value: QuickSightClientTypes.TablePinnedFieldOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PinnedLeftFields"].writeList(value.pinnedLeftFields, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TablePinnedFieldOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TablePinnedFieldOptions()
        value.pinnedLeftFields = try reader["PinnedLeftFields"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableFieldOption {

    static func write(value: QuickSightClientTypes.TableFieldOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["FieldId"].write(value.fieldId)
        try writer["URLStyling"].write(value.urlStyling, with: QuickSightClientTypes.TableFieldURLConfiguration.write(value:to:))
        try writer["Visibility"].write(value.visibility)
        try writer["Width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldOption()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.width = try reader["Width"].readIfPresent()
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.urlStyling = try reader["URLStyling"].readIfPresent(with: QuickSightClientTypes.TableFieldURLConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableFieldURLConfiguration {

    static func write(value: QuickSightClientTypes.TableFieldURLConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageConfiguration"].write(value.imageConfiguration, with: QuickSightClientTypes.TableFieldImageConfiguration.write(value:to:))
        try writer["LinkConfiguration"].write(value.linkConfiguration, with: QuickSightClientTypes.TableFieldLinkConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldURLConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldURLConfiguration()
        value.linkConfiguration = try reader["LinkConfiguration"].readIfPresent(with: QuickSightClientTypes.TableFieldLinkConfiguration.read(from:))
        value.imageConfiguration = try reader["ImageConfiguration"].readIfPresent(with: QuickSightClientTypes.TableFieldImageConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableFieldImageConfiguration {

    static func write(value: QuickSightClientTypes.TableFieldImageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SizingOptions"].write(value.sizingOptions, with: QuickSightClientTypes.TableCellImageSizingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldImageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldImageConfiguration()
        value.sizingOptions = try reader["SizingOptions"].readIfPresent(with: QuickSightClientTypes.TableCellImageSizingConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableCellImageSizingConfiguration {

    static func write(value: QuickSightClientTypes.TableCellImageSizingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TableCellImageScalingConfiguration"].write(value.tableCellImageScalingConfiguration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableCellImageSizingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableCellImageSizingConfiguration()
        value.tableCellImageScalingConfiguration = try reader["TableCellImageScalingConfiguration"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TableFieldLinkConfiguration {

    static func write(value: QuickSightClientTypes.TableFieldLinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content, with: QuickSightClientTypes.TableFieldLinkContentConfiguration.write(value:to:))
        try writer["Target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldLinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldLinkConfiguration()
        value.target = try reader["Target"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["Content"].readIfPresent(with: QuickSightClientTypes.TableFieldLinkContentConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableFieldLinkContentConfiguration {

    static func write(value: QuickSightClientTypes.TableFieldLinkContentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomIconContent"].write(value.customIconContent, with: QuickSightClientTypes.TableFieldCustomIconContent.write(value:to:))
        try writer["CustomTextContent"].write(value.customTextContent, with: QuickSightClientTypes.TableFieldCustomTextContent.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldLinkContentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldLinkContentConfiguration()
        value.customTextContent = try reader["CustomTextContent"].readIfPresent(with: QuickSightClientTypes.TableFieldCustomTextContent.read(from:))
        value.customIconContent = try reader["CustomIconContent"].readIfPresent(with: QuickSightClientTypes.TableFieldCustomIconContent.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableFieldCustomIconContent {

    static func write(value: QuickSightClientTypes.TableFieldCustomIconContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Icon"].write(value.icon)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldCustomIconContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldCustomIconContent()
        value.icon = try reader["Icon"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TableFieldCustomTextContent {

    static func write(value: QuickSightClientTypes.TableFieldCustomTextContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FontConfiguration"].write(value.fontConfiguration, with: QuickSightClientTypes.FontConfiguration.write(value:to:))
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldCustomTextContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldCustomTextContent()
        value.value = try reader["Value"].readIfPresent()
        value.fontConfiguration = try reader["FontConfiguration"].readIfPresent(with: QuickSightClientTypes.FontConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TotalOptions {

    static func write(value: QuickSightClientTypes.TotalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomLabel"].write(value.customLabel)
        try writer["Placement"].write(value.placement)
        try writer["ScrollStatus"].write(value.scrollStatus)
        try writer["TotalAggregationOptions"].writeList(value.totalAggregationOptions, memberWritingClosure: QuickSightClientTypes.TotalAggregationOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TotalCellStyle"].write(value.totalCellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["TotalsVisibility"].write(value.totalsVisibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TotalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TotalOptions()
        value.totalsVisibility = try reader["TotalsVisibility"].readIfPresent()
        value.placement = try reader["Placement"].readIfPresent()
        value.scrollStatus = try reader["ScrollStatus"].readIfPresent()
        value.customLabel = try reader["CustomLabel"].readIfPresent()
        value.totalCellStyle = try reader["TotalCellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.totalAggregationOptions = try reader["TotalAggregationOptions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TotalAggregationOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TableOptions {

    static func write(value: QuickSightClientTypes.TableOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellStyle"].write(value.cellStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["HeaderStyle"].write(value.headerStyle, with: QuickSightClientTypes.TableCellStyle.write(value:to:))
        try writer["Orientation"].write(value.orientation)
        try writer["RowAlternateColorOptions"].write(value.rowAlternateColorOptions, with: QuickSightClientTypes.RowAlternateColorOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableOptions()
        value.orientation = try reader["Orientation"].readIfPresent()
        value.headerStyle = try reader["HeaderStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.cellStyle = try reader["CellStyle"].readIfPresent(with: QuickSightClientTypes.TableCellStyle.read(from:))
        value.rowAlternateColorOptions = try reader["RowAlternateColorOptions"].readIfPresent(with: QuickSightClientTypes.RowAlternateColorOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableSortConfiguration {

    static func write(value: QuickSightClientTypes.TableSortConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PaginationConfiguration"].write(value.paginationConfiguration, with: QuickSightClientTypes.PaginationConfiguration.write(value:to:))
        try writer["RowSort"].writeList(value.rowSort, memberWritingClosure: QuickSightClientTypes.FieldSortOptions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableSortConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableSortConfiguration()
        value.rowSort = try reader["RowSort"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FieldSortOptions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.paginationConfiguration = try reader["PaginationConfiguration"].readIfPresent(with: QuickSightClientTypes.PaginationConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableFieldWells {

    static func write(value: QuickSightClientTypes.TableFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TableAggregatedFieldWells"].write(value.tableAggregatedFieldWells, with: QuickSightClientTypes.TableAggregatedFieldWells.write(value:to:))
        try writer["TableUnaggregatedFieldWells"].write(value.tableUnaggregatedFieldWells, with: QuickSightClientTypes.TableUnaggregatedFieldWells.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableFieldWells()
        value.tableAggregatedFieldWells = try reader["TableAggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.TableAggregatedFieldWells.read(from:))
        value.tableUnaggregatedFieldWells = try reader["TableUnaggregatedFieldWells"].readIfPresent(with: QuickSightClientTypes.TableUnaggregatedFieldWells.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableUnaggregatedFieldWells {

    static func write(value: QuickSightClientTypes.TableUnaggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.UnaggregatedField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableUnaggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableUnaggregatedFieldWells()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.UnaggregatedField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.UnaggregatedField {

    static func write(value: QuickSightClientTypes.UnaggregatedField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Column"].write(value.column, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["FieldId"].write(value.fieldId)
        try writer["FormatConfiguration"].write(value.formatConfiguration, with: QuickSightClientTypes.FormatConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.UnaggregatedField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.UnaggregatedField()
        value.fieldId = try reader["FieldId"].readIfPresent() ?? ""
        value.column = try reader["Column"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        value.formatConfiguration = try reader["FormatConfiguration"].readIfPresent(with: QuickSightClientTypes.FormatConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TableAggregatedFieldWells {

    static func write(value: QuickSightClientTypes.TableAggregatedFieldWells?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: QuickSightClientTypes.DimensionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: QuickSightClientTypes.MeasureField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TableAggregatedFieldWells {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TableAggregatedFieldWells()
        value.groupBy = try reader["GroupBy"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DimensionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.MeasureField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.FilterControl {

    static func write(value: QuickSightClientTypes.FilterControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossSheet"].write(value.crossSheet, with: QuickSightClientTypes.FilterCrossSheetControl.write(value:to:))
        try writer["DateTimePicker"].write(value.dateTimePicker, with: QuickSightClientTypes.FilterDateTimePickerControl.write(value:to:))
        try writer["Dropdown"].write(value.dropdown, with: QuickSightClientTypes.FilterDropDownControl.write(value:to:))
        try writer["List"].write(value.list, with: QuickSightClientTypes.FilterListControl.write(value:to:))
        try writer["RelativeDateTime"].write(value.relativeDateTime, with: QuickSightClientTypes.FilterRelativeDateTimeControl.write(value:to:))
        try writer["Slider"].write(value.slider, with: QuickSightClientTypes.FilterSliderControl.write(value:to:))
        try writer["TextArea"].write(value.textArea, with: QuickSightClientTypes.FilterTextAreaControl.write(value:to:))
        try writer["TextField"].write(value.textField, with: QuickSightClientTypes.FilterTextFieldControl.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterControl()
        value.dateTimePicker = try reader["DateTimePicker"].readIfPresent(with: QuickSightClientTypes.FilterDateTimePickerControl.read(from:))
        value.list = try reader["List"].readIfPresent(with: QuickSightClientTypes.FilterListControl.read(from:))
        value.dropdown = try reader["Dropdown"].readIfPresent(with: QuickSightClientTypes.FilterDropDownControl.read(from:))
        value.textField = try reader["TextField"].readIfPresent(with: QuickSightClientTypes.FilterTextFieldControl.read(from:))
        value.textArea = try reader["TextArea"].readIfPresent(with: QuickSightClientTypes.FilterTextAreaControl.read(from:))
        value.slider = try reader["Slider"].readIfPresent(with: QuickSightClientTypes.FilterSliderControl.read(from:))
        value.relativeDateTime = try reader["RelativeDateTime"].readIfPresent(with: QuickSightClientTypes.FilterRelativeDateTimeControl.read(from:))
        value.crossSheet = try reader["CrossSheet"].readIfPresent(with: QuickSightClientTypes.FilterCrossSheetControl.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterCrossSheetControl {

    static func write(value: QuickSightClientTypes.FilterCrossSheetControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CascadingControlConfiguration"].write(value.cascadingControlConfiguration, with: QuickSightClientTypes.CascadingControlConfiguration.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SourceFilterId"].write(value.sourceFilterId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterCrossSheetControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterCrossSheetControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.cascadingControlConfiguration = try reader["CascadingControlConfiguration"].readIfPresent(with: QuickSightClientTypes.CascadingControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CascadingControlConfiguration {

    static func write(value: QuickSightClientTypes.CascadingControlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceControls"].writeList(value.sourceControls, memberWritingClosure: QuickSightClientTypes.CascadingControlSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CascadingControlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CascadingControlConfiguration()
        value.sourceControls = try reader["SourceControls"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CascadingControlSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CascadingControlSource {

    static func write(value: QuickSightClientTypes.CascadingControlSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnToMatch"].write(value.columnToMatch, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["SourceSheetControlId"].write(value.sourceSheetControlId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CascadingControlSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CascadingControlSource()
        value.sourceSheetControlId = try reader["SourceSheetControlId"].readIfPresent()
        value.columnToMatch = try reader["ColumnToMatch"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterRelativeDateTimeControl {

    static func write(value: QuickSightClientTypes.FilterRelativeDateTimeControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterRelativeDateTimeControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterRelativeDateTimeControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.RelativeDateTimeControlDisplayOptions.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilterSliderControl {

    static func write(value: QuickSightClientTypes.FilterSliderControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.SliderControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["MaximumValue"].write(value.maximumValue)
        try writer["MinimumValue"].write(value.minimumValue)
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["StepSize"].write(value.stepSize)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterSliderControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterSliderControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.SliderControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.maximumValue = try reader["MaximumValue"].readIfPresent() ?? 0
        value.minimumValue = try reader["MinimumValue"].readIfPresent() ?? 0
        value.stepSize = try reader["StepSize"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.FilterTextAreaControl {

    static func write(value: QuickSightClientTypes.FilterTextAreaControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Delimiter"].write(value.delimiter)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextAreaControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterTextAreaControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterTextAreaControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextAreaControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterTextFieldControl {

    static func write(value: QuickSightClientTypes.FilterTextFieldControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextFieldControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterTextFieldControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterTextFieldControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextFieldControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterDropDownControl {

    static func write(value: QuickSightClientTypes.FilterDropDownControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CascadingControlConfiguration"].write(value.cascadingControlConfiguration, with: QuickSightClientTypes.CascadingControlConfiguration.write(value:to:))
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DropDownControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.FilterSelectableValues.write(value:to:))
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterDropDownControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterDropDownControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DropDownControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.FilterSelectableValues.read(from:))
        value.cascadingControlConfiguration = try reader["CascadingControlConfiguration"].readIfPresent(with: QuickSightClientTypes.CascadingControlConfiguration.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilterListControl {

    static func write(value: QuickSightClientTypes.FilterListControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CascadingControlConfiguration"].write(value.cascadingControlConfiguration, with: QuickSightClientTypes.CascadingControlConfiguration.write(value:to:))
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.ListControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.FilterSelectableValues.write(value:to:))
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterListControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterListControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.ListControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.FilterSelectableValues.read(from:))
        value.cascadingControlConfiguration = try reader["CascadingControlConfiguration"].readIfPresent(with: QuickSightClientTypes.CascadingControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.FilterDateTimePickerControl {

    static func write(value: QuickSightClientTypes.FilterDateTimePickerControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.write(value:to:))
        try writer["FilterControlId"].write(value.filterControlId)
        try writer["SourceFilterId"].write(value.sourceFilterId)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterDateTimePickerControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterDateTimePickerControl()
        value.filterControlId = try reader["FilterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceFilterId = try reader["SourceFilterId"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ParameterControl {

    static func write(value: QuickSightClientTypes.ParameterControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimePicker"].write(value.dateTimePicker, with: QuickSightClientTypes.ParameterDateTimePickerControl.write(value:to:))
        try writer["Dropdown"].write(value.dropdown, with: QuickSightClientTypes.ParameterDropDownControl.write(value:to:))
        try writer["List"].write(value.list, with: QuickSightClientTypes.ParameterListControl.write(value:to:))
        try writer["Slider"].write(value.slider, with: QuickSightClientTypes.ParameterSliderControl.write(value:to:))
        try writer["TextArea"].write(value.textArea, with: QuickSightClientTypes.ParameterTextAreaControl.write(value:to:))
        try writer["TextField"].write(value.textField, with: QuickSightClientTypes.ParameterTextFieldControl.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterControl()
        value.dateTimePicker = try reader["DateTimePicker"].readIfPresent(with: QuickSightClientTypes.ParameterDateTimePickerControl.read(from:))
        value.list = try reader["List"].readIfPresent(with: QuickSightClientTypes.ParameterListControl.read(from:))
        value.dropdown = try reader["Dropdown"].readIfPresent(with: QuickSightClientTypes.ParameterDropDownControl.read(from:))
        value.textField = try reader["TextField"].readIfPresent(with: QuickSightClientTypes.ParameterTextFieldControl.read(from:))
        value.textArea = try reader["TextArea"].readIfPresent(with: QuickSightClientTypes.ParameterTextAreaControl.read(from:))
        value.slider = try reader["Slider"].readIfPresent(with: QuickSightClientTypes.ParameterSliderControl.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterSliderControl {

    static func write(value: QuickSightClientTypes.ParameterSliderControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.SliderControlDisplayOptions.write(value:to:))
        try writer["MaximumValue"].write(value.maximumValue)
        try writer["MinimumValue"].write(value.minimumValue)
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["StepSize"].write(value.stepSize)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterSliderControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterSliderControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.SliderControlDisplayOptions.read(from:))
        value.maximumValue = try reader["MaximumValue"].readIfPresent() ?? 0
        value.minimumValue = try reader["MinimumValue"].readIfPresent() ?? 0
        value.stepSize = try reader["StepSize"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.ParameterTextAreaControl {

    static func write(value: QuickSightClientTypes.ParameterTextAreaControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Delimiter"].write(value.delimiter)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextAreaControlDisplayOptions.write(value:to:))
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterTextAreaControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterTextAreaControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.delimiter = try reader["Delimiter"].readIfPresent()
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextAreaControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterTextFieldControl {

    static func write(value: QuickSightClientTypes.ParameterTextFieldControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.TextFieldControlDisplayOptions.write(value:to:))
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterTextFieldControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterTextFieldControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.TextFieldControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterDropDownControl {

    static func write(value: QuickSightClientTypes.ParameterDropDownControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CascadingControlConfiguration"].write(value.cascadingControlConfiguration, with: QuickSightClientTypes.CascadingControlConfiguration.write(value:to:))
        try writer["CommitMode"].write(value.commitMode)
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DropDownControlDisplayOptions.write(value:to:))
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.ParameterSelectableValues.write(value:to:))
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterDropDownControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterDropDownControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DropDownControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.ParameterSelectableValues.read(from:))
        value.cascadingControlConfiguration = try reader["CascadingControlConfiguration"].readIfPresent(with: QuickSightClientTypes.CascadingControlConfiguration.read(from:))
        value.commitMode = try reader["CommitMode"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ParameterSelectableValues {

    static func write(value: QuickSightClientTypes.ParameterSelectableValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LinkToDataSetColumn"].write(value.linkToDataSetColumn, with: QuickSightClientTypes.ColumnIdentifier.write(value:to:))
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterSelectableValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterSelectableValues()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linkToDataSetColumn = try reader["LinkToDataSetColumn"].readIfPresent(with: QuickSightClientTypes.ColumnIdentifier.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterListControl {

    static func write(value: QuickSightClientTypes.ParameterListControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CascadingControlConfiguration"].write(value.cascadingControlConfiguration, with: QuickSightClientTypes.CascadingControlConfiguration.write(value:to:))
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.ListControlDisplayOptions.write(value:to:))
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SelectableValues"].write(value.selectableValues, with: QuickSightClientTypes.ParameterSelectableValues.write(value:to:))
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterListControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterListControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.ListControlDisplayOptions.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.selectableValues = try reader["SelectableValues"].readIfPresent(with: QuickSightClientTypes.ParameterSelectableValues.read(from:))
        value.cascadingControlConfiguration = try reader["CascadingControlConfiguration"].readIfPresent(with: QuickSightClientTypes.CascadingControlConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ParameterDateTimePickerControl {

    static func write(value: QuickSightClientTypes.ParameterDateTimePickerControl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayOptions"].write(value.displayOptions, with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.write(value:to:))
        try writer["ParameterControlId"].write(value.parameterControlId)
        try writer["SourceParameterName"].write(value.sourceParameterName)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ParameterDateTimePickerControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ParameterDateTimePickerControl()
        value.parameterControlId = try reader["ParameterControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.sourceParameterName = try reader["SourceParameterName"].readIfPresent() ?? ""
        value.displayOptions = try reader["DisplayOptions"].readIfPresent(with: QuickSightClientTypes.DateTimePickerControlDisplayOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataSetIdentifierDeclaration {

    static func write(value: QuickSightClientTypes.DataSetIdentifierDeclaration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetArn"].write(value.dataSetArn)
        try writer["Identifier"].write(value.identifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetIdentifierDeclaration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetIdentifierDeclaration()
        value.identifier = try reader["Identifier"].readIfPresent() ?? ""
        value.dataSetArn = try reader["DataSetArn"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.ResourcePermission {

    static func write(value: QuickSightClientTypes.ResourcePermission?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principal"].write(value.principal)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ResourcePermission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ResourcePermission()
        value.principal = try reader["Principal"].readIfPresent() ?? ""
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobError()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration {

    static func write(value: QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyses"].writeList(value.analyses, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dashboards"].writeList(value.dashboards, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSets"].writeList(value.dataSets, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Folders"].writeList(value.folders, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RefreshSchedules"].writeList(value.refreshSchedules, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceIdOverrideConfiguration"].write(value.resourceIdOverrideConfiguration, with: QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration.write(value:to:))
        try writer["Themes"].writeList(value.themes, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnections"].writeList(value.vpcConnections, memberWritingClosure: QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleCloudFormationOverridePropertyConfiguration()
        value.resourceIdOverrideConfiguration = try reader["ResourceIdOverrideConfiguration"].readIfPresent(with: QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration.read(from:))
        value.vpcConnections = try reader["VPCConnections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.refreshSchedules = try reader["RefreshSchedules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSets = try reader["DataSets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.themes = try reader["Themes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analyses = try reader["Analyses"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dashboards = try reader["Dashboards"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobFolderPropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobFolderOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobFolderPropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobDashboardPropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobDashboardOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobDashboardPropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobAnalysisPropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobAnalysisOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobAnalysisPropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobThemePropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobThemeOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobThemePropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobDataSetPropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobDataSetOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobDataSetPropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobDataSourcePropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobDataSourceOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobDataSourcePropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobRefreshSchedulePropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobRefreshScheduleOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobRefreshSchedulePropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Properties"].writeList(value.properties, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AssetBundleExportJobVPCConnectionPropertyToOverride>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobVPCConnectionOverrideProperties()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.properties = try reader["Properties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AssetBundleExportJobVPCConnectionPropertyToOverride>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrefixForAllResources"].write(value.prefixForAllResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobResourceIdOverrideConfiguration()
        value.prefixForAllResources = try reader["PrefixForAllResources"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobValidationStrategy {

    static func write(value: QuickSightClientTypes.AssetBundleExportJobValidationStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StrictModeForAllResources"].write(value.strictModeForAllResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobValidationStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobValidationStrategy()
        value.strictModeForAllResources = try reader["StrictModeForAllResources"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobWarning {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobWarning()
        value.arn = try reader["Arn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobError()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportSourceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportSourceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportSourceDescription()
        value.body = try reader["Body"].readIfPresent()
        value.s3Uri = try reader["S3Uri"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyses"].writeList(value.analyses, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dashboards"].writeList(value.dashboards, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSets"].writeList(value.dataSets, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Folders"].writeList(value.folders, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RefreshSchedules"].writeList(value.refreshSchedules, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceIdOverrideConfiguration"].write(value.resourceIdOverrideConfiguration, with: QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration.write(value:to:))
        try writer["Themes"].writeList(value.themes, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnections"].writeList(value.vpcConnections, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobOverrideParameters()
        value.resourceIdOverrideConfiguration = try reader["ResourceIdOverrideConfiguration"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration.read(from:))
        value.vpcConnections = try reader["VPCConnections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.refreshSchedules = try reader["RefreshSchedules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSets = try reader["DataSets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.themes = try reader["Themes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analyses = try reader["Analyses"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dashboards = try reader["Dashboards"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FolderId"].write(value.folderId)
        try writer["Name"].write(value.name)
        try writer["ParentFolderArn"].write(value.parentFolderArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobFolderOverrideParameters()
        value.folderId = try reader["FolderId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.parentFolderArn = try reader["ParentFolderArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardId"].write(value.dashboardId)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDashboardOverrideParameters()
        value.dashboardId = try reader["DashboardId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisId"].write(value.analysisId)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideParameters()
        value.analysisId = try reader["AnalysisId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ThemeId"].write(value.themeId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobThemeOverrideParameters()
        value.themeId = try reader["ThemeId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetId"].write(value.dataSetId)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSetOverrideParameters()
        value.dataSetId = try reader["DataSetId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Credentials"].write(value.credentials, with: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials.write(value:to:))
        try writer["DataSourceId"].write(value.dataSourceId)
        try writer["DataSourceParameters"].write(value.dataSourceParameters, with: QuickSightClientTypes.DataSourceParameters.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SslProperties"].write(value.sslProperties, with: QuickSightClientTypes.SslProperties.write(value:to:))
        try writer["VpcConnectionProperties"].write(value.vpcConnectionProperties, with: QuickSightClientTypes.VpcConnectionProperties.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideParameters()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.dataSourceParameters = try reader["DataSourceParameters"].readIfPresent(with: QuickSightClientTypes.DataSourceParameters.read(from:))
        value.vpcConnectionProperties = try reader["VpcConnectionProperties"].readIfPresent(with: QuickSightClientTypes.VpcConnectionProperties.read(from:))
        value.sslProperties = try reader["SslProperties"].readIfPresent(with: QuickSightClientTypes.SslProperties.read(from:))
        value.credentials = try reader["Credentials"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CredentialPair"].write(value.credentialPair, with: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair.write(value:to:))
        try writer["SecretArn"].write(value.secretArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSourceCredentials()
        value.credentialPair = try reader["CredentialPair"].readIfPresent(with: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair.read(from:))
        value.secretArn = try reader["SecretArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSourceCredentialPair()
        value.username = try reader["Username"].readIfPresent() ?? ""
        value.password = try reader["Password"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.SslProperties {

    static func write(value: QuickSightClientTypes.SslProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisableSsl"].write(value.disableSsl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SslProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SslProperties()
        value.disableSsl = try reader["DisableSsl"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.VpcConnectionProperties {

    static func write(value: QuickSightClientTypes.VpcConnectionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcConnectionArn"].write(value.vpcConnectionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VpcConnectionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VpcConnectionProperties()
        value.vpcConnectionArn = try reader["VpcConnectionArn"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.DataSourceParameters {

    static func write(value: QuickSightClientTypes.DataSourceParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amazonelasticsearchparameters(amazonelasticsearchparameters):
                try writer["AmazonElasticsearchParameters"].write(amazonelasticsearchparameters, with: QuickSightClientTypes.AmazonElasticsearchParameters.write(value:to:))
            case let .amazonopensearchparameters(amazonopensearchparameters):
                try writer["AmazonOpenSearchParameters"].write(amazonopensearchparameters, with: QuickSightClientTypes.AmazonOpenSearchParameters.write(value:to:))
            case let .athenaparameters(athenaparameters):
                try writer["AthenaParameters"].write(athenaparameters, with: QuickSightClientTypes.AthenaParameters.write(value:to:))
            case let .auroraparameters(auroraparameters):
                try writer["AuroraParameters"].write(auroraparameters, with: QuickSightClientTypes.AuroraParameters.write(value:to:))
            case let .aurorapostgresqlparameters(aurorapostgresqlparameters):
                try writer["AuroraPostgreSqlParameters"].write(aurorapostgresqlparameters, with: QuickSightClientTypes.AuroraPostgreSqlParameters.write(value:to:))
            case let .awsiotanalyticsparameters(awsiotanalyticsparameters):
                try writer["AwsIotAnalyticsParameters"].write(awsiotanalyticsparameters, with: QuickSightClientTypes.AwsIotAnalyticsParameters.write(value:to:))
            case let .bigqueryparameters(bigqueryparameters):
                try writer["BigQueryParameters"].write(bigqueryparameters, with: QuickSightClientTypes.BigQueryParameters.write(value:to:))
            case let .databricksparameters(databricksparameters):
                try writer["DatabricksParameters"].write(databricksparameters, with: QuickSightClientTypes.DatabricksParameters.write(value:to:))
            case let .exasolparameters(exasolparameters):
                try writer["ExasolParameters"].write(exasolparameters, with: QuickSightClientTypes.ExasolParameters.write(value:to:))
            case let .jiraparameters(jiraparameters):
                try writer["JiraParameters"].write(jiraparameters, with: QuickSightClientTypes.JiraParameters.write(value:to:))
            case let .mariadbparameters(mariadbparameters):
                try writer["MariaDbParameters"].write(mariadbparameters, with: QuickSightClientTypes.MariaDbParameters.write(value:to:))
            case let .mysqlparameters(mysqlparameters):
                try writer["MySqlParameters"].write(mysqlparameters, with: QuickSightClientTypes.MySqlParameters.write(value:to:))
            case let .oracleparameters(oracleparameters):
                try writer["OracleParameters"].write(oracleparameters, with: QuickSightClientTypes.OracleParameters.write(value:to:))
            case let .postgresqlparameters(postgresqlparameters):
                try writer["PostgreSqlParameters"].write(postgresqlparameters, with: QuickSightClientTypes.PostgreSqlParameters.write(value:to:))
            case let .prestoparameters(prestoparameters):
                try writer["PrestoParameters"].write(prestoparameters, with: QuickSightClientTypes.PrestoParameters.write(value:to:))
            case let .rdsparameters(rdsparameters):
                try writer["RdsParameters"].write(rdsparameters, with: QuickSightClientTypes.RdsParameters.write(value:to:))
            case let .redshiftparameters(redshiftparameters):
                try writer["RedshiftParameters"].write(redshiftparameters, with: QuickSightClientTypes.RedshiftParameters.write(value:to:))
            case let .s3parameters(s3parameters):
                try writer["S3Parameters"].write(s3parameters, with: QuickSightClientTypes.S3Parameters.write(value:to:))
            case let .servicenowparameters(servicenowparameters):
                try writer["ServiceNowParameters"].write(servicenowparameters, with: QuickSightClientTypes.ServiceNowParameters.write(value:to:))
            case let .snowflakeparameters(snowflakeparameters):
                try writer["SnowflakeParameters"].write(snowflakeparameters, with: QuickSightClientTypes.SnowflakeParameters.write(value:to:))
            case let .sparkparameters(sparkparameters):
                try writer["SparkParameters"].write(sparkparameters, with: QuickSightClientTypes.SparkParameters.write(value:to:))
            case let .sqlserverparameters(sqlserverparameters):
                try writer["SqlServerParameters"].write(sqlserverparameters, with: QuickSightClientTypes.SqlServerParameters.write(value:to:))
            case let .starburstparameters(starburstparameters):
                try writer["StarburstParameters"].write(starburstparameters, with: QuickSightClientTypes.StarburstParameters.write(value:to:))
            case let .teradataparameters(teradataparameters):
                try writer["TeradataParameters"].write(teradataparameters, with: QuickSightClientTypes.TeradataParameters.write(value:to:))
            case let .trinoparameters(trinoparameters):
                try writer["TrinoParameters"].write(trinoparameters, with: QuickSightClientTypes.TrinoParameters.write(value:to:))
            case let .twitterparameters(twitterparameters):
                try writer["TwitterParameters"].write(twitterparameters, with: QuickSightClientTypes.TwitterParameters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSourceParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "AmazonElasticsearchParameters":
                return .amazonelasticsearchparameters(try reader["AmazonElasticsearchParameters"].read(with: QuickSightClientTypes.AmazonElasticsearchParameters.read(from:)))
            case "AthenaParameters":
                return .athenaparameters(try reader["AthenaParameters"].read(with: QuickSightClientTypes.AthenaParameters.read(from:)))
            case "AuroraParameters":
                return .auroraparameters(try reader["AuroraParameters"].read(with: QuickSightClientTypes.AuroraParameters.read(from:)))
            case "AuroraPostgreSqlParameters":
                return .aurorapostgresqlparameters(try reader["AuroraPostgreSqlParameters"].read(with: QuickSightClientTypes.AuroraPostgreSqlParameters.read(from:)))
            case "AwsIotAnalyticsParameters":
                return .awsiotanalyticsparameters(try reader["AwsIotAnalyticsParameters"].read(with: QuickSightClientTypes.AwsIotAnalyticsParameters.read(from:)))
            case "JiraParameters":
                return .jiraparameters(try reader["JiraParameters"].read(with: QuickSightClientTypes.JiraParameters.read(from:)))
            case "MariaDbParameters":
                return .mariadbparameters(try reader["MariaDbParameters"].read(with: QuickSightClientTypes.MariaDbParameters.read(from:)))
            case "MySqlParameters":
                return .mysqlparameters(try reader["MySqlParameters"].read(with: QuickSightClientTypes.MySqlParameters.read(from:)))
            case "OracleParameters":
                return .oracleparameters(try reader["OracleParameters"].read(with: QuickSightClientTypes.OracleParameters.read(from:)))
            case "PostgreSqlParameters":
                return .postgresqlparameters(try reader["PostgreSqlParameters"].read(with: QuickSightClientTypes.PostgreSqlParameters.read(from:)))
            case "PrestoParameters":
                return .prestoparameters(try reader["PrestoParameters"].read(with: QuickSightClientTypes.PrestoParameters.read(from:)))
            case "RdsParameters":
                return .rdsparameters(try reader["RdsParameters"].read(with: QuickSightClientTypes.RdsParameters.read(from:)))
            case "RedshiftParameters":
                return .redshiftparameters(try reader["RedshiftParameters"].read(with: QuickSightClientTypes.RedshiftParameters.read(from:)))
            case "S3Parameters":
                return .s3parameters(try reader["S3Parameters"].read(with: QuickSightClientTypes.S3Parameters.read(from:)))
            case "ServiceNowParameters":
                return .servicenowparameters(try reader["ServiceNowParameters"].read(with: QuickSightClientTypes.ServiceNowParameters.read(from:)))
            case "SnowflakeParameters":
                return .snowflakeparameters(try reader["SnowflakeParameters"].read(with: QuickSightClientTypes.SnowflakeParameters.read(from:)))
            case "SparkParameters":
                return .sparkparameters(try reader["SparkParameters"].read(with: QuickSightClientTypes.SparkParameters.read(from:)))
            case "SqlServerParameters":
                return .sqlserverparameters(try reader["SqlServerParameters"].read(with: QuickSightClientTypes.SqlServerParameters.read(from:)))
            case "TeradataParameters":
                return .teradataparameters(try reader["TeradataParameters"].read(with: QuickSightClientTypes.TeradataParameters.read(from:)))
            case "TwitterParameters":
                return .twitterparameters(try reader["TwitterParameters"].read(with: QuickSightClientTypes.TwitterParameters.read(from:)))
            case "AmazonOpenSearchParameters":
                return .amazonopensearchparameters(try reader["AmazonOpenSearchParameters"].read(with: QuickSightClientTypes.AmazonOpenSearchParameters.read(from:)))
            case "ExasolParameters":
                return .exasolparameters(try reader["ExasolParameters"].read(with: QuickSightClientTypes.ExasolParameters.read(from:)))
            case "DatabricksParameters":
                return .databricksparameters(try reader["DatabricksParameters"].read(with: QuickSightClientTypes.DatabricksParameters.read(from:)))
            case "StarburstParameters":
                return .starburstparameters(try reader["StarburstParameters"].read(with: QuickSightClientTypes.StarburstParameters.read(from:)))
            case "TrinoParameters":
                return .trinoparameters(try reader["TrinoParameters"].read(with: QuickSightClientTypes.TrinoParameters.read(from:)))
            case "BigQueryParameters":
                return .bigqueryparameters(try reader["BigQueryParameters"].read(with: QuickSightClientTypes.BigQueryParameters.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QuickSightClientTypes.BigQueryParameters {

    static func write(value: QuickSightClientTypes.BigQueryParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetRegion"].write(value.dataSetRegion)
        try writer["ProjectId"].write(value.projectId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BigQueryParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BigQueryParameters()
        value.projectId = try reader["ProjectId"].readIfPresent() ?? ""
        value.dataSetRegion = try reader["DataSetRegion"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TrinoParameters {

    static func write(value: QuickSightClientTypes.TrinoParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TrinoParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TrinoParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.StarburstParameters {

    static func write(value: QuickSightClientTypes.StarburstParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["Catalog"].write(value.catalog)
        try writer["DatabaseAccessControlRole"].write(value.databaseAccessControlRole)
        try writer["Host"].write(value.host)
        try writer["OAuthParameters"].write(value.oAuthParameters, with: QuickSightClientTypes.OAuthParameters.write(value:to:))
        try writer["Port"].write(value.port)
        try writer["ProductType"].write(value.productType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StarburstParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StarburstParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.productType = try reader["ProductType"].readIfPresent()
        value.databaseAccessControlRole = try reader["DatabaseAccessControlRole"].readIfPresent()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.oAuthParameters = try reader["OAuthParameters"].readIfPresent(with: QuickSightClientTypes.OAuthParameters.read(from:))
        return value
    }
}

extension QuickSightClientTypes.OAuthParameters {

    static func write(value: QuickSightClientTypes.OAuthParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdentityProviderResourceUri"].write(value.identityProviderResourceUri)
        try writer["IdentityProviderVpcConnectionProperties"].write(value.identityProviderVpcConnectionProperties, with: QuickSightClientTypes.VpcConnectionProperties.write(value:to:))
        try writer["OAuthScope"].write(value.oAuthScope)
        try writer["TokenProviderUrl"].write(value.tokenProviderUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.OAuthParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.OAuthParameters()
        value.tokenProviderUrl = try reader["TokenProviderUrl"].readIfPresent() ?? ""
        value.oAuthScope = try reader["OAuthScope"].readIfPresent()
        value.identityProviderVpcConnectionProperties = try reader["IdentityProviderVpcConnectionProperties"].readIfPresent(with: QuickSightClientTypes.VpcConnectionProperties.read(from:))
        value.identityProviderResourceUri = try reader["IdentityProviderResourceUri"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DatabricksParameters {

    static func write(value: QuickSightClientTypes.DatabricksParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
        try writer["SqlEndpointPath"].write(value.sqlEndpointPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DatabricksParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DatabricksParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.sqlEndpointPath = try reader["SqlEndpointPath"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.ExasolParameters {

    static func write(value: QuickSightClientTypes.ExasolParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExasolParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExasolParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.AmazonOpenSearchParameters {

    static func write(value: QuickSightClientTypes.AmazonOpenSearchParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AmazonOpenSearchParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AmazonOpenSearchParameters()
        value.domain = try reader["Domain"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.TwitterParameters {

    static func write(value: QuickSightClientTypes.TwitterParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxRows"].write(value.maxRows)
        try writer["Query"].write(value.query)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TwitterParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TwitterParameters()
        value.query = try reader["Query"].readIfPresent() ?? ""
        value.maxRows = try reader["MaxRows"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.TeradataParameters {

    static func write(value: QuickSightClientTypes.TeradataParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TeradataParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TeradataParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.SqlServerParameters {

    static func write(value: QuickSightClientTypes.SqlServerParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SqlServerParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SqlServerParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.SparkParameters {

    static func write(value: QuickSightClientTypes.SparkParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SparkParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SparkParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.SnowflakeParameters {

    static func write(value: QuickSightClientTypes.SnowflakeParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["Database"].write(value.database)
        try writer["DatabaseAccessControlRole"].write(value.databaseAccessControlRole)
        try writer["Host"].write(value.host)
        try writer["OAuthParameters"].write(value.oAuthParameters, with: QuickSightClientTypes.OAuthParameters.write(value:to:))
        try writer["Warehouse"].write(value.warehouse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnowflakeParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnowflakeParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.warehouse = try reader["Warehouse"].readIfPresent() ?? ""
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.databaseAccessControlRole = try reader["DatabaseAccessControlRole"].readIfPresent()
        value.oAuthParameters = try reader["OAuthParameters"].readIfPresent(with: QuickSightClientTypes.OAuthParameters.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ServiceNowParameters {

    static func write(value: QuickSightClientTypes.ServiceNowParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SiteBaseUrl"].write(value.siteBaseUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ServiceNowParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ServiceNowParameters()
        value.siteBaseUrl = try reader["SiteBaseUrl"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.S3Parameters {

    static func write(value: QuickSightClientTypes.S3Parameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ManifestFileLocation"].write(value.manifestFileLocation, with: QuickSightClientTypes.ManifestFileLocation.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.S3Parameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.S3Parameters()
        value.manifestFileLocation = try reader["ManifestFileLocation"].readIfPresent(with: QuickSightClientTypes.ManifestFileLocation.read(from:))
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ManifestFileLocation {

    static func write(value: QuickSightClientTypes.ManifestFileLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ManifestFileLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ManifestFileLocation()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.key = try reader["Key"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.RedshiftParameters {

    static func write(value: QuickSightClientTypes.RedshiftParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["IAMParameters"].write(value.iamParameters, with: QuickSightClientTypes.RedshiftIAMParameters.write(value:to:))
        try writer["IdentityCenterConfiguration"].write(value.identityCenterConfiguration, with: QuickSightClientTypes.IdentityCenterConfiguration.write(value:to:))
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RedshiftParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RedshiftParameters()
        value.host = try reader["Host"].readIfPresent()
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.iamParameters = try reader["IAMParameters"].readIfPresent(with: QuickSightClientTypes.RedshiftIAMParameters.read(from:))
        value.identityCenterConfiguration = try reader["IdentityCenterConfiguration"].readIfPresent(with: QuickSightClientTypes.IdentityCenterConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.IdentityCenterConfiguration {

    static func write(value: QuickSightClientTypes.IdentityCenterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableIdentityPropagation"].write(value.enableIdentityPropagation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IdentityCenterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IdentityCenterConfiguration()
        value.enableIdentityPropagation = try reader["EnableIdentityPropagation"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RedshiftIAMParameters {

    static func write(value: QuickSightClientTypes.RedshiftIAMParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoCreateDatabaseUser"].write(value.autoCreateDatabaseUser)
        try writer["DatabaseGroups"].writeList(value.databaseGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseUser"].write(value.databaseUser)
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RedshiftIAMParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RedshiftIAMParameters()
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.databaseUser = try reader["DatabaseUser"].readIfPresent()
        value.databaseGroups = try reader["DatabaseGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoCreateDatabaseUser = try reader["AutoCreateDatabaseUser"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.RdsParameters {

    static func write(value: QuickSightClientTypes.RdsParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["InstanceId"].write(value.instanceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RdsParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RdsParameters()
        value.instanceId = try reader["InstanceId"].readIfPresent() ?? ""
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.PrestoParameters {

    static func write(value: QuickSightClientTypes.PrestoParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PrestoParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PrestoParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.PostgreSqlParameters {

    static func write(value: QuickSightClientTypes.PostgreSqlParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PostgreSqlParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.PostgreSqlParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.OracleParameters {

    static func write(value: QuickSightClientTypes.OracleParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.OracleParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.OracleParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.MySqlParameters {

    static func write(value: QuickSightClientTypes.MySqlParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MySqlParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MySqlParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.MariaDbParameters {

    static func write(value: QuickSightClientTypes.MariaDbParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MariaDbParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MariaDbParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.JiraParameters {

    static func write(value: QuickSightClientTypes.JiraParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SiteBaseUrl"].write(value.siteBaseUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.JiraParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.JiraParameters()
        value.siteBaseUrl = try reader["SiteBaseUrl"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AwsIotAnalyticsParameters {

    static func write(value: QuickSightClientTypes.AwsIotAnalyticsParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetName"].write(value.dataSetName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AwsIotAnalyticsParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AwsIotAnalyticsParameters()
        value.dataSetName = try reader["DataSetName"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AuroraPostgreSqlParameters {

    static func write(value: QuickSightClientTypes.AuroraPostgreSqlParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AuroraPostgreSqlParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AuroraPostgreSqlParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AuroraParameters {

    static func write(value: QuickSightClientTypes.AuroraParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Database"].write(value.database)
        try writer["Host"].write(value.host)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AuroraParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AuroraParameters()
        value.host = try reader["Host"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        value.database = try reader["Database"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AthenaParameters {

    static func write(value: QuickSightClientTypes.AthenaParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
        try writer["WorkGroup"].write(value.workGroup)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AthenaParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AthenaParameters()
        value.workGroup = try reader["WorkGroup"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AmazonElasticsearchParameters {

    static func write(value: QuickSightClientTypes.AmazonElasticsearchParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AmazonElasticsearchParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AmazonElasticsearchParameters()
        value.domain = try reader["Domain"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetId"].write(value.dataSetId)
        try writer["ScheduleId"].write(value.scheduleId)
        try writer["StartAfterDateTime"].writeTimestamp(value.startAfterDateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobRefreshScheduleOverrideParameters()
        value.dataSetId = try reader["DataSetId"].readIfPresent() ?? ""
        value.scheduleId = try reader["ScheduleId"].readIfPresent() ?? ""
        value.startAfterDateTime = try reader["StartAfterDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsResolvers"].writeList(value.dnsResolvers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnectionId"].write(value.vpcConnectionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideParameters()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsResolvers = try reader["DnsResolvers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrefixForAllResources"].write(value.prefixForAllResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobResourceIdOverrideConfiguration()
        value.prefixForAllResources = try reader["PrefixForAllResources"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyses"].writeList(value.analyses, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dashboards"].writeList(value.dashboards, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSets"].writeList(value.dataSets, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Folders"].writeList(value.folders, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Themes"].writeList(value.themes, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobOverridePermissions()
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSets = try reader["DataSets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.themes = try reader["Themes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analyses = try reader["Analyses"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dashboards = try reader["Dashboards"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FolderIds"].writeList(value.folderIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobFolderOverridePermissions()
        value.folderIds = try reader["FolderIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleResourcePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleResourcePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principals"].writeList(value.principals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleResourcePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleResourcePermissions()
        value.principals = try reader["Principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardIds"].writeList(value.dashboardIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinkSharingConfiguration"].write(value.linkSharingConfiguration, with: QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration.write(value:to:))
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDashboardOverridePermissions()
        value.dashboardIds = try reader["DashboardIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        value.linkSharingConfiguration = try reader["LinkSharingConfiguration"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration {

    static func write(value: QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleResourceLinkSharingConfiguration()
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisIds"].writeList(value.analysisIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobAnalysisOverridePermissions()
        value.analysisIds = try reader["AnalysisIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
        try writer["ThemeIds"].writeList(value.themeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobThemeOverridePermissions()
        value.themeIds = try reader["ThemeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIds"].writeList(value.dataSetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSetOverridePermissions()
        value.dataSetIds = try reader["DataSetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceIds"].writeList(value.dataSourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Permissions"].write(value.permissions, with: QuickSightClientTypes.AssetBundleResourcePermissions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSourceOverridePermissions()
        value.dataSourceIds = try reader["DataSourceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.permissions = try reader["Permissions"].readIfPresent(with: QuickSightClientTypes.AssetBundleResourcePermissions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Analyses"].writeList(value.analyses, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dashboards"].writeList(value.dashboards, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSets"].writeList(value.dataSets, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSources"].writeList(value.dataSources, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Folders"].writeList(value.folders, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Themes"].writeList(value.themes, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnections"].writeList(value.vpcConnections, memberWritingClosure: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobOverrideTags()
        value.vpcConnections = try reader["VPCConnections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSets = try reader["DataSets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.themes = try reader["Themes"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analyses = try reader["Analyses"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dashboards = try reader["Dashboards"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FolderIds"].writeList(value.folderIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobFolderOverrideTags()
        value.folderIds = try reader["FolderIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.Tag {

    static func write(value: QuickSightClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardIds"].writeList(value.dashboardIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDashboardOverrideTags()
        value.dashboardIds = try reader["DashboardIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisIds"].writeList(value.analysisIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobAnalysisOverrideTags()
        value.analysisIds = try reader["AnalysisIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThemeIds"].writeList(value.themeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobThemeOverrideTags()
        value.themeIds = try reader["ThemeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetIds"].writeList(value.dataSetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSetOverrideTags()
        value.dataSetIds = try reader["DataSetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceIds"].writeList(value.dataSourceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobDataSourceOverrideTags()
        value.dataSourceIds = try reader["DataSourceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCConnectionIds"].writeList(value.vpcConnectionIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobVPCConnectionOverrideTags()
        value.vpcConnectionIds = try reader["VPCConnectionIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy {

    static func write(value: QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StrictModeForAllResources"].write(value.strictModeForAllResources)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobOverrideValidationStrategy()
        value.strictModeForAllResources = try reader["StrictModeForAllResources"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobWarning {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobWarning()
        value.arn = try reader["Arn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Dashboard {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Dashboard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Dashboard()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent(with: QuickSightClientTypes.DashboardVersion.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastPublishedTime = try reader["LastPublishedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.linkEntities = try reader["LinkEntities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DashboardVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardVersion()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DashboardError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.sourceEntityArn = try reader["SourceEntityArn"].readIfPresent()
        value.dataSetArns = try reader["DataSetArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Sheet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DashboardError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardError()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.violatedEntities = try reader["ViolatedEntities"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Entity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DashboardVersionDefinition {

    static func write(value: QuickSightClientTypes.DashboardVersionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisDefaults"].write(value.analysisDefaults, with: QuickSightClientTypes.AnalysisDefaults.write(value:to:))
        try writer["CalculatedFields"].writeList(value.calculatedFields, memberWritingClosure: QuickSightClientTypes.CalculatedField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnConfigurations"].writeList(value.columnConfigurations, memberWritingClosure: QuickSightClientTypes.ColumnConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetIdentifierDeclarations"].writeList(value.dataSetIdentifierDeclarations, memberWritingClosure: QuickSightClientTypes.DataSetIdentifierDeclaration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterGroups"].writeList(value.filterGroups, memberWritingClosure: QuickSightClientTypes.FilterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Options"].write(value.options, with: QuickSightClientTypes.AssetOptions.write(value:to:))
        try writer["ParameterDeclarations"].writeList(value.parameterDeclarations, memberWritingClosure: QuickSightClientTypes.ParameterDeclaration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sheets"].writeList(value.sheets, memberWritingClosure: QuickSightClientTypes.SheetDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardVersionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardVersionDefinition()
        value.dataSetIdentifierDeclarations = try reader["DataSetIdentifierDeclarations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetIdentifierDeclaration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.calculatedFields = try reader["CalculatedFields"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CalculatedField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterDeclarations = try reader["ParameterDeclarations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ParameterDeclaration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterGroups = try reader["FilterGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnConfigurations = try reader["ColumnConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analysisDefaults = try reader["AnalysisDefaults"].readIfPresent(with: QuickSightClientTypes.AnalysisDefaults.read(from:))
        value.options = try reader["Options"].readIfPresent(with: QuickSightClientTypes.AssetOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DashboardPublishOptions {

    static func write(value: QuickSightClientTypes.DashboardPublishOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdHocFilteringOption"].write(value.adHocFilteringOption, with: QuickSightClientTypes.AdHocFilteringOption.write(value:to:))
        try writer["DataPointDrillUpDownOption"].write(value.dataPointDrillUpDownOption, with: QuickSightClientTypes.DataPointDrillUpDownOption.write(value:to:))
        try writer["DataPointMenuLabelOption"].write(value.dataPointMenuLabelOption, with: QuickSightClientTypes.DataPointMenuLabelOption.write(value:to:))
        try writer["DataPointTooltipOption"].write(value.dataPointTooltipOption, with: QuickSightClientTypes.DataPointTooltipOption.write(value:to:))
        try writer["ExportToCSVOption"].write(value.exportToCSVOption, with: QuickSightClientTypes.ExportToCSVOption.write(value:to:))
        try writer["ExportWithHiddenFieldsOption"].write(value.exportWithHiddenFieldsOption, with: QuickSightClientTypes.ExportWithHiddenFieldsOption.write(value:to:))
        try writer["SheetControlsOption"].write(value.sheetControlsOption, with: QuickSightClientTypes.SheetControlsOption.write(value:to:))
        try writer["SheetLayoutElementMaximizationOption"].write(value.sheetLayoutElementMaximizationOption, with: QuickSightClientTypes.SheetLayoutElementMaximizationOption.write(value:to:))
        try writer["VisualAxisSortOption"].write(value.visualAxisSortOption, with: QuickSightClientTypes.VisualAxisSortOption.write(value:to:))
        try writer["VisualMenuOption"].write(value.visualMenuOption, with: QuickSightClientTypes.VisualMenuOption.write(value:to:))
        try writer["VisualPublishOptions"].write(value.visualPublishOptions, with: QuickSightClientTypes.DashboardVisualPublishOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardPublishOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardPublishOptions()
        value.adHocFilteringOption = try reader["AdHocFilteringOption"].readIfPresent(with: QuickSightClientTypes.AdHocFilteringOption.read(from:))
        value.exportToCSVOption = try reader["ExportToCSVOption"].readIfPresent(with: QuickSightClientTypes.ExportToCSVOption.read(from:))
        value.sheetControlsOption = try reader["SheetControlsOption"].readIfPresent(with: QuickSightClientTypes.SheetControlsOption.read(from:))
        value.visualPublishOptions = try reader["VisualPublishOptions"].readIfPresent(with: QuickSightClientTypes.DashboardVisualPublishOptions.read(from:))
        value.sheetLayoutElementMaximizationOption = try reader["SheetLayoutElementMaximizationOption"].readIfPresent(with: QuickSightClientTypes.SheetLayoutElementMaximizationOption.read(from:))
        value.visualMenuOption = try reader["VisualMenuOption"].readIfPresent(with: QuickSightClientTypes.VisualMenuOption.read(from:))
        value.visualAxisSortOption = try reader["VisualAxisSortOption"].readIfPresent(with: QuickSightClientTypes.VisualAxisSortOption.read(from:))
        value.exportWithHiddenFieldsOption = try reader["ExportWithHiddenFieldsOption"].readIfPresent(with: QuickSightClientTypes.ExportWithHiddenFieldsOption.read(from:))
        value.dataPointDrillUpDownOption = try reader["DataPointDrillUpDownOption"].readIfPresent(with: QuickSightClientTypes.DataPointDrillUpDownOption.read(from:))
        value.dataPointMenuLabelOption = try reader["DataPointMenuLabelOption"].readIfPresent(with: QuickSightClientTypes.DataPointMenuLabelOption.read(from:))
        value.dataPointTooltipOption = try reader["DataPointTooltipOption"].readIfPresent(with: QuickSightClientTypes.DataPointTooltipOption.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DataPointTooltipOption {

    static func write(value: QuickSightClientTypes.DataPointTooltipOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPointTooltipOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPointTooltipOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataPointMenuLabelOption {

    static func write(value: QuickSightClientTypes.DataPointMenuLabelOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPointMenuLabelOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPointMenuLabelOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataPointDrillUpDownOption {

    static func write(value: QuickSightClientTypes.DataPointDrillUpDownOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataPointDrillUpDownOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataPointDrillUpDownOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ExportWithHiddenFieldsOption {

    static func write(value: QuickSightClientTypes.ExportWithHiddenFieldsOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExportWithHiddenFieldsOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExportWithHiddenFieldsOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VisualAxisSortOption {

    static func write(value: QuickSightClientTypes.VisualAxisSortOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualAxisSortOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualAxisSortOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SheetLayoutElementMaximizationOption {

    static func write(value: QuickSightClientTypes.SheetLayoutElementMaximizationOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetLayoutElementMaximizationOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetLayoutElementMaximizationOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DashboardVisualPublishOptions {

    static func write(value: QuickSightClientTypes.DashboardVisualPublishOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExportHiddenFieldsOption"].write(value.exportHiddenFieldsOption, with: QuickSightClientTypes.ExportHiddenFieldsOption.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardVisualPublishOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardVisualPublishOptions()
        value.exportHiddenFieldsOption = try reader["ExportHiddenFieldsOption"].readIfPresent(with: QuickSightClientTypes.ExportHiddenFieldsOption.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ExportHiddenFieldsOption {

    static func write(value: QuickSightClientTypes.ExportHiddenFieldsOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExportHiddenFieldsOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExportHiddenFieldsOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SheetControlsOption {

    static func write(value: QuickSightClientTypes.SheetControlsOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VisibilityState"].write(value.visibilityState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetControlsOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetControlsOption()
        value.visibilityState = try reader["VisibilityState"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ExportToCSVOption {

    static func write(value: QuickSightClientTypes.ExportToCSVOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ExportToCSVOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ExportToCSVOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AdHocFilteringOption {

    static func write(value: QuickSightClientTypes.AdHocFilteringOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityStatus"].write(value.availabilityStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AdHocFilteringOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AdHocFilteringOption()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LinkSharingConfiguration {

    static func write(value: QuickSightClientTypes.LinkSharingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: QuickSightClientTypes.ResourcePermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LinkSharingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LinkSharingConfiguration()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ResourcePermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotUserConfigurationRedacted {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotUserConfigurationRedacted {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotUserConfigurationRedacted()
        value.anonymousUsers = try reader["AnonymousUsers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotAnonymousUserRedacted.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotAnonymousUserRedacted {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotAnonymousUserRedacted {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotAnonymousUserRedacted()
        value.rowLevelPermissionTagKeys = try reader["RowLevelPermissionTagKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotConfiguration {

    static func write(value: QuickSightClientTypes.SnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfiguration"].write(value.destinationConfiguration, with: QuickSightClientTypes.SnapshotDestinationConfiguration.write(value:to:))
        try writer["FileGroups"].writeList(value.fileGroups, memberWritingClosure: QuickSightClientTypes.SnapshotFileGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Parameters"].write(value.parameters, with: QuickSightClientTypes.Parameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotConfiguration()
        value.fileGroups = try reader["FileGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotFileGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.destinationConfiguration = try reader["DestinationConfiguration"].readIfPresent(with: QuickSightClientTypes.SnapshotDestinationConfiguration.read(from:))
        value.parameters = try reader["Parameters"].readIfPresent(with: QuickSightClientTypes.Parameters.read(from:))
        return value
    }
}

extension QuickSightClientTypes.Parameters {

    static func write(value: QuickSightClientTypes.Parameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeParameters"].writeList(value.dateTimeParameters, memberWritingClosure: QuickSightClientTypes.DateTimeParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DecimalParameters"].writeList(value.decimalParameters, memberWritingClosure: QuickSightClientTypes.DecimalParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IntegerParameters"].writeList(value.integerParameters, memberWritingClosure: QuickSightClientTypes.IntegerParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringParameters"].writeList(value.stringParameters, memberWritingClosure: QuickSightClientTypes.StringParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Parameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Parameters()
        value.stringParameters = try reader["StringParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.StringParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.integerParameters = try reader["IntegerParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.IntegerParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.decimalParameters = try reader["DecimalParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DecimalParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateTimeParameters = try reader["DateTimeParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DateTimeParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DateTimeParameter {

    static func write(value: QuickSightClientTypes.DateTimeParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.timestampWritingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.DecimalParameter {

    static func write(value: QuickSightClientTypes.DecimalParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.IntegerParameter {

    static func write(value: QuickSightClientTypes.IntegerParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.StringParameter {

    static func write(value: QuickSightClientTypes.StringParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.SnapshotDestinationConfiguration {

    static func write(value: QuickSightClientTypes.SnapshotDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Destinations"].writeList(value.s3Destinations, memberWritingClosure: QuickSightClientTypes.SnapshotS3DestinationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotDestinationConfiguration()
        value.s3Destinations = try reader["S3Destinations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotS3DestinationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotS3DestinationConfiguration {

    static func write(value: QuickSightClientTypes.SnapshotS3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketConfiguration"].write(value.bucketConfiguration, with: QuickSightClientTypes.S3BucketConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotS3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotS3DestinationConfiguration()
        value.bucketConfiguration = try reader["BucketConfiguration"].readIfPresent(with: QuickSightClientTypes.S3BucketConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.S3BucketConfiguration {

    static func write(value: QuickSightClientTypes.S3BucketConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["BucketPrefix"].write(value.bucketPrefix)
        try writer["BucketRegion"].write(value.bucketRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.S3BucketConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.S3BucketConfiguration()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.bucketPrefix = try reader["BucketPrefix"].readIfPresent() ?? ""
        value.bucketRegion = try reader["BucketRegion"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.SnapshotFileGroup {

    static func write(value: QuickSightClientTypes.SnapshotFileGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Files"].writeList(value.files, memberWritingClosure: QuickSightClientTypes.SnapshotFile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotFileGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotFileGroup()
        value.files = try reader["Files"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotFile {

    static func write(value: QuickSightClientTypes.SnapshotFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FormatType"].write(value.formatType)
        try writer["SheetSelections"].writeList(value.sheetSelections, memberWritingClosure: QuickSightClientTypes.SnapshotFileSheetSelection.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotFile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotFile()
        value.sheetSelections = try reader["SheetSelections"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotFileSheetSelection.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.formatType = try reader["FormatType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.SnapshotFileSheetSelection {

    static func write(value: QuickSightClientTypes.SnapshotFileSheetSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectionScope"].write(value.selectionScope)
        try writer["SheetId"].write(value.sheetId)
        try writer["VisualIds"].writeList(value.visualIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotFileSheetSelection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotFileSheetSelection()
        value.sheetId = try reader["SheetId"].readIfPresent() ?? ""
        value.selectionScope = try reader["SelectionScope"].readIfPresent() ?? .sdkUnknown("")
        value.visualIds = try reader["VisualIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotJobResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotJobResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotJobResult()
        value.anonymousUsers = try reader["AnonymousUsers"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AnonymousUserSnapshotJobResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.AnonymousUserSnapshotJobResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnonymousUserSnapshotJobResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnonymousUserSnapshotJobResult()
        value.fileGroups = try reader["FileGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotJobResultFileGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotJobResultFileGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotJobResultFileGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotJobResultFileGroup()
        value.files = try reader["Files"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotFile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.s3Results = try reader["S3Results"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotJobS3Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotJobS3Result {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotJobS3Result {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotJobS3Result()
        value.s3DestinationConfiguration = try reader["S3DestinationConfiguration"].readIfPresent(with: QuickSightClientTypes.SnapshotS3DestinationConfiguration.read(from:))
        value.s3Uri = try reader["S3Uri"].readIfPresent()
        value.errorInfo = try reader["ErrorInfo"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SnapshotJobResultErrorInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SnapshotJobResultErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotJobResultErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotJobResultErrorInfo()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SnapshotJobErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SnapshotJobErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SnapshotJobErrorInfo()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorType = try reader["ErrorType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataSet {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSet()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.physicalTableMap = try reader["PhysicalTableMap"].readMapIfPresent(valueReadingClosure: QuickSightClientTypes.PhysicalTable.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logicalTableMap = try reader["LogicalTableMap"].readMapIfPresent(valueReadingClosure: QuickSightClientTypes.LogicalTable.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputColumns = try reader["OutputColumns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.OutputColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.importMode = try reader["ImportMode"].readIfPresent()
        value.consumedSpiceCapacityInBytes = try reader["ConsumedSpiceCapacityInBytes"].readIfPresent() ?? 0
        value.columnGroups = try reader["ColumnGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fieldFolders = try reader["FieldFolders"].readMapIfPresent(valueReadingClosure: QuickSightClientTypes.FieldFolder.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.rowLevelPermissionDataSet = try reader["RowLevelPermissionDataSet"].readIfPresent(with: QuickSightClientTypes.RowLevelPermissionDataSet.read(from:))
        value.rowLevelPermissionTagConfiguration = try reader["RowLevelPermissionTagConfiguration"].readIfPresent(with: QuickSightClientTypes.RowLevelPermissionTagConfiguration.read(from:))
        value.columnLevelPermissionRules = try reader["ColumnLevelPermissionRules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnLevelPermissionRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataSetUsageConfiguration = try reader["DataSetUsageConfiguration"].readIfPresent(with: QuickSightClientTypes.DataSetUsageConfiguration.read(from:))
        value.datasetParameters = try reader["DatasetParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DatasetParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DatasetParameter {

    static func write(value: QuickSightClientTypes.DatasetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeDatasetParameter"].write(value.dateTimeDatasetParameter, with: QuickSightClientTypes.DateTimeDatasetParameter.write(value:to:))
        try writer["DecimalDatasetParameter"].write(value.decimalDatasetParameter, with: QuickSightClientTypes.DecimalDatasetParameter.write(value:to:))
        try writer["IntegerDatasetParameter"].write(value.integerDatasetParameter, with: QuickSightClientTypes.IntegerDatasetParameter.write(value:to:))
        try writer["StringDatasetParameter"].write(value.stringDatasetParameter, with: QuickSightClientTypes.StringDatasetParameter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DatasetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DatasetParameter()
        value.stringDatasetParameter = try reader["StringDatasetParameter"].readIfPresent(with: QuickSightClientTypes.StringDatasetParameter.read(from:))
        value.decimalDatasetParameter = try reader["DecimalDatasetParameter"].readIfPresent(with: QuickSightClientTypes.DecimalDatasetParameter.read(from:))
        value.integerDatasetParameter = try reader["IntegerDatasetParameter"].readIfPresent(with: QuickSightClientTypes.IntegerDatasetParameter.read(from:))
        value.dateTimeDatasetParameter = try reader["DateTimeDatasetParameter"].readIfPresent(with: QuickSightClientTypes.DateTimeDatasetParameter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateTimeDatasetParameter {

    static func write(value: QuickSightClientTypes.DateTimeDatasetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.DateTimeDatasetParameterDefaultValues.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["TimeGranularity"].write(value.timeGranularity)
        try writer["ValueType"].write(value.valueType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeDatasetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeDatasetParameter()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueType = try reader["ValueType"].readIfPresent() ?? .sdkUnknown("")
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.DateTimeDatasetParameterDefaultValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DateTimeDatasetParameterDefaultValues {

    static func write(value: QuickSightClientTypes.DateTimeDatasetParameterDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.timestampWritingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DateTimeDatasetParameterDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DateTimeDatasetParameterDefaultValues()
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.IntegerDatasetParameter {

    static func write(value: QuickSightClientTypes.IntegerDatasetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.IntegerDatasetParameterDefaultValues.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ValueType"].write(value.valueType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerDatasetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerDatasetParameter()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueType = try reader["ValueType"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.IntegerDatasetParameterDefaultValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.IntegerDatasetParameterDefaultValues {

    static func write(value: QuickSightClientTypes.IntegerDatasetParameterDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IntegerDatasetParameterDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IntegerDatasetParameterDefaultValues()
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DecimalDatasetParameter {

    static func write(value: QuickSightClientTypes.DecimalDatasetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.DecimalDatasetParameterDefaultValues.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ValueType"].write(value.valueType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalDatasetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalDatasetParameter()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueType = try reader["ValueType"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.DecimalDatasetParameterDefaultValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DecimalDatasetParameterDefaultValues {

    static func write(value: QuickSightClientTypes.DecimalDatasetParameterDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DecimalDatasetParameterDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DecimalDatasetParameterDefaultValues()
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.StringDatasetParameter {

    static func write(value: QuickSightClientTypes.StringDatasetParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValues"].write(value.defaultValues, with: QuickSightClientTypes.StringDatasetParameterDefaultValues.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ValueType"].write(value.valueType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringDatasetParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringDatasetParameter()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.valueType = try reader["ValueType"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValues = try reader["DefaultValues"].readIfPresent(with: QuickSightClientTypes.StringDatasetParameterDefaultValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.StringDatasetParameterDefaultValues {

    static func write(value: QuickSightClientTypes.StringDatasetParameterDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StaticValues"].writeList(value.staticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.StringDatasetParameterDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.StringDatasetParameterDefaultValues()
        value.staticValues = try reader["StaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DataSetUsageConfiguration {

    static func write(value: QuickSightClientTypes.DataSetUsageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisableUseAsDirectQuerySource"].write(value.disableUseAsDirectQuerySource)
        try writer["DisableUseAsImportedSource"].write(value.disableUseAsImportedSource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetUsageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetUsageConfiguration()
        value.disableUseAsDirectQuerySource = try reader["DisableUseAsDirectQuerySource"].readIfPresent() ?? false
        value.disableUseAsImportedSource = try reader["DisableUseAsImportedSource"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.ColumnLevelPermissionRule {

    static func write(value: QuickSightClientTypes.ColumnLevelPermissionRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Principals"].writeList(value.principals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnLevelPermissionRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnLevelPermissionRule()
        value.principals = try reader["Principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnNames = try reader["ColumnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagConfiguration {

    static func write(value: QuickSightClientTypes.RowLevelPermissionTagConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
        try writer["TagRuleConfigurations"].writeList(value.tagRuleConfigurations, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["TagRules"].writeList(value.tagRules, memberWritingClosure: QuickSightClientTypes.RowLevelPermissionTagRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RowLevelPermissionTagConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RowLevelPermissionTagConfiguration()
        value.status = try reader["Status"].readIfPresent()
        value.tagRules = try reader["TagRules"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.RowLevelPermissionTagRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tagRuleConfigurations = try reader["TagRuleConfigurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.RowLevelPermissionTagRule {

    static func write(value: QuickSightClientTypes.RowLevelPermissionTagRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["MatchAllValue"].write(value.matchAllValue)
        try writer["TagKey"].write(value.tagKey)
        try writer["TagMultiValueDelimiter"].write(value.tagMultiValueDelimiter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RowLevelPermissionTagRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RowLevelPermissionTagRule()
        value.tagKey = try reader["TagKey"].readIfPresent() ?? ""
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.tagMultiValueDelimiter = try reader["TagMultiValueDelimiter"].readIfPresent()
        value.matchAllValue = try reader["MatchAllValue"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RowLevelPermissionDataSet {

    static func write(value: QuickSightClientTypes.RowLevelPermissionDataSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["FormatVersion"].write(value.formatVersion)
        try writer["Namespace"].write(value.namespace)
        try writer["PermissionPolicy"].write(value.permissionPolicy)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RowLevelPermissionDataSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RowLevelPermissionDataSet()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.permissionPolicy = try reader["PermissionPolicy"].readIfPresent() ?? .sdkUnknown("")
        value.formatVersion = try reader["FormatVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FieldFolder {

    static func write(value: QuickSightClientTypes.FieldFolder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columns"].writeList(value.columns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FieldFolder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FieldFolder()
        value.description = try reader["description"].readIfPresent()
        value.columns = try reader["columns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnGroup {

    static func write(value: QuickSightClientTypes.ColumnGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeoSpatialColumnGroup"].write(value.geoSpatialColumnGroup, with: QuickSightClientTypes.GeoSpatialColumnGroup.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnGroup()
        value.geoSpatialColumnGroup = try reader["GeoSpatialColumnGroup"].readIfPresent(with: QuickSightClientTypes.GeoSpatialColumnGroup.read(from:))
        return value
    }
}

extension QuickSightClientTypes.GeoSpatialColumnGroup {

    static func write(value: QuickSightClientTypes.GeoSpatialColumnGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CountryCode"].write(value.countryCode)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GeoSpatialColumnGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GeoSpatialColumnGroup()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.OutputColumn {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.OutputColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.OutputColumn()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.subType = try reader["SubType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.LogicalTable {

    static func write(value: QuickSightClientTypes.LogicalTable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["DataTransforms"].writeList(value.dataTransforms, memberWritingClosure: QuickSightClientTypes.TransformOperation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source, with: QuickSightClientTypes.LogicalTableSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LogicalTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LogicalTable()
        value.alias = try reader["Alias"].readIfPresent() ?? ""
        value.dataTransforms = try reader["DataTransforms"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TransformOperation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["Source"].readIfPresent(with: QuickSightClientTypes.LogicalTableSource.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LogicalTableSource {

    static func write(value: QuickSightClientTypes.LogicalTableSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetArn"].write(value.dataSetArn)
        try writer["JoinInstruction"].write(value.joinInstruction, with: QuickSightClientTypes.JoinInstruction.write(value:to:))
        try writer["PhysicalTableId"].write(value.physicalTableId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LogicalTableSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LogicalTableSource()
        value.joinInstruction = try reader["JoinInstruction"].readIfPresent(with: QuickSightClientTypes.JoinInstruction.read(from:))
        value.physicalTableId = try reader["PhysicalTableId"].readIfPresent()
        value.dataSetArn = try reader["DataSetArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.JoinInstruction {

    static func write(value: QuickSightClientTypes.JoinInstruction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LeftJoinKeyProperties"].write(value.leftJoinKeyProperties, with: QuickSightClientTypes.JoinKeyProperties.write(value:to:))
        try writer["LeftOperand"].write(value.leftOperand)
        try writer["OnClause"].write(value.onClause)
        try writer["RightJoinKeyProperties"].write(value.rightJoinKeyProperties, with: QuickSightClientTypes.JoinKeyProperties.write(value:to:))
        try writer["RightOperand"].write(value.rightOperand)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.JoinInstruction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.JoinInstruction()
        value.leftOperand = try reader["LeftOperand"].readIfPresent() ?? ""
        value.rightOperand = try reader["RightOperand"].readIfPresent() ?? ""
        value.leftJoinKeyProperties = try reader["LeftJoinKeyProperties"].readIfPresent(with: QuickSightClientTypes.JoinKeyProperties.read(from:))
        value.rightJoinKeyProperties = try reader["RightJoinKeyProperties"].readIfPresent(with: QuickSightClientTypes.JoinKeyProperties.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.onClause = try reader["OnClause"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.JoinKeyProperties {

    static func write(value: QuickSightClientTypes.JoinKeyProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UniqueKey"].write(value.uniqueKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.JoinKeyProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.JoinKeyProperties()
        value.uniqueKey = try reader["UniqueKey"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TransformOperation {

    static func write(value: QuickSightClientTypes.TransformOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .castcolumntypeoperation(castcolumntypeoperation):
                try writer["CastColumnTypeOperation"].write(castcolumntypeoperation, with: QuickSightClientTypes.CastColumnTypeOperation.write(value:to:))
            case let .createcolumnsoperation(createcolumnsoperation):
                try writer["CreateColumnsOperation"].write(createcolumnsoperation, with: QuickSightClientTypes.CreateColumnsOperation.write(value:to:))
            case let .filteroperation(filteroperation):
                try writer["FilterOperation"].write(filteroperation, with: QuickSightClientTypes.FilterOperation.write(value:to:))
            case let .overridedatasetparameteroperation(overridedatasetparameteroperation):
                try writer["OverrideDatasetParameterOperation"].write(overridedatasetparameteroperation, with: QuickSightClientTypes.OverrideDatasetParameterOperation.write(value:to:))
            case let .projectoperation(projectoperation):
                try writer["ProjectOperation"].write(projectoperation, with: QuickSightClientTypes.ProjectOperation.write(value:to:))
            case let .renamecolumnoperation(renamecolumnoperation):
                try writer["RenameColumnOperation"].write(renamecolumnoperation, with: QuickSightClientTypes.RenameColumnOperation.write(value:to:))
            case let .tagcolumnoperation(tagcolumnoperation):
                try writer["TagColumnOperation"].write(tagcolumnoperation, with: QuickSightClientTypes.TagColumnOperation.write(value:to:))
            case let .untagcolumnoperation(untagcolumnoperation):
                try writer["UntagColumnOperation"].write(untagcolumnoperation, with: QuickSightClientTypes.UntagColumnOperation.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TransformOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ProjectOperation":
                return .projectoperation(try reader["ProjectOperation"].read(with: QuickSightClientTypes.ProjectOperation.read(from:)))
            case "FilterOperation":
                return .filteroperation(try reader["FilterOperation"].read(with: QuickSightClientTypes.FilterOperation.read(from:)))
            case "CreateColumnsOperation":
                return .createcolumnsoperation(try reader["CreateColumnsOperation"].read(with: QuickSightClientTypes.CreateColumnsOperation.read(from:)))
            case "RenameColumnOperation":
                return .renamecolumnoperation(try reader["RenameColumnOperation"].read(with: QuickSightClientTypes.RenameColumnOperation.read(from:)))
            case "CastColumnTypeOperation":
                return .castcolumntypeoperation(try reader["CastColumnTypeOperation"].read(with: QuickSightClientTypes.CastColumnTypeOperation.read(from:)))
            case "TagColumnOperation":
                return .tagcolumnoperation(try reader["TagColumnOperation"].read(with: QuickSightClientTypes.TagColumnOperation.read(from:)))
            case "UntagColumnOperation":
                return .untagcolumnoperation(try reader["UntagColumnOperation"].read(with: QuickSightClientTypes.UntagColumnOperation.read(from:)))
            case "OverrideDatasetParameterOperation":
                return .overridedatasetparameteroperation(try reader["OverrideDatasetParameterOperation"].read(with: QuickSightClientTypes.OverrideDatasetParameterOperation.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QuickSightClientTypes.OverrideDatasetParameterOperation {

    static func write(value: QuickSightClientTypes.OverrideDatasetParameterOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NewDefaultValues"].write(value.newDefaultValues, with: QuickSightClientTypes.NewDefaultValues.write(value:to:))
        try writer["NewParameterName"].write(value.newParameterName)
        try writer["ParameterName"].write(value.parameterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.OverrideDatasetParameterOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.OverrideDatasetParameterOperation()
        value.parameterName = try reader["ParameterName"].readIfPresent() ?? ""
        value.newParameterName = try reader["NewParameterName"].readIfPresent()
        value.newDefaultValues = try reader["NewDefaultValues"].readIfPresent(with: QuickSightClientTypes.NewDefaultValues.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NewDefaultValues {

    static func write(value: QuickSightClientTypes.NewDefaultValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateTimeStaticValues"].writeList(value.dateTimeStaticValues, memberWritingClosure: SmithyReadWrite.timestampWritingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        try writer["DecimalStaticValues"].writeList(value.decimalStaticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeDouble(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IntegerStaticValues"].writeList(value.integerStaticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StringStaticValues"].writeList(value.stringStaticValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NewDefaultValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NewDefaultValues()
        value.stringStaticValues = try reader["StringStaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.decimalStaticValues = try reader["DecimalStaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDouble(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateTimeStaticValues = try reader["DateTimeStaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.timestampReadingClosure(format: SmithyTimestamps.TimestampFormat.epochSeconds), memberNodeInfo: "member", isFlattened: false)
        value.integerStaticValues = try reader["IntegerStaticValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.UntagColumnOperation {

    static func write(value: QuickSightClientTypes.UntagColumnOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["TagNames"].writeList(value.tagNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.ColumnTagName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.UntagColumnOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.UntagColumnOperation()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.tagNames = try reader["TagNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.ColumnTagName>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.TagColumnOperation {

    static func write(value: QuickSightClientTypes.TagColumnOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: QuickSightClientTypes.ColumnTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TagColumnOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TagColumnOperation()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnTag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.ColumnTag {

    static func write(value: QuickSightClientTypes.ColumnTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnDescription"].write(value.columnDescription, with: QuickSightClientTypes.ColumnDescription.write(value:to:))
        try writer["ColumnGeographicRole"].write(value.columnGeographicRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnTag()
        value.columnGeographicRole = try reader["ColumnGeographicRole"].readIfPresent()
        value.columnDescription = try reader["ColumnDescription"].readIfPresent(with: QuickSightClientTypes.ColumnDescription.read(from:))
        return value
    }
}

extension QuickSightClientTypes.ColumnDescription {

    static func write(value: QuickSightClientTypes.ColumnDescription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnDescription()
        value.text = try reader["Text"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CastColumnTypeOperation {

    static func write(value: QuickSightClientTypes.CastColumnTypeOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["Format"].write(value.format)
        try writer["NewColumnType"].write(value.newColumnType)
        try writer["SubType"].write(value.subType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CastColumnTypeOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CastColumnTypeOperation()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.newColumnType = try reader["NewColumnType"].readIfPresent() ?? .sdkUnknown("")
        value.subType = try reader["SubType"].readIfPresent()
        value.format = try reader["Format"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RenameColumnOperation {

    static func write(value: QuickSightClientTypes.RenameColumnOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["NewColumnName"].write(value.newColumnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RenameColumnOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RenameColumnOperation()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.newColumnName = try reader["NewColumnName"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.CreateColumnsOperation {

    static func write(value: QuickSightClientTypes.CreateColumnsOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.CalculatedColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CreateColumnsOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CreateColumnsOperation()
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CalculatedColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.CalculatedColumn {

    static func write(value: QuickSightClientTypes.CalculatedColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnId"].write(value.columnId)
        try writer["ColumnName"].write(value.columnName)
        try writer["Expression"].write(value.expression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CalculatedColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CalculatedColumn()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.columnId = try reader["ColumnId"].readIfPresent() ?? ""
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.FilterOperation {

    static func write(value: QuickSightClientTypes.FilterOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConditionExpression"].write(value.conditionExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterOperation()
        value.conditionExpression = try reader["ConditionExpression"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.ProjectOperation {

    static func write(value: QuickSightClientTypes.ProjectOperation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProjectedColumns"].writeList(value.projectedColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ProjectOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ProjectOperation()
        value.projectedColumns = try reader["ProjectedColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.PhysicalTable {

    static func write(value: QuickSightClientTypes.PhysicalTable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customsql(customsql):
                try writer["CustomSql"].write(customsql, with: QuickSightClientTypes.CustomSql.write(value:to:))
            case let .relationaltable(relationaltable):
                try writer["RelationalTable"].write(relationaltable, with: QuickSightClientTypes.RelationalTable.write(value:to:))
            case let .s3source(s3source):
                try writer["S3Source"].write(s3source, with: QuickSightClientTypes.S3Source.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.PhysicalTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "RelationalTable":
                return .relationaltable(try reader["RelationalTable"].read(with: QuickSightClientTypes.RelationalTable.read(from:)))
            case "CustomSql":
                return .customsql(try reader["CustomSql"].read(with: QuickSightClientTypes.CustomSql.read(from:)))
            case "S3Source":
                return .s3source(try reader["S3Source"].read(with: QuickSightClientTypes.S3Source.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension QuickSightClientTypes.S3Source {

    static func write(value: QuickSightClientTypes.S3Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceArn"].write(value.dataSourceArn)
        try writer["InputColumns"].writeList(value.inputColumns, memberWritingClosure: QuickSightClientTypes.InputColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UploadSettings"].write(value.uploadSettings, with: QuickSightClientTypes.UploadSettings.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.S3Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.S3Source()
        value.dataSourceArn = try reader["DataSourceArn"].readIfPresent() ?? ""
        value.uploadSettings = try reader["UploadSettings"].readIfPresent(with: QuickSightClientTypes.UploadSettings.read(from:))
        value.inputColumns = try reader["InputColumns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.InputColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.InputColumn {

    static func write(value: QuickSightClientTypes.InputColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SubType"].write(value.subType)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.InputColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.InputColumn()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.subType = try reader["SubType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.UploadSettings {

    static func write(value: QuickSightClientTypes.UploadSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainsHeader"].write(value.containsHeader)
        try writer["Delimiter"].write(value.delimiter)
        try writer["Format"].write(value.format)
        try writer["StartFromRow"].write(value.startFromRow)
        try writer["TextQualifier"].write(value.textQualifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.UploadSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.UploadSettings()
        value.format = try reader["Format"].readIfPresent()
        value.startFromRow = try reader["StartFromRow"].readIfPresent()
        value.containsHeader = try reader["ContainsHeader"].readIfPresent()
        value.textQualifier = try reader["TextQualifier"].readIfPresent()
        value.delimiter = try reader["Delimiter"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CustomSql {

    static func write(value: QuickSightClientTypes.CustomSql?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.InputColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSourceArn"].write(value.dataSourceArn)
        try writer["Name"].write(value.name)
        try writer["SqlQuery"].write(value.sqlQuery)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CustomSql {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CustomSql()
        value.dataSourceArn = try reader["DataSourceArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.sqlQuery = try reader["SqlQuery"].readIfPresent() ?? ""
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.InputColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.RelationalTable {

    static func write(value: QuickSightClientTypes.RelationalTable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["DataSourceArn"].write(value.dataSourceArn)
        try writer["InputColumns"].writeList(value.inputColumns, memberWritingClosure: QuickSightClientTypes.InputColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RelationalTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RelationalTable()
        value.dataSourceArn = try reader["DataSourceArn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent()
        value.schema = try reader["Schema"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.inputColumns = try reader["InputColumns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.InputColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension QuickSightClientTypes.DataSetRefreshProperties {

    static func write(value: QuickSightClientTypes.DataSetRefreshProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RefreshConfiguration"].write(value.refreshConfiguration, with: QuickSightClientTypes.RefreshConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetRefreshProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetRefreshProperties()
        value.refreshConfiguration = try reader["RefreshConfiguration"].readIfPresent(with: QuickSightClientTypes.RefreshConfiguration.read(from:))
        return value
    }
}

extension QuickSightClientTypes.RefreshConfiguration {

    static func write(value: QuickSightClientTypes.RefreshConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncrementalRefresh"].write(value.incrementalRefresh, with: QuickSightClientTypes.IncrementalRefresh.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RefreshConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RefreshConfiguration()
        value.incrementalRefresh = try reader["IncrementalRefresh"].readIfPresent(with: QuickSightClientTypes.IncrementalRefresh.read(from:))
        return value
    }
}

extension QuickSightClientTypes.IncrementalRefresh {

    static func write(value: QuickSightClientTypes.IncrementalRefresh?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LookbackWindow"].write(value.lookbackWindow, with: QuickSightClientTypes.LookbackWindow.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IncrementalRefresh {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IncrementalRefresh()
        value.lookbackWindow = try reader["LookbackWindow"].readIfPresent(with: QuickSightClientTypes.LookbackWindow.read(from:))
        return value
    }
}

extension QuickSightClientTypes.LookbackWindow {

    static func write(value: QuickSightClientTypes.LookbackWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnName"].write(value.columnName)
        try writer["Size"].write(value.size)
        try writer["SizeUnit"].write(value.sizeUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.LookbackWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.LookbackWindow()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.size = try reader["Size"].readIfPresent() ?? 0
        value.sizeUnit = try reader["SizeUnit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension QuickSightClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSource()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSourceParameters = try reader["DataSourceParameters"].readIfPresent(with: QuickSightClientTypes.DataSourceParameters.read(from:))
        value.alternateDataSourceParameters = try reader["AlternateDataSourceParameters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSourceParameters.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcConnectionProperties = try reader["VpcConnectionProperties"].readIfPresent(with: QuickSightClientTypes.VpcConnectionProperties.read(from:))
        value.sslProperties = try reader["SslProperties"].readIfPresent(with: QuickSightClientTypes.SslProperties.read(from:))
        value.errorInfo = try reader["ErrorInfo"].readIfPresent(with: QuickSightClientTypes.DataSourceErrorInfo.read(from:))
        value.secretArn = try reader["SecretArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataSourceErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSourceErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSourceErrorInfo()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Folder {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Folder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Folder()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.folderType = try reader["FolderType"].readIfPresent()
        value.folderPath = try reader["FolderPath"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sharingModel = try reader["SharingModel"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.IAMPolicyAssignment {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IAMPolicyAssignment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IAMPolicyAssignment()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.assignmentId = try reader["AssignmentId"].readIfPresent()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.identities = try reader["Identities"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.assignmentStatus = try reader["AssignmentStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Ingestion {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Ingestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Ingestion()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.ingestionId = try reader["IngestionId"].readIfPresent()
        value.ingestionStatus = try reader["IngestionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorInfo = try reader["ErrorInfo"].readIfPresent(with: QuickSightClientTypes.ErrorInfo.read(from:))
        value.rowInfo = try reader["RowInfo"].readIfPresent(with: QuickSightClientTypes.RowInfo.read(from:))
        value.queueInfo = try reader["QueueInfo"].readIfPresent(with: QuickSightClientTypes.QueueInfo.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ingestionTimeInSeconds = try reader["IngestionTimeInSeconds"].readIfPresent()
        value.ingestionSizeInBytes = try reader["IngestionSizeInBytes"].readIfPresent()
        value.requestSource = try reader["RequestSource"].readIfPresent()
        value.requestType = try reader["RequestType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.QueueInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.QueueInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.QueueInfo()
        value.waitingOnIngestion = try reader["WaitingOnIngestion"].readIfPresent() ?? ""
        value.queuedIngestion = try reader["QueuedIngestion"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.RowInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RowInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RowInfo()
        value.rowsIngested = try reader["RowsIngested"].readIfPresent()
        value.rowsDropped = try reader["RowsDropped"].readIfPresent()
        value.totalRowsInDataset = try reader["TotalRowsInDataset"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ErrorInfo()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RegisteredCustomerManagedKey {

    static func write(value: QuickSightClientTypes.RegisteredCustomerManagedKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultKey"].write(value.defaultKey)
        try writer["KeyArn"].write(value.keyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RegisteredCustomerManagedKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RegisteredCustomerManagedKey()
        value.keyArn = try reader["KeyArn"].readIfPresent()
        value.defaultKey = try reader["DefaultKey"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.NamespaceInfoV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NamespaceInfoV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NamespaceInfoV2()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.capacityRegion = try reader["CapacityRegion"].readIfPresent()
        value.creationStatus = try reader["CreationStatus"].readIfPresent()
        value.identityStore = try reader["IdentityStore"].readIfPresent()
        value.namespaceError = try reader["NamespaceError"].readIfPresent(with: QuickSightClientTypes.NamespaceError.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NamespaceError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NamespaceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NamespaceError()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RefreshSchedule {

    static func write(value: QuickSightClientTypes.RefreshSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["RefreshType"].write(value.refreshType)
        try writer["ScheduleFrequency"].write(value.scheduleFrequency, with: QuickSightClientTypes.RefreshFrequency.write(value:to:))
        try writer["ScheduleId"].write(value.scheduleId)
        try writer["StartAfterDateTime"].writeTimestamp(value.startAfterDateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RefreshSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RefreshSchedule()
        value.scheduleId = try reader["ScheduleId"].readIfPresent() ?? ""
        value.scheduleFrequency = try reader["ScheduleFrequency"].readIfPresent(with: QuickSightClientTypes.RefreshFrequency.read(from:))
        value.startAfterDateTime = try reader["StartAfterDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.refreshType = try reader["RefreshType"].readIfPresent() ?? .sdkUnknown("")
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.RefreshFrequency {

    static func write(value: QuickSightClientTypes.RefreshFrequency?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Interval"].write(value.interval)
        try writer["RefreshOnDay"].write(value.refreshOnDay, with: QuickSightClientTypes.ScheduleRefreshOnEntity.write(value:to:))
        try writer["TimeOfTheDay"].write(value.timeOfTheDay)
        try writer["Timezone"].write(value.timezone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RefreshFrequency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RefreshFrequency()
        value.interval = try reader["Interval"].readIfPresent() ?? .sdkUnknown("")
        value.refreshOnDay = try reader["RefreshOnDay"].readIfPresent(with: QuickSightClientTypes.ScheduleRefreshOnEntity.read(from:))
        value.timezone = try reader["Timezone"].readIfPresent()
        value.timeOfTheDay = try reader["TimeOfTheDay"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ScheduleRefreshOnEntity {

    static func write(value: QuickSightClientTypes.ScheduleRefreshOnEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["DayOfWeek"].write(value.dayOfWeek)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ScheduleRefreshOnEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ScheduleRefreshOnEntity()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Template {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Template {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Template()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent(with: QuickSightClientTypes.TemplateVersion.read(from:))
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.TemplateVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateVersion()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TemplateError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.dataSetConfigurations = try reader["DataSetConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readIfPresent()
        value.sourceEntityArn = try reader["SourceEntityArn"].readIfPresent()
        value.themeArn = try reader["ThemeArn"].readIfPresent()
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Sheet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DataSetConfiguration {

    static func write(value: QuickSightClientTypes.DataSetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnGroupSchemaList"].writeList(value.columnGroupSchemaList, memberWritingClosure: QuickSightClientTypes.ColumnGroupSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetSchema"].write(value.dataSetSchema, with: QuickSightClientTypes.DataSetSchema.write(value:to:))
        try writer["Placeholder"].write(value.placeholder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetConfiguration()
        value.placeholder = try reader["Placeholder"].readIfPresent()
        value.dataSetSchema = try reader["DataSetSchema"].readIfPresent(with: QuickSightClientTypes.DataSetSchema.read(from:))
        value.columnGroupSchemaList = try reader["ColumnGroupSchemaList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnGroupSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnGroupSchema {

    static func write(value: QuickSightClientTypes.ColumnGroupSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnGroupColumnSchemaList"].writeList(value.columnGroupColumnSchemaList, memberWritingClosure: QuickSightClientTypes.ColumnGroupColumnSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnGroupSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnGroupSchema()
        value.name = try reader["Name"].readIfPresent()
        value.columnGroupColumnSchemaList = try reader["ColumnGroupColumnSchemaList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnGroupColumnSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnGroupColumnSchema {

    static func write(value: QuickSightClientTypes.ColumnGroupColumnSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnGroupColumnSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnGroupColumnSchema()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataSetSchema {

    static func write(value: QuickSightClientTypes.DataSetSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColumnSchemaList"].writeList(value.columnSchemaList, memberWritingClosure: QuickSightClientTypes.ColumnSchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetSchema()
        value.columnSchemaList = try reader["ColumnSchemaList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnSchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ColumnSchema {

    static func write(value: QuickSightClientTypes.ColumnSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataType"].write(value.dataType)
        try writer["GeographicRole"].write(value.geographicRole)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ColumnSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ColumnSchema()
        value.name = try reader["Name"].readIfPresent()
        value.dataType = try reader["DataType"].readIfPresent()
        value.geographicRole = try reader["GeographicRole"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TemplateError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateError()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.violatedEntities = try reader["ViolatedEntities"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Entity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TemplateVersionDefinition {

    static func write(value: QuickSightClientTypes.TemplateVersionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnalysisDefaults"].write(value.analysisDefaults, with: QuickSightClientTypes.AnalysisDefaults.write(value:to:))
        try writer["CalculatedFields"].writeList(value.calculatedFields, memberWritingClosure: QuickSightClientTypes.CalculatedField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnConfigurations"].writeList(value.columnConfigurations, memberWritingClosure: QuickSightClientTypes.ColumnConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataSetConfigurations"].writeList(value.dataSetConfigurations, memberWritingClosure: QuickSightClientTypes.DataSetConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterGroups"].writeList(value.filterGroups, memberWritingClosure: QuickSightClientTypes.FilterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Options"].write(value.options, with: QuickSightClientTypes.AssetOptions.write(value:to:))
        try writer["ParameterDeclarations"].writeList(value.parameterDeclarations, memberWritingClosure: QuickSightClientTypes.ParameterDeclaration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryExecutionOptions"].write(value.queryExecutionOptions, with: QuickSightClientTypes.QueryExecutionOptions.write(value:to:))
        try writer["Sheets"].writeList(value.sheets, memberWritingClosure: QuickSightClientTypes.SheetDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateVersionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateVersionDefinition()
        value.dataSetConfigurations = try reader["DataSetConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DataSetConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.sheets = try reader["Sheets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.SheetDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.calculatedFields = try reader["CalculatedFields"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CalculatedField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterDeclarations = try reader["ParameterDeclarations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ParameterDeclaration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filterGroups = try reader["FilterGroups"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnConfigurations = try reader["ColumnConfigurations"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ColumnConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analysisDefaults = try reader["AnalysisDefaults"].readIfPresent(with: QuickSightClientTypes.AnalysisDefaults.read(from:))
        value.options = try reader["Options"].readIfPresent(with: QuickSightClientTypes.AssetOptions.read(from:))
        value.queryExecutionOptions = try reader["QueryExecutionOptions"].readIfPresent(with: QuickSightClientTypes.QueryExecutionOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.Theme {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Theme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Theme()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.version = try reader["Version"].readIfPresent(with: QuickSightClientTypes.ThemeVersion.read(from:))
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ThemeVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeVersion()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.baseThemeId = try reader["BaseThemeId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configuration = try reader["Configuration"].readIfPresent(with: QuickSightClientTypes.ThemeConfiguration.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ThemeError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ThemeError {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeError()
        value.type = try reader["Type"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ThemeConfiguration {

    static func write(value: QuickSightClientTypes.ThemeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataColorPalette"].write(value.dataColorPalette, with: QuickSightClientTypes.DataColorPalette.write(value:to:))
        try writer["Sheet"].write(value.sheet, with: QuickSightClientTypes.SheetStyle.write(value:to:))
        try writer["Typography"].write(value.typography, with: QuickSightClientTypes.Typography.write(value:to:))
        try writer["UIColorPalette"].write(value.uiColorPalette, with: QuickSightClientTypes.UIColorPalette.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeConfiguration()
        value.dataColorPalette = try reader["DataColorPalette"].readIfPresent(with: QuickSightClientTypes.DataColorPalette.read(from:))
        value.uiColorPalette = try reader["UIColorPalette"].readIfPresent(with: QuickSightClientTypes.UIColorPalette.read(from:))
        value.sheet = try reader["Sheet"].readIfPresent(with: QuickSightClientTypes.SheetStyle.read(from:))
        value.typography = try reader["Typography"].readIfPresent(with: QuickSightClientTypes.Typography.read(from:))
        return value
    }
}

extension QuickSightClientTypes.Typography {

    static func write(value: QuickSightClientTypes.Typography?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FontFamilies"].writeList(value.fontFamilies, memberWritingClosure: QuickSightClientTypes.Font.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Typography {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Typography()
        value.fontFamilies = try reader["FontFamilies"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Font.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.Font {

    static func write(value: QuickSightClientTypes.Font?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FontFamily"].write(value.fontFamily)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Font {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Font()
        value.fontFamily = try reader["FontFamily"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.SheetStyle {

    static func write(value: QuickSightClientTypes.SheetStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tile"].write(value.tile, with: QuickSightClientTypes.TileStyle.write(value:to:))
        try writer["TileLayout"].write(value.tileLayout, with: QuickSightClientTypes.TileLayoutStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SheetStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SheetStyle()
        value.tile = try reader["Tile"].readIfPresent(with: QuickSightClientTypes.TileStyle.read(from:))
        value.tileLayout = try reader["TileLayout"].readIfPresent(with: QuickSightClientTypes.TileLayoutStyle.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TileLayoutStyle {

    static func write(value: QuickSightClientTypes.TileLayoutStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gutter"].write(value.gutter, with: QuickSightClientTypes.GutterStyle.write(value:to:))
        try writer["Margin"].write(value.margin, with: QuickSightClientTypes.MarginStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TileLayoutStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TileLayoutStyle()
        value.gutter = try reader["Gutter"].readIfPresent(with: QuickSightClientTypes.GutterStyle.read(from:))
        value.margin = try reader["Margin"].readIfPresent(with: QuickSightClientTypes.MarginStyle.read(from:))
        return value
    }
}

extension QuickSightClientTypes.MarginStyle {

    static func write(value: QuickSightClientTypes.MarginStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Show"].write(value.show)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MarginStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MarginStyle()
        value.show = try reader["Show"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.GutterStyle {

    static func write(value: QuickSightClientTypes.GutterStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Show"].write(value.show)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.GutterStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.GutterStyle()
        value.show = try reader["Show"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TileStyle {

    static func write(value: QuickSightClientTypes.TileStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Border"].write(value.border, with: QuickSightClientTypes.BorderStyle.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TileStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TileStyle()
        value.border = try reader["Border"].readIfPresent(with: QuickSightClientTypes.BorderStyle.read(from:))
        return value
    }
}

extension QuickSightClientTypes.BorderStyle {

    static func write(value: QuickSightClientTypes.BorderStyle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Show"].write(value.show)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.BorderStyle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.BorderStyle()
        value.show = try reader["Show"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.UIColorPalette {

    static func write(value: QuickSightClientTypes.UIColorPalette?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accent"].write(value.accent)
        try writer["AccentForeground"].write(value.accentForeground)
        try writer["Danger"].write(value.danger)
        try writer["DangerForeground"].write(value.dangerForeground)
        try writer["Dimension"].write(value.dimension)
        try writer["DimensionForeground"].write(value.dimensionForeground)
        try writer["Measure"].write(value.measure)
        try writer["MeasureForeground"].write(value.measureForeground)
        try writer["PrimaryBackground"].write(value.primaryBackground)
        try writer["PrimaryForeground"].write(value.primaryForeground)
        try writer["SecondaryBackground"].write(value.secondaryBackground)
        try writer["SecondaryForeground"].write(value.secondaryForeground)
        try writer["Success"].write(value.success)
        try writer["SuccessForeground"].write(value.successForeground)
        try writer["Warning"].write(value.warning)
        try writer["WarningForeground"].write(value.warningForeground)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.UIColorPalette {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.UIColorPalette()
        value.primaryForeground = try reader["PrimaryForeground"].readIfPresent()
        value.primaryBackground = try reader["PrimaryBackground"].readIfPresent()
        value.secondaryForeground = try reader["SecondaryForeground"].readIfPresent()
        value.secondaryBackground = try reader["SecondaryBackground"].readIfPresent()
        value.accent = try reader["Accent"].readIfPresent()
        value.accentForeground = try reader["AccentForeground"].readIfPresent()
        value.danger = try reader["Danger"].readIfPresent()
        value.dangerForeground = try reader["DangerForeground"].readIfPresent()
        value.warning = try reader["Warning"].readIfPresent()
        value.warningForeground = try reader["WarningForeground"].readIfPresent()
        value.success = try reader["Success"].readIfPresent()
        value.successForeground = try reader["SuccessForeground"].readIfPresent()
        value.dimension = try reader["Dimension"].readIfPresent()
        value.dimensionForeground = try reader["DimensionForeground"].readIfPresent()
        value.measure = try reader["Measure"].readIfPresent()
        value.measureForeground = try reader["MeasureForeground"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataColorPalette {

    static func write(value: QuickSightClientTypes.DataColorPalette?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Colors"].writeList(value.colors, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EmptyFillColor"].write(value.emptyFillColor)
        try writer["MinMaxGradient"].writeList(value.minMaxGradient, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataColorPalette {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataColorPalette()
        value.colors = try reader["Colors"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minMaxGradient = try reader["MinMaxGradient"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.emptyFillColor = try reader["EmptyFillColor"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicDetails {

    static func write(value: QuickSightClientTypes.TopicDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigOptions"].write(value.configOptions, with: QuickSightClientTypes.TopicConfigOptions.write(value:to:))
        try writer["DataSets"].writeList(value.dataSets, memberWritingClosure: QuickSightClientTypes.DatasetMetadata.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["UserExperienceVersion"].write(value.userExperienceVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicDetails()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.userExperienceVersion = try reader["UserExperienceVersion"].readIfPresent()
        value.dataSets = try reader["DataSets"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.DatasetMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configOptions = try reader["ConfigOptions"].readIfPresent(with: QuickSightClientTypes.TopicConfigOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicConfigOptions {

    static func write(value: QuickSightClientTypes.TopicConfigOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["QBusinessInsightsEnabled"].write(value.qBusinessInsightsEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicConfigOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicConfigOptions()
        value.qBusinessInsightsEnabled = try reader["QBusinessInsightsEnabled"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DatasetMetadata {

    static func write(value: QuickSightClientTypes.DatasetMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculatedFields"].writeList(value.calculatedFields, memberWritingClosure: QuickSightClientTypes.TopicCalculatedField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Columns"].writeList(value.columns, memberWritingClosure: QuickSightClientTypes.TopicColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DataAggregation"].write(value.dataAggregation, with: QuickSightClientTypes.DataAggregation.write(value:to:))
        try writer["DatasetArn"].write(value.datasetArn)
        try writer["DatasetDescription"].write(value.datasetDescription)
        try writer["DatasetName"].write(value.datasetName)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: QuickSightClientTypes.TopicFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NamedEntities"].writeList(value.namedEntities, memberWritingClosure: QuickSightClientTypes.TopicNamedEntity.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DatasetMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DatasetMetadata()
        value.datasetArn = try reader["DatasetArn"].readIfPresent() ?? ""
        value.datasetName = try reader["DatasetName"].readIfPresent()
        value.datasetDescription = try reader["DatasetDescription"].readIfPresent()
        value.dataAggregation = try reader["DataAggregation"].readIfPresent(with: QuickSightClientTypes.DataAggregation.read(from:))
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.columns = try reader["Columns"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicColumn.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.calculatedFields = try reader["CalculatedFields"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicCalculatedField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.namedEntities = try reader["NamedEntities"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicNamedEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TopicNamedEntity {

    static func write(value: QuickSightClientTypes.TopicNamedEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].writeList(value.definition, memberWritingClosure: QuickSightClientTypes.NamedEntityDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EntityDescription"].write(value.entityDescription)
        try writer["EntityName"].write(value.entityName)
        try writer["EntitySynonyms"].writeList(value.entitySynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SemanticEntityType"].write(value.semanticEntityType, with: QuickSightClientTypes.SemanticEntityType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicNamedEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicNamedEntity()
        value.entityName = try reader["EntityName"].readIfPresent() ?? ""
        value.entityDescription = try reader["EntityDescription"].readIfPresent()
        value.entitySynonyms = try reader["EntitySynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.semanticEntityType = try reader["SemanticEntityType"].readIfPresent(with: QuickSightClientTypes.SemanticEntityType.read(from:))
        value.definition = try reader["Definition"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.NamedEntityDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.NamedEntityDefinition {

    static func write(value: QuickSightClientTypes.NamedEntityDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["Metric"].write(value.metric, with: QuickSightClientTypes.NamedEntityDefinitionMetric.write(value:to:))
        try writer["PropertyName"].write(value.propertyName)
        try writer["PropertyRole"].write(value.propertyRole)
        try writer["PropertyUsage"].write(value.propertyUsage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NamedEntityDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NamedEntityDefinition()
        value.fieldName = try reader["FieldName"].readIfPresent()
        value.propertyName = try reader["PropertyName"].readIfPresent()
        value.propertyRole = try reader["PropertyRole"].readIfPresent()
        value.propertyUsage = try reader["PropertyUsage"].readIfPresent()
        value.metric = try reader["Metric"].readIfPresent(with: QuickSightClientTypes.NamedEntityDefinitionMetric.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NamedEntityDefinitionMetric {

    static func write(value: QuickSightClientTypes.NamedEntityDefinitionMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["AggregationFunctionParameters"].writeMap(value.aggregationFunctionParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NamedEntityDefinitionMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NamedEntityDefinitionMetric()
        value.aggregation = try reader["Aggregation"].readIfPresent()
        value.aggregationFunctionParameters = try reader["AggregationFunctionParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SemanticEntityType {

    static func write(value: QuickSightClientTypes.SemanticEntityType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubTypeName"].write(value.subTypeName)
        try writer["TypeName"].write(value.typeName)
        try writer["TypeParameters"].writeMap(value.typeParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SemanticEntityType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SemanticEntityType()
        value.typeName = try reader["TypeName"].readIfPresent()
        value.subTypeName = try reader["SubTypeName"].readIfPresent()
        value.typeParameters = try reader["TypeParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TopicCalculatedField {

    static func write(value: QuickSightClientTypes.TopicCalculatedField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["AllowedAggregations"].writeList(value.allowedAggregations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CalculatedFieldDescription"].write(value.calculatedFieldDescription)
        try writer["CalculatedFieldName"].write(value.calculatedFieldName)
        try writer["CalculatedFieldSynonyms"].writeList(value.calculatedFieldSynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CellValueSynonyms"].writeList(value.cellValueSynonyms, memberWritingClosure: QuickSightClientTypes.CellValueSynonym.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnDataRole"].write(value.columnDataRole)
        try writer["ComparativeOrder"].write(value.comparativeOrder, with: QuickSightClientTypes.ComparativeOrder.write(value:to:))
        try writer["DefaultFormatting"].write(value.defaultFormatting, with: QuickSightClientTypes.DefaultFormatting.write(value:to:))
        try writer["DisableIndexing"].write(value.disableIndexing)
        try writer["Expression"].write(value.expression)
        try writer["IsIncludedInTopic"].write(value.isIncludedInTopic)
        try writer["NeverAggregateInFilter"].write(value.neverAggregateInFilter)
        try writer["NonAdditive"].write(value.nonAdditive)
        try writer["NotAllowedAggregations"].writeList(value.notAllowedAggregations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SemanticType"].write(value.semanticType, with: QuickSightClientTypes.SemanticType.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicCalculatedField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicCalculatedField()
        value.calculatedFieldName = try reader["CalculatedFieldName"].readIfPresent() ?? ""
        value.calculatedFieldDescription = try reader["CalculatedFieldDescription"].readIfPresent()
        value.expression = try reader["Expression"].readIfPresent() ?? ""
        value.calculatedFieldSynonyms = try reader["CalculatedFieldSynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.isIncludedInTopic = try reader["IsIncludedInTopic"].readIfPresent() ?? false
        value.disableIndexing = try reader["DisableIndexing"].readIfPresent()
        value.columnDataRole = try reader["ColumnDataRole"].readIfPresent()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.defaultFormatting = try reader["DefaultFormatting"].readIfPresent(with: QuickSightClientTypes.DefaultFormatting.read(from:))
        value.aggregation = try reader["Aggregation"].readIfPresent()
        value.comparativeOrder = try reader["ComparativeOrder"].readIfPresent(with: QuickSightClientTypes.ComparativeOrder.read(from:))
        value.semanticType = try reader["SemanticType"].readIfPresent(with: QuickSightClientTypes.SemanticType.read(from:))
        value.allowedAggregations = try reader["AllowedAggregations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notAllowedAggregations = try reader["NotAllowedAggregations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.neverAggregateInFilter = try reader["NeverAggregateInFilter"].readIfPresent() ?? false
        value.cellValueSynonyms = try reader["CellValueSynonyms"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CellValueSynonym.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nonAdditive = try reader["NonAdditive"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.CellValueSynonym {

    static func write(value: QuickSightClientTypes.CellValueSynonym?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellValue"].write(value.cellValue)
        try writer["Synonyms"].writeList(value.synonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CellValueSynonym {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CellValueSynonym()
        value.cellValue = try reader["CellValue"].readIfPresent()
        value.synonyms = try reader["Synonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.SemanticType {

    static func write(value: QuickSightClientTypes.SemanticType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FalseyCellValue"].write(value.falseyCellValue)
        try writer["FalseyCellValueSynonyms"].writeList(value.falseyCellValueSynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubTypeName"].write(value.subTypeName)
        try writer["TruthyCellValue"].write(value.truthyCellValue)
        try writer["TruthyCellValueSynonyms"].writeList(value.truthyCellValueSynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TypeName"].write(value.typeName)
        try writer["TypeParameters"].writeMap(value.typeParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SemanticType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SemanticType()
        value.typeName = try reader["TypeName"].readIfPresent()
        value.subTypeName = try reader["SubTypeName"].readIfPresent()
        value.typeParameters = try reader["TypeParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.truthyCellValue = try reader["TruthyCellValue"].readIfPresent()
        value.truthyCellValueSynonyms = try reader["TruthyCellValueSynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.falseyCellValue = try reader["FalseyCellValue"].readIfPresent()
        value.falseyCellValueSynonyms = try reader["FalseyCellValueSynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.ComparativeOrder {

    static func write(value: QuickSightClientTypes.ComparativeOrder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SpecifedOrder"].writeList(value.specifedOrder, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TreatUndefinedSpecifiedValues"].write(value.treatUndefinedSpecifiedValues)
        try writer["UseOrdering"].write(value.useOrdering)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ComparativeOrder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ComparativeOrder()
        value.useOrdering = try reader["UseOrdering"].readIfPresent()
        value.specifedOrder = try reader["SpecifedOrder"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.treatUndefinedSpecifiedValues = try reader["TreatUndefinedSpecifiedValues"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DefaultFormatting {

    static func write(value: QuickSightClientTypes.DefaultFormatting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayFormat"].write(value.displayFormat)
        try writer["DisplayFormatOptions"].write(value.displayFormatOptions, with: QuickSightClientTypes.DisplayFormatOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DefaultFormatting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DefaultFormatting()
        value.displayFormat = try reader["DisplayFormat"].readIfPresent()
        value.displayFormatOptions = try reader["DisplayFormatOptions"].readIfPresent(with: QuickSightClientTypes.DisplayFormatOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.DisplayFormatOptions {

    static func write(value: QuickSightClientTypes.DisplayFormatOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlankCellFormat"].write(value.blankCellFormat)
        try writer["CurrencySymbol"].write(value.currencySymbol)
        try writer["DateFormat"].write(value.dateFormat)
        try writer["DecimalSeparator"].write(value.decimalSeparator)
        try writer["FractionDigits"].write(value.fractionDigits)
        try writer["GroupingSeparator"].write(value.groupingSeparator)
        try writer["NegativeFormat"].write(value.negativeFormat, with: QuickSightClientTypes.NegativeFormat.write(value:to:))
        try writer["Prefix"].write(value.`prefix`)
        try writer["Suffix"].write(value.suffix)
        try writer["UnitScaler"].write(value.unitScaler)
        try writer["UseBlankCellFormat"].write(value.useBlankCellFormat)
        try writer["UseGrouping"].write(value.useGrouping)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DisplayFormatOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DisplayFormatOptions()
        value.useBlankCellFormat = try reader["UseBlankCellFormat"].readIfPresent() ?? false
        value.blankCellFormat = try reader["BlankCellFormat"].readIfPresent()
        value.dateFormat = try reader["DateFormat"].readIfPresent()
        value.decimalSeparator = try reader["DecimalSeparator"].readIfPresent()
        value.groupingSeparator = try reader["GroupingSeparator"].readIfPresent()
        value.useGrouping = try reader["UseGrouping"].readIfPresent() ?? false
        value.fractionDigits = try reader["FractionDigits"].readIfPresent() ?? 0
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        value.unitScaler = try reader["UnitScaler"].readIfPresent()
        value.negativeFormat = try reader["NegativeFormat"].readIfPresent(with: QuickSightClientTypes.NegativeFormat.read(from:))
        value.currencySymbol = try reader["CurrencySymbol"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.NegativeFormat {

    static func write(value: QuickSightClientTypes.NegativeFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Prefix"].write(value.`prefix`)
        try writer["Suffix"].write(value.suffix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NegativeFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NegativeFormat()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.suffix = try reader["Suffix"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicColumn {

    static func write(value: QuickSightClientTypes.TopicColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["AllowedAggregations"].writeList(value.allowedAggregations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CellValueSynonyms"].writeList(value.cellValueSynonyms, memberWritingClosure: QuickSightClientTypes.CellValueSynonym.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ColumnDataRole"].write(value.columnDataRole)
        try writer["ColumnDescription"].write(value.columnDescription)
        try writer["ColumnFriendlyName"].write(value.columnFriendlyName)
        try writer["ColumnName"].write(value.columnName)
        try writer["ColumnSynonyms"].writeList(value.columnSynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComparativeOrder"].write(value.comparativeOrder, with: QuickSightClientTypes.ComparativeOrder.write(value:to:))
        try writer["DefaultFormatting"].write(value.defaultFormatting, with: QuickSightClientTypes.DefaultFormatting.write(value:to:))
        try writer["DisableIndexing"].write(value.disableIndexing)
        try writer["IsIncludedInTopic"].write(value.isIncludedInTopic)
        try writer["NeverAggregateInFilter"].write(value.neverAggregateInFilter)
        try writer["NonAdditive"].write(value.nonAdditive)
        try writer["NotAllowedAggregations"].writeList(value.notAllowedAggregations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SemanticType"].write(value.semanticType, with: QuickSightClientTypes.SemanticType.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicColumn()
        value.columnName = try reader["ColumnName"].readIfPresent() ?? ""
        value.columnFriendlyName = try reader["ColumnFriendlyName"].readIfPresent()
        value.columnDescription = try reader["ColumnDescription"].readIfPresent()
        value.columnSynonyms = try reader["ColumnSynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.columnDataRole = try reader["ColumnDataRole"].readIfPresent()
        value.aggregation = try reader["Aggregation"].readIfPresent()
        value.isIncludedInTopic = try reader["IsIncludedInTopic"].readIfPresent() ?? false
        value.disableIndexing = try reader["DisableIndexing"].readIfPresent()
        value.comparativeOrder = try reader["ComparativeOrder"].readIfPresent(with: QuickSightClientTypes.ComparativeOrder.read(from:))
        value.semanticType = try reader["SemanticType"].readIfPresent(with: QuickSightClientTypes.SemanticType.read(from:))
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.allowedAggregations = try reader["AllowedAggregations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notAllowedAggregations = try reader["NotAllowedAggregations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<QuickSightClientTypes.AuthorSpecifiedAggregation>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultFormatting = try reader["DefaultFormatting"].readIfPresent(with: QuickSightClientTypes.DefaultFormatting.read(from:))
        value.neverAggregateInFilter = try reader["NeverAggregateInFilter"].readIfPresent() ?? false
        value.cellValueSynonyms = try reader["CellValueSynonyms"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CellValueSynonym.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nonAdditive = try reader["NonAdditive"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicFilter {

    static func write(value: QuickSightClientTypes.TopicFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryFilter"].write(value.categoryFilter, with: QuickSightClientTypes.TopicCategoryFilter.write(value:to:))
        try writer["DateRangeFilter"].write(value.dateRangeFilter, with: QuickSightClientTypes.TopicDateRangeFilter.write(value:to:))
        try writer["FilterClass"].write(value.filterClass)
        try writer["FilterDescription"].write(value.filterDescription)
        try writer["FilterName"].write(value.filterName)
        try writer["FilterSynonyms"].writeList(value.filterSynonyms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilterType"].write(value.filterType)
        try writer["NumericEqualityFilter"].write(value.numericEqualityFilter, with: QuickSightClientTypes.TopicNumericEqualityFilter.write(value:to:))
        try writer["NumericRangeFilter"].write(value.numericRangeFilter, with: QuickSightClientTypes.TopicNumericRangeFilter.write(value:to:))
        try writer["OperandFieldName"].write(value.operandFieldName)
        try writer["RelativeDateFilter"].write(value.relativeDateFilter, with: QuickSightClientTypes.TopicRelativeDateFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicFilter()
        value.filterDescription = try reader["FilterDescription"].readIfPresent()
        value.filterClass = try reader["FilterClass"].readIfPresent()
        value.filterName = try reader["FilterName"].readIfPresent() ?? ""
        value.filterSynonyms = try reader["FilterSynonyms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.operandFieldName = try reader["OperandFieldName"].readIfPresent() ?? ""
        value.filterType = try reader["FilterType"].readIfPresent()
        value.categoryFilter = try reader["CategoryFilter"].readIfPresent(with: QuickSightClientTypes.TopicCategoryFilter.read(from:))
        value.numericEqualityFilter = try reader["NumericEqualityFilter"].readIfPresent(with: QuickSightClientTypes.TopicNumericEqualityFilter.read(from:))
        value.numericRangeFilter = try reader["NumericRangeFilter"].readIfPresent(with: QuickSightClientTypes.TopicNumericRangeFilter.read(from:))
        value.dateRangeFilter = try reader["DateRangeFilter"].readIfPresent(with: QuickSightClientTypes.TopicDateRangeFilter.read(from:))
        value.relativeDateFilter = try reader["RelativeDateFilter"].readIfPresent(with: QuickSightClientTypes.TopicRelativeDateFilter.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicRelativeDateFilter {

    static func write(value: QuickSightClientTypes.TopicRelativeDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicSingularFilterConstant.write(value:to:))
        try writer["RelativeDateFilterFunction"].write(value.relativeDateFilterFunction)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicRelativeDateFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicRelativeDateFilter()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.relativeDateFilterFunction = try reader["RelativeDateFilterFunction"].readIfPresent()
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicSingularFilterConstant.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicSingularFilterConstant {

    static func write(value: QuickSightClientTypes.TopicSingularFilterConstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConstantType"].write(value.constantType)
        try writer["SingularConstant"].write(value.singularConstant)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicSingularFilterConstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicSingularFilterConstant()
        value.constantType = try reader["ConstantType"].readIfPresent()
        value.singularConstant = try reader["SingularConstant"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicDateRangeFilter {

    static func write(value: QuickSightClientTypes.TopicDateRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicRangeFilterConstant.write(value:to:))
        try writer["Inclusive"].write(value.inclusive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicDateRangeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicDateRangeFilter()
        value.inclusive = try reader["Inclusive"].readIfPresent() ?? false
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicRangeFilterConstant.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicRangeFilterConstant {

    static func write(value: QuickSightClientTypes.TopicRangeFilterConstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConstantType"].write(value.constantType)
        try writer["RangeConstant"].write(value.rangeConstant, with: QuickSightClientTypes.RangeConstant.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicRangeFilterConstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicRangeFilterConstant()
        value.constantType = try reader["ConstantType"].readIfPresent()
        value.rangeConstant = try reader["RangeConstant"].readIfPresent(with: QuickSightClientTypes.RangeConstant.read(from:))
        return value
    }
}

extension QuickSightClientTypes.RangeConstant {

    static func write(value: QuickSightClientTypes.RangeConstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Maximum"].write(value.maximum)
        try writer["Minimum"].write(value.minimum)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.RangeConstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.RangeConstant()
        value.minimum = try reader["Minimum"].readIfPresent()
        value.maximum = try reader["Maximum"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicNumericRangeFilter {

    static func write(value: QuickSightClientTypes.TopicNumericRangeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicRangeFilterConstant.write(value:to:))
        try writer["Inclusive"].write(value.inclusive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicNumericRangeFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicNumericRangeFilter()
        value.inclusive = try reader["Inclusive"].readIfPresent() ?? false
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicRangeFilterConstant.read(from:))
        value.aggregation = try reader["Aggregation"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicNumericEqualityFilter {

    static func write(value: QuickSightClientTypes.TopicNumericEqualityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicSingularFilterConstant.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicNumericEqualityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicNumericEqualityFilter()
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicSingularFilterConstant.read(from:))
        value.aggregation = try reader["Aggregation"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicCategoryFilter {

    static func write(value: QuickSightClientTypes.TopicCategoryFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CategoryFilterFunction"].write(value.categoryFilterFunction)
        try writer["CategoryFilterType"].write(value.categoryFilterType)
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicCategoryFilterConstant.write(value:to:))
        try writer["Inverse"].write(value.inverse)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicCategoryFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicCategoryFilter()
        value.categoryFilterFunction = try reader["CategoryFilterFunction"].readIfPresent()
        value.categoryFilterType = try reader["CategoryFilterType"].readIfPresent()
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicCategoryFilterConstant.read(from:))
        value.inverse = try reader["Inverse"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.TopicCategoryFilterConstant {

    static func write(value: QuickSightClientTypes.TopicCategoryFilterConstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CollectiveConstant"].write(value.collectiveConstant, with: QuickSightClientTypes.CollectiveConstant.write(value:to:))
        try writer["ConstantType"].write(value.constantType)
        try writer["SingularConstant"].write(value.singularConstant)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicCategoryFilterConstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicCategoryFilterConstant()
        value.constantType = try reader["ConstantType"].readIfPresent()
        value.singularConstant = try reader["SingularConstant"].readIfPresent()
        value.collectiveConstant = try reader["CollectiveConstant"].readIfPresent(with: QuickSightClientTypes.CollectiveConstant.read(from:))
        return value
    }
}

extension QuickSightClientTypes.CollectiveConstant {

    static func write(value: QuickSightClientTypes.CollectiveConstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CollectiveConstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CollectiveConstant()
        value.valueList = try reader["ValueList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.DataAggregation {

    static func write(value: QuickSightClientTypes.DataAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DatasetRowDateGranularity"].write(value.datasetRowDateGranularity)
        try writer["DefaultDateColumnName"].write(value.defaultDateColumnName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataAggregation()
        value.datasetRowDateGranularity = try reader["DatasetRowDateGranularity"].readIfPresent()
        value.defaultDateColumnName = try reader["DefaultDateColumnName"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicRefreshDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicRefreshDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicRefreshDetails()
        value.refreshArn = try reader["RefreshArn"].readIfPresent()
        value.refreshId = try reader["RefreshId"].readIfPresent()
        value.refreshStatus = try reader["RefreshStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicRefreshSchedule {

    static func write(value: QuickSightClientTypes.TopicRefreshSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BasedOnSpiceSchedule"].write(value.basedOnSpiceSchedule)
        try writer["IsEnabled"].write(value.isEnabled)
        try writer["RepeatAt"].write(value.repeatAt)
        try writer["StartingAt"].writeTimestamp(value.startingAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Timezone"].write(value.timezone)
        try writer["TopicScheduleType"].write(value.topicScheduleType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicRefreshSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicRefreshSchedule()
        value.isEnabled = try reader["IsEnabled"].readIfPresent() ?? false
        value.basedOnSpiceSchedule = try reader["BasedOnSpiceSchedule"].readIfPresent() ?? false
        value.startingAt = try reader["StartingAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timezone = try reader["Timezone"].readIfPresent()
        value.repeatAt = try reader["RepeatAt"].readIfPresent()
        value.topicScheduleType = try reader["TopicScheduleType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.User()
        value.arn = try reader["Arn"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.identityType = try reader["IdentityType"].readIfPresent()
        value.active = try reader["Active"].readIfPresent() ?? false
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.customPermissionsName = try reader["CustomPermissionsName"].readIfPresent()
        value.externalLoginFederationProviderType = try reader["ExternalLoginFederationProviderType"].readIfPresent()
        value.externalLoginFederationProviderUrl = try reader["ExternalLoginFederationProviderUrl"].readIfPresent()
        value.externalLoginId = try reader["ExternalLoginId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VPCConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VPCConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VPCConnection()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.vpcId = try reader["VPCId"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsResolvers = try reader["DnsResolvers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        value.networkInterfaces = try reader["NetworkInterfaces"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NetworkInterface()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AnalysisSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AnalysisSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AnalysisSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.analysisId = try reader["AnalysisId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.AssetBundleExportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleExportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleExportJobSummary()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assetBundleExportJobId = try reader["AssetBundleExportJobId"].readIfPresent()
        value.includeAllDependencies = try reader["IncludeAllDependencies"].readIfPresent() ?? false
        value.exportFormat = try reader["ExportFormat"].readIfPresent()
        value.includePermissions = try reader["IncludePermissions"].readIfPresent() ?? false
        value.includeTags = try reader["IncludeTags"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.AssetBundleImportJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AssetBundleImportJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AssetBundleImportJobSummary()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.assetBundleImportJobId = try reader["AssetBundleImportJobId"].readIfPresent()
        value.failureAction = try reader["FailureAction"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DashboardSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.dashboardId = try reader["DashboardId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.publishedVersionNumber = try reader["PublishedVersionNumber"].readIfPresent()
        value.lastPublishedTime = try reader["LastPublishedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.DashboardVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DashboardVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DashboardVersionSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.sourceEntityArn = try reader["SourceEntityArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.DataSetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSetSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSetId = try reader["DataSetId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.importMode = try reader["ImportMode"].readIfPresent()
        value.rowLevelPermissionDataSet = try reader["RowLevelPermissionDataSet"].readIfPresent(with: QuickSightClientTypes.RowLevelPermissionDataSet.read(from:))
        value.rowLevelPermissionTagConfigurationApplied = try reader["RowLevelPermissionTagConfigurationApplied"].readIfPresent() ?? false
        value.columnLevelPermissionRulesApplied = try reader["ColumnLevelPermissionRulesApplied"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.MemberIdArnPair {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.MemberIdArnPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.MemberIdArnPair()
        value.memberId = try reader["MemberId"].readIfPresent()
        value.memberArn = try reader["MemberArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FolderSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FolderSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FolderSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.folderId = try reader["FolderId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.folderType = try reader["FolderType"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sharingModel = try reader["SharingModel"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.IAMPolicyAssignmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.IAMPolicyAssignmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.IAMPolicyAssignmentSummary()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.assignmentStatus = try reader["AssignmentStatus"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ActiveIAMPolicyAssignment {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ActiveIAMPolicyAssignment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ActiveIAMPolicyAssignment()
        value.assignmentName = try reader["AssignmentName"].readIfPresent()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.AuthorizedTargetsByService {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AuthorizedTargetsByService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AuthorizedTargetsByService()
        value.service = try reader["Service"].readIfPresent()
        value.authorizedTargets = try reader["AuthorizedTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.templateId = try reader["TemplateId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.latestVersionNumber = try reader["LatestVersionNumber"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.TemplateVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TemplateVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TemplateVersionSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ThemeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.themeId = try reader["ThemeId"].readIfPresent()
        value.latestVersionNumber = try reader["LatestVersionNumber"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.ThemeVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ThemeVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ThemeVersionSummary()
        value.versionNumber = try reader["VersionNumber"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicRefreshScheduleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicRefreshScheduleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicRefreshScheduleSummary()
        value.datasetId = try reader["DatasetId"].readIfPresent()
        value.datasetArn = try reader["DatasetArn"].readIfPresent()
        value.datasetName = try reader["DatasetName"].readIfPresent()
        value.refreshSchedule = try reader["RefreshSchedule"].readIfPresent(with: QuickSightClientTypes.TopicRefreshSchedule.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicReviewedAnswer {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicReviewedAnswer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicReviewedAnswer()
        value.arn = try reader["Arn"].readIfPresent()
        value.answerId = try reader["AnswerId"].readIfPresent() ?? ""
        value.datasetArn = try reader["DatasetArn"].readIfPresent() ?? ""
        value.question = try reader["Question"].readIfPresent() ?? ""
        value.mir = try reader["Mir"].readIfPresent(with: QuickSightClientTypes.TopicIR.read(from:))
        value.primaryVisual = try reader["PrimaryVisual"].readIfPresent(with: QuickSightClientTypes.TopicVisual.read(from:))
        value.template = try reader["Template"].readIfPresent(with: QuickSightClientTypes.TopicTemplate.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicTemplate {

    static func write(value: QuickSightClientTypes.TopicTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Slots"].writeList(value.slots, memberWritingClosure: QuickSightClientTypes.Slot.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TemplateType"].write(value.templateType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicTemplate()
        value.templateType = try reader["TemplateType"].readIfPresent()
        value.slots = try reader["Slots"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Slot.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.Slot {

    static func write(value: QuickSightClientTypes.Slot?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SlotId"].write(value.slotId)
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Slot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Slot()
        value.slotId = try reader["SlotId"].readIfPresent()
        value.visualId = try reader["VisualId"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicVisual {

    static func write(value: QuickSightClientTypes.TopicVisual?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ir"].write(value.ir, with: QuickSightClientTypes.TopicIR.write(value:to:))
        try writer["Role"].write(value.role)
        try writer["SupportingVisuals"].writeList(value.supportingVisuals, memberWritingClosure: QuickSightClientTypes.TopicVisual.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VisualId"].write(value.visualId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicVisual {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicVisual()
        value.visualId = try reader["VisualId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.ir = try reader["Ir"].readIfPresent(with: QuickSightClientTypes.TopicIR.read(from:))
        value.supportingVisuals = try reader["SupportingVisuals"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicVisual.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.TopicIR {

    static func write(value: QuickSightClientTypes.TopicIR?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContributionAnalysis"].write(value.contributionAnalysis, with: QuickSightClientTypes.TopicIRContributionAnalysis.write(value:to:))
        try writer["Filters"].writeList(value.filters, memberWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: QuickSightClientTypes.TopicIRFilterOption.write(value:to:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["GroupByList"].writeList(value.groupByList, memberWritingClosure: QuickSightClientTypes.TopicIRGroupBy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: QuickSightClientTypes.TopicIRMetric.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sort"].write(value.sort, with: QuickSightClientTypes.TopicSortClause.write(value:to:))
        try writer["Visual"].write(value.visual, with: QuickSightClientTypes.VisualOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIR {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIR()
        value.metrics = try reader["Metrics"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicIRMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupByList = try reader["GroupByList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.TopicIRGroupBy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filters = try reader["Filters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: QuickSightClientTypes.TopicIRFilterOption.read(from:), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.sort = try reader["Sort"].readIfPresent(with: QuickSightClientTypes.TopicSortClause.read(from:))
        value.contributionAnalysis = try reader["ContributionAnalysis"].readIfPresent(with: QuickSightClientTypes.TopicIRContributionAnalysis.read(from:))
        value.visual = try reader["Visual"].readIfPresent(with: QuickSightClientTypes.VisualOptions.read(from:))
        return value
    }
}

extension QuickSightClientTypes.VisualOptions {

    static func write(value: QuickSightClientTypes.VisualOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VisualOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VisualOptions()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicIRContributionAnalysis {

    static func write(value: QuickSightClientTypes.TopicIRContributionAnalysis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Direction"].write(value.direction)
        try writer["Factors"].writeList(value.factors, memberWritingClosure: QuickSightClientTypes.ContributionAnalysisFactor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SortType"].write(value.sortType)
        try writer["TimeRanges"].write(value.timeRanges, with: QuickSightClientTypes.ContributionAnalysisTimeRanges.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIRContributionAnalysis {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIRContributionAnalysis()
        value.factors = try reader["Factors"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.ContributionAnalysisFactor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.timeRanges = try reader["TimeRanges"].readIfPresent(with: QuickSightClientTypes.ContributionAnalysisTimeRanges.read(from:))
        value.direction = try reader["Direction"].readIfPresent()
        value.sortType = try reader["SortType"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ContributionAnalysisTimeRanges {

    static func write(value: QuickSightClientTypes.ContributionAnalysisTimeRanges?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndRange"].write(value.endRange, with: QuickSightClientTypes.TopicIRFilterOption.write(value:to:))
        try writer["StartRange"].write(value.startRange, with: QuickSightClientTypes.TopicIRFilterOption.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ContributionAnalysisTimeRanges {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ContributionAnalysisTimeRanges()
        value.startRange = try reader["StartRange"].readIfPresent(with: QuickSightClientTypes.TopicIRFilterOption.read(from:))
        value.endRange = try reader["EndRange"].readIfPresent(with: QuickSightClientTypes.TopicIRFilterOption.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicIRFilterOption {

    static func write(value: QuickSightClientTypes.TopicIRFilterOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggMetrics"].writeList(value.aggMetrics, memberWritingClosure: QuickSightClientTypes.FilterAggMetrics.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Aggregation"].write(value.aggregation)
        try writer["AggregationFunctionParameters"].writeMap(value.aggregationFunctionParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AggregationPartitionBy"].writeList(value.aggregationPartitionBy, memberWritingClosure: QuickSightClientTypes.AggregationPartitionBy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Anchor"].write(value.anchor, with: QuickSightClientTypes.Anchor.write(value:to:))
        try writer["Constant"].write(value.constant, with: QuickSightClientTypes.TopicConstantValue.write(value:to:))
        try writer["FilterClass"].write(value.filterClass)
        try writer["FilterType"].write(value.filterType)
        try writer["Function"].write(value.function)
        try writer["Inclusive"].write(value.inclusive)
        try writer["Inverse"].write(value.inverse)
        try writer["LastNextOffset"].write(value.lastNextOffset, with: QuickSightClientTypes.TopicConstantValue.write(value:to:))
        try writer["NullFilter"].write(value.nullFilter)
        try writer["OperandField"].write(value.operandField, with: QuickSightClientTypes.Identifier.write(value:to:))
        try writer["Range"].write(value.range, with: QuickSightClientTypes.TopicConstantValue.write(value:to:))
        try writer["SortDirection"].write(value.sortDirection)
        try writer["TimeGranularity"].write(value.timeGranularity)
        try writer["TopBottomLimit"].write(value.topBottomLimit, with: QuickSightClientTypes.TopicConstantValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIRFilterOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIRFilterOption()
        value.filterType = try reader["FilterType"].readIfPresent()
        value.filterClass = try reader["FilterClass"].readIfPresent()
        value.operandField = try reader["OperandField"].readIfPresent(with: QuickSightClientTypes.Identifier.read(from:))
        value.function = try reader["Function"].readIfPresent()
        value.constant = try reader["Constant"].readIfPresent(with: QuickSightClientTypes.TopicConstantValue.read(from:))
        value.inverse = try reader["Inverse"].readIfPresent() ?? false
        value.nullFilter = try reader["NullFilter"].readIfPresent()
        value.aggregation = try reader["Aggregation"].readIfPresent()
        value.aggregationFunctionParameters = try reader["AggregationFunctionParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.aggregationPartitionBy = try reader["AggregationPartitionBy"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.AggregationPartitionBy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.range = try reader["Range"].readIfPresent(with: QuickSightClientTypes.TopicConstantValue.read(from:))
        value.inclusive = try reader["Inclusive"].readIfPresent() ?? false
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.lastNextOffset = try reader["LastNextOffset"].readIfPresent(with: QuickSightClientTypes.TopicConstantValue.read(from:))
        value.aggMetrics = try reader["AggMetrics"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.FilterAggMetrics.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topBottomLimit = try reader["TopBottomLimit"].readIfPresent(with: QuickSightClientTypes.TopicConstantValue.read(from:))
        value.sortDirection = try reader["SortDirection"].readIfPresent()
        value.anchor = try reader["Anchor"].readIfPresent(with: QuickSightClientTypes.Anchor.read(from:))
        return value
    }
}

extension QuickSightClientTypes.Anchor {

    static func write(value: QuickSightClientTypes.Anchor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnchorType"].write(value.anchorType)
        try writer["Offset"].write(value.offset)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Anchor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Anchor()
        value.anchorType = try reader["AnchorType"].readIfPresent()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.offset = try reader["Offset"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.TopicConstantValue {

    static func write(value: QuickSightClientTypes.TopicConstantValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConstantType"].write(value.constantType)
        try writer["Maximum"].write(value.maximum)
        try writer["Minimum"].write(value.minimum)
        try writer["Value"].write(value.value)
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: QuickSightClientTypes.CollectiveConstantEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicConstantValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicConstantValue()
        value.constantType = try reader["ConstantType"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.minimum = try reader["Minimum"].readIfPresent()
        value.maximum = try reader["Maximum"].readIfPresent()
        value.valueList = try reader["ValueList"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.CollectiveConstantEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension QuickSightClientTypes.CollectiveConstantEntry {

    static func write(value: QuickSightClientTypes.CollectiveConstantEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConstantType"].write(value.constantType)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.CollectiveConstantEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.CollectiveConstantEntry()
        value.constantType = try reader["ConstantType"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.FilterAggMetrics {

    static func write(value: QuickSightClientTypes.FilterAggMetrics?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Function"].write(value.function)
        try writer["MetricOperand"].write(value.metricOperand, with: QuickSightClientTypes.Identifier.write(value:to:))
        try writer["SortDirection"].write(value.sortDirection)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FilterAggMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FilterAggMetrics()
        value.metricOperand = try reader["MetricOperand"].readIfPresent(with: QuickSightClientTypes.Identifier.read(from:))
        value.function = try reader["Function"].readIfPresent()
        value.sortDirection = try reader["SortDirection"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.Identifier {

    static func write(value: QuickSightClientTypes.Identifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identity"].write(value.identity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.Identifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.Identifier()
        value.identity = try reader["Identity"].readIfPresent() ?? ""
        return value
    }
}

extension QuickSightClientTypes.AggregationPartitionBy {

    static func write(value: QuickSightClientTypes.AggregationPartitionBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AggregationPartitionBy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AggregationPartitionBy()
        value.fieldName = try reader["FieldName"].readIfPresent()
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.ContributionAnalysisFactor {

    static func write(value: QuickSightClientTypes.ContributionAnalysisFactor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.ContributionAnalysisFactor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.ContributionAnalysisFactor()
        value.fieldName = try reader["FieldName"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicSortClause {

    static func write(value: QuickSightClientTypes.TopicSortClause?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operand"].write(value.operand, with: QuickSightClientTypes.Identifier.write(value:to:))
        try writer["SortDirection"].write(value.sortDirection)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicSortClause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicSortClause()
        value.operand = try reader["Operand"].readIfPresent(with: QuickSightClientTypes.Identifier.read(from:))
        value.sortDirection = try reader["SortDirection"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicIRGroupBy {

    static func write(value: QuickSightClientTypes.TopicIRGroupBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayFormat"].write(value.displayFormat)
        try writer["DisplayFormatOptions"].write(value.displayFormatOptions, with: QuickSightClientTypes.DisplayFormatOptions.write(value:to:))
        try writer["FieldName"].write(value.fieldName, with: QuickSightClientTypes.Identifier.write(value:to:))
        try writer["NamedEntity"].write(value.namedEntity, with: QuickSightClientTypes.NamedEntityRef.write(value:to:))
        try writer["Sort"].write(value.sort, with: QuickSightClientTypes.TopicSortClause.write(value:to:))
        try writer["TimeGranularity"].write(value.timeGranularity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIRGroupBy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIRGroupBy()
        value.fieldName = try reader["FieldName"].readIfPresent(with: QuickSightClientTypes.Identifier.read(from:))
        value.timeGranularity = try reader["TimeGranularity"].readIfPresent()
        value.sort = try reader["Sort"].readIfPresent(with: QuickSightClientTypes.TopicSortClause.read(from:))
        value.displayFormat = try reader["DisplayFormat"].readIfPresent()
        value.displayFormatOptions = try reader["DisplayFormatOptions"].readIfPresent(with: QuickSightClientTypes.DisplayFormatOptions.read(from:))
        value.namedEntity = try reader["NamedEntity"].readIfPresent(with: QuickSightClientTypes.NamedEntityRef.read(from:))
        return value
    }
}

extension QuickSightClientTypes.NamedEntityRef {

    static func write(value: QuickSightClientTypes.NamedEntityRef?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamedEntityName"].write(value.namedEntityName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.NamedEntityRef {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.NamedEntityRef()
        value.namedEntityName = try reader["NamedEntityName"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicIRMetric {

    static func write(value: QuickSightClientTypes.TopicIRMetric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CalculatedFieldReferences"].writeList(value.calculatedFieldReferences, memberWritingClosure: QuickSightClientTypes.Identifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComparisonMethod"].write(value.comparisonMethod, with: QuickSightClientTypes.TopicIRComparisonMethod.write(value:to:))
        try writer["DisplayFormat"].write(value.displayFormat)
        try writer["DisplayFormatOptions"].write(value.displayFormatOptions, with: QuickSightClientTypes.DisplayFormatOptions.write(value:to:))
        try writer["Expression"].write(value.expression)
        try writer["Function"].write(value.function, with: QuickSightClientTypes.AggFunction.write(value:to:))
        try writer["MetricId"].write(value.metricId, with: QuickSightClientTypes.Identifier.write(value:to:))
        try writer["NamedEntity"].write(value.namedEntity, with: QuickSightClientTypes.NamedEntityRef.write(value:to:))
        try writer["Operands"].writeList(value.operands, memberWritingClosure: QuickSightClientTypes.Identifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIRMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIRMetric()
        value.metricId = try reader["MetricId"].readIfPresent(with: QuickSightClientTypes.Identifier.read(from:))
        value.function = try reader["Function"].readIfPresent(with: QuickSightClientTypes.AggFunction.read(from:))
        value.operands = try reader["Operands"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Identifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.comparisonMethod = try reader["ComparisonMethod"].readIfPresent(with: QuickSightClientTypes.TopicIRComparisonMethod.read(from:))
        value.expression = try reader["Expression"].readIfPresent()
        value.calculatedFieldReferences = try reader["CalculatedFieldReferences"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.Identifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.displayFormat = try reader["DisplayFormat"].readIfPresent()
        value.displayFormatOptions = try reader["DisplayFormatOptions"].readIfPresent(with: QuickSightClientTypes.DisplayFormatOptions.read(from:))
        value.namedEntity = try reader["NamedEntity"].readIfPresent(with: QuickSightClientTypes.NamedEntityRef.read(from:))
        return value
    }
}

extension QuickSightClientTypes.TopicIRComparisonMethod {

    static func write(value: QuickSightClientTypes.TopicIRComparisonMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Period"].write(value.period)
        try writer["Type"].write(value.type)
        try writer["WindowSize"].write(value.windowSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicIRComparisonMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicIRComparisonMethod()
        value.type = try reader["Type"].readIfPresent()
        value.period = try reader["Period"].readIfPresent()
        value.windowSize = try reader["WindowSize"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.AggFunction {

    static func write(value: QuickSightClientTypes.AggFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["AggregationFunctionParameters"].writeMap(value.aggregationFunctionParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Period"].write(value.period)
        try writer["PeriodField"].write(value.periodField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.AggFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.AggFunction()
        value.aggregation = try reader["Aggregation"].readIfPresent()
        value.aggregationFunctionParameters = try reader["AggregationFunctionParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.period = try reader["Period"].readIfPresent()
        value.periodField = try reader["PeriodField"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.TopicSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.TopicSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.TopicSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.topicId = try reader["TopicId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.userExperienceVersion = try reader["UserExperienceVersion"].readIfPresent()
        return value
    }
}

extension QuickSightClientTypes.VPCConnectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.VPCConnectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.VPCConnectionSummary()
        value.vpcConnectionId = try reader["VPCConnectionId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.vpcId = try reader["VPCId"].readIfPresent()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsResolvers = try reader["DnsResolvers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.availabilityStatus = try reader["AvailabilityStatus"].readIfPresent()
        value.networkInterfaces = try reader["NetworkInterfaces"].readListIfPresent(memberReadingClosure: QuickSightClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.DataSourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.DataSourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.DataSourceSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.dataSourceId = try reader["DataSourceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QuickSightClientTypes.FailedKeyRegistrationEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.FailedKeyRegistrationEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.FailedKeyRegistrationEntry()
        value.keyArn = try reader["KeyArn"].readIfPresent()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.statusCode = try reader["StatusCode"].readIfPresent() ?? 0
        value.senderFault = try reader["SenderFault"].readIfPresent() ?? false
        return value
    }
}

extension QuickSightClientTypes.SuccessfulKeyRegistrationEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> QuickSightClientTypes.SuccessfulKeyRegistrationEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QuickSightClientTypes.SuccessfulKeyRegistrationEntry()
        value.keyArn = try reader["KeyArn"].readIfPresent() ?? ""
        value.statusCode = try reader["StatusCode"].readIfPresent() ?? 0
        return value
    }
}

extension QuickSightClientTypes.CreateTopicReviewedAnswer {

    static func write(value: QuickSightClientTypes.CreateTopicReviewedAnswer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnswerId"].write(value.answerId)
        try writer["DatasetArn"].write(value.datasetArn)
        try writer["Mir"].write(value.mir, with: QuickSightClientTypes.TopicIR.write(value:to:))
        try writer["PrimaryVisual"].write(value.primaryVisual, with: QuickSightClientTypes.TopicVisual.write(value:to:))
        try writer["Question"].write(value.question)
        try writer["Template"].write(value.template, with: QuickSightClientTypes.TopicTemplate.write(value:to:))
    }
}

extension QuickSightClientTypes.AnalysisSourceEntity {

    static func write(value: QuickSightClientTypes.AnalysisSourceEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceTemplate"].write(value.sourceTemplate, with: QuickSightClientTypes.AnalysisSourceTemplate.write(value:to:))
    }
}

extension QuickSightClientTypes.AnalysisSourceTemplate {

    static func write(value: QuickSightClientTypes.AnalysisSourceTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["DataSetReferences"].writeList(value.dataSetReferences, memberWritingClosure: QuickSightClientTypes.DataSetReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QuickSightClientTypes.DataSetReference {

    static func write(value: QuickSightClientTypes.DataSetReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSetArn"].write(value.dataSetArn)
        try writer["DataSetPlaceholder"].write(value.dataSetPlaceholder)
    }
}

extension QuickSightClientTypes.ValidationStrategy {

    static func write(value: QuickSightClientTypes.ValidationStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
    }
}

extension QuickSightClientTypes.DashboardSourceEntity {

    static func write(value: QuickSightClientTypes.DashboardSourceEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceTemplate"].write(value.sourceTemplate, with: QuickSightClientTypes.DashboardSourceTemplate.write(value:to:))
    }
}

extension QuickSightClientTypes.DashboardSourceTemplate {

    static func write(value: QuickSightClientTypes.DashboardSourceTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["DataSetReferences"].writeList(value.dataSetReferences, memberWritingClosure: QuickSightClientTypes.DataSetReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QuickSightClientTypes.DataSourceCredentials {

    static func write(value: QuickSightClientTypes.DataSourceCredentials?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CopySourceArn"].write(value.copySourceArn)
        try writer["CredentialPair"].write(value.credentialPair, with: QuickSightClientTypes.CredentialPair.write(value:to:))
        try writer["SecretArn"].write(value.secretArn)
    }
}

extension QuickSightClientTypes.CredentialPair {

    static func write(value: QuickSightClientTypes.CredentialPair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlternateDataSourceParameters"].writeList(value.alternateDataSourceParameters, memberWritingClosure: QuickSightClientTypes.DataSourceParameters.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Password"].write(value.password)
        try writer["Username"].write(value.username)
    }
}

extension QuickSightClientTypes.TemplateSourceEntity {

    static func write(value: QuickSightClientTypes.TemplateSourceEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceAnalysis"].write(value.sourceAnalysis, with: QuickSightClientTypes.TemplateSourceAnalysis.write(value:to:))
        try writer["SourceTemplate"].write(value.sourceTemplate, with: QuickSightClientTypes.TemplateSourceTemplate.write(value:to:))
    }
}

extension QuickSightClientTypes.TemplateSourceTemplate {

    static func write(value: QuickSightClientTypes.TemplateSourceTemplate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension QuickSightClientTypes.TemplateSourceAnalysis {

    static func write(value: QuickSightClientTypes.TemplateSourceAnalysis?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["DataSetReferences"].writeList(value.dataSetReferences, memberWritingClosure: QuickSightClientTypes.DataSetReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QuickSightClientTypes.SessionTag {

    static func write(value: QuickSightClientTypes.SessionTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration {

    static func write(value: QuickSightClientTypes.AnonymousUserEmbeddingExperienceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dashboard"].write(value.dashboard, with: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration.write(value:to:))
        try writer["DashboardVisual"].write(value.dashboardVisual, with: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration.write(value:to:))
        try writer["GenerativeQnA"].write(value.generativeQnA, with: QuickSightClientTypes.AnonymousUserGenerativeQnAEmbeddingConfiguration.write(value:to:))
        try writer["QSearchBar"].write(value.qSearchBar, with: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration.write(value:to:))
    }
}

extension QuickSightClientTypes.AnonymousUserGenerativeQnAEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.AnonymousUserGenerativeQnAEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialTopicId"].write(value.initialTopicId)
    }
}

extension QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.AnonymousUserQSearchBarEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialTopicId"].write(value.initialTopicId)
    }
}

extension QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.AnonymousUserDashboardVisualEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialDashboardVisualId"].write(value.initialDashboardVisualId, with: QuickSightClientTypes.DashboardVisualId.write(value:to:))
    }
}

extension QuickSightClientTypes.DashboardVisualId {

    static func write(value: QuickSightClientTypes.DashboardVisualId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DashboardId"].write(value.dashboardId)
        try writer["SheetId"].write(value.sheetId)
        try writer["VisualId"].write(value.visualId)
    }
}

extension QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisabledFeatures"].writeList(value.disabledFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationDisabledFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnabledFeatures"].writeList(value.enabledFeatures, memberWritingClosure: SmithyReadWrite.WritingClosureBox<QuickSightClientTypes.AnonymousUserDashboardEmbeddingConfigurationEnabledFeature>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FeatureConfigurations"].write(value.featureConfigurations, with: QuickSightClientTypes.AnonymousUserDashboardFeatureConfigurations.write(value:to:))
        try writer["InitialDashboardId"].write(value.initialDashboardId)
    }
}

extension QuickSightClientTypes.AnonymousUserDashboardFeatureConfigurations {

    static func write(value: QuickSightClientTypes.AnonymousUserDashboardFeatureConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SharedView"].write(value.sharedView, with: QuickSightClientTypes.SharedViewConfigurations.write(value:to:))
    }
}

extension QuickSightClientTypes.SharedViewConfigurations {

    static func write(value: QuickSightClientTypes.SharedViewConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserEmbeddingExperienceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dashboard"].write(value.dashboard, with: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration.write(value:to:))
        try writer["DashboardVisual"].write(value.dashboardVisual, with: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration.write(value:to:))
        try writer["GenerativeQnA"].write(value.generativeQnA, with: QuickSightClientTypes.RegisteredUserGenerativeQnAEmbeddingConfiguration.write(value:to:))
        try writer["QSearchBar"].write(value.qSearchBar, with: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration.write(value:to:))
        try writer["QuickSightConsole"].write(value.quickSightConsole, with: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration.write(value:to:))
    }
}

extension QuickSightClientTypes.RegisteredUserGenerativeQnAEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserGenerativeQnAEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialTopicId"].write(value.initialTopicId)
    }
}

extension QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserDashboardVisualEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialDashboardVisualId"].write(value.initialDashboardVisualId, with: QuickSightClientTypes.DashboardVisualId.write(value:to:))
    }
}

extension QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserQSearchBarEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialTopicId"].write(value.initialTopicId)
    }
}

extension QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserQuickSightConsoleEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeatureConfigurations"].write(value.featureConfigurations, with: QuickSightClientTypes.RegisteredUserConsoleFeatureConfigurations.write(value:to:))
        try writer["InitialPath"].write(value.initialPath)
    }
}

extension QuickSightClientTypes.RegisteredUserConsoleFeatureConfigurations {

    static func write(value: QuickSightClientTypes.RegisteredUserConsoleFeatureConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SharedView"].write(value.sharedView, with: QuickSightClientTypes.SharedViewConfigurations.write(value:to:))
        try writer["StatePersistence"].write(value.statePersistence, with: QuickSightClientTypes.StatePersistenceConfigurations.write(value:to:))
    }
}

extension QuickSightClientTypes.StatePersistenceConfigurations {

    static func write(value: QuickSightClientTypes.StatePersistenceConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration {

    static func write(value: QuickSightClientTypes.RegisteredUserDashboardEmbeddingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeatureConfigurations"].write(value.featureConfigurations, with: QuickSightClientTypes.RegisteredUserDashboardFeatureConfigurations.write(value:to:))
        try writer["InitialDashboardId"].write(value.initialDashboardId)
    }
}

extension QuickSightClientTypes.RegisteredUserDashboardFeatureConfigurations {

    static func write(value: QuickSightClientTypes.RegisteredUserDashboardFeatureConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bookmarks"].write(value.bookmarks, with: QuickSightClientTypes.BookmarksConfigurations.write(value:to:))
        try writer["SharedView"].write(value.sharedView, with: QuickSightClientTypes.SharedViewConfigurations.write(value:to:))
        try writer["StatePersistence"].write(value.statePersistence, with: QuickSightClientTypes.StatePersistenceConfigurations.write(value:to:))
    }
}

extension QuickSightClientTypes.BookmarksConfigurations {

    static func write(value: QuickSightClientTypes.BookmarksConfigurations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension QuickSightClientTypes.AnalysisSearchFilter {

    static func write(value: QuickSightClientTypes.AnalysisSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.DashboardSearchFilter {

    static func write(value: QuickSightClientTypes.DashboardSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.DataSetSearchFilter {

    static func write(value: QuickSightClientTypes.DataSetSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.DataSourceSearchFilter {

    static func write(value: QuickSightClientTypes.DataSourceSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.FolderSearchFilter {

    static func write(value: QuickSightClientTypes.FolderSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.GroupSearchFilter {

    static func write(value: QuickSightClientTypes.GroupSearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

extension QuickSightClientTypes.AssetBundleImportSource {

    static func write(value: QuickSightClientTypes.AssetBundleImportSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["S3Uri"].write(value.s3Uri)
    }
}

extension QuickSightClientTypes.SnapshotUserConfiguration {

    static func write(value: QuickSightClientTypes.SnapshotUserConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnonymousUsers"].writeList(value.anonymousUsers, memberWritingClosure: QuickSightClientTypes.SnapshotAnonymousUser.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QuickSightClientTypes.SnapshotAnonymousUser {

    static func write(value: QuickSightClientTypes.SnapshotAnonymousUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RowLevelPermissionTags"].writeList(value.rowLevelPermissionTags, memberWritingClosure: QuickSightClientTypes.SessionTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum QuickSightClientTypes {}
