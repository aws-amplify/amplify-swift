//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct ApplyArchiveRuleOutput: Swift.Sendable {

    public init() { }
}

public struct CreateArchiveRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAnalyzerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteArchiveRuleOutput: Swift.Sendable {

    public init() { }
}

public struct GenerateFindingRecommendationOutput: Swift.Sendable {

    public init() { }
}

public struct StartResourceScanOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateArchiveRuleOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateFindingsOutput: Swift.Sendable {

    public init() { }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about actions and resources that define permissions to check against a policy.
    public struct Access: Swift.Sendable {
        /// A list of actions for the access permissions. Any strings that can be used as an action in an IAM policy can be used in the list of actions to check.
        public var actions: [Swift.String]?
        /// A list of resources for the access permissions. Any strings that can be used as a resource in an IAM policy can be used in the list of resources to check.
        public var resources: [Swift.String]?

        public init(
            actions: [Swift.String]? = [],
            resources: [Swift.String]? = []
        )
        {
            self.actions = actions
            self.resources = resources
        }
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A conflict exception error.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The seconds to wait to retry.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Service quote met error.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Throttling limit exceeded error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The seconds to wait to retry.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about a validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case notSupported
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .notSupported,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .notSupported: return "notSupported"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Validation exception error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of fields that didn't validate.
        public internal(set) var fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: AccessAnalyzerClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AccessAnalyzerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension AccessAnalyzerClientTypes {

    /// The criteria to use in the filter that defines the archive rule. For more information on available filter keys, see [IAM Access Analyzer filter keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html).
    public struct Criterion: Swift.Sendable {
        /// A "contains" operator to match for the filter used to create the rule.
        public var contains: [Swift.String]?
        /// An "equals" operator to match for the filter used to create the rule.
        public var eq: [Swift.String]?
        /// An "exists" operator to match for the filter used to create the rule.
        public var exists: Swift.Bool?
        /// A "not equals" operator to match for the filter used to create the rule.
        public var neq: [Swift.String]?

        public init(
            contains: [Swift.String]? = nil,
            eq: [Swift.String]? = nil,
            exists: Swift.Bool? = nil,
            neq: [Swift.String]? = nil
        )
        {
            self.contains = contains
            self.eq = eq
            self.exists = exists
            self.neq = neq
        }
    }
}

/// Creates an archive rule.
public struct CreateArchiveRuleInput: Swift.Sendable {
    /// The name of the created analyzer.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The criteria for the rule.
    /// This member is required.
    public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to create.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

/// Deletes an archive rule.
public struct DeleteArchiveRuleInput: Swift.Sendable {
    /// The name of the analyzer that associated with the archive rule to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to delete.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

/// Retrieves an archive rule.
public struct GetArchiveRuleInput: Swift.Sendable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The name of the rule to retrieve.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.ruleName = ruleName
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an archive rule.
    public struct ArchiveRuleSummary: Swift.Sendable {
        /// The time at which the archive rule was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A filter used to define the archive rule.
        /// This member is required.
        public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
        /// The name of the archive rule.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The time at which the archive rule was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.filter = filter
            self.ruleName = ruleName
            self.updatedAt = updatedAt
        }
    }
}

/// The response to the request.
public struct GetArchiveRuleOutput: Swift.Sendable {
    /// Contains information about an archive rule.
    /// This member is required.
    public var archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary?

    public init(
        archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary? = nil
    )
    {
        self.archiveRule = archiveRule
    }
}

/// Retrieves a list of archive rules created for the specified analyzer.
public struct ListArchiveRulesInput: Swift.Sendable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The maximum number of results to return in the request.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response to the request.
public struct ListArchiveRulesOutput: Swift.Sendable {
    /// A list of archive rules created for the specified analyzer.
    /// This member is required.
    public var archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archiveRules = archiveRules
        self.nextToken = nextToken
    }
}

/// Updates the specified archive rule.
public struct UpdateArchiveRuleInput: Swift.Sendable {
    /// The name of the analyzer to update the archive rules for.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// A filter to match for the rules to update. Only rules that match the filter are updated.
    /// This member is required.
    public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to update.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

extension AccessAnalyzerClientTypes {

    /// An criterion statement in an archive rule. Each archive rule may have multiple criteria.
    public struct InlineArchiveRule: Swift.Sendable {
        /// The condition and values for a criterion.
        /// This member is required.
        public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
        /// The name of the rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.filter = filter
            self.ruleName = ruleName
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access analyzer.
    public struct UnusedAccessConfiguration: Swift.Sendable {
        /// The specified access age in days for which to generate findings for unused access. For example, if you specify 90 days, the analyzer will generate findings for IAM entities within the accounts of the selected organization for any access that hasn't been used in 90 or more days since the analyzer's last scan. You can choose a value between 1 and 180 days.
        public var unusedAccessAge: Swift.Int?

        public init(
            unusedAccessAge: Swift.Int? = nil
        )
        {
            self.unusedAccessAge = unusedAccessAge
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about the configuration of an unused access analyzer for an Amazon Web Services organization or account.
    public enum AnalyzerConfiguration: Swift.Sendable {
        /// Specifies the configuration of an unused access analyzer for an Amazon Web Services organization or account. External access analyzers do not support any configuration.
        case unusedaccess(AccessAnalyzerClientTypes.UnusedAccessConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case accountUnusedAccess
        case organization
        case organizationUnusedAccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .account,
                .accountUnusedAccess,
                .organization,
                .organizationUnusedAccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .accountUnusedAccess: return "ACCOUNT_UNUSED_ACCESS"
            case .organization: return "ORGANIZATION"
            case .organizationUnusedAccess: return "ORGANIZATION_UNUSED_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Creates an analyzer.
public struct CreateAnalyzerInput: Swift.Sendable {
    /// The name of the analyzer to create.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
    public var archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]?
    /// A client token.
    public var clientToken: Swift.String?
    /// Specifies the configuration of the analyzer. If the analyzer is an unused access analyzer, the specified scope of unused access is used for the configuration. If the analyzer is an external access analyzer, this field is not used.
    public var configuration: AccessAnalyzerClientTypes.AnalyzerConfiguration?
    /// An array of key-value pairs to apply to the analyzer.
    public var tags: [Swift.String: Swift.String]?
    /// The type of analyzer to create. Only ACCOUNT, ORGANIZATION, ACCOUNT_UNUSED_ACCESS, and ORGANIZATION_UNUSED_ACCESS analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
    /// This member is required.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init(
        analyzerName: Swift.String? = nil,
        archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]? = nil,
        clientToken: Swift.String? = nil,
        configuration: AccessAnalyzerClientTypes.AnalyzerConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.analyzerName = analyzerName
        self.archiveRules = archiveRules
        self.clientToken = clientToken
        self.configuration = configuration
        self.tags = tags
        self.type = type
    }
}

/// The response to the request to create an analyzer.
public struct CreateAnalyzerOutput: Swift.Sendable {
    /// The ARN of the analyzer that was created by the request.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Deletes an analyzer.
public struct DeleteAnalyzerInput: Swift.Sendable {
    /// The name of the analyzer to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?

    public init(
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
    }
}

/// Retrieves an analyzer.
public struct GetAnalyzerInput: Swift.Sendable {
    /// The name of the analyzer retrieved.
    /// This member is required.
    public var analyzerName: Swift.String?

    public init(
        analyzerName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
    }
}

extension AccessAnalyzerClientTypes {

    public enum AnalyzerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case disabled
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyzerStatus] {
            return [
                .active,
                .creating,
                .disabled,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum ReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsServiceAccessDisabled
        case delegatedAdministratorDeregistered
        case organizationDeleted
        case serviceLinkedRoleCreationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ReasonCode] {
            return [
                .awsServiceAccessDisabled,
                .delegatedAdministratorDeregistered,
                .organizationDeleted,
                .serviceLinkedRoleCreationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsServiceAccessDisabled: return "AWS_SERVICE_ACCESS_DISABLED"
            case .delegatedAdministratorDeregistered: return "DELEGATED_ADMINISTRATOR_DEREGISTERED"
            case .organizationDeleted: return "ORGANIZATION_DELETED"
            case .serviceLinkedRoleCreationFailed: return "SERVICE_LINKED_ROLE_CREATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
    public struct StatusReason: Swift.Sendable {
        /// The reason code for the current status of the analyzer.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.ReasonCode?

        public init(
            code: AccessAnalyzerClientTypes.ReasonCode? = nil
        )
        {
            self.code = code
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about the analyzer.
    public struct AnalyzerSummary: Swift.Sendable {
        /// The ARN of the analyzer.
        /// This member is required.
        public var arn: Swift.String?
        /// Specifies whether the analyzer is an external access or unused access analyzer.
        public var configuration: AccessAnalyzerClientTypes.AnalyzerConfiguration?
        /// A timestamp for the time at which the analyzer was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The resource that was most recently analyzed by the analyzer.
        public var lastResourceAnalyzed: Swift.String?
        /// The time at which the most recently analyzed resource was analyzed.
        public var lastResourceAnalyzedAt: Foundation.Date?
        /// The name of the analyzer.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the analyzer. An Active analyzer successfully monitors supported resources and generates new findings. The analyzer is Disabled when a user action, such as removing trusted access for Identity and Access Management Access Analyzer from Organizations, causes the analyzer to stop generating new findings. The status is Creating when the analyzer creation is in progress and Failed when the analyzer creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AnalyzerStatus?
        /// The statusReason provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
        public var statusReason: AccessAnalyzerClientTypes.StatusReason?
        /// The tags added to the analyzer.
        public var tags: [Swift.String: Swift.String]?
        /// The type of analyzer, which corresponds to the zone of trust chosen for the analyzer.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.ModelType?

        public init(
            arn: Swift.String? = nil,
            configuration: AccessAnalyzerClientTypes.AnalyzerConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            lastResourceAnalyzed: Swift.String? = nil,
            lastResourceAnalyzedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AnalyzerStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.StatusReason? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: AccessAnalyzerClientTypes.ModelType? = nil
        )
        {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.lastResourceAnalyzed = lastResourceAnalyzed
            self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }
}

/// The response to the request.
public struct GetAnalyzerOutput: Swift.Sendable {
    /// An AnalyzerSummary object that contains information about the analyzer.
    /// This member is required.
    public var analyzer: AccessAnalyzerClientTypes.AnalyzerSummary?

    public init(
        analyzer: AccessAnalyzerClientTypes.AnalyzerSummary? = nil
    )
    {
        self.analyzer = analyzer
    }
}

/// Retrieves a list of analyzers.
public struct ListAnalyzersInput: Swift.Sendable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of analyzer.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

/// The response to the request.
public struct ListAnalyzersOutput: Swift.Sendable {
    /// The analyzers retrieved.
    /// This member is required.
    public var analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzers = analyzers
        self.nextToken = nextToken
    }
}

/// Retroactively applies an archive rule.
public struct ApplyArchiveRuleInput: Swift.Sendable {
    /// The Amazon resource name (ARN) of the analyzer.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to apply.
    /// This member is required.
    public var ruleName: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

public struct CancelPolicyGenerationInput: Swift.Sendable {
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CancelPolicyGenerationOutput: Swift.Sendable {

    public init() { }
}

/// The specified parameter is invalid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified entity could not be processed.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AccessAnalyzerClientTypes {

    public enum AccessCheckPolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case identityPolicy
        case resourcePolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessCheckPolicyType] {
            return [
                .identityPolicy,
                .resourcePolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .identityPolicy: return "IDENTITY_POLICY"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckAccessNotGrantedInput: Swift.Sendable {
    /// An access object containing the permissions that shouldn't be granted by the specified policy. If only actions are specified, IAM Access Analyzer checks for access of the actions on all resources in the policy. If only resources are specified, then IAM Access Analyzer checks which actions have access to the specified resources. If both actions and resources are specified, then IAM Access Analyzer checks which of the specified actions have access to the specified resources.
    /// This member is required.
    public var access: [AccessAnalyzerClientTypes.Access]?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The type of policy. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
    /// This member is required.
    public var policyType: AccessAnalyzerClientTypes.AccessCheckPolicyType?

    public init(
        access: [AccessAnalyzerClientTypes.Access]? = nil,
        policyDocument: Swift.String? = nil,
        policyType: AccessAnalyzerClientTypes.AccessCheckPolicyType? = nil
    )
    {
        self.access = access
        self.policyDocument = policyDocument
        self.policyType = policyType
    }
}

extension CheckAccessNotGrantedInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckAccessNotGrantedInput(access: \(Swift.String(describing: access)), policyType: \(Swift.String(describing: policyType)), policyDocument: \"CONTENT_REDACTED\")"}
}

extension AccessAnalyzerClientTypes {

    /// Contains information about the reasoning why a check for access passed or failed.
    public struct ReasonSummary: Swift.Sendable {
        /// A description of the reasoning of a result of checking for access.
        public var description: Swift.String?
        /// The identifier for the reason statement.
        public var statementId: Swift.String?
        /// The index number of the reason statement.
        public var statementIndex: Swift.Int?

        public init(
            description: Swift.String? = nil,
            statementId: Swift.String? = nil,
            statementIndex: Swift.Int? = nil
        )
        {
            self.description = description
            self.statementId = statementId
            self.statementIndex = statementIndex
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum CheckAccessNotGrantedResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case pass
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckAccessNotGrantedResult] {
            return [
                .fail,
                .pass
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckAccessNotGrantedOutput: Swift.Sendable {
    /// The message indicating whether the specified access is allowed.
    public var message: Swift.String?
    /// A description of the reasoning of the result.
    public var reasons: [AccessAnalyzerClientTypes.ReasonSummary]?
    /// The result of the check for whether the access is allowed. If the result is PASS, the specified policy doesn't allow any of the specified permissions in the access object. If the result is FAIL, the specified policy might allow some or all of the permissions in the access object.
    public var result: AccessAnalyzerClientTypes.CheckAccessNotGrantedResult?

    public init(
        message: Swift.String? = nil,
        reasons: [AccessAnalyzerClientTypes.ReasonSummary]? = nil,
        result: AccessAnalyzerClientTypes.CheckAccessNotGrantedResult? = nil
    )
    {
        self.message = message
        self.reasons = reasons
        self.result = result
    }
}

public struct CheckNoNewAccessInput: Swift.Sendable {
    /// The JSON policy document to use as the content for the existing policy.
    /// This member is required.
    public var existingPolicyDocument: Swift.String?
    /// The JSON policy document to use as the content for the updated policy.
    /// This member is required.
    public var newPolicyDocument: Swift.String?
    /// The type of policy to compare. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
    /// This member is required.
    public var policyType: AccessAnalyzerClientTypes.AccessCheckPolicyType?

    public init(
        existingPolicyDocument: Swift.String? = nil,
        newPolicyDocument: Swift.String? = nil,
        policyType: AccessAnalyzerClientTypes.AccessCheckPolicyType? = nil
    )
    {
        self.existingPolicyDocument = existingPolicyDocument
        self.newPolicyDocument = newPolicyDocument
        self.policyType = policyType
    }
}

extension CheckNoNewAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckNoNewAccessInput(policyType: \(Swift.String(describing: policyType)), existingPolicyDocument: \"CONTENT_REDACTED\", newPolicyDocument: \"CONTENT_REDACTED\")"}
}

extension AccessAnalyzerClientTypes {

    public enum CheckNoNewAccessResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case pass
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckNoNewAccessResult] {
            return [
                .fail,
                .pass
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckNoNewAccessOutput: Swift.Sendable {
    /// The message indicating whether the updated policy allows new access.
    public var message: Swift.String?
    /// A description of the reasoning of the result.
    public var reasons: [AccessAnalyzerClientTypes.ReasonSummary]?
    /// The result of the check for new access. If the result is PASS, no new access is allowed by the updated policy. If the result is FAIL, the updated policy might allow new access.
    public var result: AccessAnalyzerClientTypes.CheckNoNewAccessResult?

    public init(
        message: Swift.String? = nil,
        reasons: [AccessAnalyzerClientTypes.ReasonSummary]? = nil,
        result: AccessAnalyzerClientTypes.CheckNoNewAccessResult? = nil
    )
    {
        self.message = message
        self.reasons = reasons
        self.result = result
    }
}

extension AccessAnalyzerClientTypes {

    public enum AccessCheckResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dynamodbStream
        case dynamodbTable
        case efsFilesystem
        case kinesisDataStream
        case kinesisStreamConsumer
        case kmsKey
        case lambdaFunction
        case opensearchserviceDomain
        case roleTrust
        case s3expressDirectorybucket
        case s3AccessPoint
        case s3Bucket
        case s3Glacier
        case s3OutpostsAccessPoint
        case s3OutpostsBucket
        case secretsmanagerSecret
        case snsTopic
        case sqsQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessCheckResourceType] {
            return [
                .dynamodbStream,
                .dynamodbTable,
                .efsFilesystem,
                .kinesisDataStream,
                .kinesisStreamConsumer,
                .kmsKey,
                .lambdaFunction,
                .opensearchserviceDomain,
                .roleTrust,
                .s3expressDirectorybucket,
                .s3AccessPoint,
                .s3Bucket,
                .s3Glacier,
                .s3OutpostsAccessPoint,
                .s3OutpostsBucket,
                .secretsmanagerSecret,
                .snsTopic,
                .sqsQueue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamodbStream: return "AWS::DynamoDB::Stream"
            case .dynamodbTable: return "AWS::DynamoDB::Table"
            case .efsFilesystem: return "AWS::EFS::FileSystem"
            case .kinesisDataStream: return "AWS::Kinesis::Stream"
            case .kinesisStreamConsumer: return "AWS::Kinesis::StreamConsumer"
            case .kmsKey: return "AWS::KMS::Key"
            case .lambdaFunction: return "AWS::Lambda::Function"
            case .opensearchserviceDomain: return "AWS::OpenSearchService::Domain"
            case .roleTrust: return "AWS::IAM::AssumeRolePolicyDocument"
            case .s3expressDirectorybucket: return "AWS::S3Express::DirectoryBucket"
            case .s3AccessPoint: return "AWS::S3::AccessPoint"
            case .s3Bucket: return "AWS::S3::Bucket"
            case .s3Glacier: return "AWS::S3::Glacier"
            case .s3OutpostsAccessPoint: return "AWS::S3Outposts::AccessPoint"
            case .s3OutpostsBucket: return "AWS::S3Outposts::Bucket"
            case .secretsmanagerSecret: return "AWS::SecretsManager::Secret"
            case .snsTopic: return "AWS::SNS::Topic"
            case .sqsQueue: return "AWS::SQS::Queue"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckNoPublicAccessInput: Swift.Sendable {
    /// The JSON policy document to evaluate for public access.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The type of resource to evaluate for public access. For example, to check for public access to Amazon S3 buckets, you can choose AWS::S3::Bucket for the resource type. For resource types not supported as valid values, IAM Access Analyzer will return an error.
    /// This member is required.
    public var resourceType: AccessAnalyzerClientTypes.AccessCheckResourceType?

    public init(
        policyDocument: Swift.String? = nil,
        resourceType: AccessAnalyzerClientTypes.AccessCheckResourceType? = nil
    )
    {
        self.policyDocument = policyDocument
        self.resourceType = resourceType
    }
}

extension CheckNoPublicAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckNoPublicAccessInput(resourceType: \(Swift.String(describing: resourceType)), policyDocument: \"CONTENT_REDACTED\")"}
}

extension AccessAnalyzerClientTypes {

    public enum CheckNoPublicAccessResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case pass
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckNoPublicAccessResult] {
            return [
                .fail,
                .pass
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CheckNoPublicAccessOutput: Swift.Sendable {
    /// The message indicating whether the specified policy allows public access to resources.
    public var message: Swift.String?
    /// A list of reasons why the specified resource policy grants public access for the resource type.
    public var reasons: [AccessAnalyzerClientTypes.ReasonSummary]?
    /// The result of the check for public access to the specified resource type. If the result is PASS, the policy doesn't allow public access to the specified resource type. If the result is FAIL, the policy might allow public access to the specified resource type.
    public var result: AccessAnalyzerClientTypes.CheckNoPublicAccessResult?

    public init(
        message: Swift.String? = nil,
        reasons: [AccessAnalyzerClientTypes.ReasonSummary]? = nil,
        result: AccessAnalyzerClientTypes.CheckNoPublicAccessResult? = nil
    )
    {
        self.message = message
        self.reasons = reasons
        self.result = result
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for a DynamoDB stream. You can propose a configuration for a new DynamoDB stream or an existing DynamoDB stream that you own by specifying the policy for the DynamoDB stream. For more information, see [PutResourcePolicy](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutResourcePolicy.html).
    ///
    /// * If the configuration is for an existing DynamoDB stream and you do not specify the DynamoDB policy, then the access preview uses the existing DynamoDB policy for the stream.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes a DynamoDB stream without a policy.
    ///
    /// * To propose deletion of an existing DynamoDB stream policy, you can specify an empty string for the DynamoDB policy.
    public struct DynamodbStreamConfiguration: Swift.Sendable {
        /// The proposed resource policy defining who can access or manage the DynamoDB stream.
        public var streamPolicy: Swift.String?

        public init(
            streamPolicy: Swift.String? = nil
        )
        {
            self.streamPolicy = streamPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for a DynamoDB table or index. You can propose a configuration for a new DynamoDB table or index or an existing DynamoDB table or index that you own by specifying the policy for the DynamoDB table or index. For more information, see [PutResourcePolicy](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutResourcePolicy.html).
    ///
    /// * If the configuration is for an existing DynamoDB table or index and you do not specify the DynamoDB policy, then the access preview uses the existing DynamoDB policy for the table or index.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes a DynamoDB table without a policy.
    ///
    /// * To propose deletion of an existing DynamoDB table or index policy, you can specify an empty string for the DynamoDB policy.
    public struct DynamodbTableConfiguration: Swift.Sendable {
        /// The proposed resource policy defining who can access or manage the DynamoDB table.
        public var tablePolicy: Swift.String?

        public init(
            tablePolicy: Swift.String? = nil
        )
        {
            self.tablePolicy = tablePolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon EBS volume snapshot. You can propose a configuration for a new Amazon EBS volume snapshot or an Amazon EBS volume snapshot that you own by specifying the user IDs, groups, and optional KMS encryption key. For more information, see [ModifySnapshotAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySnapshotAttribute.html).
    public struct EbsSnapshotConfiguration: Swift.Sendable {
        /// The groups that have access to the Amazon EBS volume snapshot. If the value all is specified, then the Amazon EBS volume snapshot is public.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the groups, then the access preview uses the existing shared groups for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the groups, then the access preview considers the snapshot without any groups.
        ///
        /// * To propose deletion of existing shared groups, you can specify an empty list for groups.
        public var groups: [Swift.String]?
        /// The KMS key identifier for an encrypted Amazon EBS volume snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the kmsKeyId, the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?
        /// The IDs of the Amazon Web Services accounts that have access to the Amazon EBS volume snapshot.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the userIds, then the access preview uses the existing shared userIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the userIds, then the access preview considers the snapshot without any userIds.
        ///
        /// * To propose deletion of existing shared accountIds, you can specify an empty list for userIds.
        public var userIds: [Swift.String]?

        public init(
            groups: [Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.kmsKeyId = kmsKeyId
            self.userIds = userIds
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon ECR repository. You can propose a configuration for a new Amazon ECR repository or an existing Amazon ECR repository that you own by specifying the Amazon ECR policy. For more information, see [Repository](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_Repository.html).
    ///
    /// * If the configuration is for an existing Amazon ECR repository and you do not specify the Amazon ECR policy, then the access preview uses the existing Amazon ECR policy for the repository.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon ECR repository without a policy.
    ///
    /// * To propose deletion of an existing Amazon ECR repository policy, you can specify an empty string for the Amazon ECR policy.
    public struct EcrRepositoryConfiguration: Swift.Sendable {
        /// The JSON repository policy text to apply to the Amazon ECR repository. For more information, see [Private repository policy examples](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the Amazon ECR User Guide.
        public var repositoryPolicy: Swift.String?

        public init(
            repositoryPolicy: Swift.String? = nil
        )
        {
            self.repositoryPolicy = repositoryPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon EFS file system. You can propose a configuration for a new Amazon EFS file system or an existing Amazon EFS file system that you own by specifying the Amazon EFS policy. For more information, see [Using file systems in Amazon EFS](https://docs.aws.amazon.com/efs/latest/ug/using-fs.html).
    ///
    /// * If the configuration is for an existing Amazon EFS file system and you do not specify the Amazon EFS policy, then the access preview uses the existing Amazon EFS policy for the file system.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon EFS file system without a policy.
    ///
    /// * To propose deletion of an existing Amazon EFS file system policy, you can specify an empty string for the Amazon EFS policy.
    public struct EfsFileSystemConfiguration: Swift.Sendable {
        /// The JSON policy definition to apply to the Amazon EFS file system. For more information on the elements that make up a file system policy, see [Amazon EFS Resource-based policies](https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies).
        public var fileSystemPolicy: Swift.String?

        public init(
            fileSystemPolicy: Swift.String? = nil
        )
        {
            self.fileSystemPolicy = fileSystemPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an IAM role. You can propose a configuration for a new IAM role or an existing IAM role that you own by specifying the trust policy. If the configuration is for a new IAM role, you must specify the trust policy. If the configuration is for an existing IAM role that you own and you do not propose the trust policy, the access preview uses the existing trust policy for the role. The proposed trust policy cannot be an empty string. For more information about role trust policy limits, see [IAM and STS quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html).
    public struct IamRoleConfiguration: Swift.Sendable {
        /// The proposed trust policy for the IAM role.
        public var trustPolicy: Swift.String?

        public init(
            trustPolicy: Swift.String? = nil
        )
        {
            self.trustPolicy = trustPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Use this structure to propose allowing [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) in the grant only when the operation request includes the specified [encryption context](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context). You can specify only one type of encryption context. An empty map is treated as not specified. For more information, see [GrantConstraints](https://docs.aws.amazon.com/kms/latest/APIReference/API_GrantConstraints.html).
    public struct KmsGrantConstraints: Swift.Sendable {
        /// A list of key-value pairs that must match the encryption context in the [cryptographic operation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) request. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint.
        public var encryptionContextEquals: [Swift.String: Swift.String]?
        /// A list of key-value pairs that must be included in the encryption context of the [cryptographic operation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) request. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs.
        public var encryptionContextSubset: [Swift.String: Swift.String]?

        public init(
            encryptionContextEquals: [Swift.String: Swift.String]? = nil,
            encryptionContextSubset: [Swift.String: Swift.String]? = nil
        )
        {
            self.encryptionContextEquals = encryptionContextEquals
            self.encryptionContextSubset = encryptionContextSubset
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum KmsGrantOperation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createGrant
        case decrypt
        case describeKey
        case encrypt
        case generateDataKey
        case generateDataKeyPair
        case generateDataKeyPairWithoutPlaintext
        case generateDataKeyWithoutPlaintext
        case getPublicKey
        case reencryptFrom
        case reencryptTo
        case retireGrant
        case sign
        case verify
        case sdkUnknown(Swift.String)

        public static var allCases: [KmsGrantOperation] {
            return [
                .createGrant,
                .decrypt,
                .describeKey,
                .encrypt,
                .generateDataKey,
                .generateDataKeyPair,
                .generateDataKeyPairWithoutPlaintext,
                .generateDataKeyWithoutPlaintext,
                .getPublicKey,
                .reencryptFrom,
                .reencryptTo,
                .retireGrant,
                .sign,
                .verify
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createGrant: return "CreateGrant"
            case .decrypt: return "Decrypt"
            case .describeKey: return "DescribeKey"
            case .encrypt: return "Encrypt"
            case .generateDataKey: return "GenerateDataKey"
            case .generateDataKeyPair: return "GenerateDataKeyPair"
            case .generateDataKeyPairWithoutPlaintext: return "GenerateDataKeyPairWithoutPlaintext"
            case .generateDataKeyWithoutPlaintext: return "GenerateDataKeyWithoutPlaintext"
            case .getPublicKey: return "GetPublicKey"
            case .reencryptFrom: return "ReEncryptFrom"
            case .reencryptTo: return "ReEncryptTo"
            case .retireGrant: return "RetireGrant"
            case .sign: return "Sign"
            case .verify: return "Verify"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A proposed grant configuration for a KMS key. For more information, see [CreateGrant](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateGrant.html).
    public struct KmsGrantConfiguration: Swift.Sendable {
        /// Use this structure to propose allowing [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) in the grant only when the operation request includes the specified [encryption context](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context).
        public var constraints: AccessAnalyzerClientTypes.KmsGrantConstraints?
        /// The principal that is given permission to perform the operations that the grant permits.
        /// This member is required.
        public var granteePrincipal: Swift.String?
        /// The Amazon Web Services account under which the grant was issued. The account is used to propose KMS grants issued by accounts other than the owner of the key.
        /// This member is required.
        public var issuingAccount: Swift.String?
        /// A list of operations that the grant permits.
        /// This member is required.
        public var operations: [AccessAnalyzerClientTypes.KmsGrantOperation]?
        /// The principal that is given permission to retire the grant by using [RetireGrant](https://docs.aws.amazon.com/kms/latest/APIReference/API_RetireGrant.html) operation.
        public var retiringPrincipal: Swift.String?

        public init(
            constraints: AccessAnalyzerClientTypes.KmsGrantConstraints? = nil,
            granteePrincipal: Swift.String? = nil,
            issuingAccount: Swift.String? = nil,
            operations: [AccessAnalyzerClientTypes.KmsGrantOperation]? = nil,
            retiringPrincipal: Swift.String? = nil
        )
        {
            self.constraints = constraints
            self.granteePrincipal = granteePrincipal
            self.issuingAccount = issuingAccount
            self.operations = operations
            self.retiringPrincipal = retiringPrincipal
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Proposed access control configuration for a KMS key. You can propose a configuration for a new KMS key or an existing KMS key that you own by specifying the key policy and KMS grant configuration. If the configuration is for an existing key and you do not specify the key policy, the access preview uses the existing policy for the key. If the access preview is for a new resource and you do not specify the key policy, then the access preview uses the default key policy. The proposed key policy cannot be an empty string. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default). For more information about key policy limits, see [Resource quotas](https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html).
    public struct KmsKeyConfiguration: Swift.Sendable {
        /// A list of proposed grant configurations for the KMS key. If the proposed grant configuration is for an existing key, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the key.
        public var grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]?
        /// Resource policy configuration for the KMS key. The only valid value for the name of the key policy is default. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default).
        public var keyPolicies: [Swift.String: Swift.String]?

        public init(
            grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]? = nil,
            keyPolicies: [Swift.String: Swift.String]? = nil
        )
        {
            self.grants = grants
            self.keyPolicies = keyPolicies
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The values for a manual Amazon RDS DB cluster snapshot attribute.
    public enum RdsDbClusterSnapshotAttributeValue: Swift.Sendable {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB cluster snapshot. If the value all is specified, then the Amazon RDS DB cluster snapshot is public and can be copied or restored by all Amazon Web Services accounts.
        ///
        /// * If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.
        ///
        /// * To propose deletion of existing shared accountIds, you can specify an empty list for accountIds in the RdsDbClusterSnapshotAttributeValue.
        case accountids([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon RDS DB cluster snapshot. You can propose a configuration for a new Amazon RDS DB cluster snapshot or an Amazon RDS DB cluster snapshot that you own by specifying the RdsDbClusterSnapshotAttributeValue and optional KMS encryption key. For more information, see [ModifyDBClusterSnapshotAttribute](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBClusterSnapshotAttribute.html).
    public struct RdsDbClusterSnapshotConfiguration: Swift.Sendable {
        /// The names and values of manual DB cluster snapshot attributes. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB cluster snapshot. The only valid value for AttributeName for the attribute map is restore
        public var attributes: [Swift.String: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB cluster snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?

        public init(
            attributes: [Swift.String: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The name and values of a manual Amazon RDS DB snapshot attribute. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot.
    public enum RdsDbSnapshotAttributeValue: Swift.Sendable {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB snapshot. If the value all is specified, then the Amazon RDS DB snapshot is public and can be copied or restored by all Amazon Web Services accounts.
        ///
        /// * If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.
        ///
        /// * To propose deletion of an existing shared accountIds, you can specify an empty list for accountIds in the RdsDbSnapshotAttributeValue.
        case accountids([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon RDS DB snapshot. You can propose a configuration for a new Amazon RDS DB snapshot or an Amazon RDS DB snapshot that you own by specifying the RdsDbSnapshotAttributeValue and optional KMS encryption key. For more information, see [ModifyDBSnapshotAttribute](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBSnapshotAttribute.html).
    public struct RdsDbSnapshotConfiguration: Swift.Sendable {
        /// The names and values of manual DB snapshot attributes. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot. The only valid value for attributeName for the attribute map is restore.
        public var attributes: [Swift.String: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?

        public init(
            attributes: [Swift.String: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// This configuration sets the network origin for the Amazon S3 access point or multi-region access point to Internet.
    public struct InternetConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see [VpcConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html).
    public struct VpcConfiguration: Swift.Sendable {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed InternetConfiguration or VpcConfiguration to apply to the Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. You can make the access point accessible from the internet, or you can specify that all requests made through that access point must originate from a specific virtual private cloud (VPC). You can specify only one type of network configuration. For more information, see [Creating access points](https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html).
    public enum NetworkOriginConfiguration: Swift.Sendable {
        /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see [VpcConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html).
        case vpcconfiguration(AccessAnalyzerClientTypes.VpcConfiguration)
        /// The configuration for the Amazon S3 access point or multi-region access point with an Internet origin.
        case internetconfiguration(AccessAnalyzerClientTypes.InternetConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    /// The PublicAccessBlock configuration to apply to this Amazon S3 bucket. If the proposed configuration is for an existing Amazon S3 bucket and the configuration is not specified, the access preview uses the existing setting. If the proposed configuration is for a new bucket and the configuration is not specified, the access preview uses false. If the proposed configuration is for a new access point or multi-region access point and the access point BPA configuration is not specified, the access preview uses true. For more information, see [PublicAccessBlockConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html).
    public struct S3PublicAccessBlockConfiguration: Swift.Sendable {
        /// Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket.
        /// This member is required.
        public var ignorePublicAcls: Swift.Bool?
        /// Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
        /// This member is required.
        public var restrictPublicBuckets: Swift.Bool?

        public init(
            ignorePublicAcls: Swift.Bool? = nil,
            restrictPublicBuckets: Swift.Bool? = nil
        )
        {
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The configuration for an Amazon S3 access point or multi-region access point for the bucket. You can propose up to 10 access points or multi-region access points per bucket. If the proposed Amazon S3 access point configuration is for an existing bucket, the access preview uses the proposed access point configuration in place of the existing access points. To propose an access point without a policy, you can provide an empty string as the access point policy. For more information, see [Creating access points](https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html). For more information about access point policy limits, see [Access points restrictions and limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-points-restrictions-limitations.html).
    public struct S3AccessPointConfiguration: Swift.Sendable {
        /// The access point or multi-region access point policy.
        public var accessPointPolicy: Swift.String?
        /// The proposed Internet and VpcConfiguration to apply to this Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. If the access preview is for a new resource and neither is specified, the access preview uses Internet for the network origin. If the access preview is for an existing resource and neither is specified, the access preview uses the exiting network origin.
        public var networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration?
        /// The proposed S3PublicAccessBlock configuration to apply to this Amazon S3 access point or multi-region access point.
        public var publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init(
            accessPointPolicy: Swift.String? = nil,
            networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration? = nil,
            publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPointPolicy = accessPointPolicy
            self.networkOrigin = networkOrigin
            self.publicAccessBlock = publicAccessBlock
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// You specify each grantee as a type-value pair using one of these types. You can specify only one type of grantee. For more information, see [PutBucketAcl](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketAcl.html).
    public enum AclGrantee: Swift.Sendable {
        /// The value specified is the canonical user ID of an Amazon Web Services account.
        case id(Swift.String)
        /// Used for granting permissions to a predefined group.
        case uri(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    public enum AclPermission: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [AclPermission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A proposed access control list grant configuration for an Amazon S3 bucket. For more information, see [How to Specify an ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#setting-acls).
    public struct S3BucketAclGrantConfiguration: Swift.Sendable {
        /// The grantee to whom youre assigning access rights.
        /// This member is required.
        public var grantee: AccessAnalyzerClientTypes.AclGrantee?
        /// The permissions being granted.
        /// This member is required.
        public var permission: AccessAnalyzerClientTypes.AclPermission?

        public init(
            grantee: AccessAnalyzerClientTypes.AclGrantee? = nil,
            permission: AccessAnalyzerClientTypes.AclPermission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Proposed access control configuration for an Amazon S3 bucket. You can propose a configuration for a new Amazon S3 bucket or an existing Amazon S3 bucket that you own by specifying the Amazon S3 bucket policy, bucket ACLs, bucket BPA settings, Amazon S3 access points, and multi-region access points attached to the bucket. If the configuration is for an existing Amazon S3 bucket and you do not specify the Amazon S3 bucket policy, the access preview uses the existing policy attached to the bucket. If the access preview is for a new resource and you do not specify the Amazon S3 bucket policy, the access preview assumes a bucket without a policy. To propose deletion of an existing bucket policy, you can specify an empty string. For more information about bucket policy limits, see [Bucket Policy Examples](https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html).
    public struct S3BucketConfiguration: Swift.Sendable {
        /// The configuration of Amazon S3 access points or multi-region access points for the bucket. You can propose up to 10 new access points per bucket.
        public var accessPoints: [Swift.String: AccessAnalyzerClientTypes.S3AccessPointConfiguration]?
        /// The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL grants per bucket. If the proposed grant configuration is for an existing bucket, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the bucket.
        public var bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]?
        /// The proposed bucket policy for the Amazon S3 bucket.
        public var bucketPolicy: Swift.String?
        /// The proposed block public access configuration for the Amazon S3 bucket.
        public var bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init(
            accessPoints: [Swift.String: AccessAnalyzerClientTypes.S3AccessPointConfiguration]? = nil,
            bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]? = nil,
            bucketPolicy: Swift.String? = nil,
            bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPoints = accessPoints
            self.bucketAclGrants = bucketAclGrants
            self.bucketPolicy = bucketPolicy
            self.bucketPublicAccessBlock = bucketPublicAccessBlock
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Proposed access control configuration for an Amazon S3 directory bucket. You can propose a configuration for a new Amazon S3 directory bucket or an existing Amazon S3 directory bucket that you own by specifying the Amazon S3 bucket policy. If the configuration is for an existing Amazon S3 directory bucket and you do not specify the Amazon S3 bucket policy, the access preview uses the existing policy attached to the directory bucket. If the access preview is for a new resource and you do not specify the Amazon S3 bucket policy, the access preview assumes an directory bucket without a policy. To propose deletion of an existing bucket policy, you can specify an empty string. For more information about Amazon S3 directory bucket policies, see [Example directory bucket policies for S3 Express One Zone](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-express-security-iam-example-bucket-policies.html).
    public struct S3ExpressDirectoryBucketConfiguration: Swift.Sendable {
        /// The proposed bucket policy for the Amazon S3 directory bucket.
        public var bucketPolicy: Swift.String?

        public init(
            bucketPolicy: Swift.String? = nil
        )
        {
            self.bucketPolicy = bucketPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The configuration for a Secrets Manager secret. For more information, see [CreateSecret](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html). You can propose a configuration for a new secret or an existing secret that you own by specifying the secret policy and optional KMS encryption key. If the configuration is for an existing secret and you do not specify the secret policy, the access preview uses the existing policy for the secret. If the access preview is for a new resource and you do not specify the policy, the access preview assumes a secret without a policy. To propose deletion of an existing policy, you can specify an empty string. If the proposed configuration is for a new secret and you do not specify the KMS key ID, the access preview uses the Amazon Web Services managed key aws/secretsmanager. If you specify an empty string for the KMS key ID, the access preview uses the Amazon Web Services managed key of the Amazon Web Services account. For more information about secret policy limits, see [Quotas for Secrets Manager.](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html).
    public struct SecretsManagerSecretConfiguration: Swift.Sendable {
        /// The proposed ARN, key ID, or alias of the KMS key.
        public var kmsKeyId: Swift.String?
        /// The proposed resource policy defining who can access or manage the secret.
        public var secretPolicy: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            secretPolicy: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.secretPolicy = secretPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon SNS topic. You can propose a configuration for a new Amazon SNS topic or an existing Amazon SNS topic that you own by specifying the policy. If the configuration is for an existing Amazon SNS topic and you do not specify the Amazon SNS policy, then the access preview uses the existing Amazon SNS policy for the topic. If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon SNS topic without a policy. To propose deletion of an existing Amazon SNS topic policy, you can specify an empty string for the Amazon SNS policy. For more information, see [Topic](https://docs.aws.amazon.com/sns/latest/api/API_Topic.html).
    public struct SnsTopicConfiguration: Swift.Sendable {
        /// The JSON policy text that defines who can access an Amazon SNS topic. For more information, see [Example cases for Amazon SNS access control](https://docs.aws.amazon.com/sns/latest/dg/sns-access-policy-use-cases.html) in the Amazon SNS Developer Guide.
        public var topicPolicy: Swift.String?

        public init(
            topicPolicy: Swift.String? = nil
        )
        {
            self.topicPolicy = topicPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The proposed access control configuration for an Amazon SQS queue. You can propose a configuration for a new Amazon SQS queue or an existing Amazon SQS queue that you own by specifying the Amazon SQS policy. If the configuration is for an existing Amazon SQS queue and you do not specify the Amazon SQS policy, the access preview uses the existing Amazon SQS policy for the queue. If the access preview is for a new resource and you do not specify the policy, the access preview assumes an Amazon SQS queue without a policy. To propose deletion of an existing Amazon SQS queue policy, you can specify an empty string for the Amazon SQS policy. For more information about Amazon SQS policy limits, see [Quotas related to policies](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-policies.html).
    public struct SqsQueueConfiguration: Swift.Sendable {
        /// The proposed resource policy for the Amazon SQS queue.
        public var queuePolicy: Swift.String?

        public init(
            queuePolicy: Swift.String? = nil
        )
        {
            self.queuePolicy = queuePolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Access control configuration structures for your resource. You specify the configuration as a type-value pair. You can specify only one type of access control configuration.
    public enum Configuration: Swift.Sendable {
        /// The access control configuration is for an Amazon EBS volume snapshot.
        case ebssnapshot(AccessAnalyzerClientTypes.EbsSnapshotConfiguration)
        /// The access control configuration is for an Amazon ECR repository.
        case ecrrepository(AccessAnalyzerClientTypes.EcrRepositoryConfiguration)
        /// The access control configuration is for an IAM role.
        case iamrole(AccessAnalyzerClientTypes.IamRoleConfiguration)
        /// The access control configuration is for an Amazon EFS file system.
        case efsfilesystem(AccessAnalyzerClientTypes.EfsFileSystemConfiguration)
        /// The access control configuration is for a KMS key.
        case kmskey(AccessAnalyzerClientTypes.KmsKeyConfiguration)
        /// The access control configuration is for an Amazon RDS DB cluster snapshot.
        case rdsdbclustersnapshot(AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration)
        /// The access control configuration is for an Amazon RDS DB snapshot.
        case rdsdbsnapshot(AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration)
        /// The access control configuration is for a Secrets Manager secret.
        case secretsmanagersecret(AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration)
        /// The access control configuration is for an Amazon S3 bucket.
        case s3bucket(AccessAnalyzerClientTypes.S3BucketConfiguration)
        /// The access control configuration is for an Amazon SNS topic
        case snstopic(AccessAnalyzerClientTypes.SnsTopicConfiguration)
        /// The access control configuration is for an Amazon SQS queue.
        case sqsqueue(AccessAnalyzerClientTypes.SqsQueueConfiguration)
        /// The access control configuration is for an Amazon S3 directory bucket.
        case s3expressdirectorybucket(AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration)
        /// The access control configuration is for a DynamoDB stream.
        case dynamodbstream(AccessAnalyzerClientTypes.DynamodbStreamConfiguration)
        /// The access control configuration is for a DynamoDB table or index.
        case dynamodbtable(AccessAnalyzerClientTypes.DynamodbTableConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateAccessPreviewInput: Swift.Sendable {
    /// The [ARN of the account analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview. You can only create an access preview for analyzers with an Account type and Active status.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
    /// This member is required.
    public var configurations: [Swift.String: AccessAnalyzerClientTypes.Configuration]?

    public init(
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurations: [Swift.String: AccessAnalyzerClientTypes.Configuration]? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.configurations = configurations
    }
}

public struct CreateAccessPreviewOutput: Swift.Sendable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GenerateFindingRecommendationInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the finding recommendation.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The unique ID for the finding recommendation.
    /// This member is required.
    public var id: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
    }
}

public struct GetAccessPreviewInput: Swift.Sendable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?

    public init(
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
    }
}

extension AccessAnalyzerClientTypes {

    public enum AccessPreviewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatus] {
            return [
                .completed,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum AccessPreviewStatusReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case invalidConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatusReasonCode] {
            return [
                .internalError,
                .invalidConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .invalidConfiguration: return "INVALID_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
    public struct AccessPreviewStatusReason: Swift.Sendable {
        /// The reason code for the current status of the access preview.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode?

        public init(
            code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode? = nil
        )
        {
            self.code = code
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an access preview.
    public struct AccessPreview: Swift.Sendable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// A map of resource ARNs for the proposed resource configuration.
        /// This member is required.
        public var configurations: [Swift.String: AccessAnalyzerClientTypes.Configuration]?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        /// * Creating - The access preview creation is in progress.
        ///
        /// * Completed - The access preview is complete. You can preview findings for external access to the resource.
        ///
        /// * Failed - The access preview creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init(
            analyzerArn: Swift.String? = nil,
            configurations: [Swift.String: AccessAnalyzerClientTypes.Configuration]? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.configurations = configurations
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct GetAccessPreviewOutput: Swift.Sendable {
    /// An object that contains information about the access preview.
    /// This member is required.
    public var accessPreview: AccessAnalyzerClientTypes.AccessPreview?

    public init(
        accessPreview: AccessAnalyzerClientTypes.AccessPreview? = nil
    )
    {
        self.accessPreview = accessPreview
    }
}

/// Retrieves an analyzed resource.
public struct GetAnalyzedResourceInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve information from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to retrieve information about.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

extension AccessAnalyzerClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsDynamodbStream
        case awsDynamodbTable
        case awsEc2Snapshot
        case awsEcrRepository
        case awsEfsFilesystem
        case awsIamRole
        case awsKmsKey
        case awsLambdaFunction
        case awsLambdaLayerversion
        case awsRdsDbclustersnapshot
        case awsRdsDbsnapshot
        case awsS3expressDirectorybucket
        case awsS3Bucket
        case awsSecretsmanagerSecret
        case awsSnsTopic
        case awsSqsQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsDynamodbStream,
                .awsDynamodbTable,
                .awsEc2Snapshot,
                .awsEcrRepository,
                .awsEfsFilesystem,
                .awsIamRole,
                .awsKmsKey,
                .awsLambdaFunction,
                .awsLambdaLayerversion,
                .awsRdsDbclustersnapshot,
                .awsRdsDbsnapshot,
                .awsS3expressDirectorybucket,
                .awsS3Bucket,
                .awsSecretsmanagerSecret,
                .awsSnsTopic,
                .awsSqsQueue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsDynamodbStream: return "AWS::DynamoDB::Stream"
            case .awsDynamodbTable: return "AWS::DynamoDB::Table"
            case .awsEc2Snapshot: return "AWS::EC2::Snapshot"
            case .awsEcrRepository: return "AWS::ECR::Repository"
            case .awsEfsFilesystem: return "AWS::EFS::FileSystem"
            case .awsIamRole: return "AWS::IAM::Role"
            case .awsKmsKey: return "AWS::KMS::Key"
            case .awsLambdaFunction: return "AWS::Lambda::Function"
            case .awsLambdaLayerversion: return "AWS::Lambda::LayerVersion"
            case .awsRdsDbclustersnapshot: return "AWS::RDS::DBClusterSnapshot"
            case .awsRdsDbsnapshot: return "AWS::RDS::DBSnapshot"
            case .awsS3expressDirectorybucket: return "AWS::S3Express::DirectoryBucket"
            case .awsS3Bucket: return "AWS::S3::Bucket"
            case .awsSecretsmanagerSecret: return "AWS::SecretsManager::Secret"
            case .awsSnsTopic: return "AWS::SNS::Topic"
            case .awsSqsQueue: return "AWS::SQS::Queue"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum FindingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case archived
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .archived,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains details about the analyzed resource.
    public struct AnalyzedResource: Swift.Sendable {
        /// The actions that an external principal is granted permission to use by the policy that generated the finding.
        public var actions: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: Foundation.Date?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// An error message.
        public var error: Swift.String?
        /// Indicates whether the policy that generated the finding grants public access to the resource.
        /// This member is required.
        public var isPublic: Swift.Bool?
        /// The ARN of the resource that was analyzed.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// Indicates how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public var sharedVia: [Swift.String]?
        /// The current status of the finding generated from the analyzed resource.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            actions: [Swift.String]? = nil,
            analyzedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            error: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sharedVia: [Swift.String]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.actions = actions
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.isPublic = isPublic
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sharedVia = sharedVia
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

/// The response to the request.
public struct GetAnalyzedResourceOutput: Swift.Sendable {
    /// An AnalyzedResource object that contains information that IAM Access Analyzer found when it analyzed the resource.
    public var resource: AccessAnalyzerClientTypes.AnalyzedResource?

    public init(
        resource: AccessAnalyzerClientTypes.AnalyzedResource? = nil
    )
    {
        self.resource = resource
    }
}

/// Retrieves a finding.
public struct GetFindingInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) that generated the finding.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ID of the finding to retrieve.
    /// This member is required.
    public var id: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
    }
}

extension AccessAnalyzerClientTypes {

    /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
    public struct FindingSourceDetail: Swift.Sendable {
        /// The account of the cross-account access point that generated the finding.
        public var accessPointAccount: Swift.String?
        /// The ARN of the access point that generated the finding. The ARN format depends on whether the ARN represents an access point or a multi-region access point.
        public var accessPointArn: Swift.String?

        public init(
            accessPointAccount: Swift.String? = nil,
            accessPointArn: Swift.String? = nil
        )
        {
            self.accessPointAccount = accessPointAccount
            self.accessPointArn = accessPointArn
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum FindingSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bucketAcl
        case policy
        case s3AccessPoint
        case s3AccessPointAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingSourceType] {
            return [
                .bucketAcl,
                .policy,
                .s3AccessPoint,
                .s3AccessPointAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bucketAcl: return "BUCKET_ACL"
            case .policy: return "POLICY"
            case .s3AccessPoint: return "S3_ACCESS_POINT"
            case .s3AccessPointAccount: return "S3_ACCESS_POINT_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The source of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
    public struct FindingSource: Swift.Sendable {
        /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public var detail: AccessAnalyzerClientTypes.FindingSourceDetail?
        /// Indicates the type of access that generated the finding.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.FindingSourceType?

        public init(
            detail: AccessAnalyzerClientTypes.FindingSourceDetail? = nil,
            type: AccessAnalyzerClientTypes.FindingSourceType? = nil
        )
        {
            self.detail = detail
            self.type = type
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about a finding.
    public struct Finding: Swift.Sendable {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public var action: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: Foundation.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String: Swift.String]?
        /// The time at which the finding was generated.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// An error.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String: Swift.String]?
        /// The resource that an external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource identified in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The current status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            action: [Swift.String]? = nil,
            analyzedAt: Foundation.Date? = nil,
            condition: [Swift.String: Swift.String]? = nil,
            createdAt: Foundation.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String: Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

/// The response to the request.
public struct GetFindingOutput: Swift.Sendable {
    /// A finding object that contains finding details.
    public var finding: AccessAnalyzerClientTypes.Finding?

    public init(
        finding: AccessAnalyzerClientTypes.Finding? = nil
    )
    {
        self.finding = finding
    }
}

public struct GetFindingRecommendationInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the finding recommendation.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The unique ID for the finding recommendation.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about the reason that the retrieval of a recommendation for a finding failed.
    public struct RecommendationError: Swift.Sendable {
        /// The error code for a failed retrieval of a recommendation for a finding.
        /// This member is required.
        public var code: Swift.String?
        /// The error message for a failed retrieval of a recommendation for a finding.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum RecommendationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case unusedPermissionRecommendation
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .unusedPermissionRecommendation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .unusedPermissionRecommendation: return "UnusedPermissionRecommendation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum RecommendedRemediationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createPolicy
        case detachPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendedRemediationAction] {
            return [
                .createPolicy,
                .detachPolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createPolicy: return "CREATE_POLICY"
            case .detachPolicy: return "DETACH_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about the action to take for a policy in an unused permissions finding.
    public struct UnusedPermissionsRecommendedStep: Swift.Sendable {
        /// If the recommended action for the unused permissions finding is to detach a policy, the ID of an existing policy to be detached.
        public var existingPolicyId: Swift.String?
        /// The time at which the existing policy for the unused permissions finding was last updated.
        public var policyUpdatedAt: Foundation.Date?
        /// A recommendation of whether to create or detach a policy for an unused permissions finding.
        /// This member is required.
        public var recommendedAction: AccessAnalyzerClientTypes.RecommendedRemediationAction?
        /// If the recommended action for the unused permissions finding is to replace the existing policy, the contents of the recommended policy to replace the policy specified in the existingPolicyId field.
        public var recommendedPolicy: Swift.String?

        public init(
            existingPolicyId: Swift.String? = nil,
            policyUpdatedAt: Foundation.Date? = nil,
            recommendedAction: AccessAnalyzerClientTypes.RecommendedRemediationAction? = nil,
            recommendedPolicy: Swift.String? = nil
        )
        {
            self.existingPolicyId = existingPolicyId
            self.policyUpdatedAt = policyUpdatedAt
            self.recommendedAction = recommendedAction
            self.recommendedPolicy = recommendedPolicy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about a recommended step for an unused access analyzer finding.
    public enum RecommendedStep: Swift.Sendable {
        /// A recommended step for an unused permissions finding.
        case unusedpermissionsrecommendedstep(AccessAnalyzerClientTypes.UnusedPermissionsRecommendedStep)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFindingRecommendationOutput: Swift.Sendable {
    /// The time at which the retrieval of the finding recommendation was completed.
    public var completedAt: Foundation.Date?
    /// Detailed information about the reason that the retrieval of a recommendation for the finding failed.
    public var error: AccessAnalyzerClientTypes.RecommendationError?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of recommendation for the finding.
    /// This member is required.
    public var recommendationType: AccessAnalyzerClientTypes.RecommendationType?
    /// A group of recommended steps for the finding.
    public var recommendedSteps: [AccessAnalyzerClientTypes.RecommendedStep]?
    /// The ARN of the resource of the finding.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The time at which the retrieval of the finding recommendation was started.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The status of the retrieval of the finding recommendation.
    /// This member is required.
    public var status: AccessAnalyzerClientTypes.Status?

    public init(
        completedAt: Foundation.Date? = nil,
        error: AccessAnalyzerClientTypes.RecommendationError? = nil,
        nextToken: Swift.String? = nil,
        recommendationType: AccessAnalyzerClientTypes.RecommendationType? = nil,
        recommendedSteps: [AccessAnalyzerClientTypes.RecommendedStep]? = nil,
        resourceArn: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: AccessAnalyzerClientTypes.Status? = nil
    )
    {
        self.completedAt = completedAt
        self.error = error
        self.nextToken = nextToken
        self.recommendationType = recommendationType
        self.recommendedSteps = recommendedSteps
        self.resourceArn = resourceArn
        self.startedAt = startedAt
        self.status = status
    }
}

public struct GetFindingV2Input: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) that generated the finding.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ID of the finding to retrieve.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an external access finding.
    public struct ExternalAccessDetails: Swift.Sendable {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public var action: [Swift.String]?
        /// The condition in the analyzed policy statement that resulted in an external access finding.
        /// This member is required.
        public var condition: [Swift.String: Swift.String]?
        /// Specifies whether the external access finding is public.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String: Swift.String]?
        /// The sources of the external access finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?

        public init(
            action: [Swift.String]? = nil,
            condition: [Swift.String: Swift.String]? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String: Swift.String]? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil
        )
        {
            self.action = action
            self.condition = condition
            self.isPublic = isPublic
            self.principal = principal
            self.sources = sources
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access finding for an IAM role. IAM Access Analyzer charges for unused access analysis based on the number of IAM roles and users analyzed per month. For more details on pricing, see [IAM Access Analyzer pricing](https://aws.amazon.com/iam/access-analyzer/pricing).
    public struct UnusedIamRoleDetails: Swift.Sendable {
        /// The time at which the role was last accessed.
        public var lastAccessed: Foundation.Date?

        public init(
            lastAccessed: Foundation.Date? = nil
        )
        {
            self.lastAccessed = lastAccessed
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access finding for an IAM user access key. IAM Access Analyzer charges for unused access analysis based on the number of IAM roles and users analyzed per month. For more details on pricing, see [IAM Access Analyzer pricing](https://aws.amazon.com/iam/access-analyzer/pricing).
    public struct UnusedIamUserAccessKeyDetails: Swift.Sendable {
        /// The ID of the access key for which the unused access finding was generated.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The time at which the access key was last accessed.
        public var lastAccessed: Foundation.Date?

        public init(
            accessKeyId: Swift.String? = nil,
            lastAccessed: Foundation.Date? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.lastAccessed = lastAccessed
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access finding for an IAM user password. IAM Access Analyzer charges for unused access analysis based on the number of IAM roles and users analyzed per month. For more details on pricing, see [IAM Access Analyzer pricing](https://aws.amazon.com/iam/access-analyzer/pricing).
    public struct UnusedIamUserPasswordDetails: Swift.Sendable {
        /// The time at which the password was last accessed.
        public var lastAccessed: Foundation.Date?

        public init(
            lastAccessed: Foundation.Date? = nil
        )
        {
            self.lastAccessed = lastAccessed
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access finding for an action. IAM Access Analyzer charges for unused access analysis based on the number of IAM roles and users analyzed per month. For more details on pricing, see [IAM Access Analyzer pricing](https://aws.amazon.com/iam/access-analyzer/pricing).
    public struct UnusedAction: Swift.Sendable {
        /// The action for which the unused access finding was generated.
        /// This member is required.
        public var action: Swift.String?
        /// The time at which the action was last accessed.
        public var lastAccessed: Foundation.Date?

        public init(
            action: Swift.String? = nil,
            lastAccessed: Foundation.Date? = nil
        )
        {
            self.action = action
            self.lastAccessed = lastAccessed
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an unused access finding for a permission. IAM Access Analyzer charges for unused access analysis based on the number of IAM roles and users analyzed per month. For more details on pricing, see [IAM Access Analyzer pricing](https://aws.amazon.com/iam/access-analyzer/pricing).
    public struct UnusedPermissionDetails: Swift.Sendable {
        /// A list of unused actions for which the unused access finding was generated.
        public var actions: [AccessAnalyzerClientTypes.UnusedAction]?
        /// The time at which the permission was last accessed.
        public var lastAccessed: Foundation.Date?
        /// The namespace of the Amazon Web Services service that contains the unused actions.
        /// This member is required.
        public var serviceNamespace: Swift.String?

        public init(
            actions: [AccessAnalyzerClientTypes.UnusedAction]? = nil,
            lastAccessed: Foundation.Date? = nil,
            serviceNamespace: Swift.String? = nil
        )
        {
            self.actions = actions
            self.lastAccessed = lastAccessed
            self.serviceNamespace = serviceNamespace
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about an external access or unused access finding. Only one parameter can be used in a FindingDetails object.
    public enum FindingDetails: Swift.Sendable {
        /// The details for an external access analyzer finding.
        case externalaccessdetails(AccessAnalyzerClientTypes.ExternalAccessDetails)
        /// The details for an unused access analyzer finding with an unused permission finding type.
        case unusedpermissiondetails(AccessAnalyzerClientTypes.UnusedPermissionDetails)
        /// The details for an unused access analyzer finding with an unused IAM user access key finding type.
        case unusediamuseraccesskeydetails(AccessAnalyzerClientTypes.UnusedIamUserAccessKeyDetails)
        /// The details for an unused access analyzer finding with an unused IAM role finding type.
        case unusediamroledetails(AccessAnalyzerClientTypes.UnusedIamRoleDetails)
        /// The details for an unused access analyzer finding with an unused IAM user password finding type.
        case unusediamuserpassworddetails(AccessAnalyzerClientTypes.UnusedIamUserPasswordDetails)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    public enum FindingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalAccess
        case unusedIamRole
        case unusedIamUserAccessKey
        case unusedIamUserPassword
        case unusedPermission
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingType] {
            return [
                .externalAccess,
                .unusedIamRole,
                .unusedIamUserAccessKey,
                .unusedIamUserPassword,
                .unusedPermission
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalAccess: return "ExternalAccess"
            case .unusedIamRole: return "UnusedIAMRole"
            case .unusedIamUserAccessKey: return "UnusedIAMUserAccessKey"
            case .unusedIamUserPassword: return "UnusedIAMUserPassword"
            case .unusedPermission: return "UnusedPermission"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFindingV2Output: Swift.Sendable {
    /// The time at which the resource-based policy or IAM entity that generated the finding was analyzed.
    /// This member is required.
    public var analyzedAt: Foundation.Date?
    /// The time at which the finding was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// An error.
    public var error: Swift.String?
    /// A localized message that explains the finding and provides guidance on how to address it.
    /// This member is required.
    public var findingDetails: [AccessAnalyzerClientTypes.FindingDetails]?
    /// The type of the finding. For external access analyzers, the type is ExternalAccess. For unused access analyzers, the type can be UnusedIAMRole, UnusedIAMUserAccessKey, UnusedIAMUserPassword, or UnusedPermission.
    public var findingType: AccessAnalyzerClientTypes.FindingType?
    /// The ID of the finding to retrieve.
    /// This member is required.
    public var id: Swift.String?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The resource that generated the finding.
    public var resource: Swift.String?
    /// Tye Amazon Web Services account ID that owns the resource.
    /// This member is required.
    public var resourceOwnerAccount: Swift.String?
    /// The type of the resource identified in the finding.
    /// This member is required.
    public var resourceType: AccessAnalyzerClientTypes.ResourceType?
    /// The status of the finding.
    /// This member is required.
    public var status: AccessAnalyzerClientTypes.FindingStatus?
    /// The time at which the finding was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        analyzedAt: Foundation.Date? = nil,
        createdAt: Foundation.Date? = nil,
        error: Swift.String? = nil,
        findingDetails: [AccessAnalyzerClientTypes.FindingDetails]? = nil,
        findingType: AccessAnalyzerClientTypes.FindingType? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceOwnerAccount: Swift.String? = nil,
        resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
        status: AccessAnalyzerClientTypes.FindingStatus? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.analyzedAt = analyzedAt
        self.createdAt = createdAt
        self.error = error
        self.findingDetails = findingDetails
        self.findingType = findingType
        self.id = id
        self.nextToken = nextToken
        self.resource = resource
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetGeneratedPolicyInput: Swift.Sendable {
    /// The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies. For example, in the resource section of a policy, you can receive a placeholder such as "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
    public var includeResourcePlaceholders: Swift.Bool?
    /// The level of detail that you want to generate. You can specify whether to generate service-level policies. IAM Access Analyzer uses iam:servicelastaccessed to identify services that have been used recently to create this service-level template.
    public var includeServiceLevelTemplate: Swift.Bool?
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        includeResourcePlaceholders: Swift.Bool? = nil,
        includeServiceLevelTemplate: Swift.Bool? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.includeResourcePlaceholders = includeResourcePlaceholders
        self.includeServiceLevelTemplate = includeServiceLevelTemplate
        self.jobId = jobId
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the text for the generated policy.
    public struct GeneratedPolicy: Swift.Sendable {
        /// The text to use as the content for the new policy. The policy is created using the [CreatePolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html) action.
        /// This member is required.
        public var policy: Swift.String?

        public init(
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct TrailProperties: Swift.Sendable {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init(
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about CloudTrail access.
    public struct CloudTrailProperties: Swift.Sendable {
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// A TrailProperties object that contains settings for trail properties.
        /// This member is required.
        public var trailProperties: [AccessAnalyzerClientTypes.TrailProperties]?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            trailProperties: [AccessAnalyzerClientTypes.TrailProperties]? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.trailProperties = trailProperties
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the generated policy details.
    public struct GeneratedPolicyProperties: Swift.Sendable {
        /// Lists details about the Trail used to generated policy.
        public var cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties?
        /// This value is set to true if the generated policy contains all possible actions for a service that IAM Access Analyzer identified from the CloudTrail trail that you specified, and false otherwise.
        public var isComplete: Swift.Bool?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init(
            cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties? = nil,
            isComplete: Swift.Bool? = nil,
            principalArn: Swift.String? = nil
        )
        {
            self.cloudTrailProperties = cloudTrailProperties
            self.isComplete = isComplete
            self.principalArn = principalArn
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the text for the generated policy and its details.
    public struct GeneratedPolicyResult: Swift.Sendable {
        /// The text to use as the content for the new policy. The policy is created using the [CreatePolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html) action.
        public var generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]?
        /// A GeneratedPolicyProperties object that contains properties of the generated policy.
        /// This member is required.
        public var properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties?

        public init(
            generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]? = nil,
            properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties? = nil
        )
        {
            self.generatedPolicies = generatedPolicies
            self.properties = properties
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum JobErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorizationError
        case resourceNotFoundError
        case serviceError
        case serviceQuotaExceededError
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorCode] {
            return [
                .authorizationError,
                .resourceNotFoundError,
                .serviceError,
                .serviceQuotaExceededError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorizationError: return "AUTHORIZATION_ERROR"
            case .resourceNotFoundError: return "RESOURCE_NOT_FOUND_ERROR"
            case .serviceError: return "SERVICE_ERROR"
            case .serviceQuotaExceededError: return "SERVICE_QUOTA_EXCEEDED_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the details about the policy generation error.
    public struct JobError: Swift.Sendable {
        /// The job error code.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.JobErrorCode?
        /// Specific information about the error. For example, which service quota was exceeded or which resource was not found.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: AccessAnalyzerClientTypes.JobErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains details about the policy generation request.
    public struct JobDetails: Swift.Sendable {
        /// A timestamp of when the job was completed.
        public var completedOn: Foundation.Date?
        /// The job error for the policy generation request.
        public var jobError: AccessAnalyzerClientTypes.JobError?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// A timestamp of when the job was started.
        /// This member is required.
        public var startedOn: Foundation.Date?
        /// The status of the job request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init(
            completedOn: Foundation.Date? = nil,
            jobError: AccessAnalyzerClientTypes.JobError? = nil,
            jobId: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobError = jobError
            self.jobId = jobId
            self.startedOn = startedOn
            self.status = status
        }
    }
}

public struct GetGeneratedPolicyOutput: Swift.Sendable {
    /// A GeneratedPolicyResult object that contains the generated policies and associated details.
    /// This member is required.
    public var generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult?
    /// A GeneratedPolicyDetails object that contains details about the generated policy.
    /// This member is required.
    public var jobDetails: AccessAnalyzerClientTypes.JobDetails?

    public init(
        generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult? = nil,
        jobDetails: AccessAnalyzerClientTypes.JobDetails? = nil
    )
    {
        self.generatedPolicyResult = generatedPolicyResult
        self.jobDetails = jobDetails
    }
}

public struct ListAccessPreviewFindingsInput: Swift.Sendable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// Criteria to filter the returned findings.
    public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AccessAnalyzerClientTypes {

    public enum FindingChangeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case changed
        case new
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingChangeType] {
            return [
                .changed,
                .new,
                .unchanged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .changed: return "CHANGED"
            case .new: return "NEW"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// An access preview finding generated by the access preview.
    public struct AccessPreviewFinding: Swift.Sendable {
        /// The action in the analyzed policy statement that an external principal has permission to perform.
        public var action: [Swift.String]?
        /// Provides context on how the access preview finding compares to existing access identified in IAM Access Analyzer.
        ///
        /// * New - The finding is for newly-introduced access.
        ///
        /// * Unchanged - The preview finding is an existing finding that would remain unchanged.
        ///
        /// * Changed - The preview finding is an existing finding with a change in status.
        ///
        ///
        /// For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        /// This member is required.
        public var changeType: AccessAnalyzerClientTypes.FindingChangeType?
        /// The condition in the analyzed policy statement that resulted in a finding.
        public var condition: [Swift.String: Swift.String]?
        /// The time at which the access preview finding was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// An error.
        public var error: Swift.String?
        /// The existing ID of the finding in IAM Access Analyzer, provided only for existing findings.
        public var existingFindingId: Swift.String?
        /// The existing status of the finding, provided only for existing findings.
        public var existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus?
        /// The ID of the access preview finding. This ID uniquely identifies the element in the list of access preview findings and is not related to the finding ID in Access Analyzer.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String: Swift.String]?
        /// The resource that an external principal has access to. This is the resource associated with the access preview.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that can be accessed in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The preview status of the finding. This is what the status of the finding would be after permissions deployment. For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?

        public init(
            action: [Swift.String]? = nil,
            changeType: AccessAnalyzerClientTypes.FindingChangeType? = nil,
            condition: [Swift.String: Swift.String]? = nil,
            createdAt: Foundation.Date? = nil,
            error: Swift.String? = nil,
            existingFindingId: Swift.String? = nil,
            existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String: Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil
        )
        {
            self.action = action
            self.changeType = changeType
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.existingFindingId = existingFindingId
            self.existingFindingStatus = existingFindingStatus
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
        }
    }
}

public struct ListAccessPreviewFindingsOutput: Swift.Sendable {
    /// A list of access preview findings that match the specified filter criteria.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListAccessPreviewsInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains a summary of information about an access preview.
    public struct AccessPreviewSummary: Swift.Sendable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        /// * Creating - The access preview creation is in progress.
        ///
        /// * Completed - The access preview is complete and previews the findings for external access to the resource.
        ///
        /// * Failed - The access preview creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init(
            analyzerArn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ListAccessPreviewsOutput: Swift.Sendable {
    /// A list of access previews retrieved for the analyzer.
    /// This member is required.
    public var accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviews = accessPreviews
        self.nextToken = nextToken
    }
}

/// Retrieves a list of resources that have been analyzed.
public struct ListAnalyzedResourcesInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve a list of analyzed resources from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of resource.
    public var resourceType: AccessAnalyzerClientTypes.ResourceType?

    public init(
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the ARN of the analyzed resource.
    public struct AnalyzedResourceSummary: Swift.Sendable {
        /// The ARN of the analyzed resource.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?

        public init(
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
        )
        {
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
        }
    }
}

/// The response to the request.
public struct ListAnalyzedResourcesOutput: Swift.Sendable {
    /// A list of resources that were analyzed.
    /// This member is required.
    public var analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzedResources = analyzedResources
        self.nextToken = nextToken
    }
}

extension AccessAnalyzerClientTypes {

    public enum OrderBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// The criteria used to sort.
    public struct SortCriteria: Swift.Sendable {
        /// The name of the attribute to sort on.
        public var attributeName: Swift.String?
        /// The sort order, ascending or descending.
        public var orderBy: AccessAnalyzerClientTypes.OrderBy?

        public init(
            attributeName: Swift.String? = nil,
            orderBy: AccessAnalyzerClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }
}

/// Retrieves a list of findings generated by the specified analyzer.
public struct ListFindingsInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve findings from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A filter to match for the findings to return.
    public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The sort order for the findings returned.
    public var sort: AccessAnalyzerClientTypes.SortCriteria?

    public init(
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: AccessAnalyzerClientTypes.SortCriteria? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about a finding.
    public struct FindingSummary: Swift.Sendable {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public var action: [Swift.String]?
        /// The time at which the resource-based policy that generated the finding was analyzed.
        /// This member is required.
        public var analyzedAt: Foundation.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String: Swift.String]?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The error that resulted in an Error finding.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the finding reports a resource that has a policy that allows public access.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String: Swift.String]?
        /// The resource that the external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that the external principal has access to.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was most recently updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            action: [Swift.String]? = nil,
            analyzedAt: Foundation.Date? = nil,
            condition: [Swift.String: Swift.String]? = nil,
            createdAt: Foundation.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String: Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

/// The response to the request.
public struct ListFindingsOutput: Swift.Sendable {
    /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.FindingSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        findings: [AccessAnalyzerClientTypes.FindingSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListFindingsV2Input: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve findings from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A filter to match for the findings to return.
    public var filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The criteria used to sort.
    public var sort: AccessAnalyzerClientTypes.SortCriteria?

    public init(
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String: AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: AccessAnalyzerClientTypes.SortCriteria? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about a finding.
    public struct FindingSummaryV2: Swift.Sendable {
        /// The time at which the resource-based policy or IAM entity that generated the finding was analyzed.
        /// This member is required.
        public var analyzedAt: Foundation.Date?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The error that resulted in an Error finding.
        public var error: Swift.String?
        /// The type of the external access or unused access finding.
        public var findingType: AccessAnalyzerClientTypes.FindingType?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The resource that the external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that the external principal has access to.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was most recently updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            analyzedAt: Foundation.Date? = nil,
            createdAt: Foundation.Date? = nil,
            error: Swift.String? = nil,
            findingType: AccessAnalyzerClientTypes.FindingType? = nil,
            id: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.findingType = findingType
            self.id = id
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListFindingsV2Output: Swift.Sendable {
    /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.FindingSummaryV2]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        findings: [AccessAnalyzerClientTypes.FindingSummaryV2]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct ListPolicyGenerationsInput: Swift.Sendable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with ListGeneratedPolicies to filter the results to only include results for a specific principal.
    public var principalArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalArn = principalArn
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains details about the policy generation status and properties.
    public struct PolicyGeneration: Swift.Sendable {
        /// A timestamp of when the policy generation was completed.
        public var completedOn: Foundation.Date?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?
        /// A timestamp of when the policy generation started.
        /// This member is required.
        public var startedOn: Foundation.Date?
        /// The status of the policy generation request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init(
            completedOn: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            principalArn: Swift.String? = nil,
            startedOn: Foundation.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobId = jobId
            self.principalArn = principalArn
            self.startedOn = startedOn
            self.status = status
        }
    }
}

public struct ListPolicyGenerationsOutput: Swift.Sendable {
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// A PolicyGeneration object that contains details about the generated policy.
    /// This member is required.
    public var policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]?

    public init(
        nextToken: Swift.String? = nil,
        policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyGenerations = policyGenerations
    }
}

/// Retrieves a list of tags applied to the specified resource.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource to retrieve tags from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

/// The response to the request.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags that are applied to the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct Trail: Swift.Sendable {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init(
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains information about CloudTrail access.
    public struct CloudTrailDetails: Swift.Sendable {
        /// The ARN of the service role that IAM Access Analyzer uses to access your CloudTrail trail and service last accessed information.
        /// This member is required.
        public var accessRole: Swift.String?
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        public var endTime: Foundation.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// A Trail object that contains settings for a trail.
        /// This member is required.
        public var trails: [AccessAnalyzerClientTypes.Trail]?

        public init(
            accessRole: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            trails: [AccessAnalyzerClientTypes.Trail]? = nil
        )
        {
            self.accessRole = accessRole
            self.endTime = endTime
            self.startTime = startTime
            self.trails = trails
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// Contains the ARN details about the IAM entity for which the policy is generated.
    public struct PolicyGenerationDetails: Swift.Sendable {
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init(
            principalArn: Swift.String? = nil
        )
        {
            self.principalArn = principalArn
        }
    }
}

public struct StartPolicyGenerationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// A CloudTrailDetails object that contains details about a Trail that you want to analyze to generate policies.
    public var cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails?
    /// Contains the ARN of the IAM entity (user or role) for which you are generating a policy.
    /// This member is required.
    public var policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails?

    public init(
        clientToken: Swift.String? = nil,
        cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails? = nil,
        policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudTrailDetails = cloudTrailDetails
        self.policyGenerationDetails = policyGenerationDetails
    }
}

public struct StartPolicyGenerationOutput: Swift.Sendable {
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

/// Starts a scan of the policies applied to the specified resource.
public struct StartResourceScanInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to use to scan the policies applied to the specified resource.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to scan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
    public var resourceOwnerAccount: Swift.String?

    public init(
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwnerAccount: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
        self.resourceOwnerAccount = resourceOwnerAccount
    }
}

/// Adds a tag to the specified resource.
public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to add the tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// The response to the request.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Removes a tag from the specified resource.
public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key for the tag to add.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// The response to the request.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AccessAnalyzerClientTypes {

    public enum FindingStatusUpdate: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatusUpdate] {
            return [
                .active,
                .archived
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Updates findings with the new values provided in the request.
public struct UpdateFindingsInput: Swift.Sendable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) that generated the findings to update.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The IDs of the findings to update.
    public var ids: [Swift.String]?
    /// The ARN of the resource identified in the finding.
    public var resourceArn: Swift.String?
    /// The state represents the action to take to update the finding Status. Use ARCHIVE to change an Active finding to an Archived finding. Use ACTIVE to change an Archived finding to an Active finding.
    /// This member is required.
    public var status: AccessAnalyzerClientTypes.FindingStatusUpdate?

    public init(
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ids: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        status: AccessAnalyzerClientTypes.FindingStatusUpdate? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ids = ids
        self.resourceArn = resourceArn
        self.status = status
    }
}

extension AccessAnalyzerClientTypes {

    public enum Locale: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case de
        case en
        case es
        case fr
        case it
        case ja
        case ko
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .de,
                .en,
                .es,
                .fr,
                .it,
                .ja,
                .ko,
                .ptBr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .de: return "DE"
            case .en: return "EN"
            case .es: return "ES"
            case .fr: return "FR"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum PolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case identityPolicy
        case resourcePolicy
        case serviceControlPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .identityPolicy,
                .resourcePolicy,
                .serviceControlPolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .identityPolicy: return "IDENTITY_POLICY"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case .serviceControlPolicy: return "SERVICE_CONTROL_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    public enum ValidatePolicyResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dynamodbTable
        case roleTrust
        case s3AccessPoint
        case s3Bucket
        case s3MultiRegionAccessPoint
        case s3ObjectLambdaAccessPoint
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatePolicyResourceType] {
            return [
                .dynamodbTable,
                .roleTrust,
                .s3AccessPoint,
                .s3Bucket,
                .s3MultiRegionAccessPoint,
                .s3ObjectLambdaAccessPoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamodbTable: return "AWS::DynamoDB::Table"
            case .roleTrust: return "AWS::IAM::AssumeRolePolicyDocument"
            case .s3AccessPoint: return "AWS::S3::AccessPoint"
            case .s3Bucket: return "AWS::S3::Bucket"
            case .s3MultiRegionAccessPoint: return "AWS::S3::MultiRegionAccessPoint"
            case .s3ObjectLambdaAccessPoint: return "AWS::S3ObjectLambda::AccessPoint"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ValidatePolicyInput: Swift.Sendable {
    /// The locale to use for localizing the findings.
    public var locale: AccessAnalyzerClientTypes.Locale?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy. Service control policies (SCPs) are a type of organization policy attached to an Amazon Web Services organization, organizational unit (OU), or an account.
    /// This member is required.
    public var policyType: AccessAnalyzerClientTypes.PolicyType?
    /// The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is RESOURCE_POLICY. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose AWS::S3::Bucket for the policy validation resource type. For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.
    public var validatePolicyResourceType: AccessAnalyzerClientTypes.ValidatePolicyResourceType?

    public init(
        locale: AccessAnalyzerClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyType: AccessAnalyzerClientTypes.PolicyType? = nil,
        validatePolicyResourceType: AccessAnalyzerClientTypes.ValidatePolicyResourceType? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyDocument = policyDocument
        self.policyType = policyType
        self.validatePolicyResourceType = validatePolicyResourceType
    }
}

extension AccessAnalyzerClientTypes {

    public enum ValidatePolicyFindingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case securityWarning
        case suggestion
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatePolicyFindingType] {
            return [
                .error,
                .securityWarning,
                .suggestion,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .securityWarning: return "SECURITY_WARNING"
            case .suggestion: return "SUGGESTION"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A reference to a substring of a literal string in a JSON document.
    public struct Substring: Swift.Sendable {
        /// The length of the substring.
        /// This member is required.
        public var length: Swift.Int?
        /// The start index of the substring, starting from 0.
        /// This member is required.
        public var start: Swift.Int?

        public init(
            length: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.length = length
            self.start = start
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A single element in a path through the JSON representation of a policy.
    public enum PathElement: Swift.Sendable {
        /// Refers to an index in a JSON array.
        case index(Swift.Int)
        /// Refers to a key in a JSON object.
        case key(Swift.String)
        /// Refers to a substring of a literal string in a JSON object.
        case substring(AccessAnalyzerClientTypes.Substring)
        /// Refers to the value associated with a given key in a JSON object.
        case value(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension AccessAnalyzerClientTypes {

    /// A position in a policy.
    public struct Position: Swift.Sendable {
        /// The column of the position, starting from 0.
        /// This member is required.
        public var column: Swift.Int?
        /// The line of the position, starting from 1.
        /// This member is required.
        public var line: Swift.Int?
        /// The offset within the policy that corresponds to the position, starting from 0.
        /// This member is required.
        public var offset: Swift.Int?

        public init(
            column: Swift.Int? = nil,
            line: Swift.Int? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.column = column
            self.line = line
            self.offset = offset
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A span in a policy. The span consists of a start position (inclusive) and end position (exclusive).
    public struct Span: Swift.Sendable {
        /// The end position of the span (exclusive).
        /// This member is required.
        public var end: AccessAnalyzerClientTypes.Position?
        /// The start position of the span (inclusive).
        /// This member is required.
        public var start: AccessAnalyzerClientTypes.Position?

        public init(
            end: AccessAnalyzerClientTypes.Position? = nil,
            start: AccessAnalyzerClientTypes.Position? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A location in a policy that is represented as a path through the JSON representation and a corresponding span.
    public struct Location: Swift.Sendable {
        /// A path in a policy, represented as a sequence of path elements.
        /// This member is required.
        public var path: [AccessAnalyzerClientTypes.PathElement]?
        /// A span in a policy.
        /// This member is required.
        public var span: AccessAnalyzerClientTypes.Span?

        public init(
            path: [AccessAnalyzerClientTypes.PathElement]? = nil,
            span: AccessAnalyzerClientTypes.Span? = nil
        )
        {
            self.path = path
            self.span = span
        }
    }
}

extension AccessAnalyzerClientTypes {

    /// A finding in a policy. Each finding is an actionable recommendation that can be used to improve the policy.
    public struct ValidatePolicyFinding: Swift.Sendable {
        /// A localized message that explains the finding and provides guidance on how to address it.
        /// This member is required.
        public var findingDetails: Swift.String?
        /// The impact of the finding. Security warnings report when the policy allows access that we consider overly permissive. Errors report when a part of the policy is not functional. Warnings report non-security issues when a policy does not conform to policy writing best practices. Suggestions recommend stylistic improvements in the policy that do not impact access.
        /// This member is required.
        public var findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType?
        /// The issue code provides an identifier of the issue associated with this finding.
        /// This member is required.
        public var issueCode: Swift.String?
        /// A link to additional documentation about the type of finding.
        /// This member is required.
        public var learnMoreLink: Swift.String?
        /// The list of locations in the policy document that are related to the finding. The issue code provides a summary of an issue identified by the finding.
        /// This member is required.
        public var locations: [AccessAnalyzerClientTypes.Location]?

        public init(
            findingDetails: Swift.String? = nil,
            findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType? = nil,
            issueCode: Swift.String? = nil,
            learnMoreLink: Swift.String? = nil,
            locations: [AccessAnalyzerClientTypes.Location]? = nil
        )
        {
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.issueCode = issueCode
            self.learnMoreLink = learnMoreLink
            self.locations = locations
        }
    }
}

public struct ValidatePolicyOutput: Swift.Sendable {
    /// The list of findings in a policy returned by IAM Access Analyzer based on its suite of policy checks.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init(
        findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

extension ApplyArchiveRuleInput {

    static func urlPathProvider(_ value: ApplyArchiveRuleInput) -> Swift.String? {
        return "/archive-rule"
    }
}

extension CancelPolicyGenerationInput {

    static func urlPathProvider(_ value: CancelPolicyGenerationInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/policy/generation/\(jobId.urlPercentEncoding())"
    }
}

extension CheckAccessNotGrantedInput {

    static func urlPathProvider(_ value: CheckAccessNotGrantedInput) -> Swift.String? {
        return "/policy/check-access-not-granted"
    }
}

extension CheckNoNewAccessInput {

    static func urlPathProvider(_ value: CheckNoNewAccessInput) -> Swift.String? {
        return "/policy/check-no-new-access"
    }
}

extension CheckNoPublicAccessInput {

    static func urlPathProvider(_ value: CheckNoPublicAccessInput) -> Swift.String? {
        return "/policy/check-no-public-access"
    }
}

extension CreateAccessPreviewInput {

    static func urlPathProvider(_ value: CreateAccessPreviewInput) -> Swift.String? {
        return "/access-preview"
    }
}

extension CreateAnalyzerInput {

    static func urlPathProvider(_ value: CreateAnalyzerInput) -> Swift.String? {
        return "/analyzer"
    }
}

extension CreateArchiveRuleInput {

    static func urlPathProvider(_ value: CreateArchiveRuleInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
    }
}

extension DeleteAnalyzerInput {

    static func urlPathProvider(_ value: DeleteAnalyzerInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())"
    }
}

extension DeleteAnalyzerInput {

    static func queryItemProvider(_ value: DeleteAnalyzerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteArchiveRuleInput {

    static func urlPathProvider(_ value: DeleteArchiveRuleInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

extension DeleteArchiveRuleInput {

    static func queryItemProvider(_ value: DeleteArchiveRuleInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension GenerateFindingRecommendationInput {

    static func urlPathProvider(_ value: GenerateFindingRecommendationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/recommendation/\(id.urlPercentEncoding())"
    }
}

extension GenerateFindingRecommendationInput {

    static func queryItemProvider(_ value: GenerateFindingRecommendationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetAccessPreviewInput {

    static func urlPathProvider(_ value: GetAccessPreviewInput) -> Swift.String? {
        guard let accessPreviewId = value.accessPreviewId else {
            return nil
        }
        return "/access-preview/\(accessPreviewId.urlPercentEncoding())"
    }
}

extension GetAccessPreviewInput {

    static func queryItemProvider(_ value: GetAccessPreviewInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetAnalyzedResourceInput {

    static func urlPathProvider(_ value: GetAnalyzedResourceInput) -> Swift.String? {
        return "/analyzed-resource"
    }
}

extension GetAnalyzedResourceInput {

    static func queryItemProvider(_ value: GetAnalyzedResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetAnalyzerInput {

    static func urlPathProvider(_ value: GetAnalyzerInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())"
    }
}

extension GetArchiveRuleInput {

    static func urlPathProvider(_ value: GetArchiveRuleInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

extension GetFindingInput {

    static func urlPathProvider(_ value: GetFindingInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/finding/\(id.urlPercentEncoding())"
    }
}

extension GetFindingInput {

    static func queryItemProvider(_ value: GetFindingInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetFindingRecommendationInput {

    static func urlPathProvider(_ value: GetFindingRecommendationInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/recommendation/\(id.urlPercentEncoding())"
    }
}

extension GetFindingRecommendationInput {

    static func queryItemProvider(_ value: GetFindingRecommendationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetFindingV2Input {

    static func urlPathProvider(_ value: GetFindingV2Input) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/findingv2/\(id.urlPercentEncoding())"
    }
}

extension GetFindingV2Input {

    static func queryItemProvider(_ value: GetFindingV2Input) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension GetGeneratedPolicyInput {

    static func urlPathProvider(_ value: GetGeneratedPolicyInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/policy/generation/\(jobId.urlPercentEncoding())"
    }
}

extension GetGeneratedPolicyInput {

    static func queryItemProvider(_ value: GetGeneratedPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeResourcePlaceholders = value.includeResourcePlaceholders {
            let includeResourcePlaceholdersQueryItem = Smithy.URIQueryItem(name: "includeResourcePlaceholders".urlPercentEncoding(), value: Swift.String(includeResourcePlaceholders).urlPercentEncoding())
            items.append(includeResourcePlaceholdersQueryItem)
        }
        if let includeServiceLevelTemplate = value.includeServiceLevelTemplate {
            let includeServiceLevelTemplateQueryItem = Smithy.URIQueryItem(name: "includeServiceLevelTemplate".urlPercentEncoding(), value: Swift.String(includeServiceLevelTemplate).urlPercentEncoding())
            items.append(includeServiceLevelTemplateQueryItem)
        }
        return items
    }
}

extension ListAccessPreviewFindingsInput {

    static func urlPathProvider(_ value: ListAccessPreviewFindingsInput) -> Swift.String? {
        guard let accessPreviewId = value.accessPreviewId else {
            return nil
        }
        return "/access-preview/\(accessPreviewId.urlPercentEncoding())"
    }
}

extension ListAccessPreviewsInput {

    static func urlPathProvider(_ value: ListAccessPreviewsInput) -> Swift.String? {
        return "/access-preview"
    }
}

extension ListAccessPreviewsInput {

    static func queryItemProvider(_ value: ListAccessPreviewsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let analyzerArn = value.analyzerArn else {
            let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let analyzerArnQueryItem = Smithy.URIQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
        items.append(analyzerArnQueryItem)
        return items
    }
}

extension ListAnalyzedResourcesInput {

    static func urlPathProvider(_ value: ListAnalyzedResourcesInput) -> Swift.String? {
        return "/analyzed-resource"
    }
}

extension ListAnalyzersInput {

    static func urlPathProvider(_ value: ListAnalyzersInput) -> Swift.String? {
        return "/analyzer"
    }
}

extension ListAnalyzersInput {

    static func queryItemProvider(_ value: ListAnalyzersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListArchiveRulesInput {

    static func urlPathProvider(_ value: ListArchiveRulesInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
    }
}

extension ListArchiveRulesInput {

    static func queryItemProvider(_ value: ListArchiveRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFindingsInput {

    static func urlPathProvider(_ value: ListFindingsInput) -> Swift.String? {
        return "/finding"
    }
}

extension ListFindingsV2Input {

    static func urlPathProvider(_ value: ListFindingsV2Input) -> Swift.String? {
        return "/findingv2"
    }
}

extension ListPolicyGenerationsInput {

    static func urlPathProvider(_ value: ListPolicyGenerationsInput) -> Swift.String? {
        return "/policy/generation"
    }
}

extension ListPolicyGenerationsInput {

    static func queryItemProvider(_ value: ListPolicyGenerationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let principalArn = value.principalArn {
            let principalArnQueryItem = Smithy.URIQueryItem(name: "principalArn".urlPercentEncoding(), value: Swift.String(principalArn).urlPercentEncoding())
            items.append(principalArnQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartPolicyGenerationInput {

    static func urlPathProvider(_ value: StartPolicyGenerationInput) -> Swift.String? {
        return "/policy/generation"
    }
}

extension StartResourceScanInput {

    static func urlPathProvider(_ value: StartResourceScanInput) -> Swift.String? {
        return "/resource/scan"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateArchiveRuleInput {

    static func urlPathProvider(_ value: UpdateArchiveRuleInput) -> Swift.String? {
        guard let analyzerName = value.analyzerName else {
            return nil
        }
        guard let ruleName = value.ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

extension UpdateFindingsInput {

    static func urlPathProvider(_ value: UpdateFindingsInput) -> Swift.String? {
        return "/finding"
    }
}

extension ValidatePolicyInput {

    static func urlPathProvider(_ value: ValidatePolicyInput) -> Swift.String? {
        return "/policy/validation"
    }
}

extension ValidatePolicyInput {

    static func queryItemProvider(_ value: ValidatePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ApplyArchiveRuleInput {

    static func write(value: ApplyArchiveRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["ruleName"].write(value.ruleName)
    }
}

extension CheckAccessNotGrantedInput {

    static func write(value: CheckAccessNotGrantedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["access"].writeList(value.access, memberWritingClosure: AccessAnalyzerClientTypes.Access.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["policyDocument"].write(value.policyDocument)
        try writer["policyType"].write(value.policyType)
    }
}

extension CheckNoNewAccessInput {

    static func write(value: CheckNoNewAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["existingPolicyDocument"].write(value.existingPolicyDocument)
        try writer["newPolicyDocument"].write(value.newPolicyDocument)
        try writer["policyType"].write(value.policyType)
    }
}

extension CheckNoPublicAccessInput {

    static func write(value: CheckNoPublicAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyDocument"].write(value.policyDocument)
        try writer["resourceType"].write(value.resourceType)
    }
}

extension CreateAccessPreviewInput {

    static func write(value: CreateAccessPreviewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["configurations"].writeMap(value.configurations, valueWritingClosure: AccessAnalyzerClientTypes.Configuration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAnalyzerInput {

    static func write(value: CreateAnalyzerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerName"].write(value.analyzerName)
        try writer["archiveRules"].writeList(value.archiveRules, memberWritingClosure: AccessAnalyzerClientTypes.InlineArchiveRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: AccessAnalyzerClientTypes.AnalyzerConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateArchiveRuleInput {

    static func write(value: CreateArchiveRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ruleName"].write(value.ruleName)
    }
}

extension ListAccessPreviewFindingsInput {

    static func write(value: ListAccessPreviewFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAnalyzedResourcesInput {

    static func write(value: ListAnalyzedResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceType"].write(value.resourceType)
    }
}

extension ListFindingsInput {

    static func write(value: ListFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort, with: AccessAnalyzerClientTypes.SortCriteria.write(value:to:))
    }
}

extension ListFindingsV2Input {

    static func write(value: ListFindingsV2Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort, with: AccessAnalyzerClientTypes.SortCriteria.write(value:to:))
    }
}

extension StartPolicyGenerationInput {

    static func write(value: StartPolicyGenerationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["cloudTrailDetails"].write(value.cloudTrailDetails, with: AccessAnalyzerClientTypes.CloudTrailDetails.write(value:to:))
        try writer["policyGenerationDetails"].write(value.policyGenerationDetails, with: AccessAnalyzerClientTypes.PolicyGenerationDetails.write(value:to:))
    }
}

extension StartResourceScanInput {

    static func write(value: StartResourceScanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceOwnerAccount"].write(value.resourceOwnerAccount)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateArchiveRuleInput {

    static func write(value: UpdateArchiveRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateFindingsInput {

    static func write(value: UpdateFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyzerArn"].write(value.analyzerArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["status"].write(value.status)
    }
}

extension ValidatePolicyInput {

    static func write(value: ValidatePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["locale"].write(value.locale)
        try writer["policyDocument"].write(value.policyDocument)
        try writer["policyType"].write(value.policyType)
        try writer["validatePolicyResourceType"].write(value.validatePolicyResourceType)
    }
}

extension ApplyArchiveRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApplyArchiveRuleOutput {
        return ApplyArchiveRuleOutput()
    }
}

extension CancelPolicyGenerationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelPolicyGenerationOutput {
        return CancelPolicyGenerationOutput()
    }
}

extension CheckAccessNotGrantedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckAccessNotGrantedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckAccessNotGrantedOutput()
        value.message = try reader["message"].readIfPresent()
        value.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ReasonSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.result = try reader["result"].readIfPresent()
        return value
    }
}

extension CheckNoNewAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckNoNewAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckNoNewAccessOutput()
        value.message = try reader["message"].readIfPresent()
        value.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ReasonSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.result = try reader["result"].readIfPresent()
        return value
    }
}

extension CheckNoPublicAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckNoPublicAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CheckNoPublicAccessOutput()
        value.message = try reader["message"].readIfPresent()
        value.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ReasonSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.result = try reader["result"].readIfPresent()
        return value
    }
}

extension CreateAccessPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessPreviewOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAnalyzerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnalyzerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnalyzerOutput()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension CreateArchiveRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateArchiveRuleOutput {
        return CreateArchiveRuleOutput()
    }
}

extension DeleteAnalyzerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnalyzerOutput {
        return DeleteAnalyzerOutput()
    }
}

extension DeleteArchiveRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteArchiveRuleOutput {
        return DeleteArchiveRuleOutput()
    }
}

extension GenerateFindingRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateFindingRecommendationOutput {
        return GenerateFindingRecommendationOutput()
    }
}

extension GetAccessPreviewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessPreviewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessPreviewOutput()
        value.accessPreview = try reader["accessPreview"].readIfPresent(with: AccessAnalyzerClientTypes.AccessPreview.read(from:))
        return value
    }
}

extension GetAnalyzedResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnalyzedResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnalyzedResourceOutput()
        value.resource = try reader["resource"].readIfPresent(with: AccessAnalyzerClientTypes.AnalyzedResource.read(from:))
        return value
    }
}

extension GetAnalyzerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnalyzerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnalyzerOutput()
        value.analyzer = try reader["analyzer"].readIfPresent(with: AccessAnalyzerClientTypes.AnalyzerSummary.read(from:))
        return value
    }
}

extension GetArchiveRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetArchiveRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetArchiveRuleOutput()
        value.archiveRule = try reader["archiveRule"].readIfPresent(with: AccessAnalyzerClientTypes.ArchiveRuleSummary.read(from:))
        return value
    }
}

extension GetFindingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingOutput()
        value.finding = try reader["finding"].readIfPresent(with: AccessAnalyzerClientTypes.Finding.read(from:))
        return value
    }
}

extension GetFindingRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingRecommendationOutput()
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.error = try reader["error"].readIfPresent(with: AccessAnalyzerClientTypes.RecommendationError.read(from:))
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendationType = try reader["recommendationType"].readIfPresent() ?? .sdkUnknown("")
        value.recommendedSteps = try reader["recommendedSteps"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.RecommendedStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetFindingV2Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingV2Output()
        value.analyzedAt = try reader["analyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.error = try reader["error"].readIfPresent()
        value.findingDetails = try reader["findingDetails"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingDetails.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.findingType = try reader["findingType"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent()
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetGeneratedPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGeneratedPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGeneratedPolicyOutput()
        value.generatedPolicyResult = try reader["generatedPolicyResult"].readIfPresent(with: AccessAnalyzerClientTypes.GeneratedPolicyResult.read(from:))
        value.jobDetails = try reader["jobDetails"].readIfPresent(with: AccessAnalyzerClientTypes.JobDetails.read(from:))
        return value
    }
}

extension ListAccessPreviewFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessPreviewFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessPreviewFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.AccessPreviewFinding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAccessPreviewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessPreviewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessPreviewsOutput()
        value.accessPreviews = try reader["accessPreviews"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.AccessPreviewSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAnalyzedResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalyzedResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalyzedResourcesOutput()
        value.analyzedResources = try reader["analyzedResources"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.AnalyzedResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAnalyzersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalyzersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalyzersOutput()
        value.analyzers = try reader["analyzers"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.AnalyzerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListArchiveRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArchiveRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArchiveRulesOutput()
        value.archiveRules = try reader["archiveRules"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ArchiveRuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFindingsV2Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingsV2Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingsV2Output()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSummaryV2.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPolicyGenerationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyGenerationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyGenerationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.policyGenerations = try reader["policyGenerations"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.PolicyGeneration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartPolicyGenerationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartPolicyGenerationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartPolicyGenerationOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        return value
    }
}

extension StartResourceScanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartResourceScanOutput {
        return StartResourceScanOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateArchiveRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateArchiveRuleOutput {
        return UpdateArchiveRuleOutput()
    }
}

extension UpdateFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFindingsOutput {
        return UpdateFindingsOutput()
    }
}

extension ValidatePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidatePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidatePolicyOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ValidatePolicyFinding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

enum ApplyArchiveRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelPolicyGenerationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckAccessNotGrantedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckNoNewAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckNoPublicAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnprocessableEntityException": return try UnprocessableEntityException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAnalyzerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateArchiveRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnalyzerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteArchiveRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateFindingRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessPreviewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnalyzedResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnalyzerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetArchiveRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingV2OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGeneratedPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessPreviewFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessPreviewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalyzedResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalyzersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArchiveRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingsV2OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyGenerationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartPolicyGenerationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartResourceScanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateArchiveRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidatePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnprocessableEntityException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnprocessableEntityException {
        let reader = baseError.errorBodyReader
        var value = UnprocessableEntityException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessAnalyzerClientTypes.ReasonSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.ReasonSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.ReasonSummary()
        value.description = try reader["description"].readIfPresent()
        value.statementIndex = try reader["statementIndex"].readIfPresent()
        value.statementId = try reader["statementId"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.AccessPreview {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AccessPreview {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AccessPreview()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.analyzerArn = try reader["analyzerArn"].readIfPresent() ?? ""
        value.configurations = try reader["configurations"].readMapIfPresent(valueReadingClosure: AccessAnalyzerClientTypes.Configuration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent(with: AccessAnalyzerClientTypes.AccessPreviewStatusReason.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AccessPreviewStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AccessPreviewStatusReason()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AccessAnalyzerClientTypes.Configuration {

    static func write(value: AccessAnalyzerClientTypes.Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .dynamodbstream(dynamodbstream):
                try writer["dynamodbStream"].write(dynamodbstream, with: AccessAnalyzerClientTypes.DynamodbStreamConfiguration.write(value:to:))
            case let .dynamodbtable(dynamodbtable):
                try writer["dynamodbTable"].write(dynamodbtable, with: AccessAnalyzerClientTypes.DynamodbTableConfiguration.write(value:to:))
            case let .ebssnapshot(ebssnapshot):
                try writer["ebsSnapshot"].write(ebssnapshot, with: AccessAnalyzerClientTypes.EbsSnapshotConfiguration.write(value:to:))
            case let .ecrrepository(ecrrepository):
                try writer["ecrRepository"].write(ecrrepository, with: AccessAnalyzerClientTypes.EcrRepositoryConfiguration.write(value:to:))
            case let .efsfilesystem(efsfilesystem):
                try writer["efsFileSystem"].write(efsfilesystem, with: AccessAnalyzerClientTypes.EfsFileSystemConfiguration.write(value:to:))
            case let .iamrole(iamrole):
                try writer["iamRole"].write(iamrole, with: AccessAnalyzerClientTypes.IamRoleConfiguration.write(value:to:))
            case let .kmskey(kmskey):
                try writer["kmsKey"].write(kmskey, with: AccessAnalyzerClientTypes.KmsKeyConfiguration.write(value:to:))
            case let .rdsdbclustersnapshot(rdsdbclustersnapshot):
                try writer["rdsDbClusterSnapshot"].write(rdsdbclustersnapshot, with: AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration.write(value:to:))
            case let .rdsdbsnapshot(rdsdbsnapshot):
                try writer["rdsDbSnapshot"].write(rdsdbsnapshot, with: AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration.write(value:to:))
            case let .s3bucket(s3bucket):
                try writer["s3Bucket"].write(s3bucket, with: AccessAnalyzerClientTypes.S3BucketConfiguration.write(value:to:))
            case let .s3expressdirectorybucket(s3expressdirectorybucket):
                try writer["s3ExpressDirectoryBucket"].write(s3expressdirectorybucket, with: AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration.write(value:to:))
            case let .secretsmanagersecret(secretsmanagersecret):
                try writer["secretsManagerSecret"].write(secretsmanagersecret, with: AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration.write(value:to:))
            case let .snstopic(snstopic):
                try writer["snsTopic"].write(snstopic, with: AccessAnalyzerClientTypes.SnsTopicConfiguration.write(value:to:))
            case let .sqsqueue(sqsqueue):
                try writer["sqsQueue"].write(sqsqueue, with: AccessAnalyzerClientTypes.SqsQueueConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ebsSnapshot":
                return .ebssnapshot(try reader["ebsSnapshot"].read(with: AccessAnalyzerClientTypes.EbsSnapshotConfiguration.read(from:)))
            case "ecrRepository":
                return .ecrrepository(try reader["ecrRepository"].read(with: AccessAnalyzerClientTypes.EcrRepositoryConfiguration.read(from:)))
            case "iamRole":
                return .iamrole(try reader["iamRole"].read(with: AccessAnalyzerClientTypes.IamRoleConfiguration.read(from:)))
            case "efsFileSystem":
                return .efsfilesystem(try reader["efsFileSystem"].read(with: AccessAnalyzerClientTypes.EfsFileSystemConfiguration.read(from:)))
            case "kmsKey":
                return .kmskey(try reader["kmsKey"].read(with: AccessAnalyzerClientTypes.KmsKeyConfiguration.read(from:)))
            case "rdsDbClusterSnapshot":
                return .rdsdbclustersnapshot(try reader["rdsDbClusterSnapshot"].read(with: AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration.read(from:)))
            case "rdsDbSnapshot":
                return .rdsdbsnapshot(try reader["rdsDbSnapshot"].read(with: AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration.read(from:)))
            case "secretsManagerSecret":
                return .secretsmanagersecret(try reader["secretsManagerSecret"].read(with: AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration.read(from:)))
            case "s3Bucket":
                return .s3bucket(try reader["s3Bucket"].read(with: AccessAnalyzerClientTypes.S3BucketConfiguration.read(from:)))
            case "snsTopic":
                return .snstopic(try reader["snsTopic"].read(with: AccessAnalyzerClientTypes.SnsTopicConfiguration.read(from:)))
            case "sqsQueue":
                return .sqsqueue(try reader["sqsQueue"].read(with: AccessAnalyzerClientTypes.SqsQueueConfiguration.read(from:)))
            case "s3ExpressDirectoryBucket":
                return .s3expressdirectorybucket(try reader["s3ExpressDirectoryBucket"].read(with: AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration.read(from:)))
            case "dynamodbStream":
                return .dynamodbstream(try reader["dynamodbStream"].read(with: AccessAnalyzerClientTypes.DynamodbStreamConfiguration.read(from:)))
            case "dynamodbTable":
                return .dynamodbtable(try reader["dynamodbTable"].read(with: AccessAnalyzerClientTypes.DynamodbTableConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.DynamodbTableConfiguration {

    static func write(value: AccessAnalyzerClientTypes.DynamodbTableConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tablePolicy"].write(value.tablePolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.DynamodbTableConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.DynamodbTableConfiguration()
        value.tablePolicy = try reader["tablePolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.DynamodbStreamConfiguration {

    static func write(value: AccessAnalyzerClientTypes.DynamodbStreamConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["streamPolicy"].write(value.streamPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.DynamodbStreamConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.DynamodbStreamConfiguration()
        value.streamPolicy = try reader["streamPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration {

    static func write(value: AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketPolicy"].write(value.bucketPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.S3ExpressDirectoryBucketConfiguration()
        value.bucketPolicy = try reader["bucketPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.SqsQueueConfiguration {

    static func write(value: AccessAnalyzerClientTypes.SqsQueueConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queuePolicy"].write(value.queuePolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.SqsQueueConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.SqsQueueConfiguration()
        value.queuePolicy = try reader["queuePolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.SnsTopicConfiguration {

    static func write(value: AccessAnalyzerClientTypes.SnsTopicConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["topicPolicy"].write(value.topicPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.SnsTopicConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.SnsTopicConfiguration()
        value.topicPolicy = try reader["topicPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.S3BucketConfiguration {

    static func write(value: AccessAnalyzerClientTypes.S3BucketConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessPoints"].writeMap(value.accessPoints, valueWritingClosure: AccessAnalyzerClientTypes.S3AccessPointConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["bucketAclGrants"].writeList(value.bucketAclGrants, memberWritingClosure: AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["bucketPolicy"].write(value.bucketPolicy)
        try writer["bucketPublicAccessBlock"].write(value.bucketPublicAccessBlock, with: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.S3BucketConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.S3BucketConfiguration()
        value.bucketPolicy = try reader["bucketPolicy"].readIfPresent()
        value.bucketAclGrants = try reader["bucketAclGrants"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bucketPublicAccessBlock = try reader["bucketPublicAccessBlock"].readIfPresent(with: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.read(from:))
        value.accessPoints = try reader["accessPoints"].readMapIfPresent(valueReadingClosure: AccessAnalyzerClientTypes.S3AccessPointConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.S3AccessPointConfiguration {

    static func write(value: AccessAnalyzerClientTypes.S3AccessPointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessPointPolicy"].write(value.accessPointPolicy)
        try writer["networkOrigin"].write(value.networkOrigin, with: AccessAnalyzerClientTypes.NetworkOriginConfiguration.write(value:to:))
        try writer["publicAccessBlock"].write(value.publicAccessBlock, with: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.S3AccessPointConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.S3AccessPointConfiguration()
        value.accessPointPolicy = try reader["accessPointPolicy"].readIfPresent()
        value.publicAccessBlock = try reader["publicAccessBlock"].readIfPresent(with: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.read(from:))
        value.networkOrigin = try reader["networkOrigin"].readIfPresent(with: AccessAnalyzerClientTypes.NetworkOriginConfiguration.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.NetworkOriginConfiguration {

    static func write(value: AccessAnalyzerClientTypes.NetworkOriginConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .internetconfiguration(internetconfiguration):
                try writer["internetConfiguration"].write(internetconfiguration, with: AccessAnalyzerClientTypes.InternetConfiguration.write(value:to:))
            case let .vpcconfiguration(vpcconfiguration):
                try writer["vpcConfiguration"].write(vpcconfiguration, with: AccessAnalyzerClientTypes.VpcConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.NetworkOriginConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "vpcConfiguration":
                return .vpcconfiguration(try reader["vpcConfiguration"].read(with: AccessAnalyzerClientTypes.VpcConfiguration.read(from:)))
            case "internetConfiguration":
                return .internetconfiguration(try reader["internetConfiguration"].read(with: AccessAnalyzerClientTypes.InternetConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.InternetConfiguration {

    static func write(value: AccessAnalyzerClientTypes.InternetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.InternetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return AccessAnalyzerClientTypes.InternetConfiguration()
    }
}

extension AccessAnalyzerClientTypes.VpcConfiguration {

    static func write(value: AccessAnalyzerClientTypes.VpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.VpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.VpcConfiguration()
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration {

    static func write(value: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ignorePublicAcls"].write(value.ignorePublicAcls)
        try writer["restrictPublicBuckets"].write(value.restrictPublicBuckets)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration()
        value.ignorePublicAcls = try reader["ignorePublicAcls"].readIfPresent() ?? false
        value.restrictPublicBuckets = try reader["restrictPublicBuckets"].readIfPresent() ?? false
        return value
    }
}

extension AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration {

    static func write(value: AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grantee"].write(value.grantee, with: AccessAnalyzerClientTypes.AclGrantee.write(value:to:))
        try writer["permission"].write(value.permission)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration()
        value.permission = try reader["permission"].readIfPresent() ?? .sdkUnknown("")
        value.grantee = try reader["grantee"].readIfPresent(with: AccessAnalyzerClientTypes.AclGrantee.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.AclGrantee {

    static func write(value: AccessAnalyzerClientTypes.AclGrantee?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .id(id):
                try writer["id"].write(id)
            case let .uri(uri):
                try writer["uri"].write(uri)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AclGrantee {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "id":
                return .id(try reader["id"].read())
            case "uri":
                return .uri(try reader["uri"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration {

    static func write(value: AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["secretPolicy"].write(value.secretPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.secretPolicy = try reader["secretPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration {

    static func write(value: AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue {

    static func write(value: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accountids(accountids):
                try writer["accountIds"].writeList(accountids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accountIds":
                return .accountids(try reader["accountIds"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration {

    static func write(value: AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue {

    static func write(value: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accountids(accountids):
                try writer["accountIds"].writeList(accountids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accountIds":
                return .accountids(try reader["accountIds"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.KmsKeyConfiguration {

    static func write(value: AccessAnalyzerClientTypes.KmsKeyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grants"].writeList(value.grants, memberWritingClosure: AccessAnalyzerClientTypes.KmsGrantConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["keyPolicies"].writeMap(value.keyPolicies, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.KmsKeyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.KmsKeyConfiguration()
        value.keyPolicies = try reader["keyPolicies"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.grants = try reader["grants"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.KmsGrantConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConfiguration {

    static func write(value: AccessAnalyzerClientTypes.KmsGrantConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["constraints"].write(value.constraints, with: AccessAnalyzerClientTypes.KmsGrantConstraints.write(value:to:))
        try writer["granteePrincipal"].write(value.granteePrincipal)
        try writer["issuingAccount"].write(value.issuingAccount)
        try writer["operations"].writeList(value.operations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<AccessAnalyzerClientTypes.KmsGrantOperation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["retiringPrincipal"].write(value.retiringPrincipal)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.KmsGrantConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.KmsGrantConfiguration()
        value.operations = try reader["operations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<AccessAnalyzerClientTypes.KmsGrantOperation>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.granteePrincipal = try reader["granteePrincipal"].readIfPresent() ?? ""
        value.retiringPrincipal = try reader["retiringPrincipal"].readIfPresent()
        value.constraints = try reader["constraints"].readIfPresent(with: AccessAnalyzerClientTypes.KmsGrantConstraints.read(from:))
        value.issuingAccount = try reader["issuingAccount"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConstraints {

    static func write(value: AccessAnalyzerClientTypes.KmsGrantConstraints?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionContextEquals"].writeMap(value.encryptionContextEquals, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["encryptionContextSubset"].writeMap(value.encryptionContextSubset, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.KmsGrantConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.KmsGrantConstraints()
        value.encryptionContextEquals = try reader["encryptionContextEquals"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.encryptionContextSubset = try reader["encryptionContextSubset"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.EfsFileSystemConfiguration {

    static func write(value: AccessAnalyzerClientTypes.EfsFileSystemConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileSystemPolicy"].write(value.fileSystemPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.EfsFileSystemConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.EfsFileSystemConfiguration()
        value.fileSystemPolicy = try reader["fileSystemPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.IamRoleConfiguration {

    static func write(value: AccessAnalyzerClientTypes.IamRoleConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["trustPolicy"].write(value.trustPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.IamRoleConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.IamRoleConfiguration()
        value.trustPolicy = try reader["trustPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.EcrRepositoryConfiguration {

    static func write(value: AccessAnalyzerClientTypes.EcrRepositoryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["repositoryPolicy"].write(value.repositoryPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.EcrRepositoryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.EcrRepositoryConfiguration()
        value.repositoryPolicy = try reader["repositoryPolicy"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.EbsSnapshotConfiguration {

    static func write(value: AccessAnalyzerClientTypes.EbsSnapshotConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["userIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.EbsSnapshotConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.EbsSnapshotConfiguration()
        value.userIds = try reader["userIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.groups = try reader["groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResource {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AnalyzedResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AnalyzedResource()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.analyzedAt = try reader["analyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.isPublic = try reader["isPublic"].readIfPresent() ?? false
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sharedVia = try reader["sharedVia"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.AnalyzerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AnalyzerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AnalyzerSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastResourceAnalyzed = try reader["lastResourceAnalyzed"].readIfPresent()
        value.lastResourceAnalyzedAt = try reader["lastResourceAnalyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent(with: AccessAnalyzerClientTypes.StatusReason.read(from:))
        value.configuration = try reader["configuration"].readIfPresent(with: AccessAnalyzerClientTypes.AnalyzerConfiguration.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.AnalyzerConfiguration {

    static func write(value: AccessAnalyzerClientTypes.AnalyzerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .unusedaccess(unusedaccess):
                try writer["unusedAccess"].write(unusedaccess, with: AccessAnalyzerClientTypes.UnusedAccessConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AnalyzerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "unusedAccess":
                return .unusedaccess(try reader["unusedAccess"].read(with: AccessAnalyzerClientTypes.UnusedAccessConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.UnusedAccessConfiguration {

    static func write(value: AccessAnalyzerClientTypes.UnusedAccessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["unusedAccessAge"].write(value.unusedAccessAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedAccessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedAccessConfiguration()
        value.unusedAccessAge = try reader["unusedAccessAge"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.StatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.StatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.StatusReason()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AccessAnalyzerClientTypes.ArchiveRuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.ArchiveRuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.ArchiveRuleSummary()
        value.ruleName = try reader["ruleName"].readIfPresent() ?? ""
        value.filter = try reader["filter"].readMapIfPresent(valueReadingClosure: AccessAnalyzerClientTypes.Criterion.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AccessAnalyzerClientTypes.Criterion {

    static func write(value: AccessAnalyzerClientTypes.Criterion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contains"].writeList(value.contains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eq"].writeList(value.eq, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["exists"].write(value.exists)
        try writer["neq"].writeList(value.neq, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Criterion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Criterion()
        value.eq = try reader["eq"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.neq = try reader["neq"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.contains = try reader["contains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exists = try reader["exists"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.Finding {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Finding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Finding()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.principal = try reader["principal"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.action = try reader["action"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resource = try reader["resource"].readIfPresent()
        value.isPublic = try reader["isPublic"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.condition = try reader["condition"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.analyzedAt = try reader["analyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.FindingSource {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.FindingSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.FindingSource()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.detail = try reader["detail"].readIfPresent(with: AccessAnalyzerClientTypes.FindingSourceDetail.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.FindingSourceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.FindingSourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.FindingSourceDetail()
        value.accessPointArn = try reader["accessPointArn"].readIfPresent()
        value.accessPointAccount = try reader["accessPointAccount"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.RecommendationError {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RecommendationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.RecommendationError()
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.RecommendedStep {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.RecommendedStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "unusedPermissionsRecommendedStep":
                return .unusedpermissionsrecommendedstep(try reader["unusedPermissionsRecommendedStep"].read(with: AccessAnalyzerClientTypes.UnusedPermissionsRecommendedStep.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.UnusedPermissionsRecommendedStep {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedPermissionsRecommendedStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedPermissionsRecommendedStep()
        value.policyUpdatedAt = try reader["policyUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.recommendedAction = try reader["recommendedAction"].readIfPresent() ?? .sdkUnknown("")
        value.recommendedPolicy = try reader["recommendedPolicy"].readIfPresent()
        value.existingPolicyId = try reader["existingPolicyId"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.FindingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.FindingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "externalAccessDetails":
                return .externalaccessdetails(try reader["externalAccessDetails"].read(with: AccessAnalyzerClientTypes.ExternalAccessDetails.read(from:)))
            case "unusedPermissionDetails":
                return .unusedpermissiondetails(try reader["unusedPermissionDetails"].read(with: AccessAnalyzerClientTypes.UnusedPermissionDetails.read(from:)))
            case "unusedIamUserAccessKeyDetails":
                return .unusediamuseraccesskeydetails(try reader["unusedIamUserAccessKeyDetails"].read(with: AccessAnalyzerClientTypes.UnusedIamUserAccessKeyDetails.read(from:)))
            case "unusedIamRoleDetails":
                return .unusediamroledetails(try reader["unusedIamRoleDetails"].read(with: AccessAnalyzerClientTypes.UnusedIamRoleDetails.read(from:)))
            case "unusedIamUserPasswordDetails":
                return .unusediamuserpassworddetails(try reader["unusedIamUserPasswordDetails"].read(with: AccessAnalyzerClientTypes.UnusedIamUserPasswordDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.UnusedIamUserPasswordDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedIamUserPasswordDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedIamUserPasswordDetails()
        value.lastAccessed = try reader["lastAccessed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.UnusedIamRoleDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedIamRoleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedIamRoleDetails()
        value.lastAccessed = try reader["lastAccessed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.UnusedIamUserAccessKeyDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedIamUserAccessKeyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedIamUserAccessKeyDetails()
        value.accessKeyId = try reader["accessKeyId"].readIfPresent() ?? ""
        value.lastAccessed = try reader["lastAccessed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.UnusedPermissionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedPermissionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedPermissionDetails()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.UnusedAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceNamespace = try reader["serviceNamespace"].readIfPresent() ?? ""
        value.lastAccessed = try reader["lastAccessed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.UnusedAction {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.UnusedAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.UnusedAction()
        value.action = try reader["action"].readIfPresent() ?? ""
        value.lastAccessed = try reader["lastAccessed"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.ExternalAccessDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.ExternalAccessDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.ExternalAccessDetails()
        value.action = try reader["action"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.condition = try reader["condition"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.isPublic = try reader["isPublic"].readIfPresent()
        value.principal = try reader["principal"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.JobDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.JobDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.JobDetails()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedOn = try reader["startedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.completedOn = try reader["completedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobError = try reader["jobError"].readIfPresent(with: AccessAnalyzerClientTypes.JobError.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.JobError {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.JobError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.JobError()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicyResult {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.GeneratedPolicyResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.GeneratedPolicyResult()
        value.properties = try reader["properties"].readIfPresent(with: AccessAnalyzerClientTypes.GeneratedPolicyProperties.read(from:))
        value.generatedPolicies = try reader["generatedPolicies"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.GeneratedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.GeneratedPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.GeneratedPolicy()
        value.policy = try reader["policy"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.GeneratedPolicyProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.GeneratedPolicyProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.GeneratedPolicyProperties()
        value.isComplete = try reader["isComplete"].readIfPresent()
        value.principalArn = try reader["principalArn"].readIfPresent() ?? ""
        value.cloudTrailProperties = try reader["cloudTrailProperties"].readIfPresent(with: AccessAnalyzerClientTypes.CloudTrailProperties.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.CloudTrailProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.CloudTrailProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.CloudTrailProperties()
        value.trailProperties = try reader["trailProperties"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.TrailProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AccessAnalyzerClientTypes.TrailProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.TrailProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.TrailProperties()
        value.cloudTrailArn = try reader["cloudTrailArn"].readIfPresent() ?? ""
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allRegions = try reader["allRegions"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AccessPreviewFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AccessPreviewFinding()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.existingFindingId = try reader["existingFindingId"].readIfPresent()
        value.existingFindingStatus = try reader["existingFindingStatus"].readIfPresent()
        value.principal = try reader["principal"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.action = try reader["action"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.condition = try reader["condition"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resource = try reader["resource"].readIfPresent()
        value.isPublic = try reader["isPublic"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.changeType = try reader["changeType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AccessPreviewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AccessPreviewSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.analyzerArn = try reader["analyzerArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent(with: AccessAnalyzerClientTypes.AccessPreviewStatusReason.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.AnalyzedResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.AnalyzedResourceSummary()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AccessAnalyzerClientTypes.FindingSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.FindingSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.FindingSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.principal = try reader["principal"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.action = try reader["action"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resource = try reader["resource"].readIfPresent()
        value.isPublic = try reader["isPublic"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.condition = try reader["condition"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.analyzedAt = try reader["analyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.FindingSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AccessAnalyzerClientTypes.FindingSummaryV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.FindingSummaryV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.FindingSummaryV2()
        value.analyzedAt = try reader["analyzedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.error = try reader["error"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceOwnerAccount = try reader["resourceOwnerAccount"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.findingType = try reader["findingType"].readIfPresent()
        return value
    }
}

extension AccessAnalyzerClientTypes.PolicyGeneration {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.PolicyGeneration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.PolicyGeneration()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.principalArn = try reader["principalArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedOn = try reader["startedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.completedOn = try reader["completedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AccessAnalyzerClientTypes.ValidatePolicyFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.ValidatePolicyFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.ValidatePolicyFinding()
        value.findingDetails = try reader["findingDetails"].readIfPresent() ?? ""
        value.findingType = try reader["findingType"].readIfPresent() ?? .sdkUnknown("")
        value.issueCode = try reader["issueCode"].readIfPresent() ?? ""
        value.learnMoreLink = try reader["learnMoreLink"].readIfPresent() ?? ""
        value.locations = try reader["locations"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.Location.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AccessAnalyzerClientTypes.Location {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Location()
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: AccessAnalyzerClientTypes.PathElement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.span = try reader["span"].readIfPresent(with: AccessAnalyzerClientTypes.Span.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.Span {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Span {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Span()
        value.start = try reader["start"].readIfPresent(with: AccessAnalyzerClientTypes.Position.read(from:))
        value.end = try reader["end"].readIfPresent(with: AccessAnalyzerClientTypes.Position.read(from:))
        return value
    }
}

extension AccessAnalyzerClientTypes.Position {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Position {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Position()
        value.line = try reader["line"].readIfPresent() ?? 0
        value.column = try reader["column"].readIfPresent() ?? 0
        value.offset = try reader["offset"].readIfPresent() ?? 0
        return value
    }
}

extension AccessAnalyzerClientTypes.PathElement {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.PathElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "index":
                return .index(try reader["index"].read())
            case "key":
                return .key(try reader["key"].read())
            case "substring":
                return .substring(try reader["substring"].read(with: AccessAnalyzerClientTypes.Substring.read(from:)))
            case "value":
                return .value(try reader["value"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AccessAnalyzerClientTypes.Substring {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.Substring {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.Substring()
        value.start = try reader["start"].readIfPresent() ?? 0
        value.length = try reader["length"].readIfPresent() ?? 0
        return value
    }
}

extension AccessAnalyzerClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AccessAnalyzerClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AccessAnalyzerClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension AccessAnalyzerClientTypes.Access {

    static func write(value: AccessAnalyzerClientTypes.Access?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resources"].writeList(value.resources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AccessAnalyzerClientTypes.InlineArchiveRule {

    static func write(value: AccessAnalyzerClientTypes.InlineArchiveRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].writeMap(value.filter, valueWritingClosure: AccessAnalyzerClientTypes.Criterion.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ruleName"].write(value.ruleName)
    }
}

extension AccessAnalyzerClientTypes.SortCriteria {

    static func write(value: AccessAnalyzerClientTypes.SortCriteria?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeName"].write(value.attributeName)
        try writer["orderBy"].write(value.orderBy)
    }
}

extension AccessAnalyzerClientTypes.PolicyGenerationDetails {

    static func write(value: AccessAnalyzerClientTypes.PolicyGenerationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["principalArn"].write(value.principalArn)
    }
}

extension AccessAnalyzerClientTypes.CloudTrailDetails {

    static func write(value: AccessAnalyzerClientTypes.CloudTrailDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessRole"].write(value.accessRole)
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["trails"].writeList(value.trails, memberWritingClosure: AccessAnalyzerClientTypes.Trail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AccessAnalyzerClientTypes.Trail {

    static func write(value: AccessAnalyzerClientTypes.Trail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allRegions"].write(value.allRegions)
        try writer["cloudTrailArn"].write(value.cloudTrailArn)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum AccessAnalyzerClientTypes {}
