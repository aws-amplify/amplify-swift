//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AccessAnalyzerClient {
    /// Paginate over `[GetFindingRecommendationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingRecommendationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingRecommendationOutput`
    public func getFindingRecommendationPaginated(input: GetFindingRecommendationInput) -> ClientRuntime.PaginatorSequence<GetFindingRecommendationInput, GetFindingRecommendationOutput> {
        return ClientRuntime.PaginatorSequence<GetFindingRecommendationInput, GetFindingRecommendationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFindingRecommendation(input:))
    }
}

extension GetFindingRecommendationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingRecommendationInput {
        return GetFindingRecommendationInput(
            analyzerArn: self.analyzerArn,
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetFindingRecommendationInput, OperationStackOutput == GetFindingRecommendationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingRecommendationPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.RecommendedStep]`
    /// - Returns: `[AccessAnalyzerClientTypes.RecommendedStep]`
    public func recommendedSteps() async throws -> [AccessAnalyzerClientTypes.RecommendedStep] {
        return try await self.asyncCompactMap { item in item.recommendedSteps }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[GetFindingV2Output]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingV2Input]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingV2Output`
    public func getFindingV2Paginated(input: GetFindingV2Input) -> ClientRuntime.PaginatorSequence<GetFindingV2Input, GetFindingV2Output> {
        return ClientRuntime.PaginatorSequence<GetFindingV2Input, GetFindingV2Output>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFindingV2(input:))
    }
}

extension GetFindingV2Input: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingV2Input {
        return GetFindingV2Input(
            analyzerArn: self.analyzerArn,
            id: self.id,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetFindingV2Input, OperationStackOutput == GetFindingV2Output {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingV2Paginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.FindingDetails]`
    /// - Returns: `[AccessAnalyzerClientTypes.FindingDetails]`
    public func findingDetails() async throws -> [AccessAnalyzerClientTypes.FindingDetails] {
        return try await self.asyncCompactMap { item in item.findingDetails }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListAccessPreviewFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccessPreviewFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccessPreviewFindingsOutput`
    public func listAccessPreviewFindingsPaginated(input: ListAccessPreviewFindingsInput) -> ClientRuntime.PaginatorSequence<ListAccessPreviewFindingsInput, ListAccessPreviewFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListAccessPreviewFindingsInput, ListAccessPreviewFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAccessPreviewFindings(input:))
    }
}

extension ListAccessPreviewFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessPreviewFindingsInput {
        return ListAccessPreviewFindingsInput(
            accessPreviewId: self.accessPreviewId,
            analyzerArn: self.analyzerArn,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccessPreviewFindingsInput, OperationStackOutput == ListAccessPreviewFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccessPreviewFindingsPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.AccessPreviewFinding]`
    /// - Returns: `[AccessAnalyzerClientTypes.AccessPreviewFinding]`
    public func findings() async throws -> [AccessAnalyzerClientTypes.AccessPreviewFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListAccessPreviewsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccessPreviewsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccessPreviewsOutput`
    public func listAccessPreviewsPaginated(input: ListAccessPreviewsInput) -> ClientRuntime.PaginatorSequence<ListAccessPreviewsInput, ListAccessPreviewsOutput> {
        return ClientRuntime.PaginatorSequence<ListAccessPreviewsInput, ListAccessPreviewsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAccessPreviews(input:))
    }
}

extension ListAccessPreviewsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccessPreviewsInput {
        return ListAccessPreviewsInput(
            analyzerArn: self.analyzerArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccessPreviewsInput, OperationStackOutput == ListAccessPreviewsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccessPreviewsPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.AccessPreviewSummary]`
    /// - Returns: `[AccessAnalyzerClientTypes.AccessPreviewSummary]`
    public func accessPreviews() async throws -> [AccessAnalyzerClientTypes.AccessPreviewSummary] {
        return try await self.asyncCompactMap { item in item.accessPreviews }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListAnalyzedResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAnalyzedResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAnalyzedResourcesOutput`
    public func listAnalyzedResourcesPaginated(input: ListAnalyzedResourcesInput) -> ClientRuntime.PaginatorSequence<ListAnalyzedResourcesInput, ListAnalyzedResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListAnalyzedResourcesInput, ListAnalyzedResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAnalyzedResources(input:))
    }
}

extension ListAnalyzedResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAnalyzedResourcesInput {
        return ListAnalyzedResourcesInput(
            analyzerArn: self.analyzerArn,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAnalyzedResourcesInput, OperationStackOutput == ListAnalyzedResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAnalyzedResourcesPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.AnalyzedResourceSummary]`
    /// - Returns: `[AccessAnalyzerClientTypes.AnalyzedResourceSummary]`
    public func analyzedResources() async throws -> [AccessAnalyzerClientTypes.AnalyzedResourceSummary] {
        return try await self.asyncCompactMap { item in item.analyzedResources }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingsOutput`
    public func listFindingsPaginated(input: ListFindingsInput) -> ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFindings(input:))
    }
}

extension ListFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingsInput {
        return ListFindingsInput(
            analyzerArn: self.analyzerArn,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}

extension PaginatorSequence where OperationStackInput == ListFindingsInput, OperationStackOutput == ListFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFindingsPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.FindingSummary]`
    /// - Returns: `[AccessAnalyzerClientTypes.FindingSummary]`
    public func findings() async throws -> [AccessAnalyzerClientTypes.FindingSummary] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListFindingsV2Output]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingsV2Input]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingsV2Output`
    public func listFindingsV2Paginated(input: ListFindingsV2Input) -> ClientRuntime.PaginatorSequence<ListFindingsV2Input, ListFindingsV2Output> {
        return ClientRuntime.PaginatorSequence<ListFindingsV2Input, ListFindingsV2Output>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFindingsV2(input:))
    }
}

extension ListFindingsV2Input: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingsV2Input {
        return ListFindingsV2Input(
            analyzerArn: self.analyzerArn,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort
        )}
}

extension PaginatorSequence where OperationStackInput == ListFindingsV2Input, OperationStackOutput == ListFindingsV2Output {
    /// This paginator transforms the `AsyncSequence` returned by `listFindingsV2Paginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.FindingSummaryV2]`
    /// - Returns: `[AccessAnalyzerClientTypes.FindingSummaryV2]`
    public func findings() async throws -> [AccessAnalyzerClientTypes.FindingSummaryV2] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ListPolicyGenerationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPolicyGenerationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPolicyGenerationsOutput`
    public func listPolicyGenerationsPaginated(input: ListPolicyGenerationsInput) -> ClientRuntime.PaginatorSequence<ListPolicyGenerationsInput, ListPolicyGenerationsOutput> {
        return ClientRuntime.PaginatorSequence<ListPolicyGenerationsInput, ListPolicyGenerationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPolicyGenerations(input:))
    }
}

extension ListPolicyGenerationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyGenerationsInput {
        return ListPolicyGenerationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            principalArn: self.principalArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListPolicyGenerationsInput, OperationStackOutput == ListPolicyGenerationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPolicyGenerationsPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.PolicyGeneration]`
    /// - Returns: `[AccessAnalyzerClientTypes.PolicyGeneration]`
    public func policyGenerations() async throws -> [AccessAnalyzerClientTypes.PolicyGeneration] {
        return try await self.asyncCompactMap { item in item.policyGenerations }
    }
}
extension AccessAnalyzerClient {
    /// Paginate over `[ValidatePolicyOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ValidatePolicyInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ValidatePolicyOutput`
    public func validatePolicyPaginated(input: ValidatePolicyInput) -> ClientRuntime.PaginatorSequence<ValidatePolicyInput, ValidatePolicyOutput> {
        return ClientRuntime.PaginatorSequence<ValidatePolicyInput, ValidatePolicyOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.validatePolicy(input:))
    }
}

extension ValidatePolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ValidatePolicyInput {
        return ValidatePolicyInput(
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            policyDocument: self.policyDocument,
            policyType: self.policyType,
            validatePolicyResourceType: self.validatePolicyResourceType
        )}
}

extension PaginatorSequence where OperationStackInput == ValidatePolicyInput, OperationStackOutput == ValidatePolicyOutput {
    /// This paginator transforms the `AsyncSequence` returned by `validatePolicyPaginated`
    /// to access the nested member `[AccessAnalyzerClientTypes.ValidatePolicyFinding]`
    /// - Returns: `[AccessAnalyzerClientTypes.ValidatePolicyFinding]`
    public func findings() async throws -> [AccessAnalyzerClientTypes.ValidatePolicyFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
