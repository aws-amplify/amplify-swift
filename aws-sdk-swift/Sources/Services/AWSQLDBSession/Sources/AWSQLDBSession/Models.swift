//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension QLDBSessionClientTypes {

    /// Contains the details of the transaction to abort.
    public struct AbortTransactionRequest: Swift.Sendable {

        public init() { }
    }
}

extension QLDBSessionClientTypes {

    /// Contains server-side performance information for a command. Amazon QLDB captures timing information between the times when it receives the request and when it sends the corresponding response.
    public struct TimingInformation: Swift.Sendable {
        /// The amount of time that QLDB spent on processing the command, measured in milliseconds.
        public var processingTimeMilliseconds: Swift.Int

        public init(
            processingTimeMilliseconds: Swift.Int = 0
        )
        {
            self.processingTimeMilliseconds = processingTimeMilliseconds
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the aborted transaction.
    public struct AbortTransactionResult: Swift.Sendable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?

        public init(
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }
}

/// Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// Returned when the request exceeds the processing capacity of the ledger.
public struct CapacityExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CapacityExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the transaction to commit.
    public struct CommitTransactionRequest: Swift.Sendable {
        /// Specifies the commit digest for the transaction to commit. For every active transaction, the commit digest must be passed. QLDB validates CommitDigest and rejects the commit with an error if the digest computed on the client does not match the digest computed by QLDB. The purpose of the CommitDigest parameter is to ensure that QLDB commits a transaction if and only if the server has processed the exact set of statements sent by the client, in the same order that client sent them, and with no duplicates.
        /// This member is required.
        public var commitDigest: Foundation.Data?
        /// Specifies the transaction ID of the transaction to commit.
        /// This member is required.
        public var transactionId: Swift.String?

        public init(
            commitDigest: Foundation.Data? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.transactionId = transactionId
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains I/O usage metrics for a command that was invoked.
    public struct IOUsage: Swift.Sendable {
        /// The number of read I/O requests that the command made.
        public var readIOs: Swift.Int
        /// The number of write I/O requests that the command made.
        public var writeIOs: Swift.Int

        public init(
            readIOs: Swift.Int = 0,
            writeIOs: Swift.Int = 0
        )
        {
            self.readIOs = readIOs
            self.writeIOs = writeIOs
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the committed transaction.
    public struct CommitTransactionResult: Swift.Sendable {
        /// The commit digest of the committed transaction.
        public var commitDigest: Foundation.Data?
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QLDBSessionClientTypes.IOUsage?
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?
        /// The transaction ID of the committed transaction.
        public var transactionId: Swift.String?

        public init(
            commitDigest: Foundation.Data? = nil,
            consumedIOs: QLDBSessionClientTypes.IOUsage? = nil,
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.commitDigest = commitDigest
            self.consumedIOs = consumedIOs
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }
}

extension QLDBSessionClientTypes {

    /// Specifies a request to end the session.
    public struct EndSessionRequest: Swift.Sendable {

        public init() { }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the ended session.
    public struct EndSessionResult: Swift.Sendable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?

        public init(
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil
        )
        {
            self.timingInformation = timingInformation
        }
    }
}

extension QLDBSessionClientTypes {

    /// A structure that can contain a value in multiple encoding formats.
    public struct ValueHolder: Swift.Sendable {
        /// An Amazon Ion binary value contained in a ValueHolder structure.
        public var ionBinary: Foundation.Data?
        /// An Amazon Ion plaintext value contained in a ValueHolder structure.
        public var ionText: Swift.String?

        public init(
            ionBinary: Foundation.Data? = nil,
            ionText: Swift.String? = nil
        )
        {
            self.ionBinary = ionBinary
            self.ionText = ionText
        }
    }
}

extension QLDBSessionClientTypes {

    /// Specifies a request to execute a statement.
    public struct ExecuteStatementRequest: Swift.Sendable {
        /// Specifies the parameters for the parameterized statement in the request.
        public var parameters: [QLDBSessionClientTypes.ValueHolder]?
        /// Specifies the statement of the request.
        /// This member is required.
        public var statement: Swift.String?
        /// Specifies the transaction ID of the request.
        /// This member is required.
        public var transactionId: Swift.String?

        public init(
            parameters: [QLDBSessionClientTypes.ValueHolder]? = nil,
            statement: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.statement = statement
            self.transactionId = transactionId
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains details of the fetched page.
    public struct Page: Swift.Sendable {
        /// The token of the next page.
        public var nextPageToken: Swift.String?
        /// A structure that contains values in multiple encoding formats.
        public var values: [QLDBSessionClientTypes.ValueHolder]?

        public init(
            nextPageToken: Swift.String? = nil,
            values: [QLDBSessionClientTypes.ValueHolder]? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.values = values
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the executed statement.
    public struct ExecuteStatementResult: Swift.Sendable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QLDBSessionClientTypes.IOUsage?
        /// Contains the details of the first fetched page.
        public var firstPage: QLDBSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?

        public init(
            consumedIOs: QLDBSessionClientTypes.IOUsage? = nil,
            firstPage: QLDBSessionClientTypes.Page? = nil,
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.firstPage = firstPage
            self.timingInformation = timingInformation
        }
    }
}

extension QLDBSessionClientTypes {

    /// Specifies the details of the page to be fetched.
    public struct FetchPageRequest: Swift.Sendable {
        /// Specifies the next page token of the page to be fetched.
        /// This member is required.
        public var nextPageToken: Swift.String?
        /// Specifies the transaction ID of the page to be fetched.
        /// This member is required.
        public var transactionId: Swift.String?

        public init(
            nextPageToken: Swift.String? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.nextPageToken = nextPageToken
            self.transactionId = transactionId
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the page that was fetched.
    public struct FetchPageResult: Swift.Sendable {
        /// Contains metrics about the number of I/O requests that were consumed.
        public var consumedIOs: QLDBSessionClientTypes.IOUsage?
        /// Contains details of the fetched page.
        public var page: QLDBSessionClientTypes.Page?
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?

        public init(
            consumedIOs: QLDBSessionClientTypes.IOUsage? = nil,
            page: QLDBSessionClientTypes.Page? = nil,
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil
        )
        {
            self.consumedIOs = consumedIOs
            self.page = page
            self.timingInformation = timingInformation
        }
    }
}

/// Returned if the session doesn't exist anymore because it timed out or expired.
public struct InvalidSessionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSessionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// Returned if a resource limit such as number of active sessions is exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Returned when a transaction cannot be written to the journal due to a failure in the verification phase of optimistic concurrency control (OCC).
public struct OccConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OccConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Returned when the rate of requests exceeds the allowed throughput.
public struct RateExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RateExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension QLDBSessionClientTypes {

    /// Specifies a request to start a new session.
    public struct StartSessionRequest: Swift.Sendable {
        /// The name of the ledger to start a new session against.
        /// This member is required.
        public var ledgerName: Swift.String?

        public init(
            ledgerName: Swift.String? = nil
        )
        {
            self.ledgerName = ledgerName
        }
    }
}

extension QLDBSessionClientTypes {

    /// Specifies a request to start a transaction.
    public struct StartTransactionRequest: Swift.Sendable {

        public init() { }
    }
}

public struct SendCommandInput: Swift.Sendable {
    /// Command to abort the current transaction.
    public var abortTransaction: QLDBSessionClientTypes.AbortTransactionRequest?
    /// Command to commit the specified transaction.
    public var commitTransaction: QLDBSessionClientTypes.CommitTransactionRequest?
    /// Command to end the current session.
    public var endSession: QLDBSessionClientTypes.EndSessionRequest?
    /// Command to execute a statement in the specified transaction.
    public var executeStatement: QLDBSessionClientTypes.ExecuteStatementRequest?
    /// Command to fetch a page.
    public var fetchPage: QLDBSessionClientTypes.FetchPageRequest?
    /// Specifies the session token for the current command. A session token is constant throughout the life of the session. To obtain a session token, run the StartSession command. This SessionToken is required for every subsequent command that is issued during the current session.
    public var sessionToken: Swift.String?
    /// Command to start a new session. A session token is obtained as part of the response.
    public var startSession: QLDBSessionClientTypes.StartSessionRequest?
    /// Command to start a new transaction.
    public var startTransaction: QLDBSessionClientTypes.StartTransactionRequest?

    public init(
        abortTransaction: QLDBSessionClientTypes.AbortTransactionRequest? = nil,
        commitTransaction: QLDBSessionClientTypes.CommitTransactionRequest? = nil,
        endSession: QLDBSessionClientTypes.EndSessionRequest? = nil,
        executeStatement: QLDBSessionClientTypes.ExecuteStatementRequest? = nil,
        fetchPage: QLDBSessionClientTypes.FetchPageRequest? = nil,
        sessionToken: Swift.String? = nil,
        startSession: QLDBSessionClientTypes.StartSessionRequest? = nil,
        startTransaction: QLDBSessionClientTypes.StartTransactionRequest? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.sessionToken = sessionToken
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the started session.
    public struct StartSessionResult: Swift.Sendable {
        /// Session token of the started session. This SessionToken is required for every subsequent command that is issued during the current session.
        public var sessionToken: Swift.String?
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?

        public init(
            sessionToken: Swift.String? = nil,
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil
        )
        {
            self.sessionToken = sessionToken
            self.timingInformation = timingInformation
        }
    }
}

extension QLDBSessionClientTypes {

    /// Contains the details of the started transaction.
    public struct StartTransactionResult: Swift.Sendable {
        /// Contains server-side performance information for the command.
        public var timingInformation: QLDBSessionClientTypes.TimingInformation?
        /// The transaction ID of the started transaction.
        public var transactionId: Swift.String?

        public init(
            timingInformation: QLDBSessionClientTypes.TimingInformation? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.timingInformation = timingInformation
            self.transactionId = transactionId
        }
    }
}

public struct SendCommandOutput: Swift.Sendable {
    /// Contains the details of the aborted transaction.
    public var abortTransaction: QLDBSessionClientTypes.AbortTransactionResult?
    /// Contains the details of the committed transaction.
    public var commitTransaction: QLDBSessionClientTypes.CommitTransactionResult?
    /// Contains the details of the ended session.
    public var endSession: QLDBSessionClientTypes.EndSessionResult?
    /// Contains the details of the executed statement.
    public var executeStatement: QLDBSessionClientTypes.ExecuteStatementResult?
    /// Contains the details of the fetched page.
    public var fetchPage: QLDBSessionClientTypes.FetchPageResult?
    /// Contains the details of the started session that includes a session token. This SessionToken is required for every subsequent command that is issued during the current session.
    public var startSession: QLDBSessionClientTypes.StartSessionResult?
    /// Contains the details of the started transaction.
    public var startTransaction: QLDBSessionClientTypes.StartTransactionResult?

    public init(
        abortTransaction: QLDBSessionClientTypes.AbortTransactionResult? = nil,
        commitTransaction: QLDBSessionClientTypes.CommitTransactionResult? = nil,
        endSession: QLDBSessionClientTypes.EndSessionResult? = nil,
        executeStatement: QLDBSessionClientTypes.ExecuteStatementResult? = nil,
        fetchPage: QLDBSessionClientTypes.FetchPageResult? = nil,
        startSession: QLDBSessionClientTypes.StartSessionResult? = nil,
        startTransaction: QLDBSessionClientTypes.StartTransactionResult? = nil
    )
    {
        self.abortTransaction = abortTransaction
        self.commitTransaction = commitTransaction
        self.endSession = endSession
        self.executeStatement = executeStatement
        self.fetchPage = fetchPage
        self.startSession = startSession
        self.startTransaction = startTransaction
    }
}

extension SendCommandInput {

    static func urlPathProvider(_ value: SendCommandInput) -> Swift.String? {
        return "/"
    }
}

extension SendCommandInput {

    static func write(value: SendCommandInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortTransaction"].write(value.abortTransaction, with: QLDBSessionClientTypes.AbortTransactionRequest.write(value:to:))
        try writer["CommitTransaction"].write(value.commitTransaction, with: QLDBSessionClientTypes.CommitTransactionRequest.write(value:to:))
        try writer["EndSession"].write(value.endSession, with: QLDBSessionClientTypes.EndSessionRequest.write(value:to:))
        try writer["ExecuteStatement"].write(value.executeStatement, with: QLDBSessionClientTypes.ExecuteStatementRequest.write(value:to:))
        try writer["FetchPage"].write(value.fetchPage, with: QLDBSessionClientTypes.FetchPageRequest.write(value:to:))
        try writer["SessionToken"].write(value.sessionToken)
        try writer["StartSession"].write(value.startSession, with: QLDBSessionClientTypes.StartSessionRequest.write(value:to:))
        try writer["StartTransaction"].write(value.startTransaction, with: QLDBSessionClientTypes.StartTransactionRequest.write(value:to:))
    }
}

extension SendCommandOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendCommandOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendCommandOutput()
        value.abortTransaction = try reader["AbortTransaction"].readIfPresent(with: QLDBSessionClientTypes.AbortTransactionResult.read(from:))
        value.commitTransaction = try reader["CommitTransaction"].readIfPresent(with: QLDBSessionClientTypes.CommitTransactionResult.read(from:))
        value.endSession = try reader["EndSession"].readIfPresent(with: QLDBSessionClientTypes.EndSessionResult.read(from:))
        value.executeStatement = try reader["ExecuteStatement"].readIfPresent(with: QLDBSessionClientTypes.ExecuteStatementResult.read(from:))
        value.fetchPage = try reader["FetchPage"].readIfPresent(with: QLDBSessionClientTypes.FetchPageResult.read(from:))
        value.startSession = try reader["StartSession"].readIfPresent(with: QLDBSessionClientTypes.StartSessionResult.read(from:))
        value.startTransaction = try reader["StartTransaction"].readIfPresent(with: QLDBSessionClientTypes.StartTransactionResult.read(from:))
        return value
    }
}

enum SendCommandOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "CapacityExceededException": return try CapacityExceededException.makeError(baseError: baseError)
            case "InvalidSessionException": return try InvalidSessionException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OccConflictException": return try OccConflictException.makeError(baseError: baseError)
            case "RateExceededException": return try RateExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CapacityExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CapacityExceededException {
        let reader = baseError.errorBodyReader
        var value = CapacityExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSessionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSessionException {
        let reader = baseError.errorBodyReader
        var value = InvalidSessionException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OccConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OccConflictException {
        let reader = baseError.errorBodyReader
        var value = OccConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RateExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RateExceededException {
        let reader = baseError.errorBodyReader
        var value = RateExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QLDBSessionClientTypes.StartSessionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.StartSessionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.StartSessionResult()
        value.sessionToken = try reader["SessionToken"].readIfPresent()
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.TimingInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.TimingInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.TimingInformation()
        value.processingTimeMilliseconds = try reader["ProcessingTimeMilliseconds"].readIfPresent() ?? 0
        return value
    }
}

extension QLDBSessionClientTypes.StartTransactionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.StartTransactionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.StartTransactionResult()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.EndSessionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.EndSessionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.EndSessionResult()
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.CommitTransactionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.CommitTransactionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.CommitTransactionResult()
        value.transactionId = try reader["TransactionId"].readIfPresent()
        value.commitDigest = try reader["CommitDigest"].readIfPresent()
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        value.consumedIOs = try reader["ConsumedIOs"].readIfPresent(with: QLDBSessionClientTypes.IOUsage.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.IOUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.IOUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.IOUsage()
        value.readIOs = try reader["ReadIOs"].readIfPresent() ?? 0
        value.writeIOs = try reader["WriteIOs"].readIfPresent() ?? 0
        return value
    }
}

extension QLDBSessionClientTypes.AbortTransactionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.AbortTransactionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.AbortTransactionResult()
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.ExecuteStatementResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.ExecuteStatementResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.ExecuteStatementResult()
        value.firstPage = try reader["FirstPage"].readIfPresent(with: QLDBSessionClientTypes.Page.read(from:))
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        value.consumedIOs = try reader["ConsumedIOs"].readIfPresent(with: QLDBSessionClientTypes.IOUsage.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.Page {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.Page {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.Page()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: QLDBSessionClientTypes.ValueHolder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension QLDBSessionClientTypes.ValueHolder {

    static func write(value: QLDBSessionClientTypes.ValueHolder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IonBinary"].write(value.ionBinary)
        try writer["IonText"].write(value.ionText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.ValueHolder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.ValueHolder()
        value.ionBinary = try reader["IonBinary"].readIfPresent()
        value.ionText = try reader["IonText"].readIfPresent()
        return value
    }
}

extension QLDBSessionClientTypes.FetchPageResult {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBSessionClientTypes.FetchPageResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBSessionClientTypes.FetchPageResult()
        value.page = try reader["Page"].readIfPresent(with: QLDBSessionClientTypes.Page.read(from:))
        value.timingInformation = try reader["TimingInformation"].readIfPresent(with: QLDBSessionClientTypes.TimingInformation.read(from:))
        value.consumedIOs = try reader["ConsumedIOs"].readIfPresent(with: QLDBSessionClientTypes.IOUsage.read(from:))
        return value
    }
}

extension QLDBSessionClientTypes.StartSessionRequest {

    static func write(value: QLDBSessionClientTypes.StartSessionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LedgerName"].write(value.ledgerName)
    }
}

extension QLDBSessionClientTypes.StartTransactionRequest {

    static func write(value: QLDBSessionClientTypes.StartTransactionRequest?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension QLDBSessionClientTypes.EndSessionRequest {

    static func write(value: QLDBSessionClientTypes.EndSessionRequest?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension QLDBSessionClientTypes.CommitTransactionRequest {

    static func write(value: QLDBSessionClientTypes.CommitTransactionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitDigest"].write(value.commitDigest)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension QLDBSessionClientTypes.AbortTransactionRequest {

    static func write(value: QLDBSessionClientTypes.AbortTransactionRequest?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension QLDBSessionClientTypes.ExecuteStatementRequest {

    static func write(value: QLDBSessionClientTypes.ExecuteStatementRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Parameters"].writeList(value.parameters, memberWritingClosure: QLDBSessionClientTypes.ValueHolder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Statement"].write(value.statement)
        try writer["TransactionId"].write(value.transactionId)
    }
}

extension QLDBSessionClientTypes.FetchPageRequest {

    static func write(value: QLDBSessionClientTypes.FetchPageRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["TransactionId"].write(value.transactionId)
    }
}

public enum QLDBSessionClientTypes {}
