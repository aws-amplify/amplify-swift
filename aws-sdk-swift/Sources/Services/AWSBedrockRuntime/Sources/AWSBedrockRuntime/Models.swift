//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyEventStreams.DefaultMessageDecoder
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyEventStreamsAPI.MessageType
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct SmithyEventStreams.DefaultMessageDecoderStream
import struct SmithyEventStreamsAPI.Message
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
import typealias SmithyEventStreamsAPI.UnmarshalClosure

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource ARN was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request exceeds the service quota for your account. You can view your quotas at [Viewing service quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/gs-request-quota.html). You can resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request was throttled because of service-wide limitations. Resubmit your request later or in a different region. You can also purchase [Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html) to increase the rate or number of tokens you can process.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentQualifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case groundingSource
        case guardContent
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentQualifier] {
            return [
                .groundingSource,
                .guardContent,
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .groundingSource: return "grounding_source"
            case .guardContent: return "guard_content"
            case .query: return "query"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The text block to be evaluated by the guardrail.
    public struct GuardrailTextBlock: Swift.Sendable {
        /// The qualifiers describing the text block.
        public var qualifiers: [BedrockRuntimeClientTypes.GuardrailContentQualifier]?
        /// The input text details to be evaluated by the guardrail.
        /// This member is required.
        public var text: Swift.String?

        public init(
            qualifiers: [BedrockRuntimeClientTypes.GuardrailContentQualifier]? = nil,
            text: Swift.String? = nil
        )
        {
            self.qualifiers = qualifiers
            self.text = text
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The content block to be evaluated by the guardrail.
    public enum GuardrailContentBlock: Swift.Sendable {
        /// Text within content block to be evaluated by the guardrail.
        case text(BedrockRuntimeClientTypes.GuardrailTextBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case input
        case output
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentSource] {
            return [
                .input,
                .output
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .input: return "INPUT"
            case .output: return "OUTPUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ApplyGuardrailInput: Swift.Sendable {
    /// The content details used in the request to apply the guardrail.
    /// This member is required.
    public var content: [BedrockRuntimeClientTypes.GuardrailContentBlock]?
    /// The guardrail identifier used in the request to apply the guardrail.
    /// This member is required.
    public var guardrailIdentifier: Swift.String?
    /// The guardrail version used in the request to apply the guardrail.
    /// This member is required.
    public var guardrailVersion: Swift.String?
    /// The source of data used in the request to apply the guardrail.
    /// This member is required.
    public var source: BedrockRuntimeClientTypes.GuardrailContentSource?

    public init(
        content: [BedrockRuntimeClientTypes.GuardrailContentBlock]? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        source: BedrockRuntimeClientTypes.GuardrailContentSource? = nil
    )
    {
        self.content = content
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.source = source
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case guardrailIntervened
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailAction] {
            return [
                .guardrailIntervened,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .guardrailIntervened: return "GUARDRAIL_INTERVENED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentFilterConfidence: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterConfidence] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentFilterStrength: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterStrength] {
            return [
                .high,
                .low,
                .medium,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContentFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hate
        case insults
        case misconduct
        case promptAttack
        case sexual
        case violence
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContentFilterType] {
            return [
                .hate,
                .insults,
                .misconduct,
                .promptAttack,
                .sexual,
                .violence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hate: return "HATE"
            case .insults: return "INSULTS"
            case .misconduct: return "MISCONDUCT"
            case .promptAttack: return "PROMPT_ATTACK"
            case .sexual: return "SEXUAL"
            case .violence: return "VIOLENCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The content filter for a guardrail.
    public struct GuardrailContentFilter: Swift.Sendable {
        /// The guardrail action.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailContentPolicyAction?
        /// The guardrail confidence.
        /// This member is required.
        public var confidence: BedrockRuntimeClientTypes.GuardrailContentFilterConfidence?
        /// The filter strength setting for the guardrail content filter.
        public var filterStrength: BedrockRuntimeClientTypes.GuardrailContentFilterStrength?
        /// The guardrail type.
        /// This member is required.
        public var type: BedrockRuntimeClientTypes.GuardrailContentFilterType?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailContentPolicyAction? = nil,
            confidence: BedrockRuntimeClientTypes.GuardrailContentFilterConfidence? = nil,
            filterStrength: BedrockRuntimeClientTypes.GuardrailContentFilterStrength? = nil,
            type: BedrockRuntimeClientTypes.GuardrailContentFilterType? = nil
        )
        {
            self.action = action
            self.confidence = confidence
            self.filterStrength = filterStrength
            self.type = type
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// An assessment of a content policy for a guardrail.
    public struct GuardrailContentPolicyAssessment: Swift.Sendable {
        /// The content policy filters.
        /// This member is required.
        public var filters: [BedrockRuntimeClientTypes.GuardrailContentFilter]?

        public init(
            filters: [BedrockRuntimeClientTypes.GuardrailContentFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContextualGroundingPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingPolicyAction] {
            return [
                .blocked,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailContextualGroundingFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case grounding
        case relevance
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailContextualGroundingFilterType] {
            return [
                .grounding,
                .relevance
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grounding: return "GROUNDING"
            case .relevance: return "RELEVANCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingFilter: Swift.Sendable {
        /// The action performed by the guardrails contextual grounding filter.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAction?
        /// The score generated by contextual grounding filter.
        /// This member is required.
        public var score: Swift.Double?
        /// The threshold used by contextual grounding filter to determine whether the content is grounded or not.
        /// This member is required.
        public var threshold: Swift.Double?
        /// The contextual grounding filter type.
        /// This member is required.
        public var type: BedrockRuntimeClientTypes.GuardrailContextualGroundingFilterType?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAction? = nil,
            score: Swift.Double? = nil,
            threshold: Swift.Double? = nil,
            type: BedrockRuntimeClientTypes.GuardrailContextualGroundingFilterType? = nil
        )
        {
            self.action = action
            self.score = score
            self.threshold = threshold
            self.type = type
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The policy assessment details for the guardrails contextual grounding filter.
    public struct GuardrailContextualGroundingPolicyAssessment: Swift.Sendable {
        /// The filter details for the guardrails contextual grounding filter.
        public var filters: [BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter]?

        public init(
            filters: [BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The guardrail coverage for the text characters.
    public struct GuardrailTextCharactersCoverage: Swift.Sendable {
        /// The text characters that were guarded by the guardrail coverage.
        public var guarded: Swift.Int?
        /// The total text characters by the guardrail coverage.
        public var total: Swift.Int?

        public init(
            guarded: Swift.Int? = nil,
            total: Swift.Int? = nil
        )
        {
            self.guarded = guarded
            self.total = total
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The action of the guardrail coverage details.
    public struct GuardrailCoverage: Swift.Sendable {
        /// The text characters of the guardrail coverage details.
        public var textCharacters: BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage?

        public init(
            textCharacters: BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage? = nil
        )
        {
            self.textCharacters = textCharacters
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The details on the use of the guardrail.
    public struct GuardrailUsage: Swift.Sendable {
        /// The content policy units processed by the guardrail.
        /// This member is required.
        public var contentPolicyUnits: Swift.Int?
        /// The contextual grounding policy units processed by the guardrail.
        /// This member is required.
        public var contextualGroundingPolicyUnits: Swift.Int?
        /// The sensitive information policy free units processed by the guardrail.
        /// This member is required.
        public var sensitiveInformationPolicyFreeUnits: Swift.Int?
        /// The sensitive information policy units processed by the guardrail.
        /// This member is required.
        public var sensitiveInformationPolicyUnits: Swift.Int?
        /// The topic policy units processed by the guardrail.
        /// This member is required.
        public var topicPolicyUnits: Swift.Int?
        /// The word policy units processed by the guardrail.
        /// This member is required.
        public var wordPolicyUnits: Swift.Int?

        public init(
            contentPolicyUnits: Swift.Int? = nil,
            contextualGroundingPolicyUnits: Swift.Int? = nil,
            sensitiveInformationPolicyFreeUnits: Swift.Int? = nil,
            sensitiveInformationPolicyUnits: Swift.Int? = nil,
            topicPolicyUnits: Swift.Int? = nil,
            wordPolicyUnits: Swift.Int? = nil
        )
        {
            self.contentPolicyUnits = contentPolicyUnits
            self.contextualGroundingPolicyUnits = contextualGroundingPolicyUnits
            self.sensitiveInformationPolicyFreeUnits = sensitiveInformationPolicyFreeUnits
            self.sensitiveInformationPolicyUnits = sensitiveInformationPolicyUnits
            self.topicPolicyUnits = topicPolicyUnits
            self.wordPolicyUnits = wordPolicyUnits
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The invocation metrics for the guardrail.
    public struct GuardrailInvocationMetrics: Swift.Sendable {
        /// The coverage details for the guardrail invocation metrics.
        public var guardrailCoverage: BedrockRuntimeClientTypes.GuardrailCoverage?
        /// The processing latency details for the guardrail invocation metrics.
        public var guardrailProcessingLatency: Swift.Int?
        /// The usage details for the guardrail invocation metrics.
        public var usage: BedrockRuntimeClientTypes.GuardrailUsage?

        public init(
            guardrailCoverage: BedrockRuntimeClientTypes.GuardrailCoverage? = nil,
            guardrailProcessingLatency: Swift.Int? = nil,
            usage: BedrockRuntimeClientTypes.GuardrailUsage? = nil
        )
        {
            self.guardrailCoverage = guardrailCoverage
            self.guardrailProcessingLatency = guardrailProcessingLatency
            self.usage = usage
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailSensitiveInformationPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymized
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailSensitiveInformationPolicyAction] {
            return [
                .anonymized,
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymized: return "ANONYMIZED"
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailPiiEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case address
        case age
        case awsAccessKey
        case awsSecretKey
        case caHealthNumber
        case caSocialInsuranceNumber
        case creditDebitCardCvv
        case creditDebitCardExpiry
        case creditDebitCardNumber
        case driverId
        case email
        case internationalBankAccountNumber
        case ipAddress
        case licensePlate
        case macAddress
        case name
        case password
        case phone
        case pin
        case swiftCode
        case ukNationalHealthServiceNumber
        case ukNationalInsuranceNumber
        case ukUniqueTaxpayerReferenceNumber
        case url
        case username
        case usBankAccountNumber
        case usBankRoutingNumber
        case usIndividualTaxIdentificationNumber
        case usPassportNumber
        case usSocialSecurityNumber
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailPiiEntityType] {
            return [
                .address,
                .age,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A Personally Identifiable Information (PII) entity configured in a guardrail.
    public struct GuardrailPiiEntityFilter: Swift.Sendable {
        /// The PII entity filter action.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The PII entity filter match.
        /// This member is required.
        public var match: Swift.String?
        /// The PII entity filter type.
        /// This member is required.
        public var type: BedrockRuntimeClientTypes.GuardrailPiiEntityType?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockRuntimeClientTypes.GuardrailPiiEntityType? = nil
        )
        {
            self.action = action
            self.match = match
            self.type = type
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A Regex filter configured in a guardrail.
    public struct GuardrailRegexFilter: Swift.Sendable {
        /// The region filter action.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction?
        /// The regesx filter match.
        public var match: Swift.String?
        /// The regex filter name.
        public var name: Swift.String?
        /// The regex query.
        public var regex: Swift.String?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAction? = nil,
            match: Swift.String? = nil,
            name: Swift.String? = nil,
            regex: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.name = name
            self.regex = regex
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The assessment for aPersonally Identifiable Information (PII) policy.
    public struct GuardrailSensitiveInformationPolicyAssessment: Swift.Sendable {
        /// The PII entities in the assessment.
        /// This member is required.
        public var piiEntities: [BedrockRuntimeClientTypes.GuardrailPiiEntityFilter]?
        /// The regex queries in the assessment.
        /// This member is required.
        public var regexes: [BedrockRuntimeClientTypes.GuardrailRegexFilter]?

        public init(
            piiEntities: [BedrockRuntimeClientTypes.GuardrailPiiEntityFilter]? = nil,
            regexes: [BedrockRuntimeClientTypes.GuardrailRegexFilter]? = nil
        )
        {
            self.piiEntities = piiEntities
            self.regexes = regexes
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailTopicPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailTopicType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTopicType] {
            return [
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Information about a topic guardrail.
    public struct GuardrailTopic: Swift.Sendable {
        /// The action the guardrail should take when it intervenes on a topic.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailTopicPolicyAction?
        /// The name for the guardrail.
        /// This member is required.
        public var name: Swift.String?
        /// The type behavior that the guardrail should perform when the model detects the topic.
        /// This member is required.
        public var type: BedrockRuntimeClientTypes.GuardrailTopicType?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailTopicPolicyAction? = nil,
            name: Swift.String? = nil,
            type: BedrockRuntimeClientTypes.GuardrailTopicType? = nil
        )
        {
            self.action = action
            self.name = name
            self.type = type
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A behavior assessment of a topic policy.
    public struct GuardrailTopicPolicyAssessment: Swift.Sendable {
        /// The topics in the assessment.
        /// This member is required.
        public var topics: [BedrockRuntimeClientTypes.GuardrailTopic]?

        public init(
            topics: [BedrockRuntimeClientTypes.GuardrailTopic]? = nil
        )
        {
            self.topics = topics
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailWordPolicyAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blocked
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailWordPolicyAction] {
            return [
                .blocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blocked: return "BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A custom word configured in a guardrail.
    public struct GuardrailCustomWord: Swift.Sendable {
        /// The action for the custom word.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match for the custom word.
        /// This member is required.
        public var match: Swift.String?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailManagedWordType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case profanity
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailManagedWordType] {
            return [
                .profanity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .profanity: return "PROFANITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A managed word configured in a guardrail.
    public struct GuardrailManagedWord: Swift.Sendable {
        /// The action for the managed word.
        /// This member is required.
        public var action: BedrockRuntimeClientTypes.GuardrailWordPolicyAction?
        /// The match for the managed word.
        /// This member is required.
        public var match: Swift.String?
        /// The type for the managed word.
        /// This member is required.
        public var type: BedrockRuntimeClientTypes.GuardrailManagedWordType?

        public init(
            action: BedrockRuntimeClientTypes.GuardrailWordPolicyAction? = nil,
            match: Swift.String? = nil,
            type: BedrockRuntimeClientTypes.GuardrailManagedWordType? = nil
        )
        {
            self.action = action
            self.match = match
            self.type = type
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The word policy assessment.
    public struct GuardrailWordPolicyAssessment: Swift.Sendable {
        /// Custom words in the assessment.
        /// This member is required.
        public var customWords: [BedrockRuntimeClientTypes.GuardrailCustomWord]?
        /// Managed word lists in the assessment.
        /// This member is required.
        public var managedWordLists: [BedrockRuntimeClientTypes.GuardrailManagedWord]?

        public init(
            customWords: [BedrockRuntimeClientTypes.GuardrailCustomWord]? = nil,
            managedWordLists: [BedrockRuntimeClientTypes.GuardrailManagedWord]? = nil
        )
        {
            self.customWords = customWords
            self.managedWordLists = managedWordLists
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A behavior assessment of the guardrail policies used in a call to the Converse API.
    public struct GuardrailAssessment: Swift.Sendable {
        /// The content policy.
        public var contentPolicy: BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment?
        /// The contextual grounding policy used for the guardrail assessment.
        public var contextualGroundingPolicy: BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment?
        /// The invocation metrics for the guardrail assessment.
        public var invocationMetrics: BedrockRuntimeClientTypes.GuardrailInvocationMetrics?
        /// The sensitive information policy.
        public var sensitiveInformationPolicy: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment?
        /// The topic policy.
        public var topicPolicy: BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment?
        /// The word policy.
        public var wordPolicy: BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment?

        public init(
            contentPolicy: BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment? = nil,
            contextualGroundingPolicy: BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment? = nil,
            invocationMetrics: BedrockRuntimeClientTypes.GuardrailInvocationMetrics? = nil,
            sensitiveInformationPolicy: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment? = nil,
            topicPolicy: BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment? = nil,
            wordPolicy: BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment? = nil
        )
        {
            self.contentPolicy = contentPolicy
            self.contextualGroundingPolicy = contextualGroundingPolicy
            self.invocationMetrics = invocationMetrics
            self.sensitiveInformationPolicy = sensitiveInformationPolicy
            self.topicPolicy = topicPolicy
            self.wordPolicy = wordPolicy
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The output content produced by the guardrail.
    public struct GuardrailOutputContent: Swift.Sendable {
        /// The specific text for the output content produced by the guardrail.
        public var text: Swift.String?

        public init(
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }
}

public struct ApplyGuardrailOutput: Swift.Sendable {
    /// The action taken in the response from the guardrail.
    /// This member is required.
    public var action: BedrockRuntimeClientTypes.GuardrailAction?
    /// The assessment details in the response from the guardrail.
    /// This member is required.
    public var assessments: [BedrockRuntimeClientTypes.GuardrailAssessment]?
    /// The guardrail coverage details in the apply guardrail response.
    public var guardrailCoverage: BedrockRuntimeClientTypes.GuardrailCoverage?
    /// The output details in the response from the guardrail.
    /// This member is required.
    public var outputs: [BedrockRuntimeClientTypes.GuardrailOutputContent]?
    /// The usage details in the response from the guardrail.
    /// This member is required.
    public var usage: BedrockRuntimeClientTypes.GuardrailUsage?

    public init(
        action: BedrockRuntimeClientTypes.GuardrailAction? = nil,
        assessments: [BedrockRuntimeClientTypes.GuardrailAssessment]? = nil,
        guardrailCoverage: BedrockRuntimeClientTypes.GuardrailCoverage? = nil,
        outputs: [BedrockRuntimeClientTypes.GuardrailOutputContent]? = nil,
        usage: BedrockRuntimeClientTypes.GuardrailUsage? = nil
    )
    {
        self.action = action
        self.assessments = assessments
        self.guardrailCoverage = guardrailCoverage
        self.outputs = outputs
        self.usage = usage
    }
}

/// The request failed due to an error while processing the model.
public struct ModelErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
        /// The resource name.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.originalStatusCode = originalStatusCode
        self.properties.resourceName = resourceName
    }
}

/// The model specified in the request is not ready to serve inference requests. The AWS SDK will automatically retry the operation up to 5 times. For information about configuring automatic retries, see [Retry behavior](https://docs.aws.amazon.com/sdkref/latest/guide/feature-retry-behavior.html) in the AWS SDKs and Tools reference guide.
public struct ModelNotReadyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelNotReadyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request took too long to process. Processing time exceeded the model timeout length.
public struct ModelTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service isn't currently available. Try again later.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailTrace: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailTrace] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Configuration information for a guardrail that you use with the [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) operation.
    public struct GuardrailConfiguration: Swift.Sendable {
        /// The identifier for the guardrail.
        /// This member is required.
        public var guardrailIdentifier: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?
        /// The trace behavior for the guardrail.
        public var trace: BedrockRuntimeClientTypes.GuardrailTrace?

        public init(
            guardrailIdentifier: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil,
            trace: BedrockRuntimeClientTypes.GuardrailTrace? = .disabled
        )
        {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.trace = trace
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Base inference parameters to pass to a model in a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html). For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field in the call to Converse or ConverseStream. For more information, see [Model parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration: Swift.Sendable {
        /// The maximum number of tokens to allow in the generated response. The default value is the maximum allowed value for the model that you are using. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var maxTokens: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options. The default value is the default value for the model that you are using. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var temperature: Swift.Float?
        /// The percentage of most-likely candidates that the model considers for the next token. For example, if you choose a value of 0.8 for topP, the model selects from the top 80% of the probability distribution of tokens that could be next in the sequence. The default value is the default value for the model that you are using. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum DocumentFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case doc
        case docx
        case html
        case md
        case pdf
        case txt
        case xls
        case xlsx
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentFormat] {
            return [
                .csv,
                .doc,
                .docx,
                .html,
                .md,
                .pdf,
                .txt,
                .xls,
                .xlsx
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case .doc: return "doc"
            case .docx: return "docx"
            case .html: return "html"
            case .md: return "md"
            case .pdf: return "pdf"
            case .txt: return "txt"
            case .xls: return "xls"
            case .xlsx: return "xlsx"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Contains the content of a document.
    public enum DocumentSource: Swift.Sendable {
        /// The raw bytes for the document. If you use an Amazon Web Services SDK, you don't need to encode the bytes in base64.
        case bytes(Foundation.Data)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// A document to include in a message.
    public struct DocumentBlock: Swift.Sendable {
        /// The format of a document, or its extension.
        /// This member is required.
        public var format: BedrockRuntimeClientTypes.DocumentFormat?
        /// A name for the document. The name can only contain the following characters:
        ///
        /// * Alphanumeric characters
        ///
        /// * Whitespace characters (no more than one in a row)
        ///
        /// * Hyphens
        ///
        /// * Parentheses
        ///
        /// * Square brackets
        ///
        ///
        /// This field is vulnerable to prompt injections, because the model might inadvertently interpret it as instructions. Therefore, we recommend that you specify a neutral name.
        /// This member is required.
        public var name: Swift.String?
        /// Contains the content of the document.
        /// This member is required.
        public var source: BedrockRuntimeClientTypes.DocumentSource?

        public init(
            format: BedrockRuntimeClientTypes.DocumentFormat? = nil,
            name: Swift.String? = nil,
            source: BedrockRuntimeClientTypes.DocumentSource? = nil
        )
        {
            self.format = format
            self.name = name
            self.source = source
        }
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailConverseContentQualifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case groundingSource
        case guardContent
        case query
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailConverseContentQualifier] {
            return [
                .groundingSource,
                .guardContent,
                .query
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .groundingSource: return "grounding_source"
            case .guardContent: return "guard_content"
            case .query: return "query"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A text block that contains text that you want to assess with a guardrail. For more information, see [GuardrailConverseContentBlock].
    public struct GuardrailConverseTextBlock: Swift.Sendable {
        /// The qualifier details for the guardrails contextual grounding filter.
        public var qualifiers: [BedrockRuntimeClientTypes.GuardrailConverseContentQualifier]?
        /// The text that you want to guard.
        /// This member is required.
        public var text: Swift.String?

        public init(
            qualifiers: [BedrockRuntimeClientTypes.GuardrailConverseContentQualifier]? = nil,
            text: Swift.String? = nil
        )
        {
            self.qualifiers = qualifiers
            self.text = text
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A content block for selective guarding with the [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html) API operations.
    public enum GuardrailConverseContentBlock: Swift.Sendable {
        /// The text to guard.
        case text(BedrockRuntimeClientTypes.GuardrailConverseTextBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    public enum ImageFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gif
        case jpeg
        case png
        case webp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .gif,
                .jpeg,
                .png,
                .webp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gif: return "gif"
            case .jpeg: return "jpeg"
            case .png: return "png"
            case .webp: return "webp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The source for an image.
    public enum ImageSource: Swift.Sendable {
        /// The raw image bytes for the image. If you use an AWS SDK, you don't need to encode the image bytes in base64.
        case bytes(Foundation.Data)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// Image content for a message.
    public struct ImageBlock: Swift.Sendable {
        /// The format of the image.
        /// This member is required.
        public var format: BedrockRuntimeClientTypes.ImageFormat?
        /// The source for the image.
        /// This member is required.
        public var source: BedrockRuntimeClientTypes.ImageSource?

        public init(
            format: BedrockRuntimeClientTypes.ImageFormat? = nil,
            source: BedrockRuntimeClientTypes.ImageSource? = nil
        )
        {
            self.format = format
            self.source = source
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The tool result content block.
    public enum ToolResultContentBlock: Swift.Sendable {
        /// A tool result that is JSON format data.
        case json(Smithy.Document)
        /// A tool result that is text.
        case text(Swift.String)
        /// A tool result that is an image. This field is only supported by Anthropic Claude 3 models.
        case image(BedrockRuntimeClientTypes.ImageBlock)
        /// A tool result that is a document.
        case document(BedrockRuntimeClientTypes.DocumentBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    public enum ToolResultStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ToolResultStatus] {
            return [
                .error,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .success: return "success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A tool result block that contains the results for a tool request that the model previously made.
    public struct ToolResultBlock: Swift.Sendable {
        /// The content for tool result content block.
        /// This member is required.
        public var content: [BedrockRuntimeClientTypes.ToolResultContentBlock]?
        /// The status for the tool result content block. This field is only supported Anthropic Claude 3 models.
        public var status: BedrockRuntimeClientTypes.ToolResultStatus?
        /// The ID of the tool request that this is the result for.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            content: [BedrockRuntimeClientTypes.ToolResultContentBlock]? = nil,
            status: BedrockRuntimeClientTypes.ToolResultStatus? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.content = content
            self.status = status
            self.toolUseId = toolUseId
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A tool use content block. Contains information about a tool that the model is requesting be run., The model uses the result from the tool to generate a response.
    public struct ToolUseBlock: Swift.Sendable {
        /// The input to pass to the tool.
        /// This member is required.
        public var input: Smithy.Document?
        /// The name of the tool that the model wants to use.
        /// This member is required.
        public var name: Swift.String?
        /// The ID for the tool request.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            input: Smithy.Document? = nil,
            name: Swift.String? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.input = input
            self.name = name
            self.toolUseId = toolUseId
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A block of content for a message that you pass to, or receive from, a model with the [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html) API operations.
    public enum ContentBlock: Swift.Sendable {
        /// Text to include in the message.
        case text(Swift.String)
        /// Image to include in the message. This field is only supported by Anthropic Claude 3 models.
        case image(BedrockRuntimeClientTypes.ImageBlock)
        /// A document to include in the message.
        case document(BedrockRuntimeClientTypes.DocumentBlock)
        /// Information about a tool use request from a model.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlock)
        /// The result for a tool request that a model makes.
        case toolresult(BedrockRuntimeClientTypes.ToolResultBlock)
        /// Contains the content to assess with the guardrail. If you don't specify guardContent in a call to the Converse API, the guardrail (if passed in the Converse API) assesses the entire message. For more information, see Use a guardrail with the Converse API in the Amazon Bedrock User Guide.
        case guardcontent(BedrockRuntimeClientTypes.GuardrailConverseContentBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    public enum ConversationRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationRole] {
            return [
                .assistant,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "assistant"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A message input, or returned from, a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html).
    public struct Message: Swift.Sendable {
        /// The message content. Note the following restrictions:
        ///
        /// * You can include up to 20 images. Each image's size, height, and width must be no more than 3.75 MB, 8000 px, and 8000 px, respectively.
        ///
        /// * You can include up to five documents. Each document's size must be no more than 4.5 MB.
        ///
        /// * If you include a ContentBlock with a document field in the array, you must also include a ContentBlock with a text field.
        ///
        /// * You can only include images and documents if the role is user.
        /// This member is required.
        public var content: [BedrockRuntimeClientTypes.ContentBlock]?
        /// The role that the message plays in the message.
        /// This member is required.
        public var role: BedrockRuntimeClientTypes.ConversationRole?

        public init(
            content: [BedrockRuntimeClientTypes.ContentBlock]? = nil,
            role: BedrockRuntimeClientTypes.ConversationRole? = nil
        )
        {
            self.content = content
            self.role = role
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A system content block.
    public enum SystemContentBlock: Swift.Sendable {
        /// A system prompt for the model.
        case text(Swift.String)
        /// A content block to assess with the guardrail. Use with the [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html) or [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html) API operations. For more information, see Use a guardrail with the Converse API in the Amazon Bedrock User Guide.
        case guardcontent(BedrockRuntimeClientTypes.GuardrailConverseContentBlock)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// The model must request at least one tool (no text is generated). For example, {"any" : {}}.
    public struct AnyToolChoice: Swift.Sendable {

        public init() { }
    }
}

extension BedrockRuntimeClientTypes {

    /// The Model automatically decides if a tool should be called or whether to generate text instead. For example, {"auto" : {}}.
    public struct AutoToolChoice: Swift.Sendable {

        public init() { }
    }
}

extension BedrockRuntimeClientTypes {

    /// The model must request a specific tool. For example, {"tool" : {"name" : "Your tool name"}}. This field is only supported by Anthropic Claude 3 models.
    public struct SpecificToolChoice: Swift.Sendable {
        /// The name of the tool that the model must request.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Determines which tools the model should request in a call to Converse or ConverseStream. ToolChoice is only supported by Anthropic Claude 3 models and by Mistral AI Mistral Large.
    public enum ToolChoice: Swift.Sendable {
        /// (Default). The Model automatically decides if a tool should be called or whether to generate text instead.
        case auto(BedrockRuntimeClientTypes.AutoToolChoice)
        /// The model must request at least one tool (no text is generated).
        case any(BedrockRuntimeClientTypes.AnyToolChoice)
        /// The Model must request the specified tool. Only supported by Anthropic Claude 3 models.
        case tool(BedrockRuntimeClientTypes.SpecificToolChoice)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// The schema for the tool. The top level schema type must be object.
    public enum ToolInputSchema: Swift.Sendable {
        /// The JSON schema for the tool. For more information, see [JSON Schema Reference](https://json-schema.org/understanding-json-schema/reference).
        case json(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// The specification for the tool.
    public struct ToolSpecification: Swift.Sendable {
        /// The description for the tool.
        public var description: Swift.String?
        /// The input schema for the tool in JSON format.
        /// This member is required.
        public var inputSchema: BedrockRuntimeClientTypes.ToolInputSchema?
        /// The name for the tool.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputSchema: BedrockRuntimeClientTypes.ToolInputSchema? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Information about a tool that you can use with the Converse API. For more information, see [Tool use (function calling)](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html) in the Amazon Bedrock User Guide.
    public enum Tool: Swift.Sendable {
        /// The specfication for the tool.
        case toolspec(BedrockRuntimeClientTypes.ToolSpecification)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// Configuration information for the tools that you pass to a model. For more information, see [Tool use (function calling)](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html) in the Amazon Bedrock User Guide. This field is only supported by Anthropic Claude 3, Cohere Command R, Cohere Command R+, and Mistral Large models.
    public struct ToolConfiguration: Swift.Sendable {
        /// If supported by model, forces the model to request a tool.
        public var toolChoice: BedrockRuntimeClientTypes.ToolChoice?
        /// An array of tools that you want to pass to a model.
        /// This member is required.
        public var tools: [BedrockRuntimeClientTypes.Tool]?

        public init(
            toolChoice: BedrockRuntimeClientTypes.ToolChoice? = nil,
            tools: [BedrockRuntimeClientTypes.Tool]? = nil
        )
        {
            self.toolChoice = toolChoice
            self.tools = tools
        }
    }
}

public struct ConverseInput: Swift.Sendable {
    /// Additional inference parameters that the model supports, beyond the base set of inference parameters that Converse supports in the inferenceConfig field. For more information, see [Model parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public var additionalModelRequestFields: Smithy.Document?
    /// Additional model parameters field paths to return in the response. Converse returns the requested fields as a JSON Pointer object in the additionalModelResponseFields field. The following is example JSON for additionalModelResponseFieldPaths. [ "/stop_sequence" ] For information about the JSON Pointer syntax, see the [Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6901) documentation. Converse rejects an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by Converse.
    public var additionalModelResponseFieldPaths: [Swift.String]?
    /// Configuration information for a guardrail that you want to use in the request.
    public var guardrailConfig: BedrockRuntimeClientTypes.GuardrailConfiguration?
    /// Inference parameters to pass to the model. Converse supports a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
    public var inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration?
    /// The messages that you want to send to the model.
    /// This member is required.
    public var messages: [BedrockRuntimeClientTypes.Message]?
    /// The identifier for the model that you want to call. The modelId to provide depends on the type of model or throughput that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see [Supported Regions and models for cross-region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference-support.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    ///
    /// The Converse API doesn't support [imported models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html).
    /// This member is required.
    public var modelId: Swift.String?
    /// A system prompt to pass to the model.
    public var system: [BedrockRuntimeClientTypes.SystemContentBlock]?
    /// Configuration information for the tools that the model can use when generating a response. This field is only supported by Anthropic Claude 3, Cohere Command R, Cohere Command R+, and Mistral Large models.
    public var toolConfig: BedrockRuntimeClientTypes.ToolConfiguration?

    public init(
        additionalModelRequestFields: Smithy.Document? = nil,
        additionalModelResponseFieldPaths: [Swift.String]? = nil,
        guardrailConfig: BedrockRuntimeClientTypes.GuardrailConfiguration? = nil,
        inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration? = nil,
        messages: [BedrockRuntimeClientTypes.Message]? = nil,
        modelId: Swift.String? = nil,
        system: [BedrockRuntimeClientTypes.SystemContentBlock]? = nil,
        toolConfig: BedrockRuntimeClientTypes.ToolConfiguration? = nil
    )
    {
        self.additionalModelRequestFields = additionalModelRequestFields
        self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
        self.guardrailConfig = guardrailConfig
        self.inferenceConfig = inferenceConfig
        self.messages = messages
        self.modelId = modelId
        self.system = system
        self.toolConfig = toolConfig
    }
}

extension BedrockRuntimeClientTypes {

    /// Metrics for a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html).
    public struct ConverseMetrics: Swift.Sendable {
        /// The latency of the call to Converse, in milliseconds.
        /// This member is required.
        public var latencyMs: Swift.Int?

        public init(
            latencyMs: Swift.Int? = nil
        )
        {
            self.latencyMs = latencyMs
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The output from a call to [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html).
    public enum ConverseOutput: Swift.Sendable {
        /// The message that the model generates.
        case message(BedrockRuntimeClientTypes.Message)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    public enum StopReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentFiltered
        case endTurn
        case guardrailIntervened
        case maxTokens
        case stopSequence
        case toolUse
        case sdkUnknown(Swift.String)

        public static var allCases: [StopReason] {
            return [
                .contentFiltered,
                .endTurn,
                .guardrailIntervened,
                .maxTokens,
                .stopSequence,
                .toolUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentFiltered: return "content_filtered"
            case .endTurn: return "end_turn"
            case .guardrailIntervened: return "guardrail_intervened"
            case .maxTokens: return "max_tokens"
            case .stopSequence: return "stop_sequence"
            case .toolUse: return "tool_use"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A Top level guardrail trace object. For more information, see [ConverseTrace].
    public struct GuardrailTraceAssessment: Swift.Sendable {
        /// The input assessment.
        public var inputAssessment: [Swift.String: BedrockRuntimeClientTypes.GuardrailAssessment]?
        /// The output from the model.
        public var modelOutput: [Swift.String]?
        /// the output assessments.
        public var outputAssessments: [Swift.String: [BedrockRuntimeClientTypes.GuardrailAssessment]]?

        public init(
            inputAssessment: [Swift.String: BedrockRuntimeClientTypes.GuardrailAssessment]? = nil,
            modelOutput: [Swift.String]? = nil,
            outputAssessments: [Swift.String: [BedrockRuntimeClientTypes.GuardrailAssessment]]? = nil
        )
        {
            self.inputAssessment = inputAssessment
            self.modelOutput = modelOutput
            self.outputAssessments = outputAssessments
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The trace object in a response from [Converse](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html). Currently, you can only trace guardrails.
    public struct ConverseTrace: Swift.Sendable {
        /// The guardrail trace object.
        public var guardrail: BedrockRuntimeClientTypes.GuardrailTraceAssessment?

        public init(
            guardrail: BedrockRuntimeClientTypes.GuardrailTraceAssessment? = nil
        )
        {
            self.guardrail = guardrail
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The tokens used in a message API inference call.
    public struct TokenUsage: Swift.Sendable {
        /// The number of tokens sent in the request to the model.
        /// This member is required.
        public var inputTokens: Swift.Int?
        /// The number of tokens that the model generated for the request.
        /// This member is required.
        public var outputTokens: Swift.Int?
        /// The total of input tokens and tokens generated by the model.
        /// This member is required.
        public var totalTokens: Swift.Int?

        public init(
            inputTokens: Swift.Int? = nil,
            outputTokens: Swift.Int? = nil,
            totalTokens: Swift.Int? = nil
        )
        {
            self.inputTokens = inputTokens
            self.outputTokens = outputTokens
            self.totalTokens = totalTokens
        }
    }
}

public struct ConverseOutput: Swift.Sendable {
    /// Additional fields in the response that are unique to the model.
    public var additionalModelResponseFields: Smithy.Document?
    /// Metrics for the call to Converse.
    /// This member is required.
    public var metrics: BedrockRuntimeClientTypes.ConverseMetrics?
    /// The result from the call to Converse.
    /// This member is required.
    public var output: BedrockRuntimeClientTypes.ConverseOutput?
    /// The reason why the model stopped generating output.
    /// This member is required.
    public var stopReason: BedrockRuntimeClientTypes.StopReason?
    /// A trace object that contains information about the Guardrail behavior.
    public var trace: BedrockRuntimeClientTypes.ConverseTrace?
    /// The total number of tokens used in the call to Converse. The total includes the tokens input to the model and the tokens generated by the model.
    /// This member is required.
    public var usage: BedrockRuntimeClientTypes.TokenUsage?

    public init(
        additionalModelResponseFields: Smithy.Document? = nil,
        metrics: BedrockRuntimeClientTypes.ConverseMetrics? = nil,
        output: BedrockRuntimeClientTypes.ConverseOutput? = nil,
        stopReason: BedrockRuntimeClientTypes.StopReason? = nil,
        trace: BedrockRuntimeClientTypes.ConverseTrace? = nil,
        usage: BedrockRuntimeClientTypes.TokenUsage? = nil
    )
    {
        self.additionalModelResponseFields = additionalModelResponseFields
        self.metrics = metrics
        self.output = output
        self.stopReason = stopReason
        self.trace = trace
        self.usage = usage
    }
}

extension BedrockRuntimeClientTypes {

    public enum GuardrailStreamProcessingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case async
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [GuardrailStreamProcessingMode] {
            return [
                .async,
                .sync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .async: return "async"
            case .sync: return "sync"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Configuration information for a guardrail that you use with the [ConverseStream] action.
    public struct GuardrailStreamConfiguration: Swift.Sendable {
        /// The identifier for the guardrail.
        /// This member is required.
        public var guardrailIdentifier: Swift.String?
        /// The version of the guardrail.
        /// This member is required.
        public var guardrailVersion: Swift.String?
        /// The processing mode. The processing mode. For more information, see Configure streaming response behavior in the Amazon Bedrock User Guide.
        public var streamProcessingMode: BedrockRuntimeClientTypes.GuardrailStreamProcessingMode?
        /// The trace behavior for the guardrail.
        public var trace: BedrockRuntimeClientTypes.GuardrailTrace?

        public init(
            guardrailIdentifier: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil,
            streamProcessingMode: BedrockRuntimeClientTypes.GuardrailStreamProcessingMode? = .sync,
            trace: BedrockRuntimeClientTypes.GuardrailTrace? = .disabled
        )
        {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
            self.streamProcessingMode = streamProcessingMode
            self.trace = trace
        }
    }
}

public struct ConverseStreamInput: Swift.Sendable {
    /// Additional inference parameters that the model supports, beyond the base set of inference parameters that ConverseStream supports in the inferenceConfig field.
    public var additionalModelRequestFields: Smithy.Document?
    /// Additional model parameters field paths to return in the response. ConverseStream returns the requested fields as a JSON Pointer object in the additionalModelResponseFields field. The following is example JSON for additionalModelResponseFieldPaths. [ "/stop_sequence" ] For information about the JSON Pointer syntax, see the [Internet Engineering Task Force (IETF)](https://datatracker.ietf.org/doc/html/rfc6901) documentation. ConverseStream rejects an empty JSON Pointer or incorrectly structured JSON Pointer with a 400 error code. if the JSON Pointer is valid, but the requested field is not in the model response, it is ignored by ConverseStream.
    public var additionalModelResponseFieldPaths: [Swift.String]?
    /// Configuration information for a guardrail that you want to use in the request.
    public var guardrailConfig: BedrockRuntimeClientTypes.GuardrailStreamConfiguration?
    /// Inference parameters to pass to the model. ConverseStream supports a base set of inference parameters. If you need to pass additional parameters that the model supports, use the additionalModelRequestFields request field.
    public var inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration?
    /// The messages that you want to send to the model.
    /// This member is required.
    public var messages: [BedrockRuntimeClientTypes.Message]?
    /// The ID for the model. The modelId to provide depends on the type of model or throughput that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see [Supported Regions and models for cross-region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference-support.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    ///
    /// The Converse API doesn't support [imported models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html).
    /// This member is required.
    public var modelId: Swift.String?
    /// A system prompt to send to the model.
    public var system: [BedrockRuntimeClientTypes.SystemContentBlock]?
    /// Configuration information for the tools that the model can use when generating a response. This field is only supported by Anthropic Claude 3 models.
    public var toolConfig: BedrockRuntimeClientTypes.ToolConfiguration?

    public init(
        additionalModelRequestFields: Smithy.Document? = nil,
        additionalModelResponseFieldPaths: [Swift.String]? = nil,
        guardrailConfig: BedrockRuntimeClientTypes.GuardrailStreamConfiguration? = nil,
        inferenceConfig: BedrockRuntimeClientTypes.InferenceConfiguration? = nil,
        messages: [BedrockRuntimeClientTypes.Message]? = nil,
        modelId: Swift.String? = nil,
        system: [BedrockRuntimeClientTypes.SystemContentBlock]? = nil,
        toolConfig: BedrockRuntimeClientTypes.ToolConfiguration? = nil
    )
    {
        self.additionalModelRequestFields = additionalModelRequestFields
        self.additionalModelResponseFieldPaths = additionalModelResponseFieldPaths
        self.guardrailConfig = guardrailConfig
        self.inferenceConfig = inferenceConfig
        self.messages = messages
        self.modelId = modelId
        self.system = system
        self.toolConfig = toolConfig
    }
}

extension BedrockRuntimeClientTypes {

    /// The delta for a tool use block.
    public struct ToolUseBlockDelta: Swift.Sendable {
        /// The input for a requested tool.
        /// This member is required.
        public var input: Swift.String?

        public init(
            input: Swift.String? = nil
        )
        {
            self.input = input
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A bock of content in a streaming response.
    public enum ContentBlockDelta: Swift.Sendable {
        /// The content text.
        case text(Swift.String)
        /// Information about a tool that the model is requesting to use.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlockDelta)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// The content block delta event.
    public struct ContentBlockDeltaEvent: Swift.Sendable {
        /// The block index for a content block delta event.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?
        /// The delta for a content block delta event.
        /// This member is required.
        public var delta: BedrockRuntimeClientTypes.ContentBlockDelta?

        public init(
            contentBlockIndex: Swift.Int? = nil,
            delta: BedrockRuntimeClientTypes.ContentBlockDelta? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
            self.delta = delta
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The start of a tool use block.
    public struct ToolUseBlockStart: Swift.Sendable {
        /// The name of the tool that the model is requesting to use.
        /// This member is required.
        public var name: Swift.String?
        /// The ID for the tool request.
        /// This member is required.
        public var toolUseId: Swift.String?

        public init(
            name: Swift.String? = nil,
            toolUseId: Swift.String? = nil
        )
        {
            self.name = name
            self.toolUseId = toolUseId
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Content block start information.
    public enum ContentBlockStart: Swift.Sendable {
        /// Information about a tool that the model is requesting to use.
        case tooluse(BedrockRuntimeClientTypes.ToolUseBlockStart)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockRuntimeClientTypes {

    /// Content block start event.
    public struct ContentBlockStartEvent: Swift.Sendable {
        /// The index for a content block start event.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?
        /// Start information about a content block start event.
        /// This member is required.
        public var start: BedrockRuntimeClientTypes.ContentBlockStart?

        public init(
            contentBlockIndex: Swift.Int? = nil,
            start: BedrockRuntimeClientTypes.ContentBlockStart? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
            self.start = start
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A content block stop event.
    public struct ContentBlockStopEvent: Swift.Sendable {
        /// The index for a content block.
        /// This member is required.
        public var contentBlockIndex: Swift.Int?

        public init(
            contentBlockIndex: Swift.Int? = nil
        )
        {
            self.contentBlockIndex = contentBlockIndex
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The start of a message.
    public struct MessageStartEvent: Swift.Sendable {
        /// The role for the message.
        /// This member is required.
        public var role: BedrockRuntimeClientTypes.ConversationRole?

        public init(
            role: BedrockRuntimeClientTypes.ConversationRole? = nil
        )
        {
            self.role = role
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The stop event for a message.
    public struct MessageStopEvent: Swift.Sendable {
        /// The additional model response fields.
        public var additionalModelResponseFields: Smithy.Document?
        /// The reason why the model stopped generating output.
        /// This member is required.
        public var stopReason: BedrockRuntimeClientTypes.StopReason?

        public init(
            additionalModelResponseFields: Smithy.Document? = nil,
            stopReason: BedrockRuntimeClientTypes.StopReason? = nil
        )
        {
            self.additionalModelResponseFields = additionalModelResponseFields
            self.stopReason = stopReason
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// Metrics for the stream.
    public struct ConverseStreamMetrics: Swift.Sendable {
        /// The latency for the streaming request, in milliseconds.
        /// This member is required.
        public var latencyMs: Swift.Int?

        public init(
            latencyMs: Swift.Int? = nil
        )
        {
            self.latencyMs = latencyMs
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// The trace object in a response from [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html). Currently, you can only trace guardrails.
    public struct ConverseStreamTrace: Swift.Sendable {
        /// The guardrail trace object.
        public var guardrail: BedrockRuntimeClientTypes.GuardrailTraceAssessment?

        public init(
            guardrail: BedrockRuntimeClientTypes.GuardrailTraceAssessment? = nil
        )
        {
            self.guardrail = guardrail
        }
    }
}

extension BedrockRuntimeClientTypes {

    /// A conversation stream metadata event.
    public struct ConverseStreamMetadataEvent: Swift.Sendable {
        /// The metrics for the conversation stream metadata event.
        /// This member is required.
        public var metrics: BedrockRuntimeClientTypes.ConverseStreamMetrics?
        /// The trace object in the response from [ConverseStream](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_ConverseStream.html) that contains information about the guardrail behavior.
        public var trace: BedrockRuntimeClientTypes.ConverseStreamTrace?
        /// Usage information for the conversation stream event.
        /// This member is required.
        public var usage: BedrockRuntimeClientTypes.TokenUsage?

        public init(
            metrics: BedrockRuntimeClientTypes.ConverseStreamMetrics? = nil,
            trace: BedrockRuntimeClientTypes.ConverseStreamTrace? = nil,
            usage: BedrockRuntimeClientTypes.TokenUsage? = nil
        )
        {
            self.metrics = metrics
            self.trace = trace
            self.usage = usage
        }
    }
}

/// An error occurred while streaming the response. Retry your request.
public struct ModelStreamErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The original message.
        public internal(set) var originalMessage: Swift.String? = nil
        /// The original status code.
        public internal(set) var originalStatusCode: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ModelStreamErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        originalMessage: Swift.String? = nil,
        originalStatusCode: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.originalMessage = originalMessage
        self.properties.originalStatusCode = originalStatusCode
    }
}

extension BedrockRuntimeClientTypes {

    /// The messages output stream
    public enum ConverseStreamOutput: Swift.Sendable {
        /// Message start information.
        case messagestart(BedrockRuntimeClientTypes.MessageStartEvent)
        /// Start information for a content block.
        case contentblockstart(BedrockRuntimeClientTypes.ContentBlockStartEvent)
        /// The messages output content block delta.
        case contentblockdelta(BedrockRuntimeClientTypes.ContentBlockDeltaEvent)
        /// Stop information for a content block.
        case contentblockstop(BedrockRuntimeClientTypes.ContentBlockStopEvent)
        /// Message stop information.
        case messagestop(BedrockRuntimeClientTypes.MessageStopEvent)
        /// Metadata for the converse output stream.
        case metadata(BedrockRuntimeClientTypes.ConverseStreamMetadataEvent)
        case sdkUnknown(Swift.String)
    }
}

public struct ConverseStreamOutput: Swift.Sendable {
    /// The output stream that the model generated.
    public var stream: AsyncThrowingStream<BedrockRuntimeClientTypes.ConverseStreamOutput, Swift.Error>?

    public init(
        stream: AsyncThrowingStream<BedrockRuntimeClientTypes.ConverseStreamOutput, Swift.Error>? = nil
    )
    {
        self.stream = stream
    }
}

extension BedrockRuntimeClientTypes {

    public enum Trace: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Trace] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct InvokeModelInput: Swift.Sendable {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. You must provide the body in JSON format. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the input data in the request. You must specify application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error will be thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an [imported model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html), specify the ARN of the imported model. You can get the model ARN from a successful call to [CreateModelImportJob](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateModelImportJob.html) or from the Imported models page in the Amazon Bedrock console.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

public struct InvokeModelOutput: Swift.Sendable {
    /// Inference response from the model in the format specified in the contentType header. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

extension InvokeModelOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelOutput(contentType: \(Swift.String(describing: contentType)), body: \"CONTENT_REDACTED\")"}
}

public struct InvokeModelWithResponseStreamInput: Swift.Sendable {
    /// The desired MIME type of the inference body in the response. The default value is application/json.
    public var accept: Swift.String?
    /// The prompt and inference parameters in the format specified in the contentType in the header. You must provide the body in JSON format. To see the format and content of the request and response bodies for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html). For more information, see [Run inference](https://docs.aws.amazon.com/bedrock/latest/userguide/api-methods-run.html) in the Bedrock User Guide.
    /// This member is required.
    public var body: Foundation.Data?
    /// The MIME type of the input data in the request. You must specify application/json.
    public var contentType: Swift.String?
    /// The unique identifier of the guardrail that you want to use. If you don't provide a value, no guardrail is applied to the invocation. An error is thrown in the following situations.
    ///
    /// * You don't provide a guardrail identifier but you specify the amazon-bedrock-guardrailConfig field in the request body.
    ///
    /// * You enable the guardrail but the contentType isn't application/json.
    ///
    /// * You provide a guardrail identifier, but guardrailVersion isn't specified.
    public var guardrailIdentifier: Swift.String?
    /// The version number for the guardrail. The value can also be DRAFT.
    public var guardrailVersion: Swift.String?
    /// The unique identifier of the model to invoke to run inference. The modelId to provide depends on the type of model that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an [imported model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html), specify the ARN of the imported model. You can get the model ARN from a successful call to [CreateModelImportJob](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateModelImportJob.html) or from the Imported models page in the Amazon Bedrock console.
    /// This member is required.
    public var modelId: Swift.String?
    /// Specifies whether to enable or disable the Bedrock trace. If enabled, you can see the full Bedrock trace.
    public var trace: BedrockRuntimeClientTypes.Trace?

    public init(
        accept: Swift.String? = nil,
        body: Foundation.Data? = nil,
        contentType: Swift.String? = nil,
        guardrailIdentifier: Swift.String? = nil,
        guardrailVersion: Swift.String? = nil,
        modelId: Swift.String? = nil,
        trace: BedrockRuntimeClientTypes.Trace? = nil
    )
    {
        self.accept = accept
        self.body = body
        self.contentType = contentType
        self.guardrailIdentifier = guardrailIdentifier
        self.guardrailVersion = guardrailVersion
        self.modelId = modelId
        self.trace = trace
    }
}

extension InvokeModelWithResponseStreamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeModelWithResponseStreamInput(accept: \(Swift.String(describing: accept)), contentType: \(Swift.String(describing: contentType)), guardrailIdentifier: \(Swift.String(describing: guardrailIdentifier)), guardrailVersion: \(Swift.String(describing: guardrailVersion)), modelId: \(Swift.String(describing: modelId)), trace: \(Swift.String(describing: trace)), body: \"CONTENT_REDACTED\")"}
}

extension BedrockRuntimeClientTypes {

    /// Payload content included in the response.
    public struct PayloadPart: Swift.Sendable {
        /// Base64-encoded bytes of payload data.
        public var bytes: Foundation.Data?

        public init(
            bytes: Foundation.Data? = nil
        )
        {
            self.bytes = bytes
        }
    }
}

extension BedrockRuntimeClientTypes.PayloadPart: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockRuntimeClientTypes {

    /// Definition of content in the response stream.
    public enum ResponseStream: Swift.Sendable {
        /// Content included in the response.
        case chunk(BedrockRuntimeClientTypes.PayloadPart)
        case sdkUnknown(Swift.String)
    }
}

public struct InvokeModelWithResponseStreamOutput: Swift.Sendable {
    /// Inference response from the model in the format specified by the contentType header. To see the format and content of this field for different models, refer to [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    /// This member is required.
    public var body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>?
    /// The MIME type of the inference result.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        body: AsyncThrowingStream<BedrockRuntimeClientTypes.ResponseStream, Swift.Error>? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
    }
}

extension ApplyGuardrailInput {

    static func urlPathProvider(_ value: ApplyGuardrailInput) -> Swift.String? {
        guard let guardrailIdentifier = value.guardrailIdentifier else {
            return nil
        }
        guard let guardrailVersion = value.guardrailVersion else {
            return nil
        }
        return "/guardrail/\(guardrailIdentifier.urlPercentEncoding())/version/\(guardrailVersion.urlPercentEncoding())/apply"
    }
}

extension ConverseInput {

    static func urlPathProvider(_ value: ConverseInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/converse"
    }
}

extension ConverseStreamInput {

    static func urlPathProvider(_ value: ConverseStreamInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/converse-stream"
    }
}

extension InvokeModelInput {

    static func urlPathProvider(_ value: InvokeModelInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke"
    }
}

extension InvokeModelInput {

    static func headerProvider(_ value: InvokeModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension InvokeModelWithResponseStreamInput {

    static func urlPathProvider(_ value: InvokeModelWithResponseStreamInput) -> Swift.String? {
        guard let modelId = value.modelId else {
            return nil
        }
        return "/model/\(modelId.urlPercentEncoding())/invoke-with-response-stream"
    }
}

extension InvokeModelWithResponseStreamInput {

    static func headerProvider(_ value: InvokeModelWithResponseStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-Accept", value: Swift.String(accept)))
        }
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let guardrailIdentifier = value.guardrailIdentifier {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-GuardrailIdentifier", value: Swift.String(guardrailIdentifier)))
        }
        if let guardrailVersion = value.guardrailVersion {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-GuardrailVersion", value: Swift.String(guardrailVersion)))
        }
        if let trace = value.trace {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Bedrock-Trace", value: Swift.String(trace.rawValue)))
        }
        return items
    }
}

extension ApplyGuardrailInput {

    static func write(value: ApplyGuardrailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockRuntimeClientTypes.GuardrailContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["source"].write(value.source)
    }
}

extension ConverseInput {

    static func write(value: ConverseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["additionalModelResponseFieldPaths"].writeList(value.additionalModelResponseFieldPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["guardrailConfig"].write(value.guardrailConfig, with: BedrockRuntimeClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockRuntimeClientTypes.InferenceConfiguration.write(value:to:))
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockRuntimeClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["system"].writeList(value.system, memberWritingClosure: BedrockRuntimeClientTypes.SystemContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toolConfig"].write(value.toolConfig, with: BedrockRuntimeClientTypes.ToolConfiguration.write(value:to:))
    }
}

extension ConverseStreamInput {

    static func write(value: ConverseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["additionalModelResponseFieldPaths"].writeList(value.additionalModelResponseFieldPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["guardrailConfig"].write(value.guardrailConfig, with: BedrockRuntimeClientTypes.GuardrailStreamConfiguration.write(value:to:))
        try writer["inferenceConfig"].write(value.inferenceConfig, with: BedrockRuntimeClientTypes.InferenceConfiguration.write(value:to:))
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockRuntimeClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["system"].writeList(value.system, memberWritingClosure: BedrockRuntimeClientTypes.SystemContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toolConfig"].write(value.toolConfig, with: BedrockRuntimeClientTypes.ToolConfiguration.write(value:to:))
    }
}

extension InvokeModelInput {

    static func write(value: InvokeModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension InvokeModelWithResponseStreamInput {

    static func write(value: InvokeModelWithResponseStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension ApplyGuardrailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApplyGuardrailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ApplyGuardrailOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.assessments = try reader["assessments"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.guardrailCoverage = try reader["guardrailCoverage"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailCoverage.read(from:))
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailOutputContent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailUsage.read(from:))
        return value
    }
}

extension ConverseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConverseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConverseOutput()
        value.additionalModelResponseFields = try reader["additionalModelResponseFields"].readIfPresent()
        value.metrics = try reader["metrics"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseMetrics.read(from:))
        value.output = try reader["output"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseOutput.read(from:))
        value.stopReason = try reader["stopReason"].readIfPresent() ?? .sdkUnknown("")
        value.trace = try reader["trace"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseTrace.read(from:))
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.TokenUsage.read(from:))
        return value
    }
}

extension ConverseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConverseStreamOutput {
        var value = ConverseStreamOutput()
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockRuntimeClientTypes.ConverseStreamOutput.unmarshal)
            value.stream = decoderStream.toAsyncStream()
        }
        return value
    }
}

extension InvokeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeModelOutput {
        var value = InvokeModelOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.body = data
        case .stream(let stream):
            value.body = try stream.readToEnd()
        case .noStream:
            value.body = nil
        }
        return value
    }
}

extension InvokeModelWithResponseStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeModelWithResponseStreamOutput {
        var value = InvokeModelWithResponseStreamOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "X-Amzn-Bedrock-Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if case .stream(let stream) = httpResponse.body {
            let messageDecoder = SmithyEventStreams.DefaultMessageDecoder()
            let decoderStream = SmithyEventStreams.DefaultMessageDecoderStream(stream: stream, messageDecoder: messageDecoder, unmarshalClosure: BedrockRuntimeClientTypes.ResponseStream.unmarshal)
            value.body = decoderStream.toAsyncStream()
        }
        return value
    }
}

enum ApplyGuardrailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConverseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConverseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeModelWithResponseStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ModelErrorException": return try ModelErrorException.makeError(baseError: baseError)
            case "ModelNotReadyException": return try ModelNotReadyException.makeError(baseError: baseError)
            case "ModelStreamErrorException": return try ModelStreamErrorException.makeError(baseError: baseError)
            case "ModelTimeoutException": return try ModelTimeoutException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelNotReadyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelNotReadyException {
        let reader = baseError.errorBodyReader
        var value = ModelNotReadyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ModelStreamErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ModelStreamErrorException {
        let reader = baseError.errorBodyReader
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamOutput {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockRuntimeClientTypes.ConverseStreamOutput> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "messageStart":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.MessageStartEvent.read(from:))
                    return .messagestart(value)
                case "contentBlockStart":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockStartEvent.read(from:))
                    return .contentblockstart(value)
                case "contentBlockDelta":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockDeltaEvent.read(from:))
                    return .contentblockdelta(value)
                case "contentBlockStop":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ContentBlockStopEvent.read(from:))
                    return .contentblockstop(value)
                case "messageStop":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.MessageStopEvent.read(from:))
                    return .messagestop(value)
                case "metadata":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.ConverseStreamMetadataEvent.read(from:))
                    return .metadata(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "modelStreamErrorException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamErrorException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "serviceUnavailableException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceUnavailableException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockRuntimeClientTypes.ResponseStream {
    static var unmarshal: SmithyEventStreamsAPI.UnmarshalClosure<BedrockRuntimeClientTypes.ResponseStream> {
        { message in
            switch try message.type() {
            case .event(let params):
                switch params.eventType {
                case "chunk":
                    let value = try SmithyJSON.Reader.readFrom(message.payload, with: BedrockRuntimeClientTypes.PayloadPart.read(from:))
                    return .chunk(value)
                default:
                    return .sdkUnknown("error processing event stream, unrecognized event: \(params.eventType)")
                }
            case .exception(let params):
                let makeError: (SmithyEventStreamsAPI.Message, SmithyEventStreamsAPI.MessageType.ExceptionParams) throws -> Swift.Error = { message, params in
                    switch params.exceptionType {
                    case "internalServerException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: InternalServerException.read(from:))
                        return value
                    case "modelStreamErrorException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelStreamErrorException.read(from:))
                        return value
                    case "validationException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ValidationException.read(from:))
                        return value
                    case "throttlingException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ThrottlingException.read(from:))
                        return value
                    case "modelTimeoutException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ModelTimeoutException.read(from:))
                        return value
                    case "serviceUnavailableException":
                        let value = try SmithyJSON.Reader.readFrom(message.payload, with: ServiceUnavailableException.read(from:))
                        return value
                    default:
                        let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                        return AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':exceptionType': \(params.exceptionType); contentType: \(params.contentType ?? "nil")", requestID: nil, typeName: nil)
                    }
                }
                let error = try makeError(message, params)
                throw error
            case .error(let params):
                let httpResponse = SmithyHTTPAPI.HTTPResponse(body: .data(message.payload), statusCode: .ok)
                throw AWSClientRuntime.UnknownAWSHTTPServiceError(httpResponse: httpResponse, message: "error processing event stream, unrecognized ':errorType': \(params.errorCode); message: \(params.message ?? "nil")", requestID: nil, typeName: nil)
            case .unknown(messageType: let messageType):
                throw Smithy.ClientError.unknownError("unrecognized event stream message ':message-type': \(messageType)")
            }
        }
    }
}

extension BedrockRuntimeClientTypes.GuardrailUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailUsage()
        value.topicPolicyUnits = try reader["topicPolicyUnits"].readIfPresent() ?? 0
        value.contentPolicyUnits = try reader["contentPolicyUnits"].readIfPresent() ?? 0
        value.wordPolicyUnits = try reader["wordPolicyUnits"].readIfPresent() ?? 0
        value.sensitiveInformationPolicyUnits = try reader["sensitiveInformationPolicyUnits"].readIfPresent() ?? 0
        value.sensitiveInformationPolicyFreeUnits = try reader["sensitiveInformationPolicyFreeUnits"].readIfPresent() ?? 0
        value.contextualGroundingPolicyUnits = try reader["contextualGroundingPolicyUnits"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailOutputContent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailOutputContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailOutputContent()
        value.text = try reader["text"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailAssessment()
        value.topicPolicy = try reader["topicPolicy"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment.read(from:))
        value.contentPolicy = try reader["contentPolicy"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment.read(from:))
        value.wordPolicy = try reader["wordPolicy"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment.read(from:))
        value.sensitiveInformationPolicy = try reader["sensitiveInformationPolicy"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment.read(from:))
        value.contextualGroundingPolicy = try reader["contextualGroundingPolicy"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment.read(from:))
        value.invocationMetrics = try reader["invocationMetrics"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailInvocationMetrics.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailInvocationMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailInvocationMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailInvocationMetrics()
        value.guardrailProcessingLatency = try reader["guardrailProcessingLatency"].readIfPresent()
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailUsage.read(from:))
        value.guardrailCoverage = try reader["guardrailCoverage"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailCoverage.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailCoverage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailCoverage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailCoverage()
        value.textCharacters = try reader["textCharacters"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailTextCharactersCoverage()
        value.guarded = try reader["guarded"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailContextualGroundingPolicyAssessment()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailContextualGroundingFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["threshold"].readIfPresent() ?? 0.0
        value.score = try reader["score"].readIfPresent() ?? 0.0
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailSensitiveInformationPolicyAssessment()
        value.piiEntities = try reader["piiEntities"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailPiiEntityFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.regexes = try reader["regexes"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailRegexFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailRegexFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailRegexFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailRegexFilter()
        value.name = try reader["name"].readIfPresent()
        value.match = try reader["match"].readIfPresent()
        value.regex = try reader["regex"].readIfPresent()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailPiiEntityFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailPiiEntityFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailPiiEntityFilter()
        value.match = try reader["match"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailWordPolicyAssessment()
        value.customWords = try reader["customWords"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailCustomWord.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.managedWordLists = try reader["managedWordLists"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailManagedWord.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailManagedWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailManagedWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailManagedWord()
        value.match = try reader["match"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailCustomWord {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailCustomWord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailCustomWord()
        value.match = try reader["match"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailContentPolicyAssessment()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailContentFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailContentFilter {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailContentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailContentFilter()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.confidence = try reader["confidence"].readIfPresent() ?? .sdkUnknown("")
        value.filterStrength = try reader["filterStrength"].readIfPresent()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailTopicPolicyAssessment()
        value.topics = try reader["topics"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailTopic.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailTopic {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailTopic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailTopic()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "message":
                return .message(try reader["message"].read(with: BedrockRuntimeClientTypes.Message.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.Message {

    static func write(value: BedrockRuntimeClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockRuntimeClientTypes.ContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.Message {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.Message()
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.ContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlock {

    static func write(value: BedrockRuntimeClientTypes.ContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .document(document):
                try writer["document"].write(document, with: BedrockRuntimeClientTypes.DocumentBlock.write(value:to:))
            case let .guardcontent(guardcontent):
                try writer["guardContent"].write(guardcontent, with: BedrockRuntimeClientTypes.GuardrailConverseContentBlock.write(value:to:))
            case let .image(image):
                try writer["image"].write(image, with: BedrockRuntimeClientTypes.ImageBlock.write(value:to:))
            case let .text(text):
                try writer["text"].write(text)
            case let .toolresult(toolresult):
                try writer["toolResult"].write(toolresult, with: BedrockRuntimeClientTypes.ToolResultBlock.write(value:to:))
            case let .tooluse(tooluse):
                try writer["toolUse"].write(tooluse, with: BedrockRuntimeClientTypes.ToolUseBlock.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "image":
                return .image(try reader["image"].read(with: BedrockRuntimeClientTypes.ImageBlock.read(from:)))
            case "document":
                return .document(try reader["document"].read(with: BedrockRuntimeClientTypes.DocumentBlock.read(from:)))
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlock.read(from:)))
            case "toolResult":
                return .toolresult(try reader["toolResult"].read(with: BedrockRuntimeClientTypes.ToolResultBlock.read(from:)))
            case "guardContent":
                return .guardcontent(try reader["guardContent"].read(with: BedrockRuntimeClientTypes.GuardrailConverseContentBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.GuardrailConverseContentBlock {

    static func write(value: BedrockRuntimeClientTypes.GuardrailConverseContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text, with: BedrockRuntimeClientTypes.GuardrailConverseTextBlock.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailConverseContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read(with: BedrockRuntimeClientTypes.GuardrailConverseTextBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.GuardrailConverseTextBlock {

    static func write(value: BedrockRuntimeClientTypes.GuardrailConverseTextBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["qualifiers"].writeList(value.qualifiers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockRuntimeClientTypes.GuardrailConverseContentQualifier>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailConverseTextBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailConverseTextBlock()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.qualifiers = try reader["qualifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockRuntimeClientTypes.GuardrailConverseContentQualifier>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockRuntimeClientTypes.ToolResultBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolResultBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockRuntimeClientTypes.ToolResultContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
        try writer["toolUseId"].write(value.toolUseId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolResultBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolResultBlock()
        value.toolUseId = try reader["toolUseId"].readIfPresent() ?? ""
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockRuntimeClientTypes.ToolResultContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ToolResultContentBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolResultContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .document(document):
                try writer["document"].write(document, with: BedrockRuntimeClientTypes.DocumentBlock.write(value:to:))
            case let .image(image):
                try writer["image"].write(image, with: BedrockRuntimeClientTypes.ImageBlock.write(value:to:))
            case let .json(json):
                try writer["json"].write(json)
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolResultContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "json":
                return .json(try reader["json"].read())
            case "text":
                return .text(try reader["text"].read())
            case "image":
                return .image(try reader["image"].read(with: BedrockRuntimeClientTypes.ImageBlock.read(from:)))
            case "document":
                return .document(try reader["document"].read(with: BedrockRuntimeClientTypes.DocumentBlock.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.DocumentBlock {

    static func write(value: BedrockRuntimeClientTypes.DocumentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["name"].write(value.name)
        try writer["source"].write(value.source, with: BedrockRuntimeClientTypes.DocumentSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.DocumentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.DocumentBlock()
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent(with: BedrockRuntimeClientTypes.DocumentSource.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.DocumentSource {

    static func write(value: BedrockRuntimeClientTypes.DocumentSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bytes(bytes):
                try writer["bytes"].write(bytes)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.DocumentSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bytes":
                return .bytes(try reader["bytes"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ImageBlock {

    static func write(value: BedrockRuntimeClientTypes.ImageBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["source"].write(value.source, with: BedrockRuntimeClientTypes.ImageSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ImageBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ImageBlock()
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent(with: BedrockRuntimeClientTypes.ImageSource.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.ImageSource {

    static func write(value: BedrockRuntimeClientTypes.ImageSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .bytes(bytes):
                try writer["bytes"].write(bytes)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ImageSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "bytes":
                return .bytes(try reader["bytes"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlock {

    static func write(value: BedrockRuntimeClientTypes.ToolUseBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input)
        try writer["name"].write(value.name)
        try writer["toolUseId"].write(value.toolUseId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlock()
        value.toolUseId = try reader["toolUseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? [:]
        return value
    }
}

extension BedrockRuntimeClientTypes.TokenUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.TokenUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.TokenUsage()
        value.inputTokens = try reader["inputTokens"].readIfPresent() ?? 0
        value.outputTokens = try reader["outputTokens"].readIfPresent() ?? 0
        value.totalTokens = try reader["totalTokens"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseMetrics()
        value.latencyMs = try reader["latencyMs"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseTrace()
        value.guardrail = try reader["guardrail"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailTraceAssessment.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailTraceAssessment {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.GuardrailTraceAssessment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.GuardrailTraceAssessment()
        value.modelOutput = try reader["modelOutput"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputAssessment = try reader["inputAssessment"].readMapIfPresent(valueReadingClosure: BedrockRuntimeClientTypes.GuardrailAssessment.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputAssessments = try reader["outputAssessments"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: BedrockRuntimeClientTypes.GuardrailAssessment.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceUnavailableException {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceUnavailableException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ThrottlingException {

    static func read(from reader: SmithyJSON.Reader) throws -> ThrottlingException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ValidationException {

    static func read(from reader: SmithyJSON.Reader) throws -> ValidationException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ModelStreamErrorException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelStreamErrorException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelStreamErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.originalStatusCode = try reader["originalStatusCode"].readIfPresent()
        value.properties.originalMessage = try reader["originalMessage"].readIfPresent()
        return value
    }
}

extension InternalServerException {

    static func read(from reader: SmithyJSON.Reader) throws -> InternalServerException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamMetadataEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseStreamMetadataEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseStreamMetadataEvent()
        value.usage = try reader["usage"].readIfPresent(with: BedrockRuntimeClientTypes.TokenUsage.read(from:))
        value.metrics = try reader["metrics"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseStreamMetrics.read(from:))
        value.trace = try reader["trace"].readIfPresent(with: BedrockRuntimeClientTypes.ConverseStreamTrace.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamTrace {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseStreamTrace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseStreamTrace()
        value.guardrail = try reader["guardrail"].readIfPresent(with: BedrockRuntimeClientTypes.GuardrailTraceAssessment.read(from:))
        return value
    }
}

extension BedrockRuntimeClientTypes.ConverseStreamMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ConverseStreamMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ConverseStreamMetrics()
        value.latencyMs = try reader["latencyMs"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.MessageStopEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.MessageStopEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.MessageStopEvent()
        value.stopReason = try reader["stopReason"].readIfPresent() ?? .sdkUnknown("")
        value.additionalModelResponseFields = try reader["additionalModelResponseFields"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStopEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStopEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockStopEvent()
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockDeltaEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockDeltaEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockDeltaEvent()
        value.delta = try reader["delta"].readIfPresent(with: BedrockRuntimeClientTypes.ContentBlockDelta.read(from:))
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockDelta {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockDelta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlockDelta.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlockDelta {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlockDelta {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlockDelta()
        value.input = try reader["input"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStartEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStartEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ContentBlockStartEvent()
        value.start = try reader["start"].readIfPresent(with: BedrockRuntimeClientTypes.ContentBlockStart.read(from:))
        value.contentBlockIndex = try reader["contentBlockIndex"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockRuntimeClientTypes.ContentBlockStart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ContentBlockStart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "toolUse":
                return .tooluse(try reader["toolUse"].read(with: BedrockRuntimeClientTypes.ToolUseBlockStart.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockRuntimeClientTypes.ToolUseBlockStart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.ToolUseBlockStart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.ToolUseBlockStart()
        value.toolUseId = try reader["toolUseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockRuntimeClientTypes.MessageStartEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.MessageStartEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.MessageStartEvent()
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ModelTimeoutException {

    static func read(from reader: SmithyJSON.Reader) throws -> ModelTimeoutException {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ModelTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.PayloadPart {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockRuntimeClientTypes.PayloadPart {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockRuntimeClientTypes.PayloadPart()
        value.bytes = try reader["bytes"].readIfPresent()
        return value
    }
}

extension BedrockRuntimeClientTypes.GuardrailContentBlock {

    static func write(value: BedrockRuntimeClientTypes.GuardrailContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text, with: BedrockRuntimeClientTypes.GuardrailTextBlock.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.GuardrailTextBlock {

    static func write(value: BedrockRuntimeClientTypes.GuardrailTextBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["qualifiers"].writeList(value.qualifiers, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockRuntimeClientTypes.GuardrailContentQualifier>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["text"].write(value.text)
    }
}

extension BedrockRuntimeClientTypes.SystemContentBlock {

    static func write(value: BedrockRuntimeClientTypes.SystemContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .guardcontent(guardcontent):
                try writer["guardContent"].write(guardcontent, with: BedrockRuntimeClientTypes.GuardrailConverseContentBlock.write(value:to:))
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.InferenceConfiguration {

    static func write(value: BedrockRuntimeClientTypes.InferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }
}

extension BedrockRuntimeClientTypes.ToolConfiguration {

    static func write(value: BedrockRuntimeClientTypes.ToolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["toolChoice"].write(value.toolChoice, with: BedrockRuntimeClientTypes.ToolChoice.write(value:to:))
        try writer["tools"].writeList(value.tools, memberWritingClosure: BedrockRuntimeClientTypes.Tool.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockRuntimeClientTypes.ToolChoice {

    static func write(value: BedrockRuntimeClientTypes.ToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .any(any):
                try writer["any"].write(any, with: BedrockRuntimeClientTypes.AnyToolChoice.write(value:to:))
            case let .auto(auto):
                try writer["auto"].write(auto, with: BedrockRuntimeClientTypes.AutoToolChoice.write(value:to:))
            case let .tool(tool):
                try writer["tool"].write(tool, with: BedrockRuntimeClientTypes.SpecificToolChoice.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.SpecificToolChoice {

    static func write(value: BedrockRuntimeClientTypes.SpecificToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension BedrockRuntimeClientTypes.AnyToolChoice {

    static func write(value: BedrockRuntimeClientTypes.AnyToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension BedrockRuntimeClientTypes.AutoToolChoice {

    static func write(value: BedrockRuntimeClientTypes.AutoToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension BedrockRuntimeClientTypes.Tool {

    static func write(value: BedrockRuntimeClientTypes.Tool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .toolspec(toolspec):
                try writer["toolSpec"].write(toolspec, with: BedrockRuntimeClientTypes.ToolSpecification.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.ToolSpecification {

    static func write(value: BedrockRuntimeClientTypes.ToolSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputSchema"].write(value.inputSchema, with: BedrockRuntimeClientTypes.ToolInputSchema.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension BedrockRuntimeClientTypes.ToolInputSchema {

    static func write(value: BedrockRuntimeClientTypes.ToolInputSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .json(json):
                try writer["json"].write(json)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension BedrockRuntimeClientTypes.GuardrailConfiguration {

    static func write(value: BedrockRuntimeClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailIdentifier"].write(value.guardrailIdentifier)
        try writer["guardrailVersion"].write(value.guardrailVersion)
        try writer["trace"].write(value.trace)
    }
}

extension BedrockRuntimeClientTypes.GuardrailStreamConfiguration {

    static func write(value: BedrockRuntimeClientTypes.GuardrailStreamConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailIdentifier"].write(value.guardrailIdentifier)
        try writer["guardrailVersion"].write(value.guardrailVersion)
        try writer["streamProcessingMode"].write(value.streamProcessingMode)
        try writer["trace"].write(value.trace)
    }
}

public enum BedrockRuntimeClientTypes {}
