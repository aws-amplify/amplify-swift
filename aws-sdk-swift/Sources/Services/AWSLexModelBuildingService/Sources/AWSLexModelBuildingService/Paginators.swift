//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension LexModelBuildingClient {
    /// Paginate over `[GetBotAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBotAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBotAliasesOutput`
    public func getBotAliasesPaginated(input: GetBotAliasesInput) -> ClientRuntime.PaginatorSequence<GetBotAliasesInput, GetBotAliasesOutput> {
        return ClientRuntime.PaginatorSequence<GetBotAliasesInput, GetBotAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBotAliases(input:))
    }
}

extension GetBotAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBotAliasesInput {
        return GetBotAliasesInput(
            botName: self.botName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetBotChannelAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBotChannelAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBotChannelAssociationsOutput`
    public func getBotChannelAssociationsPaginated(input: GetBotChannelAssociationsInput) -> ClientRuntime.PaginatorSequence<GetBotChannelAssociationsInput, GetBotChannelAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<GetBotChannelAssociationsInput, GetBotChannelAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBotChannelAssociations(input:))
    }
}

extension GetBotChannelAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBotChannelAssociationsInput {
        return GetBotChannelAssociationsInput(
            botAlias: self.botAlias,
            botName: self.botName,
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetBotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBotsOutput`
    public func getBotsPaginated(input: GetBotsInput) -> ClientRuntime.PaginatorSequence<GetBotsInput, GetBotsOutput> {
        return ClientRuntime.PaginatorSequence<GetBotsInput, GetBotsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBots(input:))
    }
}

extension GetBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBotsInput {
        return GetBotsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetBotVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBotVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBotVersionsOutput`
    public func getBotVersionsPaginated(input: GetBotVersionsInput) -> ClientRuntime.PaginatorSequence<GetBotVersionsInput, GetBotVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetBotVersionsInput, GetBotVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBotVersions(input:))
    }
}

extension GetBotVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBotVersionsInput {
        return GetBotVersionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetBuiltinIntentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBuiltinIntentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBuiltinIntentsOutput`
    public func getBuiltinIntentsPaginated(input: GetBuiltinIntentsInput) -> ClientRuntime.PaginatorSequence<GetBuiltinIntentsInput, GetBuiltinIntentsOutput> {
        return ClientRuntime.PaginatorSequence<GetBuiltinIntentsInput, GetBuiltinIntentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBuiltinIntents(input:))
    }
}

extension GetBuiltinIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBuiltinIntentsInput {
        return GetBuiltinIntentsInput(
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            signatureContains: self.signatureContains
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetBuiltinSlotTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBuiltinSlotTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBuiltinSlotTypesOutput`
    public func getBuiltinSlotTypesPaginated(input: GetBuiltinSlotTypesInput) -> ClientRuntime.PaginatorSequence<GetBuiltinSlotTypesInput, GetBuiltinSlotTypesOutput> {
        return ClientRuntime.PaginatorSequence<GetBuiltinSlotTypesInput, GetBuiltinSlotTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBuiltinSlotTypes(input:))
    }
}

extension GetBuiltinSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBuiltinSlotTypesInput {
        return GetBuiltinSlotTypesInput(
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            signatureContains: self.signatureContains
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetIntentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetIntentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetIntentsOutput`
    public func getIntentsPaginated(input: GetIntentsInput) -> ClientRuntime.PaginatorSequence<GetIntentsInput, GetIntentsOutput> {
        return ClientRuntime.PaginatorSequence<GetIntentsInput, GetIntentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getIntents(input:))
    }
}

extension GetIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIntentsInput {
        return GetIntentsInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetIntentVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetIntentVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetIntentVersionsOutput`
    public func getIntentVersionsPaginated(input: GetIntentVersionsInput) -> ClientRuntime.PaginatorSequence<GetIntentVersionsInput, GetIntentVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetIntentVersionsInput, GetIntentVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getIntentVersions(input:))
    }
}

extension GetIntentVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetIntentVersionsInput {
        return GetIntentVersionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetMigrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetMigrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetMigrationsOutput`
    public func getMigrationsPaginated(input: GetMigrationsInput) -> ClientRuntime.PaginatorSequence<GetMigrationsInput, GetMigrationsOutput> {
        return ClientRuntime.PaginatorSequence<GetMigrationsInput, GetMigrationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getMigrations(input:))
    }
}

extension GetMigrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetMigrationsInput {
        return GetMigrationsInput(
            maxResults: self.maxResults,
            migrationStatusEquals: self.migrationStatusEquals,
            nextToken: token,
            sortByAttribute: self.sortByAttribute,
            sortByOrder: self.sortByOrder,
            v1BotNameContains: self.v1BotNameContains
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetSlotTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSlotTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSlotTypesOutput`
    public func getSlotTypesPaginated(input: GetSlotTypesInput) -> ClientRuntime.PaginatorSequence<GetSlotTypesInput, GetSlotTypesOutput> {
        return ClientRuntime.PaginatorSequence<GetSlotTypesInput, GetSlotTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSlotTypes(input:))
    }
}

extension GetSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSlotTypesInput {
        return GetSlotTypesInput(
            maxResults: self.maxResults,
            nameContains: self.nameContains,
            nextToken: token
        )}
}
extension LexModelBuildingClient {
    /// Paginate over `[GetSlotTypeVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSlotTypeVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSlotTypeVersionsOutput`
    public func getSlotTypeVersionsPaginated(input: GetSlotTypeVersionsInput) -> ClientRuntime.PaginatorSequence<GetSlotTypeVersionsInput, GetSlotTypeVersionsOutput> {
        return ClientRuntime.PaginatorSequence<GetSlotTypeVersionsInput, GetSlotTypeVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSlotTypeVersions(input:))
    }
}

extension GetSlotTypeVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSlotTypeVersionsInput {
        return GetSlotTypeVersionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
