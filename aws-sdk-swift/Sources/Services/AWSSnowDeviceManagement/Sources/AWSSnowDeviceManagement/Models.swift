//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SnowDeviceManagementClientTypes {

    public enum AttachmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attached
        case attaching
        case detached
        case detaching
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .attached,
                .attaching,
                .detached,
                .detaching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attached: return "ATTACHED"
            case .attaching: return "ATTACHING"
            case .detached: return "DETACHED"
            case .detaching: return "DETACHING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelTaskInput: Swift.Sendable {
    /// The ID of the task that you are attempting to cancel. You can retrieve a task ID by using the ListTasks operation.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct CancelTaskOutput: Swift.Sendable {
    /// The ID of the task that you are attempting to cancel.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension SnowDeviceManagementClientTypes {

    /// The physical capacity of the Amazon Web Services Snow Family device.
    public struct Capacity: Swift.Sendable {
        /// The amount of capacity available for use on the device.
        public var available: Swift.Int?
        /// The name of the type of capacity, such as memory.
        public var name: Swift.String?
        /// The total capacity on the device.
        public var total: Swift.Int?
        /// The unit of measure for the type of capacity.
        public var unit: Swift.String?
        /// The amount of capacity used on the device.
        public var used: Swift.Int?

        public init(
            available: Swift.Int? = nil,
            name: Swift.String? = nil,
            total: Swift.Int? = nil,
            unit: Swift.String? = nil,
            used: Swift.Int? = nil
        )
        {
            self.available = available
            self.name = name
            self.total = total
            self.unit = unit
            self.used = used
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// A structure used to reboot the device.
    public struct Reboot: Swift.Sendable {

        public init() { }
    }
}

extension SnowDeviceManagementClientTypes {

    /// A structure used to unlock a device.
    public struct Unlock: Swift.Sendable {

        public init() { }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The command given to the device to execute.
    public enum Command: Swift.Sendable {
        /// Unlocks the device.
        case unlock(SnowDeviceManagementClientTypes.Unlock)
        /// Reboots the device.
        case reboot(SnowDeviceManagementClientTypes.Reboot)
        case sdkUnknown(Swift.String)
    }
}

extension SnowDeviceManagementClientTypes {

    /// The options for how a device's CPU is configured.
    public struct CpuOptions: Swift.Sendable {
        /// The number of cores that the CPU can use.
        public var coreCount: Swift.Int?
        /// The number of threads per core in the CPU.
        public var threadsPerCore: Swift.Int?

        public init(
            coreCount: Swift.Int? = nil,
            threadsPerCore: Swift.Int? = nil
        )
        {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateTaskInput: Swift.Sendable {
    /// A token ensuring that the action is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The task to be performed. Only one task is executed on a device at a time.
    /// This member is required.
    public var command: SnowDeviceManagementClientTypes.Command?
    /// A description of the task and its targets.
    public var description: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?
    /// A list of managed device IDs.
    /// This member is required.
    public var targets: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        command: SnowDeviceManagementClientTypes.Command? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.command = command
        self.description = description
        self.tags = tags
        self.targets = targets
    }
}

public struct CreateTaskOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the task that you created.
    public var taskArn: Swift.String?
    /// The ID of the task that you created.
    public var taskId: Swift.String?

    public init(
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

public struct DescribeDeviceInput: Swift.Sendable {
    /// The ID of the device that you are checking the information of.
    /// This member is required.
    public var managedDeviceId: Swift.String?

    public init(
        managedDeviceId: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
    }
}

extension SnowDeviceManagementClientTypes {

    public enum UnlockState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case locked
        case unlocked
        case unlocking
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlockState] {
            return [
                .locked,
                .unlocked,
                .unlocking
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .locked: return "LOCKED"
            case .unlocked: return "UNLOCKED"
            case .unlocking: return "UNLOCKING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowDeviceManagementClientTypes {

    public enum IpAddressAssignment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dhcp
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressAssignment] {
            return [
                .dhcp,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dhcp: return "DHCP"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowDeviceManagementClientTypes {

    public enum PhysicalConnectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case qsfp
        case rj45
        case rj452
        case sfpPlus
        case wifi
        case sdkUnknown(Swift.String)

        public static var allCases: [PhysicalConnectorType] {
            return [
                .qsfp,
                .rj45,
                .rj452,
                .sfpPlus,
                .wifi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .qsfp: return "QSFP"
            case .rj45: return "RJ45"
            case .rj452: return "RJ45_2"
            case .sfpPlus: return "SFP_PLUS"
            case .wifi: return "WIFI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The details about the physical network interface for the device.
    public struct PhysicalNetworkInterface: Swift.Sendable {
        /// The default gateway of the device.
        public var defaultGateway: Swift.String?
        /// The IP address of the device.
        public var ipAddress: Swift.String?
        /// A value that describes whether the IP address is dynamic or persistent.
        public var ipAddressAssignment: SnowDeviceManagementClientTypes.IpAddressAssignment?
        /// The MAC address of the device.
        public var macAddress: Swift.String?
        /// The netmask used to divide the IP address into subnets.
        public var netmask: Swift.String?
        /// The physical connector type.
        public var physicalConnectorType: SnowDeviceManagementClientTypes.PhysicalConnectorType?
        /// The physical network interface ID.
        public var physicalNetworkInterfaceId: Swift.String?

        public init(
            defaultGateway: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            ipAddressAssignment: SnowDeviceManagementClientTypes.IpAddressAssignment? = nil,
            macAddress: Swift.String? = nil,
            netmask: Swift.String? = nil,
            physicalConnectorType: SnowDeviceManagementClientTypes.PhysicalConnectorType? = nil,
            physicalNetworkInterfaceId: Swift.String? = nil
        )
        {
            self.defaultGateway = defaultGateway
            self.ipAddress = ipAddress
            self.ipAddressAssignment = ipAddressAssignment
            self.macAddress = macAddress
            self.netmask = netmask
            self.physicalConnectorType = physicalConnectorType
            self.physicalNetworkInterfaceId = physicalNetworkInterfaceId
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// Information about the software on the device.
    public struct SoftwareInformation: Swift.Sendable {
        /// The state of the software that is installed or that is being installed on the device.
        public var installState: Swift.String?
        /// The version of the software currently installed on the device.
        public var installedVersion: Swift.String?
        /// The version of the software being installed on the device.
        public var installingVersion: Swift.String?

        public init(
            installState: Swift.String? = nil,
            installedVersion: Swift.String? = nil,
            installingVersion: Swift.String? = nil
        )
        {
            self.installState = installState
            self.installedVersion = installedVersion
            self.installingVersion = installingVersion
        }
    }
}

public struct DescribeDeviceOutput: Swift.Sendable {
    /// The ID of the job used when ordering the device.
    public var associatedWithJob: Swift.String?
    /// The hardware specifications of the device.
    public var deviceCapacities: [SnowDeviceManagementClientTypes.Capacity]?
    /// The current state of the device.
    public var deviceState: SnowDeviceManagementClientTypes.UnlockState?
    /// The type of Amazon Web Services Snow Family device.
    public var deviceType: Swift.String?
    /// When the device last contacted the Amazon Web Services Cloud. Indicates that the device is online.
    public var lastReachedOutAt: Foundation.Date?
    /// When the device last pushed an update to the Amazon Web Services Cloud. Indicates when the device cache was refreshed.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the device.
    public var managedDeviceArn: Swift.String?
    /// The ID of the device that you checked the information for.
    public var managedDeviceId: Swift.String?
    /// The network interfaces available on the device.
    public var physicalNetworkInterfaces: [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]?
    /// The software installed on the device.
    public var software: SnowDeviceManagementClientTypes.SoftwareInformation?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        associatedWithJob: Swift.String? = nil,
        deviceCapacities: [SnowDeviceManagementClientTypes.Capacity]? = nil,
        deviceState: SnowDeviceManagementClientTypes.UnlockState? = nil,
        deviceType: Swift.String? = nil,
        lastReachedOutAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        managedDeviceArn: Swift.String? = nil,
        managedDeviceId: Swift.String? = nil,
        physicalNetworkInterfaces: [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]? = nil,
        software: SnowDeviceManagementClientTypes.SoftwareInformation? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.associatedWithJob = associatedWithJob
        self.deviceCapacities = deviceCapacities
        self.deviceState = deviceState
        self.deviceType = deviceType
        self.lastReachedOutAt = lastReachedOutAt
        self.lastUpdatedAt = lastUpdatedAt
        self.managedDeviceArn = managedDeviceArn
        self.managedDeviceId = managedDeviceId
        self.physicalNetworkInterfaces = physicalNetworkInterfaces
        self.software = software
        self.tags = tags
    }
}

public struct DescribeDeviceEc2InstancesInput: Swift.Sendable {
    /// A list of instance IDs associated with the managed device.
    /// This member is required.
    public var instanceIds: [Swift.String]?
    /// The ID of the managed device.
    /// This member is required.
    public var managedDeviceId: Swift.String?

    public init(
        instanceIds: [Swift.String]? = nil,
        managedDeviceId: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.managedDeviceId = managedDeviceId
    }
}

extension SnowDeviceManagementClientTypes {

    /// Describes a parameter used to set up an Amazon Elastic Block Store (Amazon EBS) volume in a block device mapping.
    public struct EbsInstanceBlockDevice: Swift.Sendable {
        /// When the attachment was initiated.
        public var attachTime: Foundation.Date?
        /// A value that indicates whether the volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// The attachment state.
        public var status: SnowDeviceManagementClientTypes.AttachmentStatus?
        /// The ID of the Amazon EBS volume.
        public var volumeId: Swift.String?

        public init(
            attachTime: Foundation.Date? = nil,
            deleteOnTermination: Swift.Bool? = nil,
            status: SnowDeviceManagementClientTypes.AttachmentStatus? = nil,
            volumeId: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The description of a block device mapping.
    public struct InstanceBlockDeviceMapping: Swift.Sendable {
        /// The block device name.
        public var deviceName: Swift.String?
        /// The parameters used to automatically set up Amazon Elastic Block Store (Amazon EBS) volumes when the instance is launched.
        public var ebs: SnowDeviceManagementClientTypes.EbsInstanceBlockDevice?

        public init(
            deviceName: Swift.String? = nil,
            ebs: SnowDeviceManagementClientTypes.EbsInstanceBlockDevice? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// Information about the device's security group.
    public struct SecurityGroupIdentifier: Swift.Sendable {
        /// The security group ID.
        public var groupId: Swift.String?
        /// The security group name.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }
}

extension SnowDeviceManagementClientTypes {

    public enum InstanceStateName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pending
        case running
        case shuttingDown
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStateName] {
            return [
                .pending,
                .running,
                .shuttingDown,
                .stopped,
                .stopping,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .shuttingDown: return "SHUTTING_DOWN"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The description of the current state of an instance.
    public struct InstanceState: Swift.Sendable {
        /// The state of the instance as a 16-bit unsigned integer. The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored. The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. The valid values for the instance state code are all in the range of the low byte. These values are:
        ///
        /// * 0 : pending
        ///
        /// * 16 : running
        ///
        /// * 32 : shutting-down
        ///
        /// * 48 : terminated
        ///
        /// * 64 : stopping
        ///
        /// * 80 : stopped
        ///
        ///
        /// You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.
        public var code: Swift.Int?
        /// The current state of the instance.
        public var name: SnowDeviceManagementClientTypes.InstanceStateName?

        public init(
            code: Swift.Int? = nil,
            name: SnowDeviceManagementClientTypes.InstanceStateName? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The description of an instance. Currently, Amazon EC2 instances are the only supported instance type.
    public struct Instance: Swift.Sendable {
        /// The Amazon Machine Image (AMI) launch index, which you can use to find this instance in the launch group.
        public var amiLaunchIndex: Swift.Int?
        /// Any block device mapping entries for the instance.
        public var blockDeviceMappings: [SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]?
        /// The CPU options for the instance.
        public var cpuOptions: SnowDeviceManagementClientTypes.CpuOptions?
        /// When the instance was created.
        public var createdAt: Foundation.Date?
        /// The ID of the AMI used to launch the instance.
        public var imageId: Swift.String?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// The instance type.
        public var instanceType: Swift.String?
        /// The private IPv4 address assigned to the instance.
        public var privateIpAddress: Swift.String?
        /// The public IPv4 address assigned to the instance.
        public var publicIpAddress: Swift.String?
        /// The device name of the root device volume (for example, /dev/sda1).
        public var rootDeviceName: Swift.String?
        /// The security groups for the instance.
        public var securityGroups: [SnowDeviceManagementClientTypes.SecurityGroupIdentifier]?
        /// The description of the current state of an instance.
        public var state: SnowDeviceManagementClientTypes.InstanceState?
        /// When the instance was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            amiLaunchIndex: Swift.Int? = nil,
            blockDeviceMappings: [SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]? = nil,
            cpuOptions: SnowDeviceManagementClientTypes.CpuOptions? = nil,
            createdAt: Foundation.Date? = nil,
            imageId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil,
            rootDeviceName: Swift.String? = nil,
            securityGroups: [SnowDeviceManagementClientTypes.SecurityGroupIdentifier]? = nil,
            state: SnowDeviceManagementClientTypes.InstanceState? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.amiLaunchIndex = amiLaunchIndex
            self.blockDeviceMappings = blockDeviceMappings
            self.cpuOptions = cpuOptions
            self.createdAt = createdAt
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
            self.rootDeviceName = rootDeviceName
            self.securityGroups = securityGroups
            self.state = state
            self.updatedAt = updatedAt
        }
    }
}

extension SnowDeviceManagementClientTypes {

    /// The details about the instance.
    public struct InstanceSummary: Swift.Sendable {
        /// A structure containing details about the instance.
        public var instance: SnowDeviceManagementClientTypes.Instance?
        /// When the instance summary was last updated.
        public var lastUpdatedAt: Foundation.Date?

        public init(
            instance: SnowDeviceManagementClientTypes.Instance? = nil,
            lastUpdatedAt: Foundation.Date? = nil
        )
        {
            self.instance = instance
            self.lastUpdatedAt = lastUpdatedAt
        }
    }
}

public struct DescribeDeviceEc2InstancesOutput: Swift.Sendable {
    /// A list of structures containing information about each instance.
    public var instances: [SnowDeviceManagementClientTypes.InstanceSummary]?

    public init(
        instances: [SnowDeviceManagementClientTypes.InstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

public struct DescribeExecutionInput: Swift.Sendable {
    /// The ID of the managed device.
    /// This member is required.
    public var managedDeviceId: Swift.String?
    /// The ID of the task that the action is describing.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        managedDeviceId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
        self.taskId = taskId
    }
}

extension SnowDeviceManagementClientTypes {

    public enum ExecutionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionState] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeExecutionOutput: Swift.Sendable {
    /// The ID of the execution.
    public var executionId: Swift.String?
    /// When the status of the execution was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The ID of the managed device that the task is being executed on.
    public var managedDeviceId: Swift.String?
    /// When the execution began.
    public var startedAt: Foundation.Date?
    /// The current state of the execution.
    public var state: SnowDeviceManagementClientTypes.ExecutionState?
    /// The ID of the task being executed on the device.
    public var taskId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        managedDeviceId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.lastUpdatedAt = lastUpdatedAt
        self.managedDeviceId = managedDeviceId
        self.startedAt = startedAt
        self.state = state
        self.taskId = taskId
    }
}

public struct DescribeTaskInput: Swift.Sendable {
    /// The ID of the task to be described.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

extension SnowDeviceManagementClientTypes {

    public enum TaskState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case completed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskState] {
            return [
                .canceled,
                .completed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeTaskOutput: Swift.Sendable {
    /// When the task was completed.
    public var completedAt: Foundation.Date?
    /// When the CreateTask operation was called.
    public var createdAt: Foundation.Date?
    /// The description provided of the task and managed devices.
    public var description: Swift.String?
    /// When the state of the task was last updated.
    public var lastUpdatedAt: Foundation.Date?
    /// The current state of the task.
    public var state: SnowDeviceManagementClientTypes.TaskState?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String: Swift.String]?
    /// The managed devices that the task was sent to.
    public var targets: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the task.
    public var taskArn: Swift.String?
    /// The ID of the task.
    public var taskId: Swift.String?

    public init(
        completedAt: Foundation.Date? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        state: SnowDeviceManagementClientTypes.TaskState? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targets: [Swift.String]? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.state = state
        self.tags = tags
        self.targets = targets
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

extension SnowDeviceManagementClientTypes {

    /// Identifying information about the device.
    public struct DeviceSummary: Swift.Sendable {
        /// The ID of the job used to order the device.
        public var associatedWithJob: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var managedDeviceArn: Swift.String?
        /// The ID of the device.
        public var managedDeviceId: Swift.String?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public var tags: [Swift.String: Swift.String]?

        public init(
            associatedWithJob: Swift.String? = nil,
            managedDeviceArn: Swift.String? = nil,
            managedDeviceId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.associatedWithJob = associatedWithJob
            self.managedDeviceArn = managedDeviceArn
            self.managedDeviceId = managedDeviceId
            self.tags = tags
        }
    }
}

public struct ListExecutionsInput: Swift.Sendable {
    /// The maximum number of tasks to list per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A structure used to filter the tasks by their current state.
    public var state: SnowDeviceManagementClientTypes.ExecutionState?
    /// The ID of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
        self.taskId = taskId
    }
}

extension SnowDeviceManagementClientTypes {

    /// The summary of a task execution on a specified device.
    public struct ExecutionSummary: Swift.Sendable {
        /// The ID of the execution.
        public var executionId: Swift.String?
        /// The ID of the managed device that the task is being executed on.
        public var managedDeviceId: Swift.String?
        /// The state of the execution.
        public var state: SnowDeviceManagementClientTypes.ExecutionState?
        /// The ID of the task.
        public var taskId: Swift.String?

        public init(
            executionId: Swift.String? = nil,
            managedDeviceId: Swift.String? = nil,
            state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.executionId = executionId
            self.managedDeviceId = managedDeviceId
            self.state = state
            self.taskId = taskId
        }
    }
}

public struct ListExecutionsOutput: Swift.Sendable {
    /// A list of executions. Each execution contains the task ID, the device that the task is executing on, the execution ID, and the status of the execution.
    public var executions: [SnowDeviceManagementClientTypes.ExecutionSummary]?
    /// A pagination token to continue to the next page of executions.
    public var nextToken: Swift.String?

    public init(
        executions: [SnowDeviceManagementClientTypes.ExecutionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

public struct ListDeviceResourcesInput: Swift.Sendable {
    /// The ID of the managed device that you are listing the resources of.
    /// This member is required.
    public var managedDeviceId: Swift.String?
    /// The maximum number of resources per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A structure used to filter the results by type of resource.
    public var type: Swift.String?

    public init(
        managedDeviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

extension SnowDeviceManagementClientTypes {

    /// A summary of a resource available on the device.
    public struct ResourceSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The ID of the resource.
        public var id: Swift.String?
        /// The resource type.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.resourceType = resourceType
        }
    }
}

public struct ListDeviceResourcesOutput: Swift.Sendable {
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A structure defining the resource's type, Amazon Resource Name (ARN), and ID.
    public var resources: [SnowDeviceManagementClientTypes.ResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [SnowDeviceManagementClientTypes.ResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

public struct ListDevicesInput: Swift.Sendable {
    /// The ID of the job used to order the device.
    public var jobId: Swift.String?
    /// The maximum number of devices to list per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDevicesOutput: Swift.Sendable {
    /// A list of device structures that contain information about the device.
    public var devices: [SnowDeviceManagementClientTypes.DeviceSummary]?
    /// A pagination token to continue to the next page of devices.
    public var nextToken: Swift.String?

    public init(
        devices: [SnowDeviceManagementClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags for the device or task.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTasksInput: Swift.Sendable {
    /// The maximum number of tasks per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A structure used to filter the list of tasks.
    public var state: SnowDeviceManagementClientTypes.TaskState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: SnowDeviceManagementClientTypes.TaskState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

extension SnowDeviceManagementClientTypes {

    /// Information about the task assigned to one or many devices.
    public struct TaskSummary: Swift.Sendable {
        /// The state of the task assigned to one or many devices.
        public var state: SnowDeviceManagementClientTypes.TaskState?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public var tags: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of the task.
        public var taskArn: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            state: SnowDeviceManagementClientTypes.TaskState? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            taskArn: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.state = state
            self.tags = tags
            self.taskArn = taskArn
            self.taskId = taskId
        }
    }
}

public struct ListTasksOutput: Swift.Sendable {
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A list of task structures containing details about each task.
    public var tasks: [SnowDeviceManagementClientTypes.TaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [SnowDeviceManagementClientTypes.TaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension CancelTaskInput {

    static func urlPathProvider(_ value: CancelTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())/cancel"
    }
}

extension CreateTaskInput {

    static func urlPathProvider(_ value: CreateTaskInput) -> Swift.String? {
        return "/task"
    }
}

extension DescribeDeviceInput {

    static func urlPathProvider(_ value: DescribeDeviceInput) -> Swift.String? {
        guard let managedDeviceId = value.managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/describe"
    }
}

extension DescribeDeviceEc2InstancesInput {

    static func urlPathProvider(_ value: DescribeDeviceEc2InstancesInput) -> Swift.String? {
        guard let managedDeviceId = value.managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/resources/ec2/describe"
    }
}

extension DescribeExecutionInput {

    static func urlPathProvider(_ value: DescribeExecutionInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        guard let managedDeviceId = value.managedDeviceId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())/execution/\(managedDeviceId.urlPercentEncoding())"
    }
}

extension DescribeTaskInput {

    static func urlPathProvider(_ value: DescribeTaskInput) -> Swift.String? {
        guard let taskId = value.taskId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())"
    }
}

extension ListDeviceResourcesInput {

    static func urlPathProvider(_ value: ListDeviceResourcesInput) -> Swift.String? {
        guard let managedDeviceId = value.managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/resources"
    }
}

extension ListDeviceResourcesInput {

    static func queryItemProvider(_ value: ListDeviceResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/managed-devices"
    }
}

extension ListDevicesInput {

    static func queryItemProvider(_ value: ListDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let jobId = value.jobId {
            let jobIdQueryItem = Smithy.URIQueryItem(name: "jobId".urlPercentEncoding(), value: Swift.String(jobId).urlPercentEncoding())
            items.append(jobIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListExecutionsInput {

    static func urlPathProvider(_ value: ListExecutionsInput) -> Swift.String? {
        return "/executions"
    }
}

extension ListExecutionsInput {

    static func queryItemProvider(_ value: ListExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        guard let taskId = value.taskId else {
            let message = "Creating a URL Query Item failed. taskId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let taskIdQueryItem = Smithy.URIQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
        items.append(taskIdQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTasksInput {

    static func urlPathProvider(_ value: ListTasksInput) -> Swift.String? {
        return "/tasks"
    }
}

extension ListTasksInput {

    static func queryItemProvider(_ value: ListTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = Smithy.URIQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CreateTaskInput {

    static func write(value: CreateTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["command"].write(value.command, with: SnowDeviceManagementClientTypes.Command.write(value:to:))
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeDeviceEc2InstancesInput {

    static func write(value: DescribeDeviceEc2InstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CancelTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension CreateTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTaskOutput()
        value.taskArn = try reader["taskArn"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension DescribeDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceOutput()
        value.associatedWithJob = try reader["associatedWithJob"].readIfPresent()
        value.deviceCapacities = try reader["deviceCapacities"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.Capacity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceState = try reader["deviceState"].readIfPresent()
        value.deviceType = try reader["deviceType"].readIfPresent()
        value.lastReachedOutAt = try reader["lastReachedOutAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.managedDeviceArn = try reader["managedDeviceArn"].readIfPresent()
        value.managedDeviceId = try reader["managedDeviceId"].readIfPresent()
        value.physicalNetworkInterfaces = try reader["physicalNetworkInterfaces"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.PhysicalNetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.software = try reader["software"].readIfPresent(with: SnowDeviceManagementClientTypes.SoftwareInformation.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeDeviceEc2InstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeviceEc2InstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceEc2InstancesOutput()
        value.instances = try reader["instances"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.InstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExecutionOutput()
        value.executionId = try reader["executionId"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.managedDeviceId = try reader["managedDeviceId"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["state"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension DescribeTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTaskOutput()
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskArn = try reader["taskArn"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        return value
    }
}

extension ListDeviceResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.ResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.DeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExecutionsOutput()
        value.executions = try reader["executions"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.ExecutionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.TaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CancelTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeviceEc2InstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnowDeviceManagementClientTypes.PhysicalNetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.PhysicalNetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.PhysicalNetworkInterface()
        value.physicalNetworkInterfaceId = try reader["physicalNetworkInterfaceId"].readIfPresent()
        value.physicalConnectorType = try reader["physicalConnectorType"].readIfPresent()
        value.ipAddressAssignment = try reader["ipAddressAssignment"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.netmask = try reader["netmask"].readIfPresent()
        value.defaultGateway = try reader["defaultGateway"].readIfPresent()
        value.macAddress = try reader["macAddress"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.Capacity {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.Capacity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.Capacity()
        value.name = try reader["name"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        value.used = try reader["used"].readIfPresent()
        value.available = try reader["available"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.SoftwareInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.SoftwareInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.SoftwareInformation()
        value.installedVersion = try reader["installedVersion"].readIfPresent()
        value.installingVersion = try reader["installingVersion"].readIfPresent()
        value.installState = try reader["installState"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.InstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.InstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.InstanceSummary()
        value.instance = try reader["instance"].readIfPresent(with: SnowDeviceManagementClientTypes.Instance.read(from:))
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SnowDeviceManagementClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.Instance()
        value.imageId = try reader["imageId"].readIfPresent()
        value.amiLaunchIndex = try reader["amiLaunchIndex"].readIfPresent()
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.state = try reader["state"].readIfPresent(with: SnowDeviceManagementClientTypes.InstanceState.read(from:))
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.privateIpAddress = try reader["privateIpAddress"].readIfPresent()
        value.publicIpAddress = try reader["publicIpAddress"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.blockDeviceMappings = try reader["blockDeviceMappings"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SnowDeviceManagementClientTypes.SecurityGroupIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cpuOptions = try reader["cpuOptions"].readIfPresent(with: SnowDeviceManagementClientTypes.CpuOptions.read(from:))
        value.rootDeviceName = try reader["rootDeviceName"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.CpuOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.CpuOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.CpuOptions()
        value.coreCount = try reader["coreCount"].readIfPresent()
        value.threadsPerCore = try reader["threadsPerCore"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.SecurityGroupIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.SecurityGroupIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.SecurityGroupIdentifier()
        value.groupId = try reader["groupId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping()
        value.deviceName = try reader["deviceName"].readIfPresent()
        value.ebs = try reader["ebs"].readIfPresent(with: SnowDeviceManagementClientTypes.EbsInstanceBlockDevice.read(from:))
        return value
    }
}

extension SnowDeviceManagementClientTypes.EbsInstanceBlockDevice {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.EbsInstanceBlockDevice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.EbsInstanceBlockDevice()
        value.attachTime = try reader["attachTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deleteOnTermination = try reader["deleteOnTermination"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.volumeId = try reader["volumeId"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.InstanceState {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.InstanceState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.InstanceState()
        value.code = try reader["code"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.ResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.ResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.ResourceSummary()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.DeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.DeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.DeviceSummary()
        value.managedDeviceId = try reader["managedDeviceId"].readIfPresent()
        value.managedDeviceArn = try reader["managedDeviceArn"].readIfPresent()
        value.associatedWithJob = try reader["associatedWithJob"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SnowDeviceManagementClientTypes.ExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.ExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.ExecutionSummary()
        value.taskId = try reader["taskId"].readIfPresent()
        value.executionId = try reader["executionId"].readIfPresent()
        value.managedDeviceId = try reader["managedDeviceId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension SnowDeviceManagementClientTypes.TaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowDeviceManagementClientTypes.TaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowDeviceManagementClientTypes.TaskSummary()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.taskArn = try reader["taskArn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SnowDeviceManagementClientTypes.Command {

    static func write(value: SnowDeviceManagementClientTypes.Command?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .reboot(reboot):
                try writer["reboot"].write(reboot, with: SnowDeviceManagementClientTypes.Reboot.write(value:to:))
            case let .unlock(unlock):
                try writer["unlock"].write(unlock, with: SnowDeviceManagementClientTypes.Unlock.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SnowDeviceManagementClientTypes.Reboot {

    static func write(value: SnowDeviceManagementClientTypes.Reboot?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension SnowDeviceManagementClientTypes.Unlock {

    static func write(value: SnowDeviceManagementClientTypes.Unlock?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

public enum SnowDeviceManagementClientTypes {}
