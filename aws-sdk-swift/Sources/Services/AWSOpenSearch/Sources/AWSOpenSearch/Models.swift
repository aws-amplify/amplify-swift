//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct AddTagsOutput {

    public init() { }
}

public struct RemoveTagsOutput {

    public init() { }
}

/// An error occured because the client wanted to access an unsupported operation.
public struct DisabledOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DisabledOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for trying to create more than the allowed number of resources or sub-resources.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for accessing or deleting a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Container for the parameters to the AcceptInboundConnection operation.
public struct AcceptInboundConnectionInput {
    /// The ID of the inbound connection to accept.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

extension OpenSearchClientTypes {

    /// The connection mode for the cross-cluster connection.
    ///
    /// * DIRECT - Used for cross-cluster search or cross-cluster replication.
    ///
    /// * VPC_ENDPOINT - Used for remote reindex between Amazon OpenSearch Service VPC domains.
    public enum ConnectionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case direct
        case vpcEndpoint
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionMode] {
            return [
                .direct,
                .vpcEndpoint
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .direct: return "DIRECT"
            case .vpcEndpoint: return "VPC_ENDPOINT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum InboundConnectionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case approved
        case deleted
        case deleting
        case pendingAcceptance
        case provisioning
        case rejected
        case rejecting
        case sdkUnknown(Swift.String)

        public static var allCases: [InboundConnectionStatusCode] {
            return [
                .active,
                .approved,
                .deleted,
                .deleting,
                .pendingAcceptance,
                .provisioning,
                .rejected,
                .rejecting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .approved: return "APPROVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .provisioning: return "PROVISIONING"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The status of an inbound cross-cluster connection for OpenSearch Service.
    public struct InboundConnectionStatus {
        /// Information about the connection.
        public var message: Swift.String?
        /// The status code for the connection. Can be one of the following:
        ///
        /// * PENDING_ACCEPTANCE - Inbound connection is not yet accepted by the remote domain owner.
        ///
        /// * APPROVED: Inbound connection is pending acceptance by the remote domain owner.
        ///
        /// * PROVISIONING: Inbound connection is being provisioned.
        ///
        /// * ACTIVE: Inbound connection is active and ready to use.
        ///
        /// * REJECTING: Inbound connection rejection is in process.
        ///
        /// * REJECTED: Inbound connection is rejected.
        ///
        /// * DELETING: Inbound connection deletion is in progress.
        ///
        /// * DELETED: Inbound connection is deleted and can no longer be used.
        public var statusCode: OpenSearchClientTypes.InboundConnectionStatusCode?

        public init(
            message: Swift.String? = nil,
            statusCode: OpenSearchClientTypes.InboundConnectionStatusCode? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension OpenSearchClientTypes {
    /// Information about an Amazon OpenSearch Service domain.
    public struct AWSDomainInformation {
        /// Name of the domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The Amazon Web Services account ID of the domain owner.
        public var ownerId: Swift.String?
        /// The Amazon Web Services Region in which the domain is located.
        public var region: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.ownerId = ownerId
            self.region = region
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for information about an OpenSearch Service domain.
    public struct DomainInformationContainer {
        /// Information about an Amazon OpenSearch Service domain.
        public var awsDomainInformation: OpenSearchClientTypes.AWSDomainInformation?

        public init(
            awsDomainInformation: OpenSearchClientTypes.AWSDomainInformation? = nil
        )
        {
            self.awsDomainInformation = awsDomainInformation
        }
    }

}

extension OpenSearchClientTypes {
    /// Describes an inbound cross-cluster connection for Amazon OpenSearch Service. For more information, see [Cross-cluster search for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cross-cluster-search.html).
    public struct InboundConnection {
        /// The unique identifier of the connection.
        public var connectionId: Swift.String?
        /// The connection mode.
        public var connectionMode: OpenSearchClientTypes.ConnectionMode?
        /// The current status of the connection.
        public var connectionStatus: OpenSearchClientTypes.InboundConnectionStatus?
        /// Information about the source (local) domain.
        public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
        /// Information about the destination (remote) domain.
        public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

        public init(
            connectionId: Swift.String? = nil,
            connectionMode: OpenSearchClientTypes.ConnectionMode? = nil,
            connectionStatus: OpenSearchClientTypes.InboundConnectionStatus? = nil,
            localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
            remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
        )
        {
            self.connectionId = connectionId
            self.connectionMode = connectionMode
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }
    }

}

/// Contains details about the accepted inbound connection.
public struct AcceptInboundConnectionOutput {
    /// Information about the accepted inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init(
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

/// An error occurred because you don't have permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpenSearchClientTypes {

    /// The state of a requested domain configuration change. Can be one of the following:
    ///
    /// * Processing - The requested change is still in progress.
    ///
    /// * Active - The requested change is processed and deployed to the domain.
    public enum OptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case processing
        case requiresindexdocuments
        case sdkUnknown(Swift.String)

        public static var allCases: [OptionState] {
            return [
                .active,
                .processing,
                .requiresindexdocuments
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .processing: return "Processing"
            case .requiresindexdocuments: return "RequiresIndexDocuments"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Provides the current status of an entity.
    public struct OptionStatus {
        /// The timestamp when the entity was created.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// Indicates whether the entity is being deleted.
        public var pendingDeletion: Swift.Bool?
        /// The state of the entity.
        /// This member is required.
        public var state: OpenSearchClientTypes.OptionState?
        /// The timestamp of the last time the entity was updated.
        /// This member is required.
        public var updateDate: Foundation.Date?
        /// The latest version of the entity.
        public var updateVersion: Swift.Int

        public init(
            creationDate: Foundation.Date? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: OpenSearchClientTypes.OptionState? = nil,
            updateDate: Foundation.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension OpenSearchClientTypes {
    /// The configured access rules for the domain's search endpoint, and the current status of those rules.
    public struct AccessPoliciesStatus {
        /// The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see [Configuring access policies](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-access-policies).
        /// This member is required.
        public var options: Swift.String?
        /// The status of the access policy for the domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: Swift.String? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {

    public enum ActionSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionSeverity] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum ActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case eligible
        case failed
        case inProgress
        case notEligible
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionStatus] {
            return [
                .completed,
                .eligible,
                .failed,
                .inProgress,
                .notEligible,
                .pendingUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .eligible: return "ELIGIBLE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notEligible: return "NOT_ELIGIBLE"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jvmHeapSizeTuning
        case jvmYoungGenTuning
        case serviceSoftwareUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .jvmHeapSizeTuning,
                .jvmYoungGenTuning,
                .serviceSoftwareUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jvmHeapSizeTuning: return "JVM_HEAP_SIZE_TUNING"
            case .jvmYoungGenTuning: return "JVM_YOUNG_GEN_TUNING"
            case .serviceSoftwareUpdate: return "SERVICE_SOFTWARE_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An error occurred while processing the request.
public struct BaseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BaseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for when a failure in one of the dependencies results in the service being unable to fetch details about the resource.
public struct DependencyFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Request processing failed because of an unknown error, exception, or internal failure.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for accessing or deleting a resource that doesn't exist.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpenSearchClientTypes {
    /// Information about the Amazon S3 Glue Data Catalog.
    public struct S3GlueDataCatalog {
        /// >The Amazon Resource Name (ARN) for the S3 Glue Data Catalog.
        public var roleArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension OpenSearchClientTypes {
    /// The type of data source.
    public enum DataSourceType {
        /// An Amazon S3 data source.
        case s3gluedatacatalog(OpenSearchClientTypes.S3GlueDataCatalog)
        case sdkUnknown(Swift.String)
    }

}

/// Container for the parameters to the AddDataSource operation.
public struct AddDataSourceInput {
    /// The type of data source.
    /// This member is required.
    public var dataSourceType: OpenSearchClientTypes.DataSourceType?
    /// A description of the data source.
    public var description: Swift.String?
    /// The name of the domain to add the data source to.
    /// This member is required.
    public var domainName: Swift.String?
    /// A name for the data source.
    /// This member is required.
    public var name: Swift.String?

    public init(
        dataSourceType: OpenSearchClientTypes.DataSourceType? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.description = description
        self.domainName = domainName
        self.name = name
    }
}

/// The result of an AddDataSource operation.
public struct AddDataSourceOutput {
    /// A message associated with creation of the data source.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension OpenSearchClientTypes {
    /// List of limits that are specific to a given instance type.
    public struct AdditionalLimit {
        /// * MaximumNumberOfDataNodesSupported - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.
        ///
        /// * MaximumNumberOfDataNodesWithoutMasterNode - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.
        public var limitName: Swift.String?
        /// The values of the additional instance type limits.
        public var limitValues: [Swift.String]?

        public init(
            limitName: Swift.String? = nil,
            limitValues: [Swift.String]? = nil
        )
        {
            self.limitName = limitName
            self.limitValues = limitValues
        }
    }

}

extension OpenSearchClientTypes {
    /// A tag (key-value pair) for an Amazon OpenSearch Service resource.
    public struct Tag {
        /// The tag key. Tag keys must be unique for the domain to which they are attached.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

/// Container for the parameters to the AddTags operation. Specifies the tags to attach to the domain.
public struct AddTagsInput {
    /// Amazon Resource Name (ARN) for the OpenSearch Service domain to which you want to attach resource tags.
    /// This member is required.
    public var arn: Swift.String?
    /// List of resource tags.
    /// This member is required.
    public var tagList: [OpenSearchClientTypes.Tag]?

    public init(
        arn: Swift.String? = nil,
        tagList: [OpenSearchClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tagList = tagList
    }
}

extension OpenSearchClientTypes {
    /// Status of the advanced options for the specified domain. The following options are available:
    ///
    /// * "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.
    ///
    /// * "indices.fielddata.cache.size": "80"  - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.
    ///
    /// * "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.
    ///
    /// * "override_main_response_version": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether the domain reports its version as 7.10 to allow Elasticsearch OSS clients and plugins to continue working with it. Default is false when creating a domain and true when upgrading a domain.
    ///
    ///
    /// For more information, see [Advanced cluster parameters](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public struct AdvancedOptionsStatus {
        /// The status of advanced options for the specified domain.
        /// This member is required.
        public var options: [Swift.String: Swift.String]?
        /// The status of advanced options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: [Swift.String: Swift.String]? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Describes the JWT options configured for the domain.
    public struct JWTOptionsOutput {
        /// True if JWT use is enabled.
        public var enabled: Swift.Bool?
        /// The key used to verify the signature of incoming JWT requests.
        public var publicKey: Swift.String?
        /// The key used for matching the JWT roles attribute.
        public var rolesKey: Swift.String?
        /// The key used for matching the JWT subject attribute.
        public var subjectKey: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            publicKey: Swift.String? = nil,
            rolesKey: Swift.String? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.publicKey = publicKey
            self.rolesKey = rolesKey
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes {
    /// The SAML identity povider information.
    public struct SAMLIdp {
        /// The unique entity ID of the application in the SAML identity provider.
        /// This member is required.
        public var entityId: Swift.String?
        /// The metadata of the SAML application, in XML format.
        /// This member is required.
        public var metadataContent: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            metadataContent: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.metadataContent = metadataContent
        }
    }

}

extension OpenSearchClientTypes {
    /// Describes the SAML application configured for the domain.
    public struct SAMLOptionsOutput {
        /// True if SAML is enabled.
        public var enabled: Swift.Bool?
        /// Describes the SAML identity provider's information.
        public var idp: OpenSearchClientTypes.SAMLIdp?
        /// The key used for matching the SAML roles attribute.
        public var rolesKey: Swift.String?
        /// The duration, in minutes, after which a user session becomes inactive.
        public var sessionTimeoutMinutes: Swift.Int?
        /// The key used for matching the SAML subject attribute.
        public var subjectKey: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            idp: OpenSearchClientTypes.SAMLIdp? = nil,
            rolesKey: Swift.String? = nil,
            sessionTimeoutMinutes: Swift.Int? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.idp = idp
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for fine-grained access control settings.
    public struct AdvancedSecurityOptions {
        /// Date and time when the migration period will be disabled. Only necessary when [enabling fine-grained access control on an existing domain](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing).
        public var anonymousAuthDisableDate: Foundation.Date?
        /// True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when [enabling fine-grained access control on an existing domain](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing).
        public var anonymousAuthEnabled: Swift.Bool?
        /// True if fine-grained access control is enabled.
        public var enabled: Swift.Bool?
        /// True if the internal user database is enabled.
        public var internalUserDatabaseEnabled: Swift.Bool?
        /// Container for information about the JWT configuration of the Amazon OpenSearch Service.
        public var jwtOptions: OpenSearchClientTypes.JWTOptionsOutput?
        /// Container for information about the SAML configuration for OpenSearch Dashboards.
        public var samlOptions: OpenSearchClientTypes.SAMLOptionsOutput?

        public init(
            anonymousAuthDisableDate: Foundation.Date? = nil,
            anonymousAuthEnabled: Swift.Bool? = nil,
            enabled: Swift.Bool? = nil,
            internalUserDatabaseEnabled: Swift.Bool? = nil,
            jwtOptions: OpenSearchClientTypes.JWTOptionsOutput? = nil,
            samlOptions: OpenSearchClientTypes.SAMLOptionsOutput? = nil
        )
        {
            self.anonymousAuthDisableDate = anonymousAuthDisableDate
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.jwtOptions = jwtOptions
            self.samlOptions = samlOptions
        }
    }

}

extension OpenSearchClientTypes {
    /// The JWT authentication and authorization configuration for an Amazon OpenSearch Service domain.
    public struct JWTOptionsInput {
        /// True to enable JWT authentication and authorization for a domain.
        public var enabled: Swift.Bool?
        /// Element of the JWT assertion used by the cluster to verify JWT signatures.
        public var publicKey: Swift.String?
        /// Element of the JWT assertion to use for roles.
        public var rolesKey: Swift.String?
        /// Element of the JWT assertion to use for the user name.
        public var subjectKey: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            publicKey: Swift.String? = nil,
            rolesKey: Swift.String? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.publicKey = publicKey
            self.rolesKey = rolesKey
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes {
    /// Credentials for the master user for a domain.
    public struct MasterUserOptions {
        /// Amazon Resource Name (ARN) for the master user. Only specify if InternalUserDatabaseEnabled is false.
        public var masterUserARN: Swift.String?
        /// User name for the master user. Only specify if InternalUserDatabaseEnabled is true.
        public var masterUserName: Swift.String?
        /// Password for the master user. Only specify if InternalUserDatabaseEnabled is true.
        public var masterUserPassword: Swift.String?

        public init(
            masterUserARN: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil
        )
        {
            self.masterUserARN = masterUserARN
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }
    }

}

extension OpenSearchClientTypes.MasterUserOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MasterUserOptions(masterUserARN: \(Swift.String(describing: masterUserARN)), masterUserName: \"CONTENT_REDACTED\", masterUserPassword: \"CONTENT_REDACTED\")"}
}

extension OpenSearchClientTypes {
    /// The SAML authentication configuration for an Amazon OpenSearch Service domain.
    public struct SAMLOptionsInput {
        /// True to enable SAML authentication for a domain.
        public var enabled: Swift.Bool?
        /// The SAML Identity Provider's information.
        public var idp: OpenSearchClientTypes.SAMLIdp?
        /// The backend role that the SAML master user is mapped to.
        public var masterBackendRole: Swift.String?
        /// The SAML master user name, which is stored in the domain's internal user database.
        public var masterUserName: Swift.String?
        /// Element of the SAML assertion to use for backend roles. Default is roles.
        public var rolesKey: Swift.String?
        /// The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.
        public var sessionTimeoutMinutes: Swift.Int?
        /// Element of the SAML assertion to use for the user name. Default is NameID.
        public var subjectKey: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            idp: OpenSearchClientTypes.SAMLIdp? = nil,
            masterBackendRole: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            rolesKey: Swift.String? = nil,
            sessionTimeoutMinutes: Swift.Int? = nil,
            subjectKey: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.idp = idp
            self.masterBackendRole = masterBackendRole
            self.masterUserName = masterUserName
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }
    }

}

extension OpenSearchClientTypes.SAMLOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SAMLOptionsInput(enabled: \(Swift.String(describing: enabled)), idp: \(Swift.String(describing: idp)), masterBackendRole: \(Swift.String(describing: masterBackendRole)), rolesKey: \(Swift.String(describing: rolesKey)), sessionTimeoutMinutes: \(Swift.String(describing: sessionTimeoutMinutes)), subjectKey: \(Swift.String(describing: subjectKey)), masterUserName: \"CONTENT_REDACTED\")"}
}

extension OpenSearchClientTypes {
    /// Options for enabling and configuring fine-grained access control. For more information, see [Fine-grained access control in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html).
    public struct AdvancedSecurityOptionsInput {
        /// True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when [enabling fine-grained access control on an existing domain](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/fgac.html#fgac-enabling-existing).
        public var anonymousAuthEnabled: Swift.Bool?
        /// True to enable fine-grained access control.
        public var enabled: Swift.Bool?
        /// True to enable the internal user database.
        public var internalUserDatabaseEnabled: Swift.Bool?
        /// Container for information about the JWT configuration of the Amazon OpenSearch Service.
        public var jwtOptions: OpenSearchClientTypes.JWTOptionsInput?
        /// Container for information about the master user.
        public var masterUserOptions: OpenSearchClientTypes.MasterUserOptions?
        /// Container for information about the SAML configuration for OpenSearch Dashboards.
        public var samlOptions: OpenSearchClientTypes.SAMLOptionsInput?

        public init(
            anonymousAuthEnabled: Swift.Bool? = nil,
            enabled: Swift.Bool? = nil,
            internalUserDatabaseEnabled: Swift.Bool? = nil,
            jwtOptions: OpenSearchClientTypes.JWTOptionsInput? = nil,
            masterUserOptions: OpenSearchClientTypes.MasterUserOptions? = nil,
            samlOptions: OpenSearchClientTypes.SAMLOptionsInput? = nil
        )
        {
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.jwtOptions = jwtOptions
            self.masterUserOptions = masterUserOptions
            self.samlOptions = samlOptions
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of fine-grained access control settings for a domain.
    public struct AdvancedSecurityOptionsStatus {
        /// Container for fine-grained access control settings.
        /// This member is required.
        public var options: OpenSearchClientTypes.AdvancedSecurityOptions?
        /// Status of the fine-grained access control settings for a domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.AdvancedSecurityOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {

    public enum NaturalLanguageQueryGenerationDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NaturalLanguageQueryGenerationDesiredState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Container for parameters required to enable the natural language query generation feature.
    public struct NaturalLanguageQueryGenerationOptionsInput {
        /// The desired state of the natural language query generation feature. Valid values are ENABLED and DISABLED.
        public var desiredState: OpenSearchClientTypes.NaturalLanguageQueryGenerationDesiredState?

        public init(
            desiredState: OpenSearchClientTypes.NaturalLanguageQueryGenerationDesiredState? = nil
        )
        {
            self.desiredState = desiredState
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for parameters required to enable all machine learning features.
    public struct AIMLOptionsInput {
        /// Container for parameters required for natural language query generation on the specified domain.
        public var naturalLanguageQueryGenerationOptions: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsInput?

        public init(
            naturalLanguageQueryGenerationOptions: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsInput? = nil
        )
        {
            self.naturalLanguageQueryGenerationOptions = naturalLanguageQueryGenerationOptions
        }
    }

}

extension OpenSearchClientTypes {

    public enum NaturalLanguageQueryGenerationCurrentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disablecomplete
        case disablefailed
        case disableinprogress
        case enablecomplete
        case enablefailed
        case enableinprogress
        case notenabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NaturalLanguageQueryGenerationCurrentState] {
            return [
                .disablecomplete,
                .disablefailed,
                .disableinprogress,
                .enablecomplete,
                .enablefailed,
                .enableinprogress,
                .notenabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disablecomplete: return "DISABLE_COMPLETE"
            case .disablefailed: return "DISABLE_FAILED"
            case .disableinprogress: return "DISABLE_IN_PROGRESS"
            case .enablecomplete: return "ENABLE_COMPLETE"
            case .enablefailed: return "ENABLE_FAILED"
            case .enableinprogress: return "ENABLE_IN_PROGRESS"
            case .notenabled: return "NOT_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Container for parameters representing the state of the natural language query generation feature on the specified domain.
    public struct NaturalLanguageQueryGenerationOptionsOutput {
        /// The current state of the natural language query generation feature, indicating completion, in progress, or failure.
        public var currentState: OpenSearchClientTypes.NaturalLanguageQueryGenerationCurrentState?
        /// The desired state of the natural language query generation feature. Valid values are ENABLED and DISABLED.
        public var desiredState: OpenSearchClientTypes.NaturalLanguageQueryGenerationDesiredState?

        public init(
            currentState: OpenSearchClientTypes.NaturalLanguageQueryGenerationCurrentState? = nil,
            desiredState: OpenSearchClientTypes.NaturalLanguageQueryGenerationDesiredState? = nil
        )
        {
            self.currentState = currentState
            self.desiredState = desiredState
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for parameters representing the state of machine learning features on the specified domain.
    public struct AIMLOptionsOutput {
        /// Container for parameters required for natural language query generation on the specified domain.
        public var naturalLanguageQueryGenerationOptions: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput?

        public init(
            naturalLanguageQueryGenerationOptions: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput? = nil
        )
        {
            self.naturalLanguageQueryGenerationOptions = naturalLanguageQueryGenerationOptions
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of machine learning options on the specified domain.
    public struct AIMLOptionsStatus {
        /// Machine learning options on the specified domain.
        public var options: OpenSearchClientTypes.AIMLOptionsOutput?
        /// Provides the current status of an entity.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.AIMLOptionsOutput? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

/// An error occurred because the client attempts to remove a resource that is currently in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Container for the request parameters to the AssociatePackage operation.
public struct AssociatePackageInput {
    /// Name of the domain to associate the package with.
    /// This member is required.
    public var domainName: Swift.String?
    /// Internal ID of the package to associate with a domain. Use DescribePackages to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.packageID = packageID
    }
}

extension OpenSearchClientTypes {

    public enum DomainPackageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case associating
        case associationFailed
        case dissociating
        case dissociationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainPackageStatus] {
            return [
                .active,
                .associating,
                .associationFailed,
                .dissociating,
                .dissociationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .associationFailed: return "ASSOCIATION_FAILED"
            case .dissociating: return "DISSOCIATING"
            case .dissociationFailed: return "DISSOCIATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Additional information if the package is in an error state. Null otherwise.
    public struct ErrorDetails {
        /// A message describing the error.
        public var errorMessage: Swift.String?
        /// The type of error that occurred.
        public var errorType: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            errorType: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }
    }

}

extension OpenSearchClientTypes {

    public enum PackageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case txtDictionary
        case zipPlugin
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageType] {
            return [
                .txtDictionary,
                .zipPlugin
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .txtDictionary: return "TXT-DICTIONARY"
            case .zipPlugin: return "ZIP-PLUGIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about a package that is associated with a domain. For more information, see [Custom packages for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/custom-packages.html).
    public struct DomainPackageDetails {
        /// Name of the domain that the package is associated with.
        public var domainName: Swift.String?
        /// State of the association.
        public var domainPackageStatus: OpenSearchClientTypes.DomainPackageStatus?
        /// Additional information if the package is in an error state. Null otherwise.
        public var errorDetails: OpenSearchClientTypes.ErrorDetails?
        /// Timestamp of the most recent update to the package association status.
        public var lastUpdated: Foundation.Date?
        /// Internal ID of the package.
        public var packageID: Swift.String?
        /// User-specified name of the package.
        public var packageName: Swift.String?
        /// The type of package.
        public var packageType: OpenSearchClientTypes.PackageType?
        /// The current version of the package.
        public var packageVersion: Swift.String?
        /// The relative path of the package on the OpenSearch Service cluster nodes. This is synonym_path when the package is for synonym files.
        public var referencePath: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            domainPackageStatus: OpenSearchClientTypes.DomainPackageStatus? = nil,
            errorDetails: OpenSearchClientTypes.ErrorDetails? = nil,
            lastUpdated: Foundation.Date? = nil,
            packageID: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageType: OpenSearchClientTypes.PackageType? = nil,
            packageVersion: Swift.String? = nil,
            referencePath: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.domainPackageStatus = domainPackageStatus
            self.errorDetails = errorDetails
            self.lastUpdated = lastUpdated
            self.packageID = packageID
            self.packageName = packageName
            self.packageType = packageType
            self.packageVersion = packageVersion
            self.referencePath = referencePath
        }
    }

}

/// Container for the response returned by the AssociatePackage operation.
public struct AssociatePackageOutput {
    /// Information about a package that is associated with a domain.
    public var domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?

    public init(
        domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails? = nil
    )
    {
        self.domainPackageDetails = domainPackageDetails
    }
}

public struct AuthorizeVpcEndpointAccessInput {
    /// The Amazon Web Services account ID to grant access to.
    /// This member is required.
    public var account: Swift.String?
    /// The name of the OpenSearch Service domain to provide access to.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        account: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.account = account
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {

    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAccount
        case awsService
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .awsAccount,
                .awsService
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case .awsService: return "AWS_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about an Amazon Web Services account or service that has access to an Amazon OpenSearch Service domain through the use of an interface VPC endpoint.
    public struct AuthorizedPrincipal {
        /// The [IAM principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html) that is allowed access to the domain.
        public var principal: Swift.String?
        /// The type of principal.
        public var principalType: OpenSearchClientTypes.PrincipalType?

        public init(
            principal: Swift.String? = nil,
            principalType: OpenSearchClientTypes.PrincipalType? = nil
        )
        {
            self.principal = principal
            self.principalType = principalType
        }
    }

}

public struct AuthorizeVpcEndpointAccessOutput {
    /// Information about the Amazon Web Services account or service that was provided access to the domain.
    /// This member is required.
    public var authorizedPrincipal: OpenSearchClientTypes.AuthorizedPrincipal?

    public init(
        authorizedPrincipal: OpenSearchClientTypes.AuthorizedPrincipal? = nil
    )
    {
        self.authorizedPrincipal = authorizedPrincipal
    }
}

public struct CancelDomainConfigChangeInput {
    /// The name of an OpenSearch Service domain. Domain names are unique across the domains owned by an account within an Amazon Web Services Region.
    /// This member is required.
    public var domainName: Swift.String?
    /// When set to True, returns the list of change IDs and properties that will be cancelled without actually cancelling the change.
    public var dryRun: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.dryRun = dryRun
    }
}

extension OpenSearchClientTypes {
    /// A property change that was cancelled for an Amazon OpenSearch Service domain.
    public struct CancelledChangeProperty {
        /// The current value of the property, after the change was cancelled.
        public var activeValue: Swift.String?
        /// The pending value of the property that was cancelled. This would have been the eventual value of the property if the chance had not been cancelled.
        public var cancelledValue: Swift.String?
        /// The name of the property whose change was cancelled.
        public var propertyName: Swift.String?

        public init(
            activeValue: Swift.String? = nil,
            cancelledValue: Swift.String? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.activeValue = activeValue
            self.cancelledValue = cancelledValue
            self.propertyName = propertyName
        }
    }

}

public struct CancelDomainConfigChangeOutput {
    /// The unique identifiers of the changes that were cancelled.
    public var cancelledChangeIds: [Swift.String]?
    /// The domain change properties that were cancelled.
    public var cancelledChangeProperties: [OpenSearchClientTypes.CancelledChangeProperty]?
    /// Whether or not the request was a dry run. If True, the changes were not actually cancelled.
    public var dryRun: Swift.Bool?

    public init(
        cancelledChangeIds: [Swift.String]? = nil,
        cancelledChangeProperties: [OpenSearchClientTypes.CancelledChangeProperty]? = nil,
        dryRun: Swift.Bool? = nil
    )
    {
        self.cancelledChangeIds = cancelledChangeIds
        self.cancelledChangeProperties = cancelledChangeProperties
        self.dryRun = dryRun
    }
}

/// Container for the request parameters to cancel a service software update.
public struct CancelServiceSoftwareUpdateInput {
    /// Name of the OpenSearch Service domain that you want to cancel the service software update on.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {

    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case eligible
        case inProgress
        case notEligible
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .completed,
                .eligible,
                .inProgress,
                .notEligible,
                .pendingUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .eligible: return "ELIGIBLE"
            case .inProgress: return "IN_PROGRESS"
            case .notEligible: return "NOT_ELIGIBLE"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The current status of the service software for an Amazon OpenSearch Service domain. For more information, see [Service software updates in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/service-software.html).
    public struct ServiceSoftwareOptions {
        /// The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.
        public var automatedUpdateDate: Foundation.Date?
        /// True if you're able to cancel your service software version update. False if you can't cancel your service software update.
        public var cancellable: Swift.Bool?
        /// The current service software version present on the domain.
        public var currentVersion: Swift.String?
        /// A description of the service software update status.
        public var description: Swift.String?
        /// The new service software version, if one is available.
        public var newVersion: Swift.String?
        /// True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.
        public var optionalDeployment: Swift.Bool?
        /// True if you're able to update your service software version. False if you can't update your service software version.
        public var updateAvailable: Swift.Bool?
        /// The status of your service software update.
        public var updateStatus: OpenSearchClientTypes.DeploymentStatus?

        public init(
            automatedUpdateDate: Foundation.Date? = nil,
            cancellable: Swift.Bool? = nil,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            optionalDeployment: Swift.Bool? = nil,
            updateAvailable: Swift.Bool? = nil,
            updateStatus: OpenSearchClientTypes.DeploymentStatus? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

/// Container for the response to a CancelServiceSoftwareUpdate operation. Contains the status of the update.
public struct CancelServiceSoftwareUpdateOutput {
    /// Container for the state of your domain relative to the latest service software.
    public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?

    public init(
        serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil
    )
    {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }
}

/// An exception for trying to create or access a sub-resource that's either invalid or not supported.
public struct InvalidTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception for creating a resource that already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpenSearchClientTypes {

    /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
    public enum AutoTuneDesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneDesiredState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    /// The unit of a maintenance schedule duration. Valid value is HOUR.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hours
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .hours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hours: return "HOURS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The duration of a maintenance schedule. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct Duration {
        /// The unit of measurement for the duration of a maintenance schedule.
        public var unit: OpenSearchClientTypes.TimeUnit?
        /// Integer to specify the value of a maintenance schedule duration.
        public var value: Swift.Int?

        public init(
            unit: OpenSearchClientTypes.TimeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension OpenSearchClientTypes {
    /// This object is deprecated. Use the domain's [off-peak window](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html) to schedule Auto-Tune optimizations. For migration instructions, see [Migrating from Auto-Tune maintenance windows](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html#off-peak-migrate). The Auto-Tune maintenance schedule. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct AutoTuneMaintenanceSchedule {
        /// A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.
        public var cronExpressionForRecurrence: Swift.String?
        /// The duration of the maintenance schedule. For example, "Duration": {"Value": 2, "Unit": "HOURS"}.
        public var duration: OpenSearchClientTypes.Duration?
        /// The Epoch timestamp at which the Auto-Tune maintenance schedule starts.
        public var startAt: Foundation.Date?

        public init(
            cronExpressionForRecurrence: Swift.String? = nil,
            duration: OpenSearchClientTypes.Duration? = nil,
            startAt: Foundation.Date? = nil
        )
        {
            self.cronExpressionForRecurrence = cronExpressionForRecurrence
            self.duration = duration
            self.startAt = startAt
        }
    }

}

extension OpenSearchClientTypes {
    /// Options for configuring Auto-Tune. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html)
    public struct AutoTuneOptionsInput {
        /// Whether Auto-Tune is enabled or disabled.
        public var desiredState: OpenSearchClientTypes.AutoTuneDesiredState?
        /// A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance windows are deprecated and have been replaced with [off-peak windows](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html).
        public var maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]?
        /// Whether to schedule Auto-Tune optimizations that require blue/green deployments during the domain's configured daily off-peak window.
        public var useOffPeakWindow: Swift.Bool?

        public init(
            desiredState: OpenSearchClientTypes.AutoTuneDesiredState? = nil,
            maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil,
            useOffPeakWindow: Swift.Bool? = nil
        )
        {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.useOffPeakWindow = useOffPeakWindow
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for the parameters required to enable cold storage for an OpenSearch Service domain. For more information, see [Cold storage for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cold-storage.html).
    public struct ColdStorageOptions {
        /// Whether to enable or disable cold storage on the domain. You must enable UltraWarm storage to enable cold storage.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes {

    public enum OpenSearchPartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case c42xlargeSearch
        case c44xlargeSearch
        case c48xlargeSearch
        case c4LargeSearch
        case c4XlargeSearch
        case c518xlargeSearch
        case c52xlargeSearch
        case c54xlargeSearch
        case c59xlargeSearch
        case c5LargeSearch
        case c5XlargeSearch
        case c6g12xlargeSearch
        case c6g2xlargeSearch
        case c6g4xlargeSearch
        case c6g8xlargeSearch
        case c6gLargeSearch
        case c6gXlargeSearch
        case d22xlargeSearch
        case d24xlargeSearch
        case d28xlargeSearch
        case d2XlargeSearch
        case i22xlargeSearch
        case i2XlargeSearch
        case i316xlargeSearch
        case i32xlargeSearch
        case i34xlargeSearch
        case i38xlargeSearch
        case i3LargeSearch
        case i3XlargeSearch
        case m32xlargeSearch
        case m3LargeSearch
        case m3MediumSearch
        case m3XlargeSearch
        case m410xlargeSearch
        case m42xlargeSearch
        case m44xlargeSearch
        case m4LargeSearch
        case m4XlargeSearch
        case m512xlargeSearch
        case m524xlargeSearch
        case m52xlargeSearch
        case m54xlargeSearch
        case m5LargeSearch
        case m5XlargeSearch
        case m6g12xlargeSearch
        case m6g2xlargeSearch
        case m6g4xlargeSearch
        case m6g8xlargeSearch
        case m6gLargeSearch
        case m6gXlargeSearch
        case or112xlargeSearch
        case or116xlargeSearch
        case or12xlargeSearch
        case or14xlargeSearch
        case or18xlargeSearch
        case or1LargeSearch
        case or1MediumSearch
        case or1XlargeSearch
        case r32xlargeSearch
        case r34xlargeSearch
        case r38xlargeSearch
        case r3LargeSearch
        case r3XlargeSearch
        case r416xlargeSearch
        case r42xlargeSearch
        case r44xlargeSearch
        case r48xlargeSearch
        case r4LargeSearch
        case r4XlargeSearch
        case r512xlargeSearch
        case r524xlargeSearch
        case r52xlargeSearch
        case r54xlargeSearch
        case r5LargeSearch
        case r5XlargeSearch
        case r6g12xlargeSearch
        case r6g2xlargeSearch
        case r6g4xlargeSearch
        case r6g8xlargeSearch
        case r6gLargeSearch
        case r6gXlargeSearch
        case r6gd12xlargeSearch
        case r6gd16xlargeSearch
        case r6gd2xlargeSearch
        case r6gd4xlargeSearch
        case r6gd8xlargeSearch
        case r6gdLargeSearch
        case r6gdXlargeSearch
        case t2MediumSearch
        case t2MicroSearch
        case t2SmallSearch
        case t32xlargeSearch
        case t3LargeSearch
        case t3MediumSearch
        case t3MicroSearch
        case t3NanoSearch
        case t3SmallSearch
        case t3XlargeSearch
        case t4gMediumSearch
        case t4gSmallSearch
        case ultrawarm1LargeSearch
        case ultrawarm1MediumSearch
        case ultrawarm1XlargeSearch
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenSearchPartitionInstanceType] {
            return [
                .c42xlargeSearch,
                .c44xlargeSearch,
                .c48xlargeSearch,
                .c4LargeSearch,
                .c4XlargeSearch,
                .c518xlargeSearch,
                .c52xlargeSearch,
                .c54xlargeSearch,
                .c59xlargeSearch,
                .c5LargeSearch,
                .c5XlargeSearch,
                .c6g12xlargeSearch,
                .c6g2xlargeSearch,
                .c6g4xlargeSearch,
                .c6g8xlargeSearch,
                .c6gLargeSearch,
                .c6gXlargeSearch,
                .d22xlargeSearch,
                .d24xlargeSearch,
                .d28xlargeSearch,
                .d2XlargeSearch,
                .i22xlargeSearch,
                .i2XlargeSearch,
                .i316xlargeSearch,
                .i32xlargeSearch,
                .i34xlargeSearch,
                .i38xlargeSearch,
                .i3LargeSearch,
                .i3XlargeSearch,
                .m32xlargeSearch,
                .m3LargeSearch,
                .m3MediumSearch,
                .m3XlargeSearch,
                .m410xlargeSearch,
                .m42xlargeSearch,
                .m44xlargeSearch,
                .m4LargeSearch,
                .m4XlargeSearch,
                .m512xlargeSearch,
                .m524xlargeSearch,
                .m52xlargeSearch,
                .m54xlargeSearch,
                .m5LargeSearch,
                .m5XlargeSearch,
                .m6g12xlargeSearch,
                .m6g2xlargeSearch,
                .m6g4xlargeSearch,
                .m6g8xlargeSearch,
                .m6gLargeSearch,
                .m6gXlargeSearch,
                .or112xlargeSearch,
                .or116xlargeSearch,
                .or12xlargeSearch,
                .or14xlargeSearch,
                .or18xlargeSearch,
                .or1LargeSearch,
                .or1MediumSearch,
                .or1XlargeSearch,
                .r32xlargeSearch,
                .r34xlargeSearch,
                .r38xlargeSearch,
                .r3LargeSearch,
                .r3XlargeSearch,
                .r416xlargeSearch,
                .r42xlargeSearch,
                .r44xlargeSearch,
                .r48xlargeSearch,
                .r4LargeSearch,
                .r4XlargeSearch,
                .r512xlargeSearch,
                .r524xlargeSearch,
                .r52xlargeSearch,
                .r54xlargeSearch,
                .r5LargeSearch,
                .r5XlargeSearch,
                .r6g12xlargeSearch,
                .r6g2xlargeSearch,
                .r6g4xlargeSearch,
                .r6g8xlargeSearch,
                .r6gLargeSearch,
                .r6gXlargeSearch,
                .r6gd12xlargeSearch,
                .r6gd16xlargeSearch,
                .r6gd2xlargeSearch,
                .r6gd4xlargeSearch,
                .r6gd8xlargeSearch,
                .r6gdLargeSearch,
                .r6gdXlargeSearch,
                .t2MediumSearch,
                .t2MicroSearch,
                .t2SmallSearch,
                .t32xlargeSearch,
                .t3LargeSearch,
                .t3MediumSearch,
                .t3MicroSearch,
                .t3NanoSearch,
                .t3SmallSearch,
                .t3XlargeSearch,
                .t4gMediumSearch,
                .t4gSmallSearch,
                .ultrawarm1LargeSearch,
                .ultrawarm1MediumSearch,
                .ultrawarm1XlargeSearch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .c42xlargeSearch: return "c4.2xlarge.search"
            case .c44xlargeSearch: return "c4.4xlarge.search"
            case .c48xlargeSearch: return "c4.8xlarge.search"
            case .c4LargeSearch: return "c4.large.search"
            case .c4XlargeSearch: return "c4.xlarge.search"
            case .c518xlargeSearch: return "c5.18xlarge.search"
            case .c52xlargeSearch: return "c5.2xlarge.search"
            case .c54xlargeSearch: return "c5.4xlarge.search"
            case .c59xlargeSearch: return "c5.9xlarge.search"
            case .c5LargeSearch: return "c5.large.search"
            case .c5XlargeSearch: return "c5.xlarge.search"
            case .c6g12xlargeSearch: return "c6g.12xlarge.search"
            case .c6g2xlargeSearch: return "c6g.2xlarge.search"
            case .c6g4xlargeSearch: return "c6g.4xlarge.search"
            case .c6g8xlargeSearch: return "c6g.8xlarge.search"
            case .c6gLargeSearch: return "c6g.large.search"
            case .c6gXlargeSearch: return "c6g.xlarge.search"
            case .d22xlargeSearch: return "d2.2xlarge.search"
            case .d24xlargeSearch: return "d2.4xlarge.search"
            case .d28xlargeSearch: return "d2.8xlarge.search"
            case .d2XlargeSearch: return "d2.xlarge.search"
            case .i22xlargeSearch: return "i2.2xlarge.search"
            case .i2XlargeSearch: return "i2.xlarge.search"
            case .i316xlargeSearch: return "i3.16xlarge.search"
            case .i32xlargeSearch: return "i3.2xlarge.search"
            case .i34xlargeSearch: return "i3.4xlarge.search"
            case .i38xlargeSearch: return "i3.8xlarge.search"
            case .i3LargeSearch: return "i3.large.search"
            case .i3XlargeSearch: return "i3.xlarge.search"
            case .m32xlargeSearch: return "m3.2xlarge.search"
            case .m3LargeSearch: return "m3.large.search"
            case .m3MediumSearch: return "m3.medium.search"
            case .m3XlargeSearch: return "m3.xlarge.search"
            case .m410xlargeSearch: return "m4.10xlarge.search"
            case .m42xlargeSearch: return "m4.2xlarge.search"
            case .m44xlargeSearch: return "m4.4xlarge.search"
            case .m4LargeSearch: return "m4.large.search"
            case .m4XlargeSearch: return "m4.xlarge.search"
            case .m512xlargeSearch: return "m5.12xlarge.search"
            case .m524xlargeSearch: return "m5.24xlarge.search"
            case .m52xlargeSearch: return "m5.2xlarge.search"
            case .m54xlargeSearch: return "m5.4xlarge.search"
            case .m5LargeSearch: return "m5.large.search"
            case .m5XlargeSearch: return "m5.xlarge.search"
            case .m6g12xlargeSearch: return "m6g.12xlarge.search"
            case .m6g2xlargeSearch: return "m6g.2xlarge.search"
            case .m6g4xlargeSearch: return "m6g.4xlarge.search"
            case .m6g8xlargeSearch: return "m6g.8xlarge.search"
            case .m6gLargeSearch: return "m6g.large.search"
            case .m6gXlargeSearch: return "m6g.xlarge.search"
            case .or112xlargeSearch: return "or1.12xlarge.search"
            case .or116xlargeSearch: return "or1.16xlarge.search"
            case .or12xlargeSearch: return "or1.2xlarge.search"
            case .or14xlargeSearch: return "or1.4xlarge.search"
            case .or18xlargeSearch: return "or1.8xlarge.search"
            case .or1LargeSearch: return "or1.large.search"
            case .or1MediumSearch: return "or1.medium.search"
            case .or1XlargeSearch: return "or1.xlarge.search"
            case .r32xlargeSearch: return "r3.2xlarge.search"
            case .r34xlargeSearch: return "r3.4xlarge.search"
            case .r38xlargeSearch: return "r3.8xlarge.search"
            case .r3LargeSearch: return "r3.large.search"
            case .r3XlargeSearch: return "r3.xlarge.search"
            case .r416xlargeSearch: return "r4.16xlarge.search"
            case .r42xlargeSearch: return "r4.2xlarge.search"
            case .r44xlargeSearch: return "r4.4xlarge.search"
            case .r48xlargeSearch: return "r4.8xlarge.search"
            case .r4LargeSearch: return "r4.large.search"
            case .r4XlargeSearch: return "r4.xlarge.search"
            case .r512xlargeSearch: return "r5.12xlarge.search"
            case .r524xlargeSearch: return "r5.24xlarge.search"
            case .r52xlargeSearch: return "r5.2xlarge.search"
            case .r54xlargeSearch: return "r5.4xlarge.search"
            case .r5LargeSearch: return "r5.large.search"
            case .r5XlargeSearch: return "r5.xlarge.search"
            case .r6g12xlargeSearch: return "r6g.12xlarge.search"
            case .r6g2xlargeSearch: return "r6g.2xlarge.search"
            case .r6g4xlargeSearch: return "r6g.4xlarge.search"
            case .r6g8xlargeSearch: return "r6g.8xlarge.search"
            case .r6gLargeSearch: return "r6g.large.search"
            case .r6gXlargeSearch: return "r6g.xlarge.search"
            case .r6gd12xlargeSearch: return "r6gd.12xlarge.search"
            case .r6gd16xlargeSearch: return "r6gd.16xlarge.search"
            case .r6gd2xlargeSearch: return "r6gd.2xlarge.search"
            case .r6gd4xlargeSearch: return "r6gd.4xlarge.search"
            case .r6gd8xlargeSearch: return "r6gd.8xlarge.search"
            case .r6gdLargeSearch: return "r6gd.large.search"
            case .r6gdXlargeSearch: return "r6gd.xlarge.search"
            case .t2MediumSearch: return "t2.medium.search"
            case .t2MicroSearch: return "t2.micro.search"
            case .t2SmallSearch: return "t2.small.search"
            case .t32xlargeSearch: return "t3.2xlarge.search"
            case .t3LargeSearch: return "t3.large.search"
            case .t3MediumSearch: return "t3.medium.search"
            case .t3MicroSearch: return "t3.micro.search"
            case .t3NanoSearch: return "t3.nano.search"
            case .t3SmallSearch: return "t3.small.search"
            case .t3XlargeSearch: return "t3.xlarge.search"
            case .t4gMediumSearch: return "t4g.medium.search"
            case .t4gSmallSearch: return "t4g.small.search"
            case .ultrawarm1LargeSearch: return "ultrawarm1.large.search"
            case .ultrawarm1MediumSearch: return "ultrawarm1.medium.search"
            case .ultrawarm1XlargeSearch: return "ultrawarm1.xlarge.search"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum OpenSearchWarmPartitionInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ultrawarm1LargeSearch
        case ultrawarm1MediumSearch
        case ultrawarm1XlargeSearch
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenSearchWarmPartitionInstanceType] {
            return [
                .ultrawarm1LargeSearch,
                .ultrawarm1MediumSearch,
                .ultrawarm1XlargeSearch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ultrawarm1LargeSearch: return "ultrawarm1.large.search"
            case .ultrawarm1MediumSearch: return "ultrawarm1.medium.search"
            case .ultrawarm1XlargeSearch: return "ultrawarm1.xlarge.search"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The zone awareness configuration for an Amazon OpenSearch Service domain.
    public struct ZoneAwarenessConfig {
        /// If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are 2 and 3. If your domain is provisioned within a VPC, this value be equal to number of subnets.
        public var availabilityZoneCount: Swift.Int?

        public init(
            availabilityZoneCount: Swift.Int? = nil
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for the cluster configuration of an OpenSearch Service domain. For more information, see [Creating and managing Amazon OpenSearch Service domains](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html).
    public struct ClusterConfig {
        /// Container for cold storage configuration options.
        public var coldStorageOptions: OpenSearchClientTypes.ColdStorageOptions?
        /// Number of dedicated master nodes in the cluster. This number must be greater than 2 and not 4, otherwise you receive a validation exception.
        public var dedicatedMasterCount: Swift.Int?
        /// Indicates whether dedicated master nodes are enabled for the cluster.True if the cluster will use a dedicated master node.False if the cluster will not.
        public var dedicatedMasterEnabled: Swift.Bool?
        /// OpenSearch Service instance type of the dedicated master nodes in the cluster.
        public var dedicatedMasterType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// Number of data nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.
        public var instanceCount: Swift.Int?
        /// Instance type of data nodes in the cluster.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// A boolean that indicates whether a multi-AZ domain is turned on with a standby AZ. For more information, see [Configuring a multi-AZ domain in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html).
        public var multiAZWithStandbyEnabled: Swift.Bool?
        /// The number of warm nodes in the cluster.
        public var warmCount: Swift.Int?
        /// Whether to enable warm storage for the cluster.
        public var warmEnabled: Swift.Bool?
        /// The instance type for the cluster's warm nodes.
        public var warmType: OpenSearchClientTypes.OpenSearchWarmPartitionInstanceType?
        /// Container for zone awareness configuration options. Only required if ZoneAwarenessEnabled is true.
        public var zoneAwarenessConfig: OpenSearchClientTypes.ZoneAwarenessConfig?
        /// Indicates whether multiple Availability Zones are enabled. For more information, see [Configuring a multi-AZ domain in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html).
        public var zoneAwarenessEnabled: Swift.Bool?

        public init(
            coldStorageOptions: OpenSearchClientTypes.ColdStorageOptions? = nil,
            dedicatedMasterCount: Swift.Int? = nil,
            dedicatedMasterEnabled: Swift.Bool? = nil,
            dedicatedMasterType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            instanceCount: Swift.Int? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            multiAZWithStandbyEnabled: Swift.Bool? = nil,
            warmCount: Swift.Int? = nil,
            warmEnabled: Swift.Bool? = nil,
            warmType: OpenSearchClientTypes.OpenSearchWarmPartitionInstanceType? = nil,
            zoneAwarenessConfig: OpenSearchClientTypes.ZoneAwarenessConfig? = nil,
            zoneAwarenessEnabled: Swift.Bool? = nil
        )
        {
            self.coldStorageOptions = coldStorageOptions
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.multiAZWithStandbyEnabled = multiAZWithStandbyEnabled
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for the parameters required to enable Cognito authentication for an OpenSearch Service domain. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
    public struct CognitoOptions {
        /// Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.
        public var enabled: Swift.Bool?
        /// The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.
        public var identityPoolId: Swift.String?
        /// The AmazonOpenSearchServiceCognitoAccess role that allows OpenSearch Service to configure your user pool and identity pool.
        public var roleArn: Swift.String?
        /// The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.
        public var userPoolId: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            identityPoolId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.identityPoolId = identityPoolId
            self.roleArn = roleArn
            self.userPoolId = userPoolId
        }
    }

}

extension OpenSearchClientTypes {

    public enum TLSSecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case policyMinTls10201907
        case policyMinTls12201907
        case policyMinTls12Pfs202310
        case sdkUnknown(Swift.String)

        public static var allCases: [TLSSecurityPolicy] {
            return [
                .policyMinTls10201907,
                .policyMinTls12201907,
                .policyMinTls12Pfs202310
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .policyMinTls10201907: return "Policy-Min-TLS-1-0-2019-07"
            case .policyMinTls12201907: return "Policy-Min-TLS-1-2-2019-07"
            case .policyMinTls12Pfs202310: return "Policy-Min-TLS-1-2-PFS-2023-10"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Options to configure a custom endpoint for an OpenSearch Service domain.
    public struct DomainEndpointOptions {
        /// The fully qualified URL for the custom endpoint.
        public var customEndpoint: Swift.String?
        /// The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).
        public var customEndpointCertificateArn: Swift.String?
        /// Whether to enable a custom endpoint for the domain.
        public var customEndpointEnabled: Swift.Bool?
        /// True to require that all traffic to the domain arrive over HTTPS.
        public var enforceHTTPS: Swift.Bool?
        /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain. The policy can be one of the following values:
        ///
        /// * Policy-Min-TLS-1-0-2019-07: TLS security policy that supports TLS version 1.0 to TLS version 1.2
        ///
        /// * Policy-Min-TLS-1-2-2019-07: TLS security policy that supports only TLS version 1.2
        ///
        /// * Policy-Min-TLS-1-2-PFS-2023-10: TLS security policy that supports TLS version 1.2 to TLS version 1.3 with perfect forward secrecy cipher suites
        public var tlsSecurityPolicy: OpenSearchClientTypes.TLSSecurityPolicy?

        public init(
            customEndpoint: Swift.String? = nil,
            customEndpointCertificateArn: Swift.String? = nil,
            customEndpointEnabled: Swift.Bool? = nil,
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: OpenSearchClientTypes.TLSSecurityPolicy? = nil
        )
        {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension OpenSearchClientTypes {

    /// The type of EBS volume that a domain uses. For more information, see [Configuring EBS-based storage](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/opensearch-createupdatedomains.html#opensearch-createdomain-configure-ebs).
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.
    public struct EBSOptions {
        /// Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.
        public var ebsEnabled: Swift.Bool?
        /// Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the gp3 and provisioned IOPS EBS volume types.
        public var iops: Swift.Int?
        /// Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        public var throughput: Swift.Int?
        /// Specifies the size (in GiB) of EBS volumes attached to data nodes.
        public var volumeSize: Swift.Int?
        /// Specifies the type of EBS volumes attached to data nodes.
        public var volumeType: OpenSearchClientTypes.VolumeType?

        public init(
            ebsEnabled: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: OpenSearchClientTypes.VolumeType? = nil
        )
        {
            self.ebsEnabled = ebsEnabled
            self.iops = iops
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension OpenSearchClientTypes {
    /// Specifies whether the domain should encrypt data at rest, and if so, the Key Management Service (KMS) key to use. Can only be used when creating a new domain or enabling encryption at rest for the first time on an existing domain. You can't modify this parameter after it's already been specified.
    public struct EncryptionAtRestOptions {
        /// True to enable encryption at rest.
        public var enabled: Swift.Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public var kmsKeyId: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension OpenSearchClientTypes {

    public enum IPAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualstack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IPAddressType] {
            return [
                .dualstack,
                .ipv4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "dualstack"
            case .ipv4: return "ipv4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    /// The type of log file. Can be one of the following:
    ///
    /// * INDEX_SLOW_LOGS - Index slow logs contain insert requests that took more time than the configured index query log threshold to execute.
    ///
    /// * SEARCH_SLOW_LOGS - Search slow logs contain search queries that took more time than the configured search query log threshold to execute.
    ///
    /// * ES_APPLICATION_LOGS - OpenSearch application logs contain information about errors and warnings raised during the operation of the service and can be useful for troubleshooting.
    ///
    /// * AUDIT_LOGS - Audit logs contain records of user requests for access to the domain.
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auditLogs
        case esApplicationLogs
        case indexSlowLogs
        case searchSlowLogs
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .auditLogs,
                .esApplicationLogs,
                .indexSlowLogs,
                .searchSlowLogs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auditLogs: return "AUDIT_LOGS"
            case .esApplicationLogs: return "ES_APPLICATION_LOGS"
            case .indexSlowLogs: return "INDEX_SLOW_LOGS"
            case .searchSlowLogs: return "SEARCH_SLOW_LOGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Specifies whether the Amazon OpenSearch Service domain publishes the OpenSearch application and slow logs to Amazon CloudWatch. For more information, see [Monitoring OpenSearch logs with Amazon CloudWatch Logs](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createdomain-configure-slow-logs.html). After you enable log publishing, you still have to enable the collection of slow logs using the OpenSearch REST API.
    public struct LogPublishingOption {
        /// The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the log should be published.
        public var enabled: Swift.Bool?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes {
    /// Enables or disables node-to-node encryption. For more information, see [Node-to-node encryption for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/ntn.html).
    public struct NodeToNodeEncryptionOptions {
        /// True to enable node-to-node encryption.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension OpenSearchClientTypes {
    /// The desired start time for an [off-peak maintenance window](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html).
    public struct WindowStartTime {
        /// The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, 17 refers to 5:00 P.M. UTC.
        /// This member is required.
        public var hours: Swift.Int
        /// The start minute of the window, in UTC.
        /// This member is required.
        public var minutes: Swift.Int

        public init(
            hours: Swift.Int = 0,
            minutes: Swift.Int = 0
        )
        {
            self.hours = hours
            self.minutes = minutes
        }
    }

}

extension OpenSearchClientTypes {
    /// A custom 10-hour, low-traffic window during which OpenSearch Service can perform mandatory configuration changes on the domain. These actions can include scheduled service software updates and blue/green Auto-Tune enhancements. OpenSearch Service will schedule these actions during the window that you specify. If you don't specify a window start time, it defaults to 10:00 P.M. local time. For more information, see [Defining off-peak maintenance windows for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html).
    public struct OffPeakWindow {
        /// A custom start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M.
        public var windowStartTime: OpenSearchClientTypes.WindowStartTime?

        public init(
            windowStartTime: OpenSearchClientTypes.WindowStartTime? = nil
        )
        {
            self.windowStartTime = windowStartTime
        }
    }

}

extension OpenSearchClientTypes {
    /// Options for a domain's [off-peak window](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html), during which OpenSearch Service can perform mandatory configuration changes on the domain.
    public struct OffPeakWindowOptions {
        /// Whether to enable an off-peak window. This option is only available when modifying a domain created prior to February 16, 2023, not when creating a new domain. All domains created after this date have the off-peak window enabled by default. You can't disable the off-peak window after it's enabled for a domain.
        public var enabled: Swift.Bool?
        /// Off-peak window settings for the domain.
        public var offPeakWindow: OpenSearchClientTypes.OffPeakWindow?

        public init(
            enabled: Swift.Bool? = nil,
            offPeakWindow: OpenSearchClientTypes.OffPeakWindow? = nil
        )
        {
            self.enabled = enabled
            self.offPeakWindow = offPeakWindow
        }
    }

}

extension OpenSearchClientTypes {
    /// The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is 0 hours.
    public struct SnapshotOptions {
        /// The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is 0 hours.
        public var automatedSnapshotStartHour: Swift.Int?

        public init(
            automatedSnapshotStartHour: Swift.Int? = nil
        )
        {
            self.automatedSnapshotStartHour = automatedSnapshotStartHour
        }
    }

}

extension OpenSearchClientTypes {
    /// Options for configuring service software updates for a domain.
    public struct SoftwareUpdateOptions {
        /// Whether automatic service software updates are enabled for the domain.
        public var autoSoftwareUpdateEnabled: Swift.Bool?

        public init(
            autoSoftwareUpdateEnabled: Swift.Bool? = nil
        )
        {
            self.autoSoftwareUpdateEnabled = autoSoftwareUpdateEnabled
        }
    }

}

extension OpenSearchClientTypes {
    /// Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint. For more information, see [Launching your Amazon OpenSearch Service domains using a VPC](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public struct VPCOptions {
        /// The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

public struct CreateDomainInput {
    /// Identity and Access Management (IAM) policy document specifying the access policies for the new domain.
    public var accessPolicies: Swift.String?
    /// Key-value pairs to specify advanced configuration options. The following key-value pairs are supported:
    ///
    /// * "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.
    ///
    /// * "indices.fielddata.cache.size": "80"  - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.
    ///
    /// * "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.
    ///
    /// * "override_main_response_version": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether the domain reports its version as 7.10 to allow Elasticsearch OSS clients and plugins to continue working with it. Default is false when creating a domain and true when upgrading a domain.
    ///
    ///
    /// For more information, see [Advanced cluster parameters](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public var advancedOptions: [Swift.String: Swift.String]?
    /// Options for fine-grained access control.
    public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    /// Options for all machine learning features for the specified domain.
    public var aimlOptions: OpenSearchClientTypes.AIMLOptionsInput?
    /// Options for Auto-Tune.
    public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsInput?
    /// Container for the cluster configuration of a domain.
    public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
    /// Key-value pairs to configure Amazon Cognito authentication. For more information, see [Configuring Amazon Cognito authentication for OpenSearch Dashboards](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/cognito-auth.html).
    public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
    public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    /// Name of the OpenSearch Service domain to create. Domain names are unique across the domains owned by an account within an Amazon Web Services Region.
    /// This member is required.
    public var domainName: Swift.String?
    /// Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.
    public var ebsOptions: OpenSearchClientTypes.EBSOptions?
    /// Key-value pairs to enable encryption at rest.
    public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch Service domain. For example, OpenSearch_1.0 or Elasticsearch_7.9. For more information, see [Creating and managing Amazon OpenSearch Service domains](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomains).
    public var engineVersion: Swift.String?
    /// Specify either dual stack or IPv4 as your IP address type. Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option. If you set your IP address type to dual stack, you can't change your address type later.
    public var ipAddressType: OpenSearchClientTypes.IPAddressType?
    /// Key-value pairs to configure log publishing.
    public var logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]?
    /// Enables node-to-node encryption.
    public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    /// Specifies a daily 10-hour time block during which OpenSearch Service can perform configuration changes on the domain, including service software updates and Auto-Tune enhancements that require a blue/green deployment. If no options are specified, the default start time of 10:00 P.M. local time (for the Region that the domain is created in) is used.
    public var offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions?
    /// DEPRECATED. Container for the parameters required to configure automated snapshots of domain indexes.
    public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    /// Software update options for the domain.
    public var softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions?
    /// List of tags to add to the domain upon creation.
    public var tagList: [OpenSearchClientTypes.Tag]?
    /// Container for the values required to configure VPC access domains. If you don't specify these values, OpenSearch Service creates the domain with a public endpoint. For more information, see [Launching your Amazon OpenSearch Service domains using a VPC](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public var vpcOptions: OpenSearchClientTypes.VPCOptions?

    public init(
        accessPolicies: Swift.String? = nil,
        advancedOptions: [Swift.String: Swift.String]? = nil,
        advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput? = nil,
        aimlOptions: OpenSearchClientTypes.AIMLOptionsInput? = nil,
        autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsInput? = nil,
        clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
        cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
        domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil,
        ebsOptions: OpenSearchClientTypes.EBSOptions? = nil,
        encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
        engineVersion: Swift.String? = nil,
        ipAddressType: OpenSearchClientTypes.IPAddressType? = nil,
        logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]? = nil,
        nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
        offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions? = nil,
        snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
        softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions? = nil,
        tagList: [OpenSearchClientTypes.Tag]? = nil,
        vpcOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.advancedOptions = advancedOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.aimlOptions = aimlOptions
        self.autoTuneOptions = autoTuneOptions
        self.clusterConfig = clusterConfig
        self.cognitoOptions = cognitoOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
        self.ebsOptions = ebsOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.engineVersion = engineVersion
        self.ipAddressType = ipAddressType
        self.logPublishingOptions = logPublishingOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.offPeakWindowOptions = offPeakWindowOptions
        self.snapshotOptions = snapshotOptions
        self.softwareUpdateOptions = softwareUpdateOptions
        self.tagList = tagList
        self.vpcOptions = vpcOptions
    }
}

extension OpenSearchClientTypes {

    /// The Auto-Tune state for the domain. For valid states see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public enum AutoTuneState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case disabledAndRollbackComplete
        case disabledAndRollbackError
        case disabledAndRollbackInProgress
        case disabledAndRollbackScheduled
        case disableInProgress
        case enabled
        case enableInProgress
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneState] {
            return [
                .disabled,
                .disabledAndRollbackComplete,
                .disabledAndRollbackError,
                .disabledAndRollbackInProgress,
                .disabledAndRollbackScheduled,
                .disableInProgress,
                .enabled,
                .enableInProgress,
                .error
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabledAndRollbackComplete: return "DISABLED_AND_ROLLBACK_COMPLETE"
            case .disabledAndRollbackError: return "DISABLED_AND_ROLLBACK_ERROR"
            case .disabledAndRollbackInProgress: return "DISABLED_AND_ROLLBACK_IN_PROGRESS"
            case .disabledAndRollbackScheduled: return "DISABLED_AND_ROLLBACK_SCHEDULED"
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case .enableInProgress: return "ENABLE_IN_PROGRESS"
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The Auto-Tune settings for a domain, displayed when enabling or disabling Auto-Tune.
    public struct AutoTuneOptionsOutput {
        /// Any errors that occurred while enabling or disabling Auto-Tune.
        public var errorMessage: Swift.String?
        /// The current state of Auto-Tune on the domain.
        public var state: OpenSearchClientTypes.AutoTuneState?
        /// Whether the domain's off-peak window will be used to deploy Auto-Tune changes rather than a maintenance schedule.
        public var useOffPeakWindow: Swift.Bool?

        public init(
            errorMessage: Swift.String? = nil,
            state: OpenSearchClientTypes.AutoTuneState? = nil,
            useOffPeakWindow: Swift.Bool? = nil
        )
        {
            self.errorMessage = errorMessage
            self.state = state
            self.useOffPeakWindow = useOffPeakWindow
        }
    }

}

extension OpenSearchClientTypes {

    public enum ConfigChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applyingChanges
        case cancelled
        case completed
        case initializing
        case pending
        case pendingUserInput
        case validating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigChangeStatus] {
            return [
                .applyingChanges,
                .cancelled,
                .completed,
                .initializing,
                .pending,
                .pendingUserInput,
                .validating,
                .validationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applyingChanges: return "ApplyingChanges"
            case .cancelled: return "Cancelled"
            case .completed: return "Completed"
            case .initializing: return "Initializing"
            case .pending: return "Pending"
            case .pendingUserInput: return "PendingUserInput"
            case .validating: return "Validating"
            case .validationFailed: return "ValidationFailed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customer
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .customer,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customer: return "CUSTOMER"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Container for information about a configuration change happening on a domain.
    public struct ChangeProgressDetails {
        /// The ID of the configuration change.
        public var changeId: Swift.String?
        /// The current status of the configuration change.
        public var configChangeStatus: OpenSearchClientTypes.ConfigChangeStatus?
        /// The IAM principal who initiated the configuration change.
        public var initiatedBy: OpenSearchClientTypes.InitiatedBy?
        /// The last time that the configuration change was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A message corresponding to the status of the configuration change.
        public var message: Swift.String?
        /// The time that the configuration change was initiated, in Universal Coordinated Time (UTC).
        public var startTime: Foundation.Date?

        public init(
            changeId: Swift.String? = nil,
            configChangeStatus: OpenSearchClientTypes.ConfigChangeStatus? = nil,
            initiatedBy: OpenSearchClientTypes.InitiatedBy? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.changeId = changeId
            self.configChangeStatus = configChangeStatus
            self.initiatedBy = initiatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.message = message
            self.startTime = startTime
        }
    }

}

extension OpenSearchClientTypes {

    public enum DomainProcessingStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case isolated
        case modifying
        case updating
        case upgrading
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainProcessingStatusType] {
            return [
                .active,
                .creating,
                .deleting,
                .isolated,
                .modifying,
                .updating,
                .upgrading
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .isolated: return "Isolated"
            case .modifying: return "Modifying"
            case .updating: return "UpdatingServiceSoftware"
            case .upgrading: return "UpgradingEngineVersion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum PropertyValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plainText
        case stringifiedJson
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyValueType] {
            return [
                .plainText,
                .stringifiedJson
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plainText: return "PLAIN_TEXT"
            case .stringifiedJson: return "STRINGIFIED_JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about the domain properties that are currently being modified.
    public struct ModifyingProperties {
        /// The current value of the domain property that is being modified.
        public var activeValue: Swift.String?
        /// The name of the property that is currently being modified.
        public var name: Swift.String?
        /// The value that the property that is currently being modified will eventually have.
        public var pendingValue: Swift.String?
        /// The type of value that is currently being modified. Properties can have two types:
        ///
        /// * PLAIN_TEXT: Contain direct values such as "1", "True", or "c5.large.search".
        ///
        /// * STRINGIFIED_JSON: Contain content in JSON format, such as {"Enabled":"True"}".
        public var valueType: OpenSearchClientTypes.PropertyValueType?

        public init(
            activeValue: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingValue: Swift.String? = nil,
            valueType: OpenSearchClientTypes.PropertyValueType? = nil
        )
        {
            self.activeValue = activeValue
            self.name = name
            self.pendingValue = pendingValue
            self.valueType = valueType
        }
    }

}

extension OpenSearchClientTypes {
    /// Information about the subnets and security groups for an Amazon OpenSearch Service domain provisioned within a virtual private cloud (VPC). For more information, see [Launching your Amazon OpenSearch Service domains using a VPC](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html). This information only exists if the domain was created with VPCOptions.
    public struct VPCDerivedInfo {
        /// The list of Availability Zones associated with the VPC subnets.
        public var availabilityZones: [Swift.String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public var subnetIds: [Swift.String]?
        /// The ID for your VPC. Amazon VPC generates this value when you create a VPC.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension OpenSearchClientTypes {
    /// The current status of an OpenSearch Service domain.
    public struct DomainStatus {
        /// Identity and Access Management (IAM) policy document specifying the access policies for the domain.
        public var accessPolicies: Swift.String?
        /// Key-value pairs that specify advanced configuration options.
        public var advancedOptions: [Swift.String: Swift.String]?
        /// Settings for fine-grained access control.
        public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptions?
        /// Container for parameters required to enable all machine learning features.
        public var aimlOptions: OpenSearchClientTypes.AIMLOptionsOutput?
        /// The Amazon Resource Name (ARN) of the domain. For more information, see [IAM identifiers ](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the AWS Identity and Access Management User Guide.
        /// This member is required.
        public var arn: Swift.String?
        /// Auto-Tune settings for the domain.
        public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsOutput?
        /// Information about a configuration change happening on the domain.
        public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
        /// Container for the cluster configuration of the domain.
        /// This member is required.
        public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
        /// Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.
        public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
        /// Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.
        public var created: Swift.Bool?
        /// Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.
        public var deleted: Swift.Bool?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
        /// The dual stack hosted zone ID for the domain.
        public var domainEndpointV2HostedZoneId: Swift.String?
        /// Unique identifier for the domain.
        /// This member is required.
        public var domainId: Swift.String?
        /// Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.
        /// This member is required.
        public var domainName: Swift.String?
        /// The status of any changes that are currently in progress for the domain.
        public var domainProcessingStatus: OpenSearchClientTypes.DomainProcessingStatusType?
        /// Container for EBS-based storage settings for the domain.
        public var ebsOptions: OpenSearchClientTypes.EBSOptions?
        /// Encryption at rest settings for the domain.
        public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to the domain.
        public var endpoint: Swift.String?
        /// If IPAddressType to set to dualstack, a version 2 domain endpoint is provisioned. This endpoint functions like a normal endpoint, except that it works with both IPv4 and IPv6 IP addresses. Normal endpoints work only with IPv4 IP addresses.
        public var endpointV2: Swift.String?
        /// The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints. For example:
        ///
        /// * IPv4 IP addresses - 'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'
        ///
        /// * Dual stack IP addresses - 'vpcv2':'vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.aos.us-east-1.on.aws'
        public var endpoints: [Swift.String: Swift.String]?
        /// Version of OpenSearch or Elasticsearch that the domain is running, in the format Elasticsearch_X.Y or OpenSearch_X.Y.
        public var engineVersion: Swift.String?
        /// The type of IP addresses supported by the endpoint for the domain.
        public var ipAddressType: OpenSearchClientTypes.IPAddressType?
        /// Log publishing options for the domain.
        public var logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]?
        /// Information about the domain properties that are currently being modified.
        public var modifyingProperties: [OpenSearchClientTypes.ModifyingProperties]?
        /// Whether node-to-node encryption is enabled or disabled.
        public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
        /// Options that specify a custom 10-hour window during which OpenSearch Service can perform configuration changes on the domain.
        public var offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions?
        /// The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.
        public var processing: Swift.Bool?
        /// The current status of the domain's service software.
        public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?
        /// DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.
        public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
        /// Service software update options for the domain.
        public var softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions?
        /// The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.
        public var upgradeProcessing: Swift.Bool?
        /// The VPC configuration for the domain.
        public var vpcOptions: OpenSearchClientTypes.VPCDerivedInfo?

        public init(
            accessPolicies: Swift.String? = nil,
            advancedOptions: [Swift.String: Swift.String]? = nil,
            advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptions? = nil,
            aimlOptions: OpenSearchClientTypes.AIMLOptionsOutput? = nil,
            arn: Swift.String? = nil,
            autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsOutput? = nil,
            changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
            clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
            cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
            created: Swift.Bool? = nil,
            deleted: Swift.Bool? = nil,
            domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
            domainEndpointV2HostedZoneId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainProcessingStatus: OpenSearchClientTypes.DomainProcessingStatusType? = nil,
            ebsOptions: OpenSearchClientTypes.EBSOptions? = nil,
            encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
            endpoint: Swift.String? = nil,
            endpointV2: Swift.String? = nil,
            endpoints: [Swift.String: Swift.String]? = nil,
            engineVersion: Swift.String? = nil,
            ipAddressType: OpenSearchClientTypes.IPAddressType? = nil,
            logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]? = nil,
            modifyingProperties: [OpenSearchClientTypes.ModifyingProperties]? = nil,
            nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
            offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions? = nil,
            processing: Swift.Bool? = nil,
            serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil,
            snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
            softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions? = nil,
            upgradeProcessing: Swift.Bool? = nil,
            vpcOptions: OpenSearchClientTypes.VPCDerivedInfo? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.aimlOptions = aimlOptions
            self.arn = arn
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.created = created
            self.deleted = deleted
            self.domainEndpointOptions = domainEndpointOptions
            self.domainEndpointV2HostedZoneId = domainEndpointV2HostedZoneId
            self.domainId = domainId
            self.domainName = domainName
            self.domainProcessingStatus = domainProcessingStatus
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpointV2 = endpointV2
            self.endpoints = endpoints
            self.engineVersion = engineVersion
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.modifyingProperties = modifyingProperties
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.processing = processing
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.upgradeProcessing = upgradeProcessing
            self.vpcOptions = vpcOptions
        }
    }

}

/// The result of a CreateDomain operation. Contains the status of the newly created domain.
public struct CreateDomainOutput {
    /// The status of the newly created domain.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init(
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

extension OpenSearchClientTypes {

    /// The status of SkipUnavailable setting for the outbound connection.
    ///
    /// * ENABLED - The SkipUnavailable setting is enabled for the connection.
    ///
    /// * DISABLED - The SkipUnavailable setting is disabled for the connection.
    public enum SkipUnavailableStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [SkipUnavailableStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Cross-cluster search specific connection properties.
    public struct CrossClusterSearchConnectionProperties {
        /// The status of the SkipUnavailable setting for the outbound connection. This feature allows you to specify some clusters as optional and ensure that your cross-cluster queries return partial results despite failures on one or more remote clusters.
        public var skipUnavailable: OpenSearchClientTypes.SkipUnavailableStatus?

        public init(
            skipUnavailable: OpenSearchClientTypes.SkipUnavailableStatus? = nil
        )
        {
            self.skipUnavailable = skipUnavailable
        }
    }

}

extension OpenSearchClientTypes {
    /// The connection properties of an outbound connection.
    public struct ConnectionProperties {
        /// The connection properties for cross cluster search.
        public var crossClusterSearch: OpenSearchClientTypes.CrossClusterSearchConnectionProperties?
        /// The Endpoint attribute cannot be modified. The endpoint of the remote domain. Applicable for VPC_ENDPOINT connection mode.
        public var endpoint: Swift.String?

        public init(
            crossClusterSearch: OpenSearchClientTypes.CrossClusterSearchConnectionProperties? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.crossClusterSearch = crossClusterSearch
            self.endpoint = endpoint
        }
    }

}

/// Container for the parameters to the CreateOutboundConnection operation.
public struct CreateOutboundConnectionInput {
    /// Name of the connection.
    /// This member is required.
    public var connectionAlias: Swift.String?
    /// The connection mode.
    public var connectionMode: OpenSearchClientTypes.ConnectionMode?
    /// The ConnectionProperties for the outbound connection.
    public var connectionProperties: OpenSearchClientTypes.ConnectionProperties?
    /// Name and Region of the source (local) domain.
    /// This member is required.
    public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    /// Name and Region of the destination (remote) domain.
    /// This member is required.
    public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

    public init(
        connectionAlias: Swift.String? = nil,
        connectionMode: OpenSearchClientTypes.ConnectionMode? = nil,
        connectionProperties: OpenSearchClientTypes.ConnectionProperties? = nil,
        localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
        remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
    )
    {
        self.connectionAlias = connectionAlias
        self.connectionMode = connectionMode
        self.connectionProperties = connectionProperties
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
    }
}

extension OpenSearchClientTypes {

    public enum OutboundConnectionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case approved
        case deleted
        case deleting
        case pendingAcceptance
        case provisioning
        case rejected
        case rejecting
        case validating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [OutboundConnectionStatusCode] {
            return [
                .active,
                .approved,
                .deleted,
                .deleting,
                .pendingAcceptance,
                .provisioning,
                .rejected,
                .rejecting,
                .validating,
                .validationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .approved: return "APPROVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingAcceptance: return "PENDING_ACCEPTANCE"
            case .provisioning: return "PROVISIONING"
            case .rejected: return "REJECTED"
            case .rejecting: return "REJECTING"
            case .validating: return "VALIDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The status of an outbound cross-cluster connection.
    public struct OutboundConnectionStatus {
        /// Verbose information for the outbound connection.
        public var message: Swift.String?
        /// The status code for the outbound connection. Can be one of the following:
        ///
        /// * VALIDATING - The outbound connection request is being validated.
        ///
        /// * VALIDATION_FAILED - Validation failed for the connection request.
        ///
        /// * PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner.
        ///
        /// * APPROVED - Outbound connection has been approved by the remote domain owner for getting provisioned.
        ///
        /// * PROVISIONING - Outbound connection request is in process.
        ///
        /// * ACTIVE - Outbound connection is active and ready to use.
        ///
        /// * REJECTING - Outbound connection rejection by remote domain owner is in progress.
        ///
        /// * REJECTED - Outbound connection request is rejected by remote domain owner.
        ///
        /// * DELETING - Outbound connection deletion is in progress.
        ///
        /// * DELETED - Outbound connection is deleted and can no longer be used.
        public var statusCode: OpenSearchClientTypes.OutboundConnectionStatusCode?

        public init(
            message: Swift.String? = nil,
            statusCode: OpenSearchClientTypes.OutboundConnectionStatusCode? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

/// The result of a CreateOutboundConnection request. Contains details about the newly created cross-cluster connection.
public struct CreateOutboundConnectionOutput {
    /// Name of the connection.
    public var connectionAlias: Swift.String?
    /// The unique identifier for the created outbound connection, which is used for subsequent operations on the connection.
    public var connectionId: Swift.String?
    /// The connection mode.
    public var connectionMode: OpenSearchClientTypes.ConnectionMode?
    /// The ConnectionProperties for the newly created connection.
    public var connectionProperties: OpenSearchClientTypes.ConnectionProperties?
    /// The status of the connection.
    public var connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus?
    /// Information about the source (local) domain.
    public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
    /// Information about the destination (remote) domain.
    public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

    public init(
        connectionAlias: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionMode: OpenSearchClientTypes.ConnectionMode? = nil,
        connectionProperties: OpenSearchClientTypes.ConnectionProperties? = nil,
        connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus? = nil,
        localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
        remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
    )
    {
        self.connectionAlias = connectionAlias
        self.connectionId = connectionId
        self.connectionMode = connectionMode
        self.connectionProperties = connectionProperties
        self.connectionStatus = connectionStatus
        self.localDomainInfo = localDomainInfo
        self.remoteDomainInfo = remoteDomainInfo
    }
}

extension OpenSearchClientTypes {
    /// The Amazon S3 location to import the package from.
    public struct PackageSource {
        /// The name of the Amazon S3 bucket containing the package.
        public var s3BucketName: Swift.String?
        /// Key (file name) of the package.
        public var s3Key: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3Key = s3Key
        }
    }

}

/// Container for request parameters to the CreatePackage operation.
public struct CreatePackageInput {
    /// Description of the package.
    public var packageDescription: Swift.String?
    /// Unique name for the package.
    /// This member is required.
    public var packageName: Swift.String?
    /// The Amazon S3 location from which to import the package.
    /// This member is required.
    public var packageSource: OpenSearchClientTypes.PackageSource?
    /// The type of package.
    /// This member is required.
    public var packageType: OpenSearchClientTypes.PackageType?

    public init(
        packageDescription: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageSource: OpenSearchClientTypes.PackageSource? = nil,
        packageType: OpenSearchClientTypes.PackageType? = nil
    )
    {
        self.packageDescription = packageDescription
        self.packageName = packageName
        self.packageSource = packageSource
        self.packageType = packageType
    }
}

extension OpenSearchClientTypes {
    /// Basic information about the plugin.
    public struct PluginProperties {
        /// The name of the class to load.
        public var className: Swift.String?
        /// The description of the plugin.
        public var description: Swift.String?
        /// The name of the plugin.
        public var name: Swift.String?
        /// The uncompressed size of the plugin.
        public var uncompressedSizeInBytes: Swift.Int?
        /// The version of the plugin.
        public var version: Swift.String?

        public init(
            className: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            uncompressedSizeInBytes: Swift.Int? = nil,
            version: Swift.String? = nil
        )
        {
            self.className = className
            self.description = description
            self.name = name
            self.uncompressedSizeInBytes = uncompressedSizeInBytes
            self.version = version
        }
    }

}

extension OpenSearchClientTypes {

    public enum PackageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case copying
        case copyFailed
        case deleted
        case deleteFailed
        case deleting
        case validating
        case validationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageStatus] {
            return [
                .available,
                .copying,
                .copyFailed,
                .deleted,
                .deleteFailed,
                .deleting,
                .validating,
                .validationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .copyFailed: return "COPY_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .validating: return "VALIDATING"
            case .validationFailed: return "VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Basic information about a package.
    public struct PackageDetails {
        /// The package version.
        public var availablePackageVersion: Swift.String?
        /// If the package is a ZIP-PLUGIN package, additional information about plugin properties.
        public var availablePluginProperties: OpenSearchClientTypes.PluginProperties?
        /// The timestamp when the package was created.
        public var createdAt: Foundation.Date?
        /// Version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
        public var engineVersion: Swift.String?
        /// Additional information if the package is in an error state. Null otherwise.
        public var errorDetails: OpenSearchClientTypes.ErrorDetails?
        /// Date and time when the package was last updated.
        public var lastUpdatedAt: Foundation.Date?
        /// User-specified description of the package.
        public var packageDescription: Swift.String?
        /// The unique identifier of the package.
        public var packageID: Swift.String?
        /// The user-specified name of the package.
        public var packageName: Swift.String?
        /// The current status of the package. The available options are AVAILABLE, COPYING, COPY_FAILED, VALIDATNG, VALIDATION_FAILED, DELETING, and DELETE_FAILED.
        public var packageStatus: OpenSearchClientTypes.PackageStatus?
        /// The type of package.
        public var packageType: OpenSearchClientTypes.PackageType?

        public init(
            availablePackageVersion: Swift.String? = nil,
            availablePluginProperties: OpenSearchClientTypes.PluginProperties? = nil,
            createdAt: Foundation.Date? = nil,
            engineVersion: Swift.String? = nil,
            errorDetails: OpenSearchClientTypes.ErrorDetails? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            packageDescription: Swift.String? = nil,
            packageID: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageStatus: OpenSearchClientTypes.PackageStatus? = nil,
            packageType: OpenSearchClientTypes.PackageType? = nil
        )
        {
            self.availablePackageVersion = availablePackageVersion
            self.availablePluginProperties = availablePluginProperties
            self.createdAt = createdAt
            self.engineVersion = engineVersion
            self.errorDetails = errorDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageName = packageName
            self.packageStatus = packageStatus
            self.packageType = packageType
        }
    }

}

/// Container for the response returned by the CreatePackage operation.
public struct CreatePackageOutput {
    /// Basic information about an OpenSearch Service package.
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init(
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

public struct CreateVpcEndpointInput {
    /// Unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the domain to create the endpoint for.
    /// This member is required.
    public var domainArn: Swift.String?
    /// Options to specify the subnets and security groups for the endpoint.
    /// This member is required.
    public var vpcOptions: OpenSearchClientTypes.VPCOptions?

    public init(
        clientToken: Swift.String? = nil,
        domainArn: Swift.String? = nil,
        vpcOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.clientToken = clientToken
        self.domainArn = domainArn
        self.vpcOptions = vpcOptions
    }
}

extension OpenSearchClientTypes {

    public enum VpcEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointStatus] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The connection endpoint for connecting to an Amazon OpenSearch Service domain through a proxy.
    public struct VpcEndpoint {
        /// The Amazon Resource Name (ARN) of the domain associated with the endpoint.
        public var domainArn: Swift.String?
        /// The connection endpoint ID for connecting to the domain.
        public var endpoint: Swift.String?
        /// The current status of the endpoint.
        public var status: OpenSearchClientTypes.VpcEndpointStatus?
        /// The unique identifier of the endpoint.
        public var vpcEndpointId: Swift.String?
        /// The creator of the endpoint.
        public var vpcEndpointOwner: Swift.String?
        /// Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.
        public var vpcOptions: OpenSearchClientTypes.VPCDerivedInfo?

        public init(
            domainArn: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            status: OpenSearchClientTypes.VpcEndpointStatus? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcEndpointOwner: Swift.String? = nil,
            vpcOptions: OpenSearchClientTypes.VPCDerivedInfo? = nil
        )
        {
            self.domainArn = domainArn
            self.endpoint = endpoint
            self.status = status
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
            self.vpcOptions = vpcOptions
        }
    }

}

public struct CreateVpcEndpointOutput {
    /// Information about the newly created VPC endpoint.
    /// This member is required.
    public var vpcEndpoint: OpenSearchClientTypes.VpcEndpoint?

    public init(
        vpcEndpoint: OpenSearchClientTypes.VpcEndpoint? = nil
    )
    {
        self.vpcEndpoint = vpcEndpoint
    }
}

/// Container for the parameters to the DeleteDataSource operation.
public struct DeleteDataSourceInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the data source to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.name = name
    }
}

/// The result of a GetDataSource operation.
public struct DeleteDataSourceOutput {
    /// A message associated with deletion of the data source.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

/// Container for the parameters to the DeleteDomain operation.
public struct DeleteDomainInput {
    /// The name of the domain you want to permanently delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// The results of a DeleteDomain request. Contains the status of the pending deletion, or a "domain not found" error if the domain and all of its resources have been deleted.
public struct DeleteDomainOutput {
    /// The status of the domain being deleted.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init(
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

/// Container for the parameters to the DeleteInboundConnection operation.
public struct DeleteInboundConnectionInput {
    /// The ID of the inbound connection to permanently delete.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

/// The results of a DeleteInboundConnection operation. Contains details about the deleted inbound connection.
public struct DeleteInboundConnectionOutput {
    /// The deleted inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init(
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

/// Container for the parameters to the DeleteOutboundConnection operation.
public struct DeleteOutboundConnectionInput {
    /// The ID of the outbound connection you want to permanently delete.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

extension OpenSearchClientTypes {
    /// Specifies details about an outbound cross-cluster connection.
    public struct OutboundConnection {
        /// Name of the connection.
        public var connectionAlias: Swift.String?
        /// Unique identifier of the connection.
        public var connectionId: Swift.String?
        /// The connection mode.
        public var connectionMode: OpenSearchClientTypes.ConnectionMode?
        /// Properties for the outbound connection.
        public var connectionProperties: OpenSearchClientTypes.ConnectionProperties?
        /// Status of the connection.
        public var connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus?
        /// Information about the source (local) domain.
        public var localDomainInfo: OpenSearchClientTypes.DomainInformationContainer?
        /// Information about the destination (remote) domain.
        public var remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer?

        public init(
            connectionAlias: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionMode: OpenSearchClientTypes.ConnectionMode? = nil,
            connectionProperties: OpenSearchClientTypes.ConnectionProperties? = nil,
            connectionStatus: OpenSearchClientTypes.OutboundConnectionStatus? = nil,
            localDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil,
            remoteDomainInfo: OpenSearchClientTypes.DomainInformationContainer? = nil
        )
        {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionMode = connectionMode
            self.connectionProperties = connectionProperties
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }
    }

}

/// Details about the deleted outbound connection.
public struct DeleteOutboundConnectionOutput {
    /// The deleted inbound connection.
    public var connection: OpenSearchClientTypes.OutboundConnection?

    public init(
        connection: OpenSearchClientTypes.OutboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

/// Deletes a package from OpenSearch Service. The package can't be associated with any OpenSearch Service domain.
public struct DeletePackageInput {
    /// The internal ID of the package you want to delete. Use DescribePackages to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init(
        packageID: Swift.String? = nil
    )
    {
        self.packageID = packageID
    }
}

/// Container for the response parameters to the DeletePackage operation.
public struct DeletePackageOutput {
    /// Information about the deleted package.
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init(
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

public struct DeleteVpcEndpointInput {
    /// The unique identifier of the endpoint.
    /// This member is required.
    public var vpcEndpointId: Swift.String?

    public init(
        vpcEndpointId: Swift.String? = nil
    )
    {
        self.vpcEndpointId = vpcEndpointId
    }
}

extension OpenSearchClientTypes {
    /// Summary information for an Amazon OpenSearch Service-managed VPC endpoint.
    public struct VpcEndpointSummary {
        /// The Amazon Resource Name (ARN) of the domain associated with the endpoint.
        public var domainArn: Swift.String?
        /// The current status of the endpoint.
        public var status: OpenSearchClientTypes.VpcEndpointStatus?
        /// The unique identifier of the endpoint.
        public var vpcEndpointId: Swift.String?
        /// The creator of the endpoint.
        public var vpcEndpointOwner: Swift.String?

        public init(
            domainArn: Swift.String? = nil,
            status: OpenSearchClientTypes.VpcEndpointStatus? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcEndpointOwner: Swift.String? = nil
        )
        {
            self.domainArn = domainArn
            self.status = status
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
        }
    }

}

public struct DeleteVpcEndpointOutput {
    /// Information about the deleted endpoint, including its current status (DELETING or DELETE_FAILED).
    /// This member is required.
    public var vpcEndpointSummary: OpenSearchClientTypes.VpcEndpointSummary?

    public init(
        vpcEndpointSummary: OpenSearchClientTypes.VpcEndpointSummary? = nil
    )
    {
        self.vpcEndpointSummary = vpcEndpointSummary
    }
}

/// Container for the parameters to the DescribeDomain operation.
public struct DescribeDomainInput {
    /// The name of the domain that you want information about.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// Contains the status of the domain specified in the request.
public struct DescribeDomainOutput {
    /// List that contains the status of each specified OpenSearch Service domain.
    /// This member is required.
    public var domainStatus: OpenSearchClientTypes.DomainStatus?

    public init(
        domainStatus: OpenSearchClientTypes.DomainStatus? = nil
    )
    {
        self.domainStatus = domainStatus
    }
}

/// Container for the parameters to the DescribeDomainAutoTunes operation.
public struct DescribeDomainAutoTunesInput {
    /// Name of the domain that you want Auto-Tune details about.
    /// This member is required.
    public var domainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribeDomainAutoTunes operation returns a nextToken, you can include the returned nextToken in subsequent DescribeDomainAutoTunes operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OpenSearchClientTypes {

    /// The Auto-Tune action type.
    public enum ScheduledAutoTuneActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jvmHeapSizeTuning
        case jvmYoungGenTuning
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledAutoTuneActionType] {
            return [
                .jvmHeapSizeTuning,
                .jvmYoungGenTuning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jvmHeapSizeTuning: return "JVM_HEAP_SIZE_TUNING"
            case .jvmYoungGenTuning: return "JVM_YOUNG_GEN_TUNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    /// The Auto-Tune action severity.
    public enum ScheduledAutoTuneSeverityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledAutoTuneSeverityType] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Specifies details about a scheduled Auto-Tune action. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct ScheduledAutoTuneDetails {
        /// A description of the Auto-Tune action.
        public var action: Swift.String?
        /// The type of Auto-Tune action.
        public var actionType: OpenSearchClientTypes.ScheduledAutoTuneActionType?
        /// The date and time when the Auto-Tune action is scheduled for the domain.
        public var date: Foundation.Date?
        /// The severity of the Auto-Tune action. Valid values are LOW, MEDIUM, and HIGH.
        public var severity: OpenSearchClientTypes.ScheduledAutoTuneSeverityType?

        public init(
            action: Swift.String? = nil,
            actionType: OpenSearchClientTypes.ScheduledAutoTuneActionType? = nil,
            date: Foundation.Date? = nil,
            severity: OpenSearchClientTypes.ScheduledAutoTuneSeverityType? = nil
        )
        {
            self.action = action
            self.actionType = actionType
            self.date = date
            self.severity = severity
        }
    }

}

extension OpenSearchClientTypes {
    /// Specifies details about a scheduled Auto-Tune action. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct AutoTuneDetails {
        /// Container for details about a scheduled Auto-Tune action.
        public var scheduledAutoTuneDetails: OpenSearchClientTypes.ScheduledAutoTuneDetails?

        public init(
            scheduledAutoTuneDetails: OpenSearchClientTypes.ScheduledAutoTuneDetails? = nil
        )
        {
            self.scheduledAutoTuneDetails = scheduledAutoTuneDetails
        }
    }

}

extension OpenSearchClientTypes {

    /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
    public enum AutoTuneType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case scheduledAction
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoTuneType] {
            return [
                .scheduledAction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .scheduledAction: return "SCHEDULED_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about an Auto-Tune action. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct AutoTune {
        /// Details about an Auto-Tune action.
        public var autoTuneDetails: OpenSearchClientTypes.AutoTuneDetails?
        /// The type of Auto-Tune action.
        public var autoTuneType: OpenSearchClientTypes.AutoTuneType?

        public init(
            autoTuneDetails: OpenSearchClientTypes.AutoTuneDetails? = nil,
            autoTuneType: OpenSearchClientTypes.AutoTuneType? = nil
        )
        {
            self.autoTuneDetails = autoTuneDetails
            self.autoTuneType = autoTuneType
        }
    }

}

/// The result of a DescribeDomainAutoTunes request.
public struct DescribeDomainAutoTunesOutput {
    /// The list of setting adjustments that Auto-Tune has made to the domain.
    public var autoTunes: [OpenSearchClientTypes.AutoTune]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        autoTunes: [OpenSearchClientTypes.AutoTune]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoTunes = autoTunes
        self.nextToken = nextToken
    }
}

/// Container for the parameters to the DescribeDomainChangeProgress operation.
public struct DescribeDomainChangeProgressInput {
    /// The specific change ID for which you want to get progress information. If omitted, the request returns information about the most recent configuration change.
    public var changeId: Swift.String?
    /// The name of the domain to get progress information for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        changeId: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.changeId = changeId
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {
    /// Progress details for each stage of a domain update.
    public struct ChangeProgressStage {
        /// The description of the stage.
        public var description: Swift.String?
        /// The most recent updated timestamp of the stage.
        public var lastUpdated: Foundation.Date?
        /// The name of the stage.
        public var name: Swift.String?
        /// The status of the stage.
        public var status: Swift.String?

        public init(
            description: Swift.String? = nil,
            lastUpdated: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.description = description
            self.lastUpdated = lastUpdated
            self.name = name
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {

    /// The overall status value of the domain configuration change.
    public enum OverallChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case pending
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OverallChangeStatus] {
            return [
                .completed,
                .failed,
                .pending,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// The progress details of a specific domain configuration change.
    public struct ChangeProgressStatusDetails {
        /// The unique change identifier associated with a specific domain configuration change.
        public var changeId: Swift.String?
        /// The specific stages that the domain is going through to perform the configuration change.
        public var changeProgressStages: [OpenSearchClientTypes.ChangeProgressStage]?
        /// The list of properties in the domain configuration change that have completed.
        public var completedProperties: [Swift.String]?
        /// The current status of the configuration change.
        public var configChangeStatus: OpenSearchClientTypes.ConfigChangeStatus?
        /// The IAM principal who initiated the configuration change.
        public var initiatedBy: OpenSearchClientTypes.InitiatedBy?
        /// The last time that the status of the configuration change was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The list of properties in the domain configuration change that are still pending.
        public var pendingProperties: [Swift.String]?
        /// The time at which the configuration change is made on the domain.
        public var startTime: Foundation.Date?
        /// The overall status of the domain configuration change.
        public var status: OpenSearchClientTypes.OverallChangeStatus?
        /// The total number of stages required for the configuration change.
        public var totalNumberOfStages: Swift.Int

        public init(
            changeId: Swift.String? = nil,
            changeProgressStages: [OpenSearchClientTypes.ChangeProgressStage]? = nil,
            completedProperties: [Swift.String]? = nil,
            configChangeStatus: OpenSearchClientTypes.ConfigChangeStatus? = nil,
            initiatedBy: OpenSearchClientTypes.InitiatedBy? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            pendingProperties: [Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            status: OpenSearchClientTypes.OverallChangeStatus? = nil,
            totalNumberOfStages: Swift.Int = 0
        )
        {
            self.changeId = changeId
            self.changeProgressStages = changeProgressStages
            self.completedProperties = completedProperties
            self.configChangeStatus = configChangeStatus
            self.initiatedBy = initiatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.pendingProperties = pendingProperties
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }
    }

}

/// The result of a DescribeDomainChangeProgress request. Contains progress information for the requested domain change.
public struct DescribeDomainChangeProgressOutput {
    /// Container for information about the stages of a configuration change happening on a domain.
    public var changeProgressStatus: OpenSearchClientTypes.ChangeProgressStatusDetails?

    public init(
        changeProgressStatus: OpenSearchClientTypes.ChangeProgressStatusDetails? = nil
    )
    {
        self.changeProgressStatus = changeProgressStatus
    }
}

/// Container for the parameters to the DescribeDomainConfig operation.
public struct DescribeDomainConfigInput {
    /// Name of the OpenSearch Service domain configuration that you want to describe.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {

    /// The rollback state while disabling Auto-Tune for the domain.
    public enum RollbackOnDisable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case defaultRollback
        case noRollback
        case sdkUnknown(Swift.String)

        public static var allCases: [RollbackOnDisable] {
            return [
                .defaultRollback,
                .noRollback
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .defaultRollback: return "DEFAULT_ROLLBACK"
            case .noRollback: return "NO_ROLLBACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Auto-Tune settings when updating a domain. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct AutoTuneOptions {
        /// Whether Auto-Tune is enabled or disabled.
        public var desiredState: OpenSearchClientTypes.AutoTuneDesiredState?
        /// DEPRECATED. Use [off-peak window](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/off-peak.html) instead. A list of maintenance schedules during which Auto-Tune can deploy changes.
        public var maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]?
        /// When disabling Auto-Tune, specify NO_ROLLBACK to retain all prior Auto-Tune settings or DEFAULT_ROLLBACK to revert to the OpenSearch Service defaults. If you specify DEFAULT_ROLLBACK, you must include a MaintenanceSchedule in the request. Otherwise, OpenSearch Service is unable to perform the rollback.
        public var rollbackOnDisable: OpenSearchClientTypes.RollbackOnDisable?
        /// Whether to use the domain's [off-peak window](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html) to deploy configuration changes on the domain rather than a maintenance schedule.
        public var useOffPeakWindow: Swift.Bool?

        public init(
            desiredState: OpenSearchClientTypes.AutoTuneDesiredState? = nil,
            maintenanceSchedules: [OpenSearchClientTypes.AutoTuneMaintenanceSchedule]? = nil,
            rollbackOnDisable: OpenSearchClientTypes.RollbackOnDisable? = nil,
            useOffPeakWindow: Swift.Bool? = nil
        )
        {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.rollbackOnDisable = rollbackOnDisable
            self.useOffPeakWindow = useOffPeakWindow
        }
    }

}

extension OpenSearchClientTypes {
    /// The current status of Auto-Tune for the domain. For more information, see [Auto-Tune for Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html).
    public struct AutoTuneStatus {
        /// Date and time when Auto-Tune was enabled for the domain.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// Any errors that occurred while enabling or disabling Auto-Tune.
        public var errorMessage: Swift.String?
        /// Indicates whether the domain is being deleted.
        public var pendingDeletion: Swift.Bool?
        /// The current state of Auto-Tune on the domain.
        /// This member is required.
        public var state: OpenSearchClientTypes.AutoTuneState?
        /// Date and time when the Auto-Tune options were last updated for the domain.
        /// This member is required.
        public var updateDate: Foundation.Date?
        /// The latest version of the Auto-Tune options.
        public var updateVersion: Swift.Int

        public init(
            creationDate: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            pendingDeletion: Swift.Bool? = nil,
            state: OpenSearchClientTypes.AutoTuneState? = nil,
            updateDate: Foundation.Date? = nil,
            updateVersion: Swift.Int = 0
        )
        {
            self.creationDate = creationDate
            self.errorMessage = errorMessage
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }
    }

}

extension OpenSearchClientTypes {
    /// The Auto-Tune status for the domain.
    public struct AutoTuneOptionsStatus {
        /// Auto-Tune settings for updating a domain.
        public var options: OpenSearchClientTypes.AutoTuneOptions?
        /// The current status of Auto-Tune for a domain.
        public var status: OpenSearchClientTypes.AutoTuneStatus?

        public init(
            options: OpenSearchClientTypes.AutoTuneOptions? = nil,
            status: OpenSearchClientTypes.AutoTuneStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The cluster configuration status for a domain.
    public struct ClusterConfigStatus {
        /// Cluster configuration options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.ClusterConfig?
        /// The status of cluster configuration options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.ClusterConfig? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of the Cognito options for the specified domain.
    public struct CognitoOptionsStatus {
        /// Cognito options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.CognitoOptions?
        /// The status of the Cognito options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.CognitoOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The configured endpoint options for a domain and their current status.
    public struct DomainEndpointOptionsStatus {
        /// Options to configure the endpoint for a domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.DomainEndpointOptions?
        /// The status of the endpoint options for a domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.DomainEndpointOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of the EBS options for the specified OpenSearch Service domain.
    public struct EBSOptionsStatus {
        /// The configured EBS options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.EBSOptions?
        /// The status of the EBS options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.EBSOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Status of the encryption at rest options for the specified OpenSearch Service domain.
    public struct EncryptionAtRestOptionsStatus {
        /// Encryption at rest options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.EncryptionAtRestOptions?
        /// The status of the encryption at rest options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of the the OpenSearch or Elasticsearch version options for the specified Amazon OpenSearch Service domain.
    public struct VersionStatus {
        /// The OpenSearch or Elasticsearch version for the specified domain.
        /// This member is required.
        public var options: Swift.String?
        /// The status of the version options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: Swift.String? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The IP address type status for the domain.
    public struct IPAddressTypeStatus {
        /// The IP address options for the domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.IPAddressType?
        /// Provides the current status of an entity.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.IPAddressType? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The configured log publishing options for the domain and their current status.
    public struct LogPublishingOptionsStatus {
        /// The log publishing options configured for the domain.
        public var options: [Swift.String: OpenSearchClientTypes.LogPublishingOption]?
        /// The status of the log publishing options for the domain.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: [Swift.String: OpenSearchClientTypes.LogPublishingOption]? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Status of the node-to-node encryption options for the specified domain.
    public struct NodeToNodeEncryptionOptionsStatus {
        /// The node-to-node encryption options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
        /// The status of the node-to-node encryption options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of [off-peak window](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_OffPeakWindow.html) options for a domain.
    public struct OffPeakWindowOptionsStatus {
        /// The domain's off-peak window configuration.
        public var options: OpenSearchClientTypes.OffPeakWindowOptions?
        /// The current status of off-peak window options.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.OffPeakWindowOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for information about a daily automated snapshot for an OpenSearch Service domain.
    public struct SnapshotOptionsStatus {
        /// The daily snapshot options specified for the domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.SnapshotOptions?
        /// The status of a daily automated snapshot.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.SnapshotOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// The status of the service software options for a domain.
    public struct SoftwareUpdateOptionsStatus {
        /// The service software update options for a domain.
        public var options: OpenSearchClientTypes.SoftwareUpdateOptions?
        /// The status of service software update options, including creation date and last updated date.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.SoftwareUpdateOptions? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Status of the VPC options for a specified domain.
    public struct VPCDerivedInfoStatus {
        /// The VPC options for the specified domain.
        /// This member is required.
        public var options: OpenSearchClientTypes.VPCDerivedInfo?
        /// The status of the VPC options for the specified domain.
        /// This member is required.
        public var status: OpenSearchClientTypes.OptionStatus?

        public init(
            options: OpenSearchClientTypes.VPCDerivedInfo? = nil,
            status: OpenSearchClientTypes.OptionStatus? = nil
        )
        {
            self.options = options
            self.status = status
        }
    }

}

extension OpenSearchClientTypes {
    /// Container for the configuration of an OpenSearch Service domain.
    public struct DomainConfig {
        /// Specifies the access policies for the domain.
        public var accessPolicies: OpenSearchClientTypes.AccessPoliciesStatus?
        /// Key-value pairs to specify advanced configuration options. For more information, see [Advanced options](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
        public var advancedOptions: OpenSearchClientTypes.AdvancedOptionsStatus?
        /// Container for fine-grained access control settings for the domain.
        public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsStatus?
        /// Container for parameters required to enable all machine learning features.
        public var aimlOptions: OpenSearchClientTypes.AIMLOptionsStatus?
        /// Container for Auto-Tune settings for the domain.
        public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsStatus?
        /// Container for information about the progress of an existing configuration change.
        public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
        /// Container for the cluster configuration of a the domain.
        public var clusterConfig: OpenSearchClientTypes.ClusterConfigStatus?
        /// Container for Amazon Cognito options for the domain.
        public var cognitoOptions: OpenSearchClientTypes.CognitoOptionsStatus?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptionsStatus?
        /// Container for EBS options configured for the domain.
        public var ebsOptions: OpenSearchClientTypes.EBSOptionsStatus?
        /// Key-value pairs to enable encryption at rest.
        public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptionsStatus?
        /// The OpenSearch or Elasticsearch version that the domain is running.
        public var engineVersion: OpenSearchClientTypes.VersionStatus?
        /// Choose either dual stack or IPv4 as your IP address type. Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option. If you set your IP address type to dual stack, you can't change your address type later.
        public var ipAddressType: OpenSearchClientTypes.IPAddressTypeStatus?
        /// Key-value pairs to configure log publishing.
        public var logPublishingOptions: OpenSearchClientTypes.LogPublishingOptionsStatus?
        /// Information about the domain properties that are currently being modified.
        public var modifyingProperties: [OpenSearchClientTypes.ModifyingProperties]?
        /// Whether node-to-node encryption is enabled or disabled.
        public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus?
        /// Container for off-peak window options for the domain.
        public var offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptionsStatus?
        /// DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.
        public var snapshotOptions: OpenSearchClientTypes.SnapshotOptionsStatus?
        /// Software update options for the domain.
        public var softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptionsStatus?
        /// The current VPC options for the domain and the status of any updates to their configuration.
        public var vpcOptions: OpenSearchClientTypes.VPCDerivedInfoStatus?

        public init(
            accessPolicies: OpenSearchClientTypes.AccessPoliciesStatus? = nil,
            advancedOptions: OpenSearchClientTypes.AdvancedOptionsStatus? = nil,
            advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsStatus? = nil,
            aimlOptions: OpenSearchClientTypes.AIMLOptionsStatus? = nil,
            autoTuneOptions: OpenSearchClientTypes.AutoTuneOptionsStatus? = nil,
            changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
            clusterConfig: OpenSearchClientTypes.ClusterConfigStatus? = nil,
            cognitoOptions: OpenSearchClientTypes.CognitoOptionsStatus? = nil,
            domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptionsStatus? = nil,
            ebsOptions: OpenSearchClientTypes.EBSOptionsStatus? = nil,
            encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptionsStatus? = nil,
            engineVersion: OpenSearchClientTypes.VersionStatus? = nil,
            ipAddressType: OpenSearchClientTypes.IPAddressTypeStatus? = nil,
            logPublishingOptions: OpenSearchClientTypes.LogPublishingOptionsStatus? = nil,
            modifyingProperties: [OpenSearchClientTypes.ModifyingProperties]? = nil,
            nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus? = nil,
            offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptionsStatus? = nil,
            snapshotOptions: OpenSearchClientTypes.SnapshotOptionsStatus? = nil,
            softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptionsStatus? = nil,
            vpcOptions: OpenSearchClientTypes.VPCDerivedInfoStatus? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.aimlOptions = aimlOptions
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.modifyingProperties = modifyingProperties
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.vpcOptions = vpcOptions
        }
    }

}

/// Contains the configuration information of the requested domain.
public struct DescribeDomainConfigOutput {
    /// Container for the configuration of the OpenSearch Service domain.
    /// This member is required.
    public var domainConfig: OpenSearchClientTypes.DomainConfig?

    public init(
        domainConfig: OpenSearchClientTypes.DomainConfig? = nil
    )
    {
        self.domainConfig = domainConfig
    }
}

/// Container for the parameters to the DescribeDomainHealth operation.
public struct DescribeDomainHealthInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {

    public enum DomainHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case green
        case notavailable
        case red
        case yellow
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainHealth] {
            return [
                .green,
                .notavailable,
                .red,
                .yellow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .green: return "Green"
            case .notavailable: return "NotAvailable"
            case .red: return "Red"
            case .yellow: return "Yellow"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum DomainState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case notavailable
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainState] {
            return [
                .active,
                .notavailable,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .notavailable: return "NotAvailable"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum ZoneStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case notavailable
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ZoneStatus] {
            return [
                .active,
                .notavailable,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .notavailable: return "NotAvailable"
            case .standby: return "StandBy"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about an Availability Zone on a domain.
    public struct AvailabilityZoneInfo {
        /// The name of the Availability Zone.
        public var availabilityZoneName: Swift.String?
        /// The number of data nodes active in the Availability Zone.
        public var availableDataNodeCount: Swift.String?
        /// The total number of data nodes configured in the Availability Zone.
        public var configuredDataNodeCount: Swift.String?
        /// The total number of primary and replica shards in the Availability Zone.
        public var totalShards: Swift.String?
        /// The total number of primary and replica shards that aren't allocated to any of the nodes in the Availability Zone.
        public var totalUnAssignedShards: Swift.String?
        /// The current state of the Availability Zone. Current options are Active and StandBy.
        ///
        /// * Active - Data nodes in the Availability Zone are in use.
        ///
        /// * StandBy - Data nodes in the Availability Zone are in a standby state.
        ///
        /// * NotAvailable - Unable to retrieve information.
        public var zoneStatus: OpenSearchClientTypes.ZoneStatus?

        public init(
            availabilityZoneName: Swift.String? = nil,
            availableDataNodeCount: Swift.String? = nil,
            configuredDataNodeCount: Swift.String? = nil,
            totalShards: Swift.String? = nil,
            totalUnAssignedShards: Swift.String? = nil,
            zoneStatus: OpenSearchClientTypes.ZoneStatus? = nil
        )
        {
            self.availabilityZoneName = availabilityZoneName
            self.availableDataNodeCount = availableDataNodeCount
            self.configuredDataNodeCount = configuredDataNodeCount
            self.totalShards = totalShards
            self.totalUnAssignedShards = totalUnAssignedShards
            self.zoneStatus = zoneStatus
        }
    }

}

extension OpenSearchClientTypes {
    /// Information about the active domain environment.
    public struct EnvironmentInfo {
        /// A list of AvailabilityZoneInfo for the domain.
        public var availabilityZoneInformation: [OpenSearchClientTypes.AvailabilityZoneInfo]?

        public init(
            availabilityZoneInformation: [OpenSearchClientTypes.AvailabilityZoneInfo]? = nil
        )
        {
            self.availabilityZoneInformation = availabilityZoneInformation
        }
    }

}

extension OpenSearchClientTypes {

    public enum MasterNodeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [MasterNodeStatus] {
            return [
                .available,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .unavailable: return "UnAvailable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The result of a DescribeDomainHealth request. Contains health information for the requested domain.
public struct DescribeDomainHealthOutput {
    /// The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
    public var activeAvailabilityZoneCount: Swift.String?
    /// The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
    public var availabilityZoneCount: Swift.String?
    /// The current health status of your cluster.
    ///
    /// * Red - At least one primary shard is not allocated to any node.
    ///
    /// * Yellow - All primary shards are allocated to nodes, but some replicas arent.
    ///
    /// * Green - All primary shards and their replicas are allocated to nodes.
    ///
    /// * NotAvailable - Unable to retrieve cluster health.
    public var clusterHealth: OpenSearchClientTypes.DomainHealth?
    /// The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
    public var dataNodeCount: Swift.String?
    /// A boolean that indicates if dedicated master nodes are activated for the domain.
    public var dedicatedMaster: Swift.Bool?
    /// The current state of the domain.
    ///
    /// * Processing - The domain has updates in progress.
    ///
    /// * Active - Requested changes have been processed and deployed to the domain.
    public var domainState: OpenSearchClientTypes.DomainState?
    /// A list of EnvironmentInfo for the domain.
    public var environmentInformation: [OpenSearchClientTypes.EnvironmentInfo]?
    /// The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
    public var masterEligibleNodeCount: Swift.String?
    /// Indicates whether the domain has an elected master node.
    ///
    /// * Available - The domain has an elected master node.
    ///
    /// * UnAvailable - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.
    public var masterNode: OpenSearchClientTypes.MasterNodeStatus?
    /// The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
    public var standByAvailabilityZoneCount: Swift.String?
    /// The total number of primary and replica shards for the domain.
    public var totalShards: Swift.String?
    /// The total number of primary and replica shards not allocated to any of the nodes for the cluster.
    public var totalUnAssignedShards: Swift.String?
    /// The number of warm nodes configured for the domain.
    public var warmNodeCount: Swift.String?

    public init(
        activeAvailabilityZoneCount: Swift.String? = nil,
        availabilityZoneCount: Swift.String? = nil,
        clusterHealth: OpenSearchClientTypes.DomainHealth? = nil,
        dataNodeCount: Swift.String? = nil,
        dedicatedMaster: Swift.Bool? = nil,
        domainState: OpenSearchClientTypes.DomainState? = nil,
        environmentInformation: [OpenSearchClientTypes.EnvironmentInfo]? = nil,
        masterEligibleNodeCount: Swift.String? = nil,
        masterNode: OpenSearchClientTypes.MasterNodeStatus? = nil,
        standByAvailabilityZoneCount: Swift.String? = nil,
        totalShards: Swift.String? = nil,
        totalUnAssignedShards: Swift.String? = nil,
        warmNodeCount: Swift.String? = nil
    )
    {
        self.activeAvailabilityZoneCount = activeAvailabilityZoneCount
        self.availabilityZoneCount = availabilityZoneCount
        self.clusterHealth = clusterHealth
        self.dataNodeCount = dataNodeCount
        self.dedicatedMaster = dedicatedMaster
        self.domainState = domainState
        self.environmentInformation = environmentInformation
        self.masterEligibleNodeCount = masterEligibleNodeCount
        self.masterNode = masterNode
        self.standByAvailabilityZoneCount = standByAvailabilityZoneCount
        self.totalShards = totalShards
        self.totalUnAssignedShards = totalUnAssignedShards
        self.warmNodeCount = warmNodeCount
    }
}

/// Container for the parameters to the DescribeDomainNodes operation.
public struct DescribeDomainNodesInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {

    public enum NodeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case notavailable
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeStatus] {
            return [
                .active,
                .notavailable,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .notavailable: return "NotAvailable"
            case .standby: return "StandBy"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum NodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case data
        case master
        case ultrawarm
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeType] {
            return [
                .data,
                .master,
                .ultrawarm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .data: return "Data"
            case .master: return "Master"
            case .ultrawarm: return "Ultrawarm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Container for information about nodes on the domain.
    public struct DomainNodesStatus {
        /// The Availability Zone of the node.
        public var availabilityZone: Swift.String?
        /// The instance type information of the node.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// The ID of the node.
        public var nodeId: Swift.String?
        /// Indicates if the node is active or in standby.
        public var nodeStatus: OpenSearchClientTypes.NodeStatus?
        /// Indicates whether the nodes is a data, master, or ultrawarm node.
        public var nodeType: OpenSearchClientTypes.NodeType?
        /// The storage size of the node, in GiB.
        public var storageSize: Swift.String?
        /// Indicates if the node has EBS or instance storage.
        public var storageType: Swift.String?
        /// If the nodes has EBS storage, indicates if the volume type is GP2 or GP3. Only applicable for data nodes.
        public var storageVolumeType: OpenSearchClientTypes.VolumeType?

        public init(
            availabilityZone: Swift.String? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            nodeId: Swift.String? = nil,
            nodeStatus: OpenSearchClientTypes.NodeStatus? = nil,
            nodeType: OpenSearchClientTypes.NodeType? = nil,
            storageSize: Swift.String? = nil,
            storageType: Swift.String? = nil,
            storageVolumeType: OpenSearchClientTypes.VolumeType? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.instanceType = instanceType
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
            self.nodeType = nodeType
            self.storageSize = storageSize
            self.storageType = storageType
            self.storageVolumeType = storageVolumeType
        }
    }

}

/// The result of a DescribeDomainNodes request. Contains information about the nodes on the requested domain.
public struct DescribeDomainNodesOutput {
    /// Contains nodes information list DomainNodesStatusList with details about the all nodes on the requested domain.
    public var domainNodesStatusList: [OpenSearchClientTypes.DomainNodesStatus]?

    public init(
        domainNodesStatusList: [OpenSearchClientTypes.DomainNodesStatus]? = nil
    )
    {
        self.domainNodesStatusList = domainNodesStatusList
    }
}

/// Container for the parameters to the DescribeDomains operation.
public struct DescribeDomainsInput {
    /// Array of OpenSearch Service domain names that you want information about. You must specify at least one domain name.
    /// This member is required.
    public var domainNames: [Swift.String]?

    public init(
        domainNames: [Swift.String]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

/// Contains the status of the specified domains or all domains owned by the account.
public struct DescribeDomainsOutput {
    /// The status of the requested domains.
    /// This member is required.
    public var domainStatusList: [OpenSearchClientTypes.DomainStatus]?

    public init(
        domainStatusList: [OpenSearchClientTypes.DomainStatus]? = nil
    )
    {
        self.domainStatusList = domainStatusList
    }
}

public struct DescribeDryRunProgressInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the dry run.
    public var dryRunId: Swift.String?
    /// Whether to include the configuration of the dry run in the response. The configuration specifies the updates that you're planning to make on the domain.
    public var loadDryRunConfig: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        dryRunId: Swift.String? = nil,
        loadDryRunConfig: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.dryRunId = dryRunId
        self.loadDryRunConfig = loadDryRunConfig
    }
}

extension OpenSearchClientTypes {
    /// A validation failure that occurred as the result of a pre-update validation check (verbose dry run) on a domain.
    public struct ValidationFailure {
        /// The error code of the failure.
        public var code: Swift.String?
        /// A message corresponding to the failure.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension OpenSearchClientTypes {
    /// Information about the progress of a pre-upgrade dry run analysis.
    public struct DryRunProgressStatus {
        /// The timestamp when the dry run was initiated.
        /// This member is required.
        public var creationDate: Swift.String?
        /// The unique identifier of the dry run.
        /// This member is required.
        public var dryRunId: Swift.String?
        /// The current status of the dry run.
        /// This member is required.
        public var dryRunStatus: Swift.String?
        /// The timestamp when the dry run was last updated.
        /// This member is required.
        public var updateDate: Swift.String?
        /// Any validation failures that occurred as a result of the dry run.
        public var validationFailures: [OpenSearchClientTypes.ValidationFailure]?

        public init(
            creationDate: Swift.String? = nil,
            dryRunId: Swift.String? = nil,
            dryRunStatus: Swift.String? = nil,
            updateDate: Swift.String? = nil,
            validationFailures: [OpenSearchClientTypes.ValidationFailure]? = nil
        )
        {
            self.creationDate = creationDate
            self.dryRunId = dryRunId
            self.dryRunStatus = dryRunStatus
            self.updateDate = updateDate
            self.validationFailures = validationFailures
        }
    }

}

extension OpenSearchClientTypes {
    /// Results of a dry run performed in an update domain request.
    public struct DryRunResults {
        /// Specifies the way in which OpenSearch Service will apply an update. Possible values are:
        ///
        /// * Blue/Green - The update requires a blue/green deployment.
        ///
        /// * DynamicUpdate - No blue/green deployment required
        ///
        /// * Undetermined - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.
        ///
        /// * None - The request doesn't include any configuration changes.
        public var deploymentType: Swift.String?
        /// A message corresponding to the deployment type.
        public var message: Swift.String?

        public init(
            deploymentType: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.deploymentType = deploymentType
            self.message = message
        }
    }

}

public struct DescribeDryRunProgressOutput {
    /// Details about the changes you're planning to make on the domain.
    public var dryRunConfig: OpenSearchClientTypes.DomainStatus?
    /// The current status of the dry run, including any validation errors.
    public var dryRunProgressStatus: OpenSearchClientTypes.DryRunProgressStatus?
    /// The results of the dry run.
    public var dryRunResults: OpenSearchClientTypes.DryRunResults?

    public init(
        dryRunConfig: OpenSearchClientTypes.DomainStatus? = nil,
        dryRunProgressStatus: OpenSearchClientTypes.DryRunProgressStatus? = nil,
        dryRunResults: OpenSearchClientTypes.DryRunResults? = nil
    )
    {
        self.dryRunConfig = dryRunConfig
        self.dryRunProgressStatus = dryRunProgressStatus
        self.dryRunResults = dryRunResults
    }
}

/// Request processing failed because you provided an invalid pagination token.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension OpenSearchClientTypes {
    /// A filter used to limit results when describing inbound or outbound cross-cluster connections. You can specify multiple values per filter. A cross-cluster connection must match at least one of the specified values for it to be returned from an operation.
    public struct Filter {
        /// The name of the filter.
        public var name: Swift.String?
        /// One or more values for the filter.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

/// Container for the parameters to the DescribeInboundConnections operation.
public struct DescribeInboundConnectionsInput {
    /// A list of filters used to match properties for inbound cross-cluster connections.
    public var filters: [OpenSearchClientTypes.Filter]?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribeInboundConnections operation returns a nextToken, you can include the returned nextToken in subsequent DescribeInboundConnections operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        filters: [OpenSearchClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Contains a list of connections matching the filter criteria.
public struct DescribeInboundConnectionsOutput {
    /// List of inbound connections.
    public var connections: [OpenSearchClientTypes.InboundConnection]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        connections: [OpenSearchClientTypes.InboundConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

/// Container for the parameters to the DescribeInstanceTypeLimits operation.
public struct DescribeInstanceTypeLimitsInput {
    /// The name of the domain. Only specify if you need the limits for an existing domain.
    public var domainName: Swift.String?
    /// Version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The OpenSearch Service instance type for which you need limit information.
    /// This member is required.
    public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?

    public init(
        domainName: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil
    )
    {
        self.domainName = domainName
        self.engineVersion = engineVersion
        self.instanceType = instanceType
    }
}

extension OpenSearchClientTypes {
    /// Limits on the number of instances that can be created in OpenSearch Service for a given instance type.
    public struct InstanceCountLimits {
        /// The minimum allowed number of instances.
        public var maximumInstanceCount: Swift.Int
        /// The maximum allowed number of instances.
        public var minimumInstanceCount: Swift.Int

        public init(
            maximumInstanceCount: Swift.Int = 0,
            minimumInstanceCount: Swift.Int = 0
        )
        {
            self.maximumInstanceCount = maximumInstanceCount
            self.minimumInstanceCount = minimumInstanceCount
        }
    }

}

extension OpenSearchClientTypes {
    /// Instance-related attributes that are available for a given instance type.
    public struct InstanceLimits {
        /// Limits on the number of instances that can be created for a given instance type.
        public var instanceCountLimits: OpenSearchClientTypes.InstanceCountLimits?

        public init(
            instanceCountLimits: OpenSearchClientTypes.InstanceCountLimits? = nil
        )
        {
            self.instanceCountLimits = instanceCountLimits
        }
    }

}

extension OpenSearchClientTypes {
    /// Limits that are applicable for the given Amazon OpenSearch Service storage type.
    public struct StorageTypeLimit {
        /// Name of storage limits that are applicable for the given storage type. If StorageType is ebs, the following options are available:
        ///
        /// * MinimumVolumeSize - Minimum volume size that is available for the given storage type. Can be empty if not applicable.
        ///
        /// * MaximumVolumeSize - Maximum volume size that is available for the given storage type. Can be empty if not applicable.
        ///
        /// * MaximumIops - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.
        ///
        /// * MinimumIops - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.
        ///
        /// * MaximumThroughput - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.
        ///
        /// * MinimumThroughput - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.
        public var limitName: Swift.String?
        /// The limit values.
        public var limitValues: [Swift.String]?

        public init(
            limitName: Swift.String? = nil,
            limitValues: [Swift.String]? = nil
        )
        {
            self.limitName = limitName
            self.limitValues = limitValues
        }
    }

}

extension OpenSearchClientTypes {
    /// A list of storage types for an Amazon OpenSearch Service domain that are available for a given intance type.
    public struct StorageType {
        /// The storage sub-type, such as gp3 or io1.
        public var storageSubTypeName: Swift.String?
        /// Limits that are applicable for the given storage type.
        public var storageTypeLimits: [OpenSearchClientTypes.StorageTypeLimit]?
        /// The name of the storage type.
        public var storageTypeName: Swift.String?

        public init(
            storageSubTypeName: Swift.String? = nil,
            storageTypeLimits: [OpenSearchClientTypes.StorageTypeLimit]? = nil,
            storageTypeName: Swift.String? = nil
        )
        {
            self.storageSubTypeName = storageSubTypeName
            self.storageTypeLimits = storageTypeLimits
            self.storageTypeName = storageTypeName
        }
    }

}

extension OpenSearchClientTypes {
    /// Limits for a given instance type and for each of its roles.
    public struct Limits {
        /// List of additional limits that are specific to a given instance type for each of its instance roles.
        public var additionalLimits: [OpenSearchClientTypes.AdditionalLimit]?
        /// The limits for a given instance type.
        public var instanceLimits: OpenSearchClientTypes.InstanceLimits?
        /// Storage-related attributes that are available for a given instance type.
        public var storageTypes: [OpenSearchClientTypes.StorageType]?

        public init(
            additionalLimits: [OpenSearchClientTypes.AdditionalLimit]? = nil,
            instanceLimits: OpenSearchClientTypes.InstanceLimits? = nil,
            storageTypes: [OpenSearchClientTypes.StorageType]? = nil
        )
        {
            self.additionalLimits = additionalLimits
            self.instanceLimits = instanceLimits
            self.storageTypes = storageTypes
        }
    }

}

/// Container for the parameters received from the DescribeInstanceTypeLimits operation.
public struct DescribeInstanceTypeLimitsOutput {
    /// Map that contains all applicable instance type limits.data refers to data nodes.master refers to dedicated master nodes.
    public var limitsByRole: [Swift.String: OpenSearchClientTypes.Limits]?

    public init(
        limitsByRole: [Swift.String: OpenSearchClientTypes.Limits]? = nil
    )
    {
        self.limitsByRole = limitsByRole
    }
}

/// Container for the parameters to the DescribeOutboundConnections operation.
public struct DescribeOutboundConnectionsInput {
    /// List of filter names and values that you can use for requests.
    public var filters: [OpenSearchClientTypes.Filter]?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribeOutboundConnections operation returns a nextToken, you can include the returned nextToken in subsequent DescribeOutboundConnections operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        filters: [OpenSearchClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Contains a list of connections matching the filter criteria.
public struct DescribeOutboundConnectionsOutput {
    /// List of outbound connections that match the filter criteria.
    public var connections: [OpenSearchClientTypes.OutboundConnection]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        connections: [OpenSearchClientTypes.OutboundConnection]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

extension OpenSearchClientTypes {

    public enum DescribePackagesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case engineversion
        case packageid
        case packagename
        case packagestatus
        case packagetype
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribePackagesFilterName] {
            return [
                .engineversion,
                .packageid,
                .packagename,
                .packagestatus,
                .packagetype
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .engineversion: return "EngineVersion"
            case .packageid: return "PackageID"
            case .packagename: return "PackageName"
            case .packagestatus: return "PackageStatus"
            case .packagetype: return "PackageType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// A filter to apply to the DescribePackage response.
    public struct DescribePackagesFilter {
        /// Any field from PackageDetails.
        public var name: OpenSearchClientTypes.DescribePackagesFilterName?
        /// A non-empty list of values for the specified filter field.
        public var value: [Swift.String]?

        public init(
            name: OpenSearchClientTypes.DescribePackagesFilterName? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

/// Container for the request parameters to the DescribePackage operation.
public struct DescribePackagesInput {
    /// Only returns packages that match the DescribePackagesFilterList values.
    public var filters: [OpenSearchClientTypes.DescribePackagesFilter]?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribePackageFilters operation returns a nextToken, you can include the returned nextToken in subsequent DescribePackageFilters operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        filters: [OpenSearchClientTypes.DescribePackagesFilter]? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Container for the response returned by the DescribePackages operation.
public struct DescribePackagesOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// Basic information about a package.
    public var packageDetailsList: [OpenSearchClientTypes.PackageDetails]?

    public init(
        nextToken: Swift.String? = nil,
        packageDetailsList: [OpenSearchClientTypes.PackageDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageDetailsList = packageDetailsList
    }
}

/// Container for the request parameters to a DescribeReservedInstanceOfferings operation.
public struct DescribeReservedInstanceOfferingsInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribeReservedInstanceOfferings operation returns a nextToken, you can include the returned nextToken in subsequent DescribeReservedInstanceOfferings operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The Reserved Instance identifier filter value. Use this parameter to show only the available instance types that match the specified reservation identifier.
    public var reservedInstanceOfferingId: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        reservedInstanceOfferingId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reservedInstanceOfferingId = reservedInstanceOfferingId
    }
}

extension OpenSearchClientTypes {

    public enum ReservedInstancePaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservedInstancePaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Contains the specific price and frequency of a recurring charges for an OpenSearch Reserved Instance, or for a Reserved Instance offering.
    public struct RecurringCharge {
        /// The monetary amount of the recurring charge.
        public var recurringChargeAmount: Swift.Double?
        /// The frequency of the recurring charge.
        public var recurringChargeFrequency: Swift.String?

        public init(
            recurringChargeAmount: Swift.Double? = nil,
            recurringChargeFrequency: Swift.String? = nil
        )
        {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }
    }

}

extension OpenSearchClientTypes {
    /// Details of an OpenSearch Reserved Instance offering.
    public struct ReservedInstanceOffering {
        /// The currency code for the Reserved Instance offering.
        public var currencyCode: Swift.String?
        /// The duration, in seconds, for which the offering will reserve the OpenSearch instance.
        public var duration: Swift.Int
        /// The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.
        public var fixedPrice: Swift.Double?
        /// The OpenSearch instance type offered by the Reserved Instance offering.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// Payment option for the Reserved Instance offering
        public var paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption?
        /// The recurring charge to your account, regardless of whether you creates any domains using the offering.
        public var recurringCharges: [OpenSearchClientTypes.RecurringCharge]?
        /// The unique identifier of the Reserved Instance offering.
        public var reservedInstanceOfferingId: Swift.String?
        /// The hourly rate at which you're charged for the domain using this Reserved Instance.
        public var usagePrice: Swift.Double?

        public init(
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption? = nil,
            recurringCharges: [OpenSearchClientTypes.RecurringCharge]? = nil,
            reservedInstanceOfferingId: Swift.String? = nil,
            usagePrice: Swift.Double? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.usagePrice = usagePrice
        }
    }

}

/// Container for results of a DescribeReservedInstanceOfferings request.
public struct DescribeReservedInstanceOfferingsOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// List of Reserved Instance offerings.
    public var reservedInstanceOfferings: [OpenSearchClientTypes.ReservedInstanceOffering]?

    public init(
        nextToken: Swift.String? = nil,
        reservedInstanceOfferings: [OpenSearchClientTypes.ReservedInstanceOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedInstanceOfferings = reservedInstanceOfferings
    }
}

/// Container for the request parameters to the DescribeReservedInstances operation.
public struct DescribeReservedInstancesInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial DescribeReservedInstances operation returns a nextToken, you can include the returned nextToken in subsequent DescribeReservedInstances operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The reserved instance identifier filter value. Use this parameter to show only the reservation that matches the specified reserved OpenSearch instance ID.
    public var reservedInstanceId: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        reservedInstanceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reservedInstanceId = reservedInstanceId
    }
}

extension OpenSearchClientTypes {
    /// Details of an OpenSearch Reserved Instance.
    public struct ReservedInstance {
        /// The unique identifier of the billing subscription.
        public var billingSubscriptionId: Swift.Int?
        /// The currency code for the offering.
        public var currencyCode: Swift.String?
        /// The duration, in seconds, for which the OpenSearch instance is reserved.
        public var duration: Swift.Int
        /// The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.
        public var fixedPrice: Swift.Double?
        /// The number of OpenSearch instances that have been reserved.
        public var instanceCount: Swift.Int
        /// The OpenSearch instance type offered by theReserved Instance offering.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// The payment option as defined in the Reserved Instance offering.
        public var paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption?
        /// The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.
        public var recurringCharges: [OpenSearchClientTypes.RecurringCharge]?
        /// The customer-specified identifier to track this reservation.
        public var reservationName: Swift.String?
        /// The unique identifier for the reservation.
        public var reservedInstanceId: Swift.String?
        /// The unique identifier of the Reserved Instance offering.
        public var reservedInstanceOfferingId: Swift.String?
        /// The date and time when the reservation was purchased.
        public var startTime: Foundation.Date?
        /// The state of the Reserved Instance.
        public var state: Swift.String?
        /// The hourly rate at which you're charged for the domain using this Reserved Instance.
        public var usagePrice: Swift.Double?

        public init(
            billingSubscriptionId: Swift.Int? = nil,
            currencyCode: Swift.String? = nil,
            duration: Swift.Int = 0,
            fixedPrice: Swift.Double? = nil,
            instanceCount: Swift.Int = 0,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            paymentOption: OpenSearchClientTypes.ReservedInstancePaymentOption? = nil,
            recurringCharges: [OpenSearchClientTypes.RecurringCharge]? = nil,
            reservationName: Swift.String? = nil,
            reservedInstanceId: Swift.String? = nil,
            reservedInstanceOfferingId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: Swift.String? = nil,
            usagePrice: Swift.Double? = nil
        )
        {
            self.billingSubscriptionId = billingSubscriptionId
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }
    }

}

/// Container for results from DescribeReservedInstances
public struct DescribeReservedInstancesOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// List of Reserved Instances in the current Region.
    public var reservedInstances: [OpenSearchClientTypes.ReservedInstance]?

    public init(
        nextToken: Swift.String? = nil,
        reservedInstances: [OpenSearchClientTypes.ReservedInstance]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservedInstances = reservedInstances
    }
}

public struct DescribeVpcEndpointsInput {
    /// The unique identifiers of the endpoints to get information about.
    /// This member is required.
    public var vpcEndpointIds: [Swift.String]?

    public init(
        vpcEndpointIds: [Swift.String]? = nil
    )
    {
        self.vpcEndpointIds = vpcEndpointIds
    }
}

extension OpenSearchClientTypes {

    public enum VpcEndpointErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endpointNotFound
        case serverError
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcEndpointErrorCode] {
            return [
                .endpointNotFound,
                .serverError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endpointNotFound: return "ENDPOINT_NOT_FOUND"
            case .serverError: return "SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Error information when attempting to describe an Amazon OpenSearch Service-managed VPC endpoint.
    public struct VpcEndpointError {
        /// The code associated with the error.
        public var errorCode: OpenSearchClientTypes.VpcEndpointErrorCode?
        /// A message describing the error.
        public var errorMessage: Swift.String?
        /// The unique identifier of the endpoint.
        public var vpcEndpointId: Swift.String?

        public init(
            errorCode: OpenSearchClientTypes.VpcEndpointErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.vpcEndpointId = vpcEndpointId
        }
    }

}

public struct DescribeVpcEndpointsOutput {
    /// Any errors associated with the request.
    /// This member is required.
    public var vpcEndpointErrors: [OpenSearchClientTypes.VpcEndpointError]?
    /// Information about each requested VPC endpoint.
    /// This member is required.
    public var vpcEndpoints: [OpenSearchClientTypes.VpcEndpoint]?

    public init(
        vpcEndpointErrors: [OpenSearchClientTypes.VpcEndpointError]? = nil,
        vpcEndpoints: [OpenSearchClientTypes.VpcEndpoint]? = nil
    )
    {
        self.vpcEndpointErrors = vpcEndpointErrors
        self.vpcEndpoints = vpcEndpoints
    }
}

/// Container for the request parameters to the DissociatePackage operation.
public struct DissociatePackageInput {
    /// Name of the domain to dissociate the package from.
    /// This member is required.
    public var domainName: Swift.String?
    /// Internal ID of the package to dissociate from the domain. Use ListPackagesForDomain to find this value.
    /// This member is required.
    public var packageID: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.packageID = packageID
    }
}

/// Container for the response returned by an DissociatePackage operation.
public struct DissociatePackageOutput {
    /// Information about a package that has been dissociated from the domain.
    public var domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails?

    public init(
        domainPackageDetails: OpenSearchClientTypes.DomainPackageDetails? = nil
    )
    {
        self.domainPackageDetails = domainPackageDetails
    }
}

/// Container for the request parameters to GetCompatibleVersions operation.
public struct GetCompatibleVersionsInput {
    /// The name of an existing domain. Provide this parameter to limit the results to a single domain.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {
    /// A map of OpenSearch or Elasticsearch versions and the versions you can upgrade them to.
    public struct CompatibleVersionsMap {
        /// The current version that the OpenSearch Service domain is running.
        public var sourceVersion: Swift.String?
        /// The possible versions that you can upgrade the domain to.
        public var targetVersions: [Swift.String]?

        public init(
            sourceVersion: Swift.String? = nil,
            targetVersions: [Swift.String]? = nil
        )
        {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }
    }

}

/// Container for the response returned by the GetCompatibleVersions operation.
public struct GetCompatibleVersionsOutput {
    /// A map of OpenSearch or Elasticsearch versions and the versions you can upgrade them to.
    public var compatibleVersions: [OpenSearchClientTypes.CompatibleVersionsMap]?

    public init(
        compatibleVersions: [OpenSearchClientTypes.CompatibleVersionsMap]? = nil
    )
    {
        self.compatibleVersions = compatibleVersions
    }
}

/// Container for the parameters to the GetDataSource operation.
public struct GetDataSourceInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the data source to get information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.name = name
    }
}

extension OpenSearchClientTypes {

    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .active,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The result of a GetDataSource operation.
public struct GetDataSourceOutput {
    /// The type of data source.
    public var dataSourceType: OpenSearchClientTypes.DataSourceType?
    /// A description of the data source.
    public var description: Swift.String?
    /// The name of the data source.
    public var name: Swift.String?
    /// The status of the data source.
    public var status: OpenSearchClientTypes.DataSourceStatus?

    public init(
        dataSourceType: OpenSearchClientTypes.DataSourceType? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OpenSearchClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.description = description
        self.name = name
        self.status = status
    }
}

/// Container for the parameters to the GetDomainMaintenanceStatus operation.
public struct GetDomainMaintenanceStatusInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The request ID of the maintenance action.
    /// This member is required.
    public var maintenanceId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maintenanceId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maintenanceId = maintenanceId
    }
}

extension OpenSearchClientTypes {

    public enum MaintenanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rebootNode
        case restartDashboard
        case restartSearchProcess
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceType] {
            return [
                .rebootNode,
                .restartDashboard,
                .restartSearchProcess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rebootNode: return "REBOOT_NODE"
            case .restartDashboard: return "RESTART_DASHBOARD"
            case .restartSearchProcess: return "RESTART_SEARCH_PROCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum MaintenanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case pending
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .pending,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The result of a GetDomainMaintenanceStatus request that information about the requested action.
public struct GetDomainMaintenanceStatusOutput {
    /// The action name.
    public var action: OpenSearchClientTypes.MaintenanceType?
    /// The time at which the action was created.
    public var createdAt: Foundation.Date?
    /// The node ID of the maintenance action.
    public var nodeId: Swift.String?
    /// The status of the maintenance action.
    public var status: OpenSearchClientTypes.MaintenanceStatus?
    /// The status message of the maintenance action.
    public var statusMessage: Swift.String?
    /// The time at which the action was updated.
    public var updatedAt: Foundation.Date?

    public init(
        action: OpenSearchClientTypes.MaintenanceType? = nil,
        createdAt: Foundation.Date? = nil,
        nodeId: Swift.String? = nil,
        status: OpenSearchClientTypes.MaintenanceStatus? = nil,
        statusMessage: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.action = action
        self.createdAt = createdAt
        self.nodeId = nodeId
        self.status = status
        self.statusMessage = statusMessage
        self.updatedAt = updatedAt
    }
}

/// Container for the request parameters to the GetPackageVersionHistory operation.
public struct GetPackageVersionHistoryInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial GetPackageVersionHistory operation returns a nextToken, you can include the returned nextToken in subsequent GetPackageVersionHistory operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The unique identifier of the package.
    /// This member is required.
    public var packageID: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageID = packageID
    }
}

extension OpenSearchClientTypes {
    /// Details about a package version.
    public struct PackageVersionHistory {
        /// A message associated with the package version when it was uploaded.
        public var commitMessage: Swift.String?
        /// The date and time when the package was created.
        public var createdAt: Foundation.Date?
        /// The package version.
        public var packageVersion: Swift.String?
        /// Additional information about plugin properties if the package is a ZIP-PLUGIN package.
        public var pluginProperties: OpenSearchClientTypes.PluginProperties?

        public init(
            commitMessage: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            packageVersion: Swift.String? = nil,
            pluginProperties: OpenSearchClientTypes.PluginProperties? = nil
        )
        {
            self.commitMessage = commitMessage
            self.createdAt = createdAt
            self.packageVersion = packageVersion
            self.pluginProperties = pluginProperties
        }
    }

}

/// Container for response returned by GetPackageVersionHistory operation.
public struct GetPackageVersionHistoryOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// The unique identifier of the package.
    public var packageID: Swift.String?
    /// A list of package versions, along with their creation time and commit message.
    public var packageVersionHistoryList: [OpenSearchClientTypes.PackageVersionHistory]?

    public init(
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil,
        packageVersionHistoryList: [OpenSearchClientTypes.PackageVersionHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageID = packageID
        self.packageVersionHistoryList = packageVersionHistoryList
    }
}

/// Container for the request parameters to the GetUpgradeHistory operation.
public struct GetUpgradeHistoryInput {
    /// The name of an existing domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial GetUpgradeHistory operation returns a nextToken, you can include the returned nextToken in subsequent GetUpgradeHistory operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OpenSearchClientTypes {

    public enum UpgradeStep: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case preUpgradeCheck
        case snapshot
        case upgrade
        case sdkUnknown(Swift.String)

        public static var allCases: [UpgradeStep] {
            return [
                .preUpgradeCheck,
                .snapshot,
                .upgrade
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .preUpgradeCheck: return "PRE_UPGRADE_CHECK"
            case .snapshot: return "SNAPSHOT"
            case .upgrade: return "UPGRADE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {

    public enum UpgradeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case succeededWithIssues
        case sdkUnknown(Swift.String)

        public static var allCases: [UpgradeStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .succeededWithIssues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case .succeededWithIssues: return "SUCCEEDED_WITH_ISSUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Represents a single step of an upgrade or upgrade eligibility check workflow.
    public struct UpgradeStepItem {
        /// A list of strings containing detailed information about the errors encountered in a particular step.
        public var issues: [Swift.String]?
        /// The floating point value representing the progress percentage of a particular step.
        public var progressPercent: Swift.Double?
        /// One of three steps that an upgrade or upgrade eligibility check goes through:
        ///
        /// * PreUpgradeCheck
        ///
        /// * Snapshot
        ///
        /// * Upgrade
        public var upgradeStep: OpenSearchClientTypes.UpgradeStep?
        /// The current status of the upgrade. The status can take one of the following values:
        ///
        /// * In Progress
        ///
        /// * Succeeded
        ///
        /// * Succeeded with Issues
        ///
        /// * Failed
        public var upgradeStepStatus: OpenSearchClientTypes.UpgradeStatus?

        public init(
            issues: [Swift.String]? = nil,
            progressPercent: Swift.Double? = nil,
            upgradeStep: OpenSearchClientTypes.UpgradeStep? = nil,
            upgradeStepStatus: OpenSearchClientTypes.UpgradeStatus? = nil
        )
        {
            self.issues = issues
            self.progressPercent = progressPercent
            self.upgradeStep = upgradeStep
            self.upgradeStepStatus = upgradeStepStatus
        }
    }

}

extension OpenSearchClientTypes {
    /// History of the last 10 upgrades and upgrade eligibility checks for an Amazon OpenSearch Service domain.
    public struct UpgradeHistory {
        /// UTC timestamp at which the upgrade API call was made, in the format yyyy-MM-ddTHH:mm:ssZ.
        public var startTimestamp: Foundation.Date?
        /// A list of each step performed as part of a specific upgrade or upgrade eligibility check.
        public var stepsList: [OpenSearchClientTypes.UpgradeStepItem]?
        /// A string that describes the upgrade.
        public var upgradeName: Swift.String?
        /// The current status of the upgrade. The status can take one of the following values:
        ///
        /// * In Progress
        ///
        /// * Succeeded
        ///
        /// * Succeeded with Issues
        ///
        /// * Failed
        public var upgradeStatus: OpenSearchClientTypes.UpgradeStatus?

        public init(
            startTimestamp: Foundation.Date? = nil,
            stepsList: [OpenSearchClientTypes.UpgradeStepItem]? = nil,
            upgradeName: Swift.String? = nil,
            upgradeStatus: OpenSearchClientTypes.UpgradeStatus? = nil
        )
        {
            self.startTimestamp = startTimestamp
            self.stepsList = stepsList
            self.upgradeName = upgradeName
            self.upgradeStatus = upgradeStatus
        }
    }

}

/// Container for the response returned by the GetUpgradeHistory operation.
public struct GetUpgradeHistoryOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// A list of objects corresponding to each upgrade or upgrade eligibility check performed on a domain.
    public var upgradeHistories: [OpenSearchClientTypes.UpgradeHistory]?

    public init(
        nextToken: Swift.String? = nil,
        upgradeHistories: [OpenSearchClientTypes.UpgradeHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.upgradeHistories = upgradeHistories
    }
}

/// Container for the request parameters to the GetUpgradeStatus operation.
public struct GetUpgradeStatusInput {
    /// The domain of the domain to get upgrade status information for.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

/// Container for the response returned by the GetUpgradeStatus operation.
public struct GetUpgradeStatusOutput {
    /// The status of the current step that an upgrade is on.
    public var stepStatus: OpenSearchClientTypes.UpgradeStatus?
    /// A string that describes the update.
    public var upgradeName: Swift.String?
    /// One of three steps that an upgrade or upgrade eligibility check goes through.
    public var upgradeStep: OpenSearchClientTypes.UpgradeStep?

    public init(
        stepStatus: OpenSearchClientTypes.UpgradeStatus? = nil,
        upgradeName: Swift.String? = nil,
        upgradeStep: OpenSearchClientTypes.UpgradeStep? = nil
    )
    {
        self.stepStatus = stepStatus
        self.upgradeName = upgradeName
        self.upgradeStep = upgradeStep
    }
}

/// Container for the parameters to the ListDataSources operation.
public struct ListDataSourcesInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

extension OpenSearchClientTypes {
    /// Details about a direct-query data source.
    public struct DataSourceDetails {
        /// The type of data source.
        public var dataSourceType: OpenSearchClientTypes.DataSourceType?
        /// A description of the data source.
        public var description: Swift.String?
        /// The name of the data source.
        public var name: Swift.String?
        /// The status of the data source.
        public var status: OpenSearchClientTypes.DataSourceStatus?

        public init(
            dataSourceType: OpenSearchClientTypes.DataSourceType? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OpenSearchClientTypes.DataSourceStatus? = nil
        )
        {
            self.dataSourceType = dataSourceType
            self.description = description
            self.name = name
            self.status = status
        }
    }

}

/// The result of a ListDataSources operation.
public struct ListDataSourcesOutput {
    /// A list of data sources associated with specified domain.
    public var dataSources: [OpenSearchClientTypes.DataSourceDetails]?

    public init(
        dataSources: [OpenSearchClientTypes.DataSourceDetails]? = nil
    )
    {
        self.dataSources = dataSources
    }
}

/// Container for the parameters to the ListDomainMaintenances operation.
public struct ListDomainMaintenancesInput {
    /// The name of the action.
    public var action: OpenSearchClientTypes.MaintenanceType?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListDomainMaintenances operation returns a nextToken, include the returned nextToken in subsequent ListDomainMaintenances operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The status of the action.
    public var status: OpenSearchClientTypes.MaintenanceStatus?

    public init(
        action: OpenSearchClientTypes.MaintenanceType? = nil,
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        status: OpenSearchClientTypes.MaintenanceStatus? = nil
    )
    {
        self.action = action
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension OpenSearchClientTypes {
    /// Container for the domain maintenance details.
    public struct DomainMaintenanceDetails {
        /// The name of the action.
        public var action: OpenSearchClientTypes.MaintenanceType?
        /// The time at which the action was created.
        public var createdAt: Foundation.Date?
        /// The name of the domain.
        public var domainName: Swift.String?
        /// The ID of the requested action.
        public var maintenanceId: Swift.String?
        /// The ID of the data node.
        public var nodeId: Swift.String?
        /// The status of the action.
        public var status: OpenSearchClientTypes.MaintenanceStatus?
        /// The status message for the action.
        public var statusMessage: Swift.String?
        /// The time at which the action was updated.
        public var updatedAt: Foundation.Date?

        public init(
            action: OpenSearchClientTypes.MaintenanceType? = nil,
            createdAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            maintenanceId: Swift.String? = nil,
            nodeId: Swift.String? = nil,
            status: OpenSearchClientTypes.MaintenanceStatus? = nil,
            statusMessage: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.action = action
            self.createdAt = createdAt
            self.domainName = domainName
            self.maintenanceId = maintenanceId
            self.nodeId = nodeId
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }
    }

}

/// The result of a ListDomainMaintenances request that contains information about the requested actions.
public struct ListDomainMaintenancesOutput {
    /// A list of the submitted maintenance actions.
    public var domainMaintenances: [OpenSearchClientTypes.DomainMaintenanceDetails]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        domainMaintenances: [OpenSearchClientTypes.DomainMaintenanceDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainMaintenances = domainMaintenances
        self.nextToken = nextToken
    }
}

extension OpenSearchClientTypes {

    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case elasticsearch
        case opensearch
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .elasticsearch,
                .opensearch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .elasticsearch: return "Elasticsearch"
            case .opensearch: return "OpenSearch"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Container for the parameters to the ListDomainNames operation.
public struct ListDomainNamesInput {
    /// Filters the output by domain engine type.
    public var engineType: OpenSearchClientTypes.EngineType?

    public init(
        engineType: OpenSearchClientTypes.EngineType? = nil
    )
    {
        self.engineType = engineType
    }
}

extension OpenSearchClientTypes {
    /// Information about an OpenSearch Service domain.
    public struct DomainInfo {
        /// Name of the domain.
        public var domainName: Swift.String?
        /// The type of search engine that the domain is running.OpenSearch for an OpenSearch engine, or Elasticsearch for a legacy Elasticsearch OSS engine.
        public var engineType: OpenSearchClientTypes.EngineType?

        public init(
            domainName: Swift.String? = nil,
            engineType: OpenSearchClientTypes.EngineType? = nil
        )
        {
            self.domainName = domainName
            self.engineType = engineType
        }
    }

}

/// The results of a ListDomainNames operation. Contains the names of all domains owned by this account and their respective engine types.
public struct ListDomainNamesOutput {
    /// The names of all OpenSearch Service domains owned by the current user and their respective engine types.
    public var domainNames: [OpenSearchClientTypes.DomainInfo]?

    public init(
        domainNames: [OpenSearchClientTypes.DomainInfo]? = nil
    )
    {
        self.domainNames = domainNames
    }
}

/// Container for the request parameters to the ListDomainsForPackage operation.
public struct ListDomainsForPackageInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListDomainsForPackage operation returns a nextToken, you can include the returned nextToken in subsequent ListDomainsForPackage operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// The unique identifier of the package for which to list associated domains.
    /// This member is required.
    public var packageID: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        packageID: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packageID = packageID
    }
}

/// Container for the response parameters to the ListDomainsForPackage operation.
public struct ListDomainsForPackageOutput {
    /// Information about all domains associated with a package.
    public var domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }
}

public struct ListInstanceTypeDetailsInput {
    /// The name of the domain.
    public var domainName: Swift.String?
    /// The version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// An optional parameter that lists information for a given instance type.
    public var instanceType: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListInstanceTypeDetails operation returns a nextToken, you can include the returned nextToken in subsequent ListInstanceTypeDetails operations, which returns results in the next page.
    public var nextToken: Swift.String?
    /// An optional parameter that specifies the Availability Zones for the domain.
    public var retrieveAZs: Swift.Bool?

    public init(
        domainName: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        retrieveAZs: Swift.Bool? = nil
    )
    {
        self.domainName = domainName
        self.engineVersion = engineVersion
        self.instanceType = instanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.retrieveAZs = retrieveAZs
    }
}

extension OpenSearchClientTypes {
    /// Lists all instance types and available features for a given OpenSearch or Elasticsearch version.
    public struct InstanceTypeDetails {
        /// Whether fine-grained access control is supported for the instance type.
        public var advancedSecurityEnabled: Swift.Bool?
        /// Whether logging is supported for the instance type.
        public var appLogsEnabled: Swift.Bool?
        /// The supported Availability Zones for the instance type.
        public var availabilityZones: [Swift.String]?
        /// Whether Amazon Cognito access is supported for the instance type.
        public var cognitoEnabled: Swift.Bool?
        /// Whether encryption at rest and node-to-node encryption are supported for the instance type.
        public var encryptionEnabled: Swift.Bool?
        /// Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.
        public var instanceRole: [Swift.String]?
        /// The instance type.
        public var instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType?
        /// Whether UltraWarm is supported for the instance type.
        public var warmEnabled: Swift.Bool?

        public init(
            advancedSecurityEnabled: Swift.Bool? = nil,
            appLogsEnabled: Swift.Bool? = nil,
            availabilityZones: [Swift.String]? = nil,
            cognitoEnabled: Swift.Bool? = nil,
            encryptionEnabled: Swift.Bool? = nil,
            instanceRole: [Swift.String]? = nil,
            instanceType: OpenSearchClientTypes.OpenSearchPartitionInstanceType? = nil,
            warmEnabled: Swift.Bool? = nil
        )
        {
            self.advancedSecurityEnabled = advancedSecurityEnabled
            self.appLogsEnabled = appLogsEnabled
            self.availabilityZones = availabilityZones
            self.cognitoEnabled = cognitoEnabled
            self.encryptionEnabled = encryptionEnabled
            self.instanceRole = instanceRole
            self.instanceType = instanceType
            self.warmEnabled = warmEnabled
        }
    }

}

public struct ListInstanceTypeDetailsOutput {
    /// Lists all supported instance types and features for the given OpenSearch or Elasticsearch version.
    public var instanceTypeDetails: [OpenSearchClientTypes.InstanceTypeDetails]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        instanceTypeDetails: [OpenSearchClientTypes.InstanceTypeDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceTypeDetails = instanceTypeDetails
        self.nextToken = nextToken
    }
}

/// Container for the request parameters to the ListPackagesForDomain operation.
public struct ListPackagesForDomainInput {
    /// The name of the domain for which you want to list associated packages.
    /// This member is required.
    public var domainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListPackagesForDomain operation returns a nextToken, you can include the returned nextToken in subsequent ListPackagesForDomain operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Container for the response parameters to the ListPackagesForDomain operation.
public struct ListPackagesForDomainOutput {
    /// List of all packages associated with a domain.
    public var domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        domainPackageDetailsList: [OpenSearchClientTypes.DomainPackageDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainPackageDetailsList = domainPackageDetailsList
        self.nextToken = nextToken
    }
}

public struct ListScheduledActionsInput {
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListScheduledActions operation returns a nextToken, you can include the returned nextToken in subsequent ListScheduledActions operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension OpenSearchClientTypes {

    public enum ScheduledBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customer
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduledBy] {
            return [
                .customer,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customer: return "CUSTOMER"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension OpenSearchClientTypes {
    /// Information about a scheduled configuration change for an OpenSearch Service domain. This actions can be a [service software update](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/service-software.html) or a [blue/green Auto-Tune enhancement](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/auto-tune.html#auto-tune-types).
    public struct ScheduledAction {
        /// Whether or not the scheduled action is cancellable.
        public var cancellable: Swift.Bool?
        /// A description of the action to be taken.
        public var description: Swift.String?
        /// The unique identifier of the scheduled action.
        /// This member is required.
        public var id: Swift.String?
        /// Whether the action is required or optional.
        public var mandatory: Swift.Bool?
        /// Whether the action was scheduled manually (CUSTOMER, or by OpenSearch Service automatically (SYSTEM).
        public var scheduledBy: OpenSearchClientTypes.ScheduledBy?
        /// The time when the change is scheduled to happen.
        /// This member is required.
        public var scheduledTime: Swift.Int?
        /// The severity of the action.
        /// This member is required.
        public var severity: OpenSearchClientTypes.ActionSeverity?
        /// The current status of the scheduled action.
        public var status: OpenSearchClientTypes.ActionStatus?
        /// The type of action that will be taken on the domain.
        /// This member is required.
        public var type: OpenSearchClientTypes.ActionType?

        public init(
            cancellable: Swift.Bool? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            mandatory: Swift.Bool? = nil,
            scheduledBy: OpenSearchClientTypes.ScheduledBy? = nil,
            scheduledTime: Swift.Int? = nil,
            severity: OpenSearchClientTypes.ActionSeverity? = nil,
            status: OpenSearchClientTypes.ActionStatus? = nil,
            type: OpenSearchClientTypes.ActionType? = nil
        )
        {
            self.cancellable = cancellable
            self.description = description
            self.id = id
            self.mandatory = mandatory
            self.scheduledBy = scheduledBy
            self.scheduledTime = scheduledTime
            self.severity = severity
            self.status = status
            self.type = type
        }
    }

}

public struct ListScheduledActionsOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// A list of actions that are scheduled for the domain.
    public var scheduledActions: [OpenSearchClientTypes.ScheduledAction]?

    public init(
        nextToken: Swift.String? = nil,
        scheduledActions: [OpenSearchClientTypes.ScheduledAction]? = nil
    )
    {
        self.nextToken = nextToken
        self.scheduledActions = scheduledActions
    }
}

/// Container for the parameters to the ListTags operation.
public struct ListTagsInput {
    /// Amazon Resource Name (ARN) for the domain to view tags for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// The results of a ListTags operation.
public struct ListTagsOutput {
    /// List of resource tags associated with the specified domain.
    public var tagList: [OpenSearchClientTypes.Tag]?

    public init(
        tagList: [OpenSearchClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

/// Container for the request parameters to the ListVersions operation.
public struct ListVersionsInput {
    /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
    public var maxResults: Swift.Int?
    /// If your initial ListVersions operation returns a nextToken, you can include the returned nextToken in subsequent ListVersions operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Container for the parameters for response received from the ListVersions operation.
public struct ListVersionsOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    public var nextToken: Swift.String?
    /// A list of all versions of OpenSearch and Elasticsearch that Amazon OpenSearch Service supports.
    public var versions: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListVpcEndpointAccessInput {
    /// The name of the OpenSearch Service domain to retrieve access information for.
    /// This member is required.
    public var domainName: Swift.String?
    /// If your initial ListVpcEndpointAccess operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpointAccess operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.nextToken = nextToken
    }
}

public struct ListVpcEndpointAccessOutput {
    /// A list of [IAM principals](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html) that can currently access the domain.
    /// This member is required.
    public var authorizedPrincipalList: [OpenSearchClientTypes.AuthorizedPrincipal]?
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    /// This member is required.
    public var nextToken: Swift.String?

    public init(
        authorizedPrincipalList: [OpenSearchClientTypes.AuthorizedPrincipal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authorizedPrincipalList = authorizedPrincipalList
        self.nextToken = nextToken
    }
}

public struct ListVpcEndpointsInput {
    /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

public struct ListVpcEndpointsOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    /// This member is required.
    public var nextToken: Swift.String?
    /// Information about each endpoint.
    /// This member is required.
    public var vpcEndpointSummaryList: [OpenSearchClientTypes.VpcEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vpcEndpointSummaryList: [OpenSearchClientTypes.VpcEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcEndpointSummaryList = vpcEndpointSummaryList
    }
}

public struct ListVpcEndpointsForDomainInput {
    /// The name of the domain to list associated VPC endpoints for.
    /// This member is required.
    public var domainName: Swift.String?
    /// If your initial ListEndpointsForDomain operation returns a nextToken, you can include the returned nextToken in subsequent ListEndpointsForDomain operations, which returns results in the next page.
    public var nextToken: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.nextToken = nextToken
    }
}

public struct ListVpcEndpointsForDomainOutput {
    /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
    /// This member is required.
    public var nextToken: Swift.String?
    /// Information about each endpoint associated with the domain.
    /// This member is required.
    public var vpcEndpointSummaryList: [OpenSearchClientTypes.VpcEndpointSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vpcEndpointSummaryList: [OpenSearchClientTypes.VpcEndpointSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcEndpointSummaryList = vpcEndpointSummaryList
    }
}

/// Container for request parameters to the PurchaseReservedInstanceOffering operation.
public struct PurchaseReservedInstanceOfferingInput {
    /// The number of OpenSearch instances to reserve.
    public var instanceCount: Swift.Int?
    /// A customer-specified identifier to track this reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The ID of the Reserved Instance offering to purchase.
    /// This member is required.
    public var reservedInstanceOfferingId: Swift.String?

    public init(
        instanceCount: Swift.Int? = nil,
        reservationName: Swift.String? = nil,
        reservedInstanceOfferingId: Swift.String? = nil
    )
    {
        self.instanceCount = instanceCount
        self.reservationName = reservationName
        self.reservedInstanceOfferingId = reservedInstanceOfferingId
    }
}

/// Represents the output of a PurchaseReservedInstanceOffering operation.
public struct PurchaseReservedInstanceOfferingOutput {
    /// The customer-specified identifier used to track this reservation.
    public var reservationName: Swift.String?
    /// The ID of the Reserved Instance offering that was purchased.
    public var reservedInstanceId: Swift.String?

    public init(
        reservationName: Swift.String? = nil,
        reservedInstanceId: Swift.String? = nil
    )
    {
        self.reservationName = reservationName
        self.reservedInstanceId = reservedInstanceId
    }
}

/// Container for the request parameters to the RejectInboundConnection operation.
public struct RejectInboundConnectionInput {
    /// The unique identifier of the inbound connection to reject.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

/// Represents the output of a RejectInboundConnection operation.
public struct RejectInboundConnectionOutput {
    /// Contains details about the rejected inbound connection.
    public var connection: OpenSearchClientTypes.InboundConnection?

    public init(
        connection: OpenSearchClientTypes.InboundConnection? = nil
    )
    {
        self.connection = connection
    }
}

/// Container for the request parameters to the RemoveTags operation.
public struct RemoveTagsInput {
    /// The Amazon Resource Name (ARN) of the domain from which you want to delete the specified tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of tag keys to remove from the domain.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

public struct RevokeVpcEndpointAccessInput {
    /// The account ID to revoke access from.
    /// This member is required.
    public var account: Swift.String?
    /// The name of the OpenSearch Service domain.
    /// This member is required.
    public var domainName: Swift.String?

    public init(
        account: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.account = account
        self.domainName = domainName
    }
}

public struct RevokeVpcEndpointAccessOutput {

    public init() { }
}

/// Container for the parameters to the StartDomainMaintenance operation.
public struct StartDomainMaintenanceInput {
    /// The name of the action.
    /// This member is required.
    public var action: OpenSearchClientTypes.MaintenanceType?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The ID of the data node.
    public var nodeId: Swift.String?

    public init(
        action: OpenSearchClientTypes.MaintenanceType? = nil,
        domainName: Swift.String? = nil,
        nodeId: Swift.String? = nil
    )
    {
        self.action = action
        self.domainName = domainName
        self.nodeId = nodeId
    }
}

/// The result of a StartDomainMaintenance request that information about the requested action.
public struct StartDomainMaintenanceOutput {
    /// The request ID of requested action.
    public var maintenanceId: Swift.String?

    public init(
        maintenanceId: Swift.String? = nil
    )
    {
        self.maintenanceId = maintenanceId
    }
}

extension OpenSearchClientTypes {

    public enum ScheduleAt: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case now
        case offPeakWindow
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleAt] {
            return [
                .now,
                .offPeakWindow,
                .timestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .now: return "NOW"
            case .offPeakWindow: return "OFF_PEAK_WINDOW"
            case .timestamp: return "TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Container for the request parameters to the StartServiceSoftwareUpdate operation.
public struct StartServiceSoftwareUpdateInput {
    /// The Epoch timestamp when you want the service software update to start. You only need to specify this parameter if you set ScheduleAt to TIMESTAMP.
    public var desiredStartTime: Swift.Int?
    /// The name of the domain that you want to update to the latest service software.
    /// This member is required.
    public var domainName: Swift.String?
    /// When to start the service software update.
    ///
    /// * NOW - Immediately schedules the update to happen in the current hour if there's capacity available.
    ///
    /// * TIMESTAMP - Lets you specify a custom date and time to apply the update. If you specify this value, you must also provide a value for DesiredStartTime.
    ///
    /// * OFF_PEAK_WINDOW - Marks the update to be picked up during an upcoming off-peak window. There's no guarantee that the update will happen during the next immediate window. Depending on capacity, it might happen in subsequent days.
    ///
    ///
    /// Default: NOW if you don't specify a value for DesiredStartTime, and TIMESTAMP if you do.
    public var scheduleAt: OpenSearchClientTypes.ScheduleAt?

    public init(
        desiredStartTime: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        scheduleAt: OpenSearchClientTypes.ScheduleAt? = nil
    )
    {
        self.desiredStartTime = desiredStartTime
        self.domainName = domainName
        self.scheduleAt = scheduleAt
    }
}

/// Represents the output of a StartServiceSoftwareUpdate operation. Contains the status of the update.
public struct StartServiceSoftwareUpdateOutput {
    /// The current status of the OpenSearch Service software update.
    public var serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions?

    public init(
        serviceSoftwareOptions: OpenSearchClientTypes.ServiceSoftwareOptions? = nil
    )
    {
        self.serviceSoftwareOptions = serviceSoftwareOptions
    }
}

/// Container for the parameters to the UpdateDataSource operation.
public struct UpdateDataSourceInput {
    /// The type of data source.
    /// This member is required.
    public var dataSourceType: OpenSearchClientTypes.DataSourceType?
    /// A new description of the data source.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The name of the data source to modify.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the data source update.
    public var status: OpenSearchClientTypes.DataSourceStatus?

    public init(
        dataSourceType: OpenSearchClientTypes.DataSourceType? = nil,
        description: Swift.String? = nil,
        domainName: Swift.String? = nil,
        name: Swift.String? = nil,
        status: OpenSearchClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.description = description
        self.domainName = domainName
        self.name = name
        self.status = status
    }
}

/// The result of an UpdateDataSource operation.
public struct UpdateDataSourceOutput {
    /// A message associated with the updated data source.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

extension OpenSearchClientTypes {

    public enum DryRunMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case verbose
        case sdkUnknown(Swift.String)

        public static var allCases: [DryRunMode] {
            return [
                .basic,
                .verbose
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "Basic"
            case .verbose: return "Verbose"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Container for the request parameters to the UpdateDomain operation.
public struct UpdateDomainConfigInput {
    /// Identity and Access Management (IAM) access policy as a JSON-formatted string.
    public var accessPolicies: Swift.String?
    /// Key-value pairs to specify advanced configuration options. The following key-value pairs are supported:
    ///
    /// * "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.
    ///
    /// * "indices.fielddata.cache.size": "80"  - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.
    ///
    /// * "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.
    ///
    ///
    /// For more information, see [Advanced cluster parameters](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/createupdatedomains.html#createdomain-configure-advanced-options).
    public var advancedOptions: [Swift.String: Swift.String]?
    /// Options for fine-grained access control.
    public var advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput?
    /// Options for all machine learning features for the specified domain.
    public var aimlOptions: OpenSearchClientTypes.AIMLOptionsInput?
    /// Options for Auto-Tune.
    public var autoTuneOptions: OpenSearchClientTypes.AutoTuneOptions?
    /// Changes that you want to make to the cluster configuration, such as the instance type and number of EC2 instances.
    public var clusterConfig: OpenSearchClientTypes.ClusterConfig?
    /// Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.
    public var cognitoOptions: OpenSearchClientTypes.CognitoOptions?
    /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
    public var domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions?
    /// The name of the domain that you're updating.
    /// This member is required.
    public var domainName: Swift.String?
    /// This flag, when set to True, specifies whether the UpdateDomain request should return the results of a dry run analysis without actually applying the change. A dry run determines what type of deployment the update will cause.
    public var dryRun: Swift.Bool?
    /// The type of dry run to perform.
    ///
    /// * Basic only returns the type of deployment (blue/green or dynamic) that the update will cause.
    ///
    /// * Verbose runs an additional check to validate the changes you're making. For more information, see [Validating a domain update](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-configuration-changes#validation-check).
    public var dryRunMode: OpenSearchClientTypes.DryRunMode?
    /// The type and size of the EBS volume to attach to instances in the domain.
    public var ebsOptions: OpenSearchClientTypes.EBSOptions?
    /// Encryption at rest options for the domain.
    public var encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions?
    /// Specify either dual stack or IPv4 as your IP address type. Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option. If your IP address type is currently set to dual stack, you can't change it.
    public var ipAddressType: OpenSearchClientTypes.IPAddressType?
    /// Options to publish OpenSearch logs to Amazon CloudWatch Logs.
    public var logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]?
    /// Node-to-node encryption options for the domain.
    public var nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions?
    /// Off-peak window options for the domain.
    public var offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions?
    /// Option to set the time, in UTC format, for the daily automated snapshot. Default value is 0 hours.
    public var snapshotOptions: OpenSearchClientTypes.SnapshotOptions?
    /// Service software update options for the domain.
    public var softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions?
    /// Options to specify the subnets and security groups for a VPC endpoint. For more information, see [Launching your Amazon OpenSearch Service domains using a VPC](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/vpc.html).
    public var vpcOptions: OpenSearchClientTypes.VPCOptions?

    public init(
        accessPolicies: Swift.String? = nil,
        advancedOptions: [Swift.String: Swift.String]? = nil,
        advancedSecurityOptions: OpenSearchClientTypes.AdvancedSecurityOptionsInput? = nil,
        aimlOptions: OpenSearchClientTypes.AIMLOptionsInput? = nil,
        autoTuneOptions: OpenSearchClientTypes.AutoTuneOptions? = nil,
        clusterConfig: OpenSearchClientTypes.ClusterConfig? = nil,
        cognitoOptions: OpenSearchClientTypes.CognitoOptions? = nil,
        domainEndpointOptions: OpenSearchClientTypes.DomainEndpointOptions? = nil,
        domainName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        dryRunMode: OpenSearchClientTypes.DryRunMode? = nil,
        ebsOptions: OpenSearchClientTypes.EBSOptions? = nil,
        encryptionAtRestOptions: OpenSearchClientTypes.EncryptionAtRestOptions? = nil,
        ipAddressType: OpenSearchClientTypes.IPAddressType? = nil,
        logPublishingOptions: [Swift.String: OpenSearchClientTypes.LogPublishingOption]? = nil,
        nodeToNodeEncryptionOptions: OpenSearchClientTypes.NodeToNodeEncryptionOptions? = nil,
        offPeakWindowOptions: OpenSearchClientTypes.OffPeakWindowOptions? = nil,
        snapshotOptions: OpenSearchClientTypes.SnapshotOptions? = nil,
        softwareUpdateOptions: OpenSearchClientTypes.SoftwareUpdateOptions? = nil,
        vpcOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.accessPolicies = accessPolicies
        self.advancedOptions = advancedOptions
        self.advancedSecurityOptions = advancedSecurityOptions
        self.aimlOptions = aimlOptions
        self.autoTuneOptions = autoTuneOptions
        self.clusterConfig = clusterConfig
        self.cognitoOptions = cognitoOptions
        self.domainEndpointOptions = domainEndpointOptions
        self.domainName = domainName
        self.dryRun = dryRun
        self.dryRunMode = dryRunMode
        self.ebsOptions = ebsOptions
        self.encryptionAtRestOptions = encryptionAtRestOptions
        self.ipAddressType = ipAddressType
        self.logPublishingOptions = logPublishingOptions
        self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
        self.offPeakWindowOptions = offPeakWindowOptions
        self.snapshotOptions = snapshotOptions
        self.softwareUpdateOptions = softwareUpdateOptions
        self.vpcOptions = vpcOptions
    }
}

/// The results of an UpdateDomain request. Contains the status of the domain being updated.
public struct UpdateDomainConfigOutput {
    /// The status of the updated domain.
    /// This member is required.
    public var domainConfig: OpenSearchClientTypes.DomainConfig?
    /// The status of the dry run being performed on the domain, if any.
    public var dryRunProgressStatus: OpenSearchClientTypes.DryRunProgressStatus?
    /// Results of the dry run performed in the update domain request.
    public var dryRunResults: OpenSearchClientTypes.DryRunResults?

    public init(
        domainConfig: OpenSearchClientTypes.DomainConfig? = nil,
        dryRunProgressStatus: OpenSearchClientTypes.DryRunProgressStatus? = nil,
        dryRunResults: OpenSearchClientTypes.DryRunResults? = nil
    )
    {
        self.domainConfig = domainConfig
        self.dryRunProgressStatus = dryRunProgressStatus
        self.dryRunResults = dryRunResults
    }
}

/// Container for request parameters to the UpdatePackage operation.
public struct UpdatePackageInput {
    /// Commit message for the updated file, which is shown as part of GetPackageVersionHistoryResponse.
    public var commitMessage: Swift.String?
    /// A new description of the package.
    public var packageDescription: Swift.String?
    /// The unique identifier for the package.
    /// This member is required.
    public var packageID: Swift.String?
    /// Amazon S3 bucket and key for the package.
    /// This member is required.
    public var packageSource: OpenSearchClientTypes.PackageSource?

    public init(
        commitMessage: Swift.String? = nil,
        packageDescription: Swift.String? = nil,
        packageID: Swift.String? = nil,
        packageSource: OpenSearchClientTypes.PackageSource? = nil
    )
    {
        self.commitMessage = commitMessage
        self.packageDescription = packageDescription
        self.packageID = packageID
        self.packageSource = packageSource
    }
}

/// Container for the response returned by the UpdatePackage operation.
public struct UpdatePackageOutput {
    /// Information about a package.
    public var packageDetails: OpenSearchClientTypes.PackageDetails?

    public init(
        packageDetails: OpenSearchClientTypes.PackageDetails? = nil
    )
    {
        self.packageDetails = packageDetails
    }
}

/// An exception for attempting to schedule a domain action during an unavailable time slot.
public struct SlotNotAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A description of the error.
        public internal(set) var message: Swift.String? = nil
        /// Alternate time slots during which OpenSearch Service has available capacity to schedule a domain action.
        public internal(set) var slotSuggestions: [Swift.Int]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SlotNotAvailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        slotSuggestions: [Swift.Int]? = nil
    )
    {
        self.properties.message = message
        self.properties.slotSuggestions = slotSuggestions
    }
}

public struct UpdateScheduledActionInput {
    /// The unique identifier of the action to reschedule. To retrieve this ID, send a [ListScheduledActions](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_ListScheduledActions.html) request.
    /// This member is required.
    public var actionID: Swift.String?
    /// The type of action to reschedule. Can be one of SERVICE_SOFTWARE_UPDATE, JVM_HEAP_SIZE_TUNING, or JVM_YOUNG_GEN_TUNING. To retrieve this value, send a [ListScheduledActions](https://docs.aws.amazon.com/opensearch-service/latest/APIReference/API_ListScheduledActions.html) request.
    /// This member is required.
    public var actionType: OpenSearchClientTypes.ActionType?
    /// The time to implement the change, in Coordinated Universal Time (UTC). Only specify this parameter if you set ScheduleAt to TIMESTAMP.
    public var desiredStartTime: Swift.Int?
    /// The name of the domain to reschedule an action for.
    /// This member is required.
    public var domainName: Swift.String?
    /// When to schedule the action.
    ///
    /// * NOW - Immediately schedules the update to happen in the current hour if there's capacity available.
    ///
    /// * TIMESTAMP - Lets you specify a custom date and time to apply the update. If you specify this value, you must also provide a value for DesiredStartTime.
    ///
    /// * OFF_PEAK_WINDOW - Marks the action to be picked up during an upcoming off-peak window. There's no guarantee that the change will be implemented during the next immediate window. Depending on capacity, it might happen in subsequent days.
    /// This member is required.
    public var scheduleAt: OpenSearchClientTypes.ScheduleAt?

    public init(
        actionID: Swift.String? = nil,
        actionType: OpenSearchClientTypes.ActionType? = nil,
        desiredStartTime: Swift.Int? = nil,
        domainName: Swift.String? = nil,
        scheduleAt: OpenSearchClientTypes.ScheduleAt? = nil
    )
    {
        self.actionID = actionID
        self.actionType = actionType
        self.desiredStartTime = desiredStartTime
        self.domainName = domainName
        self.scheduleAt = scheduleAt
    }
}

public struct UpdateScheduledActionOutput {
    /// Information about the rescheduled action.
    public var scheduledAction: OpenSearchClientTypes.ScheduledAction?

    public init(
        scheduledAction: OpenSearchClientTypes.ScheduledAction? = nil
    )
    {
        self.scheduledAction = scheduledAction
    }
}

public struct UpdateVpcEndpointInput {
    /// The unique identifier of the endpoint.
    /// This member is required.
    public var vpcEndpointId: Swift.String?
    /// The security groups and/or subnets to add, remove, or modify.
    /// This member is required.
    public var vpcOptions: OpenSearchClientTypes.VPCOptions?

    public init(
        vpcEndpointId: Swift.String? = nil,
        vpcOptions: OpenSearchClientTypes.VPCOptions? = nil
    )
    {
        self.vpcEndpointId = vpcEndpointId
        self.vpcOptions = vpcOptions
    }
}

public struct UpdateVpcEndpointOutput {
    /// The endpoint to be updated.
    /// This member is required.
    public var vpcEndpoint: OpenSearchClientTypes.VpcEndpoint?

    public init(
        vpcEndpoint: OpenSearchClientTypes.VpcEndpoint? = nil
    )
    {
        self.vpcEndpoint = vpcEndpoint
    }
}

/// Container for the request parameters to the UpgradeDomain operation.
public struct UpgradeDomainInput {
    /// Only supports the override_main_response_version parameter and not other advanced options. You can only include this option when upgrading to an OpenSearch version. Specifies whether the domain reports its version as 7.10 so that it continues to work with Elasticsearch OSS clients and plugins.
    public var advancedOptions: [Swift.String: Swift.String]?
    /// Name of the OpenSearch Service domain that you want to upgrade.
    /// This member is required.
    public var domainName: Swift.String?
    /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
    public var performCheckOnly: Swift.Bool?
    /// OpenSearch or Elasticsearch version to which you want to upgrade, in the format Opensearch_X.Y or Elasticsearch_X.Y.
    /// This member is required.
    public var targetVersion: Swift.String?

    public init(
        advancedOptions: [Swift.String: Swift.String]? = nil,
        domainName: Swift.String? = nil,
        performCheckOnly: Swift.Bool? = nil,
        targetVersion: Swift.String? = nil
    )
    {
        self.advancedOptions = advancedOptions
        self.domainName = domainName
        self.performCheckOnly = performCheckOnly
        self.targetVersion = targetVersion
    }
}

/// Container for the response returned by UpgradeDomain operation.
public struct UpgradeDomainOutput {
    /// The advanced options configuration for the domain.
    public var advancedOptions: [Swift.String: Swift.String]?
    /// Container for information about a configuration change happening on a domain.
    public var changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails?
    /// The name of the domain that was upgraded.
    public var domainName: Swift.String?
    /// When true, indicates that an upgrade eligibility check was performed.
    public var performCheckOnly: Swift.Bool?
    /// OpenSearch or Elasticsearch version that the domain was upgraded to.
    public var targetVersion: Swift.String?
    /// The unique identifier of the domain upgrade.
    public var upgradeId: Swift.String?

    public init(
        advancedOptions: [Swift.String: Swift.String]? = nil,
        changeProgressDetails: OpenSearchClientTypes.ChangeProgressDetails? = nil,
        domainName: Swift.String? = nil,
        performCheckOnly: Swift.Bool? = nil,
        targetVersion: Swift.String? = nil,
        upgradeId: Swift.String? = nil
    )
    {
        self.advancedOptions = advancedOptions
        self.changeProgressDetails = changeProgressDetails
        self.domainName = domainName
        self.performCheckOnly = performCheckOnly
        self.targetVersion = targetVersion
        self.upgradeId = upgradeId
    }
}

extension AcceptInboundConnectionInput {

    static func urlPathProvider(_ value: AcceptInboundConnectionInput) -> Swift.String? {
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())/accept"
    }
}

extension AddDataSourceInput {

    static func urlPathProvider(_ value: AddDataSourceInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dataSource"
    }
}

extension AddTagsInput {

    static func urlPathProvider(_ value: AddTagsInput) -> Swift.String? {
        return "/2021-01-01/tags"
    }
}

extension AssociatePackageInput {

    static func urlPathProvider(_ value: AssociatePackageInput) -> Swift.String? {
        guard let packageID = value.packageID else {
            return nil
        }
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/packages/associate/\(packageID.urlPercentEncoding())/\(domainName.urlPercentEncoding())"
    }
}

extension AuthorizeVpcEndpointAccessInput {

    static func urlPathProvider(_ value: AuthorizeVpcEndpointAccessInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/authorizeVpcEndpointAccess"
    }
}

extension CancelDomainConfigChangeInput {

    static func urlPathProvider(_ value: CancelDomainConfigChangeInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/config/cancel"
    }
}

extension CancelServiceSoftwareUpdateInput {

    static func urlPathProvider(_ value: CancelServiceSoftwareUpdateInput) -> Swift.String? {
        return "/2021-01-01/opensearch/serviceSoftwareUpdate/cancel"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/2021-01-01/opensearch/domain"
    }
}

extension CreateOutboundConnectionInput {

    static func urlPathProvider(_ value: CreateOutboundConnectionInput) -> Swift.String? {
        return "/2021-01-01/opensearch/cc/outboundConnection"
    }
}

extension CreatePackageInput {

    static func urlPathProvider(_ value: CreatePackageInput) -> Swift.String? {
        return "/2021-01-01/packages"
    }
}

extension CreateVpcEndpointInput {

    static func urlPathProvider(_ value: CreateVpcEndpointInput) -> Swift.String? {
        return "/2021-01-01/opensearch/vpcEndpoints"
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dataSource/\(name.urlPercentEncoding())"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())"
    }
}

extension DeleteInboundConnectionInput {

    static func urlPathProvider(_ value: DeleteInboundConnectionInput) -> Swift.String? {
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())"
    }
}

extension DeleteOutboundConnectionInput {

    static func urlPathProvider(_ value: DeleteOutboundConnectionInput) -> Swift.String? {
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/outboundConnection/\(connectionId.urlPercentEncoding())"
    }
}

extension DeletePackageInput {

    static func urlPathProvider(_ value: DeletePackageInput) -> Swift.String? {
        guard let packageID = value.packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())"
    }
}

extension DeleteVpcEndpointInput {

    static func urlPathProvider(_ value: DeleteVpcEndpointInput) -> Swift.String? {
        guard let vpcEndpointId = value.vpcEndpointId else {
            return nil
        }
        return "/2021-01-01/opensearch/vpcEndpoints/\(vpcEndpointId.urlPercentEncoding())"
    }
}

extension DescribeDomainInput {

    static func urlPathProvider(_ value: DescribeDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())"
    }
}

extension DescribeDomainAutoTunesInput {

    static func urlPathProvider(_ value: DescribeDomainAutoTunesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/autoTunes"
    }
}

extension DescribeDomainChangeProgressInput {

    static func urlPathProvider(_ value: DescribeDomainChangeProgressInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/progress"
    }
}

extension DescribeDomainChangeProgressInput {

    static func queryItemProvider(_ value: DescribeDomainChangeProgressInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let changeId = value.changeId {
            let changeIdQueryItem = Smithy.URIQueryItem(name: "changeid".urlPercentEncoding(), value: Swift.String(changeId).urlPercentEncoding())
            items.append(changeIdQueryItem)
        }
        return items
    }
}

extension DescribeDomainConfigInput {

    static func urlPathProvider(_ value: DescribeDomainConfigInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/config"
    }
}

extension DescribeDomainHealthInput {

    static func urlPathProvider(_ value: DescribeDomainHealthInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/health"
    }
}

extension DescribeDomainNodesInput {

    static func urlPathProvider(_ value: DescribeDomainNodesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/nodes"
    }
}

extension DescribeDomainsInput {

    static func urlPathProvider(_ value: DescribeDomainsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/domain-info"
    }
}

extension DescribeDryRunProgressInput {

    static func urlPathProvider(_ value: DescribeDryRunProgressInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dryRun"
    }
}

extension DescribeDryRunProgressInput {

    static func queryItemProvider(_ value: DescribeDryRunProgressInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let dryRunId = value.dryRunId {
            let dryRunIdQueryItem = Smithy.URIQueryItem(name: "dryRunId".urlPercentEncoding(), value: Swift.String(dryRunId).urlPercentEncoding())
            items.append(dryRunIdQueryItem)
        }
        if let loadDryRunConfig = value.loadDryRunConfig {
            let loadDryRunConfigQueryItem = Smithy.URIQueryItem(name: "loadDryRunConfig".urlPercentEncoding(), value: Swift.String(loadDryRunConfig).urlPercentEncoding())
            items.append(loadDryRunConfigQueryItem)
        }
        return items
    }
}

extension DescribeInboundConnectionsInput {

    static func urlPathProvider(_ value: DescribeInboundConnectionsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/cc/inboundConnection/search"
    }
}

extension DescribeInstanceTypeLimitsInput {

    static func urlPathProvider(_ value: DescribeInstanceTypeLimitsInput) -> Swift.String? {
        guard let engineVersion = value.engineVersion else {
            return nil
        }
        guard let instanceType = value.instanceType else {
            return nil
        }
        return "/2021-01-01/opensearch/instanceTypeLimits/\(engineVersion.urlPercentEncoding())/\(instanceType.rawValue.urlPercentEncoding())"
    }
}

extension DescribeInstanceTypeLimitsInput {

    static func queryItemProvider(_ value: DescribeInstanceTypeLimitsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainName = value.domainName {
            let domainNameQueryItem = Smithy.URIQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        return items
    }
}

extension DescribeOutboundConnectionsInput {

    static func urlPathProvider(_ value: DescribeOutboundConnectionsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/cc/outboundConnection/search"
    }
}

extension DescribePackagesInput {

    static func urlPathProvider(_ value: DescribePackagesInput) -> Swift.String? {
        return "/2021-01-01/packages/describe"
    }
}

extension DescribeReservedInstanceOfferingsInput {

    static func urlPathProvider(_ value: DescribeReservedInstanceOfferingsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/reservedInstanceOfferings"
    }
}

extension DescribeReservedInstanceOfferingsInput {

    static func queryItemProvider(_ value: DescribeReservedInstanceOfferingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let reservedInstanceOfferingId = value.reservedInstanceOfferingId {
            let reservedInstanceOfferingIdQueryItem = Smithy.URIQueryItem(name: "offeringId".urlPercentEncoding(), value: Swift.String(reservedInstanceOfferingId).urlPercentEncoding())
            items.append(reservedInstanceOfferingIdQueryItem)
        }
        return items
    }
}

extension DescribeReservedInstancesInput {

    static func urlPathProvider(_ value: DescribeReservedInstancesInput) -> Swift.String? {
        return "/2021-01-01/opensearch/reservedInstances"
    }
}

extension DescribeReservedInstancesInput {

    static func queryItemProvider(_ value: DescribeReservedInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let reservedInstanceId = value.reservedInstanceId {
            let reservedInstanceIdQueryItem = Smithy.URIQueryItem(name: "reservationId".urlPercentEncoding(), value: Swift.String(reservedInstanceId).urlPercentEncoding())
            items.append(reservedInstanceIdQueryItem)
        }
        return items
    }
}

extension DescribeVpcEndpointsInput {

    static func urlPathProvider(_ value: DescribeVpcEndpointsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/vpcEndpoints/describe"
    }
}

extension DissociatePackageInput {

    static func urlPathProvider(_ value: DissociatePackageInput) -> Swift.String? {
        guard let packageID = value.packageID else {
            return nil
        }
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/packages/dissociate/\(packageID.urlPercentEncoding())/\(domainName.urlPercentEncoding())"
    }
}

extension GetCompatibleVersionsInput {

    static func urlPathProvider(_ value: GetCompatibleVersionsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/compatibleVersions"
    }
}

extension GetCompatibleVersionsInput {

    static func queryItemProvider(_ value: GetCompatibleVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let domainName = value.domainName {
            let domainNameQueryItem = Smithy.URIQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        return items
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dataSource/\(name.urlPercentEncoding())"
    }
}

extension GetDomainMaintenanceStatusInput {

    static func urlPathProvider(_ value: GetDomainMaintenanceStatusInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/domainMaintenance"
    }
}

extension GetDomainMaintenanceStatusInput {

    static func queryItemProvider(_ value: GetDomainMaintenanceStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let maintenanceId = value.maintenanceId else {
            let message = "Creating a URL Query Item failed. maintenanceId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let maintenanceIdQueryItem = Smithy.URIQueryItem(name: "maintenanceId".urlPercentEncoding(), value: Swift.String(maintenanceId).urlPercentEncoding())
        items.append(maintenanceIdQueryItem)
        return items
    }
}

extension GetPackageVersionHistoryInput {

    static func urlPathProvider(_ value: GetPackageVersionHistoryInput) -> Swift.String? {
        guard let packageID = value.packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())/history"
    }
}

extension GetPackageVersionHistoryInput {

    static func queryItemProvider(_ value: GetPackageVersionHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetUpgradeHistoryInput {

    static func urlPathProvider(_ value: GetUpgradeHistoryInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/upgradeDomain/\(domainName.urlPercentEncoding())/history"
    }
}

extension GetUpgradeHistoryInput {

    static func queryItemProvider(_ value: GetUpgradeHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetUpgradeStatusInput {

    static func urlPathProvider(_ value: GetUpgradeStatusInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/upgradeDomain/\(domainName.urlPercentEncoding())/status"
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dataSource"
    }
}

extension ListDomainMaintenancesInput {

    static func urlPathProvider(_ value: ListDomainMaintenancesInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/domainMaintenances"
    }
}

extension ListDomainMaintenancesInput {

    static func queryItemProvider(_ value: ListDomainMaintenancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let action = value.action {
            let actionQueryItem = Smithy.URIQueryItem(name: "action".urlPercentEncoding(), value: Swift.String(action.rawValue).urlPercentEncoding())
            items.append(actionQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainNamesInput {

    static func urlPathProvider(_ value: ListDomainNamesInput) -> Swift.String? {
        return "/2021-01-01/domain"
    }
}

extension ListDomainNamesInput {

    static func queryItemProvider(_ value: ListDomainNamesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let engineType = value.engineType {
            let engineTypeQueryItem = Smithy.URIQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension ListDomainsForPackageInput {

    static func urlPathProvider(_ value: ListDomainsForPackageInput) -> Swift.String? {
        guard let packageID = value.packageID else {
            return nil
        }
        return "/2021-01-01/packages/\(packageID.urlPercentEncoding())/domains"
    }
}

extension ListDomainsForPackageInput {

    static func queryItemProvider(_ value: ListDomainsForPackageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstanceTypeDetailsInput {

    static func urlPathProvider(_ value: ListInstanceTypeDetailsInput) -> Swift.String? {
        guard let engineVersion = value.engineVersion else {
            return nil
        }
        return "/2021-01-01/opensearch/instanceTypeDetails/\(engineVersion.urlPercentEncoding())"
    }
}

extension ListInstanceTypeDetailsInput {

    static func queryItemProvider(_ value: ListInstanceTypeDetailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let domainName = value.domainName {
            let domainNameQueryItem = Smithy.URIQueryItem(name: "domainName".urlPercentEncoding(), value: Swift.String(domainName).urlPercentEncoding())
            items.append(domainNameQueryItem)
        }
        if let retrieveAZs = value.retrieveAZs {
            let retrieveAZsQueryItem = Smithy.URIQueryItem(name: "retrieveAZs".urlPercentEncoding(), value: Swift.String(retrieveAZs).urlPercentEncoding())
            items.append(retrieveAZsQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let instanceType = value.instanceType {
            let instanceTypeQueryItem = Smithy.URIQueryItem(name: "instanceType".urlPercentEncoding(), value: Swift.String(instanceType).urlPercentEncoding())
            items.append(instanceTypeQueryItem)
        }
        return items
    }
}

extension ListPackagesForDomainInput {

    static func urlPathProvider(_ value: ListPackagesForDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/domain/\(domainName.urlPercentEncoding())/packages"
    }
}

extension ListPackagesForDomainInput {

    static func queryItemProvider(_ value: ListPackagesForDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListScheduledActionsInput {

    static func urlPathProvider(_ value: ListScheduledActionsInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/scheduledActions"
    }
}

extension ListScheduledActionsInput {

    static func queryItemProvider(_ value: ListScheduledActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsInput {

    static func urlPathProvider(_ value: ListTagsInput) -> Swift.String? {
        return "/2021-01-01/tags"
    }
}

extension ListTagsInput {

    static func queryItemProvider(_ value: ListTagsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let arn = value.arn else {
            let message = "Creating a URL Query Item failed. arn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let arnQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(arn).urlPercentEncoding())
        items.append(arnQueryItem)
        return items
    }
}

extension ListVersionsInput {

    static func urlPathProvider(_ value: ListVersionsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/versions"
    }
}

extension ListVersionsInput {

    static func queryItemProvider(_ value: ListVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVpcEndpointAccessInput {

    static func urlPathProvider(_ value: ListVpcEndpointAccessInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/listVpcEndpointAccess"
    }
}

extension ListVpcEndpointAccessInput {

    static func queryItemProvider(_ value: ListVpcEndpointAccessInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListVpcEndpointsInput {

    static func urlPathProvider(_ value: ListVpcEndpointsInput) -> Swift.String? {
        return "/2021-01-01/opensearch/vpcEndpoints"
    }
}

extension ListVpcEndpointsInput {

    static func queryItemProvider(_ value: ListVpcEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListVpcEndpointsForDomainInput {

    static func urlPathProvider(_ value: ListVpcEndpointsForDomainInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/vpcEndpoints"
    }
}

extension ListVpcEndpointsForDomainInput {

    static func queryItemProvider(_ value: ListVpcEndpointsForDomainInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension PurchaseReservedInstanceOfferingInput {

    static func urlPathProvider(_ value: PurchaseReservedInstanceOfferingInput) -> Swift.String? {
        return "/2021-01-01/opensearch/purchaseReservedInstanceOffering"
    }
}

extension RejectInboundConnectionInput {

    static func urlPathProvider(_ value: RejectInboundConnectionInput) -> Swift.String? {
        guard let connectionId = value.connectionId else {
            return nil
        }
        return "/2021-01-01/opensearch/cc/inboundConnection/\(connectionId.urlPercentEncoding())/reject"
    }
}

extension RemoveTagsInput {

    static func urlPathProvider(_ value: RemoveTagsInput) -> Swift.String? {
        return "/2021-01-01/tags-removal"
    }
}

extension RevokeVpcEndpointAccessInput {

    static func urlPathProvider(_ value: RevokeVpcEndpointAccessInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/revokeVpcEndpointAccess"
    }
}

extension StartDomainMaintenanceInput {

    static func urlPathProvider(_ value: StartDomainMaintenanceInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/domainMaintenance"
    }
}

extension StartServiceSoftwareUpdateInput {

    static func urlPathProvider(_ value: StartServiceSoftwareUpdateInput) -> Swift.String? {
        return "/2021-01-01/opensearch/serviceSoftwareUpdate/start"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/dataSource/\(name.urlPercentEncoding())"
    }
}

extension UpdateDomainConfigInput {

    static func urlPathProvider(_ value: UpdateDomainConfigInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/config"
    }
}

extension UpdatePackageInput {

    static func urlPathProvider(_ value: UpdatePackageInput) -> Swift.String? {
        return "/2021-01-01/packages/update"
    }
}

extension UpdateScheduledActionInput {

    static func urlPathProvider(_ value: UpdateScheduledActionInput) -> Swift.String? {
        guard let domainName = value.domainName else {
            return nil
        }
        return "/2021-01-01/opensearch/domain/\(domainName.urlPercentEncoding())/scheduledAction/update"
    }
}

extension UpdateVpcEndpointInput {

    static func urlPathProvider(_ value: UpdateVpcEndpointInput) -> Swift.String? {
        return "/2021-01-01/opensearch/vpcEndpoints/update"
    }
}

extension UpgradeDomainInput {

    static func urlPathProvider(_ value: UpgradeDomainInput) -> Swift.String? {
        return "/2021-01-01/opensearch/upgradeDomain"
    }
}

extension AddDataSourceInput {

    static func write(value: AddDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceType"].write(value.dataSourceType, with: OpenSearchClientTypes.DataSourceType.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension AddTagsInput {

    static func write(value: AddTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: OpenSearchClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AuthorizeVpcEndpointAccessInput {

    static func write(value: AuthorizeVpcEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Account"].write(value.account)
    }
}

extension CancelDomainConfigChangeInput {

    static func write(value: CancelDomainConfigChangeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DryRun"].write(value.dryRun)
    }
}

extension CancelServiceSoftwareUpdateInput {

    static func write(value: CancelServiceSoftwareUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AIMLOptions"].write(value.aimlOptions, with: OpenSearchClientTypes.AIMLOptionsInput.write(value:to:))
        try writer["AccessPolicies"].write(value.accessPolicies)
        try writer["AdvancedOptions"].writeMap(value.advancedOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdvancedSecurityOptions"].write(value.advancedSecurityOptions, with: OpenSearchClientTypes.AdvancedSecurityOptionsInput.write(value:to:))
        try writer["AutoTuneOptions"].write(value.autoTuneOptions, with: OpenSearchClientTypes.AutoTuneOptionsInput.write(value:to:))
        try writer["ClusterConfig"].write(value.clusterConfig, with: OpenSearchClientTypes.ClusterConfig.write(value:to:))
        try writer["CognitoOptions"].write(value.cognitoOptions, with: OpenSearchClientTypes.CognitoOptions.write(value:to:))
        try writer["DomainEndpointOptions"].write(value.domainEndpointOptions, with: OpenSearchClientTypes.DomainEndpointOptions.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["EBSOptions"].write(value.ebsOptions, with: OpenSearchClientTypes.EBSOptions.write(value:to:))
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: OpenSearchClientTypes.EncryptionAtRestOptions.write(value:to:))
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["IPAddressType"].write(value.ipAddressType)
        try writer["LogPublishingOptions"].writeMap(value.logPublishingOptions, valueWritingClosure: OpenSearchClientTypes.LogPublishingOption.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NodeToNodeEncryptionOptions"].write(value.nodeToNodeEncryptionOptions, with: OpenSearchClientTypes.NodeToNodeEncryptionOptions.write(value:to:))
        try writer["OffPeakWindowOptions"].write(value.offPeakWindowOptions, with: OpenSearchClientTypes.OffPeakWindowOptions.write(value:to:))
        try writer["SnapshotOptions"].write(value.snapshotOptions, with: OpenSearchClientTypes.SnapshotOptions.write(value:to:))
        try writer["SoftwareUpdateOptions"].write(value.softwareUpdateOptions, with: OpenSearchClientTypes.SoftwareUpdateOptions.write(value:to:))
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: OpenSearchClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCOptions"].write(value.vpcOptions, with: OpenSearchClientTypes.VPCOptions.write(value:to:))
    }
}

extension CreateOutboundConnectionInput {

    static func write(value: CreateOutboundConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionAlias"].write(value.connectionAlias)
        try writer["ConnectionMode"].write(value.connectionMode)
        try writer["ConnectionProperties"].write(value.connectionProperties, with: OpenSearchClientTypes.ConnectionProperties.write(value:to:))
        try writer["LocalDomainInfo"].write(value.localDomainInfo, with: OpenSearchClientTypes.DomainInformationContainer.write(value:to:))
        try writer["RemoteDomainInfo"].write(value.remoteDomainInfo, with: OpenSearchClientTypes.DomainInformationContainer.write(value:to:))
    }
}

extension CreatePackageInput {

    static func write(value: CreatePackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PackageDescription"].write(value.packageDescription)
        try writer["PackageName"].write(value.packageName)
        try writer["PackageSource"].write(value.packageSource, with: OpenSearchClientTypes.PackageSource.write(value:to:))
        try writer["PackageType"].write(value.packageType)
    }
}

extension CreateVpcEndpointInput {

    static func write(value: CreateVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DomainArn"].write(value.domainArn)
        try writer["VpcOptions"].write(value.vpcOptions, with: OpenSearchClientTypes.VPCOptions.write(value:to:))
    }
}

extension DescribeDomainAutoTunesInput {

    static func write(value: DescribeDomainAutoTunesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeDomainsInput {

    static func write(value: DescribeDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainNames"].writeList(value.domainNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeInboundConnectionsInput {

    static func write(value: DescribeInboundConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: OpenSearchClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeOutboundConnectionsInput {

    static func write(value: DescribeOutboundConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: OpenSearchClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribePackagesInput {

    static func write(value: DescribePackagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: OpenSearchClientTypes.DescribePackagesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeVpcEndpointsInput {

    static func write(value: DescribeVpcEndpointsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcEndpointIds"].writeList(value.vpcEndpointIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PurchaseReservedInstanceOfferingInput {

    static func write(value: PurchaseReservedInstanceOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["ReservationName"].write(value.reservationName)
        try writer["ReservedInstanceOfferingId"].write(value.reservedInstanceOfferingId)
    }
}

extension RemoveTagsInput {

    static func write(value: RemoveTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RevokeVpcEndpointAccessInput {

    static func write(value: RevokeVpcEndpointAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Account"].write(value.account)
    }
}

extension StartDomainMaintenanceInput {

    static func write(value: StartDomainMaintenanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["NodeId"].write(value.nodeId)
    }
}

extension StartServiceSoftwareUpdateInput {

    static func write(value: StartServiceSoftwareUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredStartTime"].write(value.desiredStartTime)
        try writer["DomainName"].write(value.domainName)
        try writer["ScheduleAt"].write(value.scheduleAt)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSourceType"].write(value.dataSourceType, with: OpenSearchClientTypes.DataSourceType.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Status"].write(value.status)
    }
}

extension UpdateDomainConfigInput {

    static func write(value: UpdateDomainConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AIMLOptions"].write(value.aimlOptions, with: OpenSearchClientTypes.AIMLOptionsInput.write(value:to:))
        try writer["AccessPolicies"].write(value.accessPolicies)
        try writer["AdvancedOptions"].writeMap(value.advancedOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdvancedSecurityOptions"].write(value.advancedSecurityOptions, with: OpenSearchClientTypes.AdvancedSecurityOptionsInput.write(value:to:))
        try writer["AutoTuneOptions"].write(value.autoTuneOptions, with: OpenSearchClientTypes.AutoTuneOptions.write(value:to:))
        try writer["ClusterConfig"].write(value.clusterConfig, with: OpenSearchClientTypes.ClusterConfig.write(value:to:))
        try writer["CognitoOptions"].write(value.cognitoOptions, with: OpenSearchClientTypes.CognitoOptions.write(value:to:))
        try writer["DomainEndpointOptions"].write(value.domainEndpointOptions, with: OpenSearchClientTypes.DomainEndpointOptions.write(value:to:))
        try writer["DryRun"].write(value.dryRun)
        try writer["DryRunMode"].write(value.dryRunMode)
        try writer["EBSOptions"].write(value.ebsOptions, with: OpenSearchClientTypes.EBSOptions.write(value:to:))
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: OpenSearchClientTypes.EncryptionAtRestOptions.write(value:to:))
        try writer["IPAddressType"].write(value.ipAddressType)
        try writer["LogPublishingOptions"].writeMap(value.logPublishingOptions, valueWritingClosure: OpenSearchClientTypes.LogPublishingOption.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NodeToNodeEncryptionOptions"].write(value.nodeToNodeEncryptionOptions, with: OpenSearchClientTypes.NodeToNodeEncryptionOptions.write(value:to:))
        try writer["OffPeakWindowOptions"].write(value.offPeakWindowOptions, with: OpenSearchClientTypes.OffPeakWindowOptions.write(value:to:))
        try writer["SnapshotOptions"].write(value.snapshotOptions, with: OpenSearchClientTypes.SnapshotOptions.write(value:to:))
        try writer["SoftwareUpdateOptions"].write(value.softwareUpdateOptions, with: OpenSearchClientTypes.SoftwareUpdateOptions.write(value:to:))
        try writer["VPCOptions"].write(value.vpcOptions, with: OpenSearchClientTypes.VPCOptions.write(value:to:))
    }
}

extension UpdatePackageInput {

    static func write(value: UpdatePackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommitMessage"].write(value.commitMessage)
        try writer["PackageDescription"].write(value.packageDescription)
        try writer["PackageID"].write(value.packageID)
        try writer["PackageSource"].write(value.packageSource, with: OpenSearchClientTypes.PackageSource.write(value:to:))
    }
}

extension UpdateScheduledActionInput {

    static func write(value: UpdateScheduledActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionID"].write(value.actionID)
        try writer["ActionType"].write(value.actionType)
        try writer["DesiredStartTime"].write(value.desiredStartTime)
        try writer["ScheduleAt"].write(value.scheduleAt)
    }
}

extension UpdateVpcEndpointInput {

    static func write(value: UpdateVpcEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcEndpointId"].write(value.vpcEndpointId)
        try writer["VpcOptions"].write(value.vpcOptions, with: OpenSearchClientTypes.VPCOptions.write(value:to:))
    }
}

extension UpgradeDomainInput {

    static func write(value: UpgradeDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedOptions"].writeMap(value.advancedOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DomainName"].write(value.domainName)
        try writer["PerformCheckOnly"].write(value.performCheckOnly)
        try writer["TargetVersion"].write(value.targetVersion)
    }
}

extension AcceptInboundConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptInboundConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptInboundConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: OpenSearchClientTypes.InboundConnection.read(from:))
        return value
    }
}

extension AddDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddDataSourceOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension AddTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddTagsOutput {
        return AddTagsOutput()
    }
}

extension AssociatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociatePackageOutput()
        value.domainPackageDetails = try reader["DomainPackageDetails"].readIfPresent(with: OpenSearchClientTypes.DomainPackageDetails.read(from:))
        return value
    }
}

extension AuthorizeVpcEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AuthorizeVpcEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AuthorizeVpcEndpointAccessOutput()
        value.authorizedPrincipal = try reader["AuthorizedPrincipal"].readIfPresent(with: OpenSearchClientTypes.AuthorizedPrincipal.read(from:))
        return value
    }
}

extension CancelDomainConfigChangeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelDomainConfigChangeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelDomainConfigChangeOutput()
        value.cancelledChangeIds = try reader["CancelledChangeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cancelledChangeProperties = try reader["CancelledChangeProperties"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.CancelledChangeProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dryRun = try reader["DryRun"].readIfPresent()
        return value
    }
}

extension CancelServiceSoftwareUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelServiceSoftwareUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelServiceSoftwareUpdateOutput()
        value.serviceSoftwareOptions = try reader["ServiceSoftwareOptions"].readIfPresent(with: OpenSearchClientTypes.ServiceSoftwareOptions.read(from:))
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.domainStatus = try reader["DomainStatus"].readIfPresent(with: OpenSearchClientTypes.DomainStatus.read(from:))
        return value
    }
}

extension CreateOutboundConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOutboundConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOutboundConnectionOutput()
        value.connectionAlias = try reader["ConnectionAlias"].readIfPresent()
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionMode = try reader["ConnectionMode"].readIfPresent()
        value.connectionProperties = try reader["ConnectionProperties"].readIfPresent(with: OpenSearchClientTypes.ConnectionProperties.read(from:))
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: OpenSearchClientTypes.OutboundConnectionStatus.read(from:))
        value.localDomainInfo = try reader["LocalDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        value.remoteDomainInfo = try reader["RemoteDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        return value
    }
}

extension CreatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePackageOutput()
        value.packageDetails = try reader["PackageDetails"].readIfPresent(with: OpenSearchClientTypes.PackageDetails.read(from:))
        return value
    }
}

extension CreateVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcEndpointOutput()
        value.vpcEndpoint = try reader["VpcEndpoint"].readIfPresent(with: OpenSearchClientTypes.VpcEndpoint.read(from:))
        return value
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDomainOutput()
        value.domainStatus = try reader["DomainStatus"].readIfPresent(with: OpenSearchClientTypes.DomainStatus.read(from:))
        return value
    }
}

extension DeleteInboundConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInboundConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInboundConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: OpenSearchClientTypes.InboundConnection.read(from:))
        return value
    }
}

extension DeleteOutboundConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOutboundConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOutboundConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: OpenSearchClientTypes.OutboundConnection.read(from:))
        return value
    }
}

extension DeletePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePackageOutput()
        value.packageDetails = try reader["PackageDetails"].readIfPresent(with: OpenSearchClientTypes.PackageDetails.read(from:))
        return value
    }
}

extension DeleteVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVpcEndpointOutput()
        value.vpcEndpointSummary = try reader["VpcEndpointSummary"].readIfPresent(with: OpenSearchClientTypes.VpcEndpointSummary.read(from:))
        return value
    }
}

extension DescribeDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainOutput()
        value.domainStatus = try reader["DomainStatus"].readIfPresent(with: OpenSearchClientTypes.DomainStatus.read(from:))
        return value
    }
}

extension DescribeDomainAutoTunesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainAutoTunesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainAutoTunesOutput()
        value.autoTunes = try reader["AutoTunes"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.AutoTune.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeDomainChangeProgressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainChangeProgressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainChangeProgressOutput()
        value.changeProgressStatus = try reader["ChangeProgressStatus"].readIfPresent(with: OpenSearchClientTypes.ChangeProgressStatusDetails.read(from:))
        return value
    }
}

extension DescribeDomainConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainConfigOutput()
        value.domainConfig = try reader["DomainConfig"].readIfPresent(with: OpenSearchClientTypes.DomainConfig.read(from:))
        return value
    }
}

extension DescribeDomainHealthOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainHealthOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainHealthOutput()
        value.activeAvailabilityZoneCount = try reader["ActiveAvailabilityZoneCount"].readIfPresent()
        value.availabilityZoneCount = try reader["AvailabilityZoneCount"].readIfPresent()
        value.clusterHealth = try reader["ClusterHealth"].readIfPresent()
        value.dataNodeCount = try reader["DataNodeCount"].readIfPresent()
        value.dedicatedMaster = try reader["DedicatedMaster"].readIfPresent()
        value.domainState = try reader["DomainState"].readIfPresent()
        value.environmentInformation = try reader["EnvironmentInformation"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.EnvironmentInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.masterEligibleNodeCount = try reader["MasterEligibleNodeCount"].readIfPresent()
        value.masterNode = try reader["MasterNode"].readIfPresent()
        value.standByAvailabilityZoneCount = try reader["StandByAvailabilityZoneCount"].readIfPresent()
        value.totalShards = try reader["TotalShards"].readIfPresent()
        value.totalUnAssignedShards = try reader["TotalUnAssignedShards"].readIfPresent()
        value.warmNodeCount = try reader["WarmNodeCount"].readIfPresent()
        return value
    }
}

extension DescribeDomainNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainNodesOutput()
        value.domainNodesStatusList = try reader["DomainNodesStatusList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainNodesStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainsOutput()
        value.domainStatusList = try reader["DomainStatusList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainStatus.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeDryRunProgressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDryRunProgressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDryRunProgressOutput()
        value.dryRunConfig = try reader["DryRunConfig"].readIfPresent(with: OpenSearchClientTypes.DomainStatus.read(from:))
        value.dryRunProgressStatus = try reader["DryRunProgressStatus"].readIfPresent(with: OpenSearchClientTypes.DryRunProgressStatus.read(from:))
        value.dryRunResults = try reader["DryRunResults"].readIfPresent(with: OpenSearchClientTypes.DryRunResults.read(from:))
        return value
    }
}

extension DescribeInboundConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInboundConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInboundConnectionsOutput()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.InboundConnection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeInstanceTypeLimitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceTypeLimitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceTypeLimitsOutput()
        value.limitsByRole = try reader["LimitsByRole"].readMapIfPresent(valueReadingClosure: OpenSearchClientTypes.Limits.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeOutboundConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOutboundConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOutboundConnectionsOutput()
        value.connections = try reader["Connections"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.OutboundConnection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribePackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePackagesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.packageDetailsList = try reader["PackageDetailsList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.PackageDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReservedInstanceOfferingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservedInstanceOfferingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservedInstanceOfferingsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reservedInstanceOfferings = try reader["ReservedInstanceOfferings"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ReservedInstanceOffering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReservedInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReservedInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReservedInstancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.reservedInstances = try reader["ReservedInstances"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ReservedInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeVpcEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVpcEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVpcEndpointsOutput()
        value.vpcEndpointErrors = try reader["VpcEndpointErrors"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.VpcEndpointError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcEndpoints = try reader["VpcEndpoints"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.VpcEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DissociatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DissociatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DissociatePackageOutput()
        value.domainPackageDetails = try reader["DomainPackageDetails"].readIfPresent(with: OpenSearchClientTypes.DomainPackageDetails.read(from:))
        return value
    }
}

extension GetCompatibleVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCompatibleVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCompatibleVersionsOutput()
        value.compatibleVersions = try reader["CompatibleVersions"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.CompatibleVersionsMap.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.dataSourceType = try reader["DataSourceType"].readIfPresent(with: OpenSearchClientTypes.DataSourceType.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetDomainMaintenanceStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDomainMaintenanceStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDomainMaintenanceStatusOutput()
        value.action = try reader["Action"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetPackageVersionHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPackageVersionHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPackageVersionHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.packageID = try reader["PackageID"].readIfPresent()
        value.packageVersionHistoryList = try reader["PackageVersionHistoryList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.PackageVersionHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetUpgradeHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUpgradeHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUpgradeHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.upgradeHistories = try reader["UpgradeHistories"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.UpgradeHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetUpgradeStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUpgradeStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUpgradeStatusOutput()
        value.stepStatus = try reader["StepStatus"].readIfPresent()
        value.upgradeName = try reader["UpgradeName"].readIfPresent()
        value.upgradeStep = try reader["UpgradeStep"].readIfPresent()
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSources = try reader["DataSources"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DataSourceDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDomainMaintenancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainMaintenancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainMaintenancesOutput()
        value.domainMaintenances = try reader["DomainMaintenances"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainMaintenanceDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDomainNamesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainNamesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainNamesOutput()
        value.domainNames = try reader["DomainNames"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDomainsForPackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsForPackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsForPackageOutput()
        value.domainPackageDetailsList = try reader["DomainPackageDetailsList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainPackageDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstanceTypeDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceTypeDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceTypeDetailsOutput()
        value.instanceTypeDetails = try reader["InstanceTypeDetails"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.InstanceTypeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPackagesForDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPackagesForDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPackagesForDomainOutput()
        value.domainPackageDetailsList = try reader["DomainPackageDetailsList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.DomainPackageDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListScheduledActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScheduledActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScheduledActionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.scheduledActions = try reader["ScheduledActions"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ScheduledAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVpcEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcEndpointAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcEndpointAccessOutput()
        value.authorizedPrincipalList = try reader["AuthorizedPrincipalList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.AuthorizedPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent() ?? ""
        return value
    }
}

extension ListVpcEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcEndpointsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent() ?? ""
        value.vpcEndpointSummaryList = try reader["VpcEndpointSummaryList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.VpcEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVpcEndpointsForDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcEndpointsForDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcEndpointsForDomainOutput()
        value.nextToken = try reader["NextToken"].readIfPresent() ?? ""
        value.vpcEndpointSummaryList = try reader["VpcEndpointSummaryList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.VpcEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PurchaseReservedInstanceOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PurchaseReservedInstanceOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PurchaseReservedInstanceOfferingOutput()
        value.reservationName = try reader["ReservationName"].readIfPresent()
        value.reservedInstanceId = try reader["ReservedInstanceId"].readIfPresent()
        return value
    }
}

extension RejectInboundConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectInboundConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectInboundConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: OpenSearchClientTypes.InboundConnection.read(from:))
        return value
    }
}

extension RemoveTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveTagsOutput {
        return RemoveTagsOutput()
    }
}

extension RevokeVpcEndpointAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeVpcEndpointAccessOutput {
        return RevokeVpcEndpointAccessOutput()
    }
}

extension StartDomainMaintenanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDomainMaintenanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDomainMaintenanceOutput()
        value.maintenanceId = try reader["MaintenanceId"].readIfPresent()
        return value
    }
}

extension StartServiceSoftwareUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartServiceSoftwareUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartServiceSoftwareUpdateOutput()
        value.serviceSoftwareOptions = try reader["ServiceSoftwareOptions"].readIfPresent(with: OpenSearchClientTypes.ServiceSoftwareOptions.read(from:))
        return value
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension UpdateDomainConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainConfigOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainConfigOutput()
        value.domainConfig = try reader["DomainConfig"].readIfPresent(with: OpenSearchClientTypes.DomainConfig.read(from:))
        value.dryRunProgressStatus = try reader["DryRunProgressStatus"].readIfPresent(with: OpenSearchClientTypes.DryRunProgressStatus.read(from:))
        value.dryRunResults = try reader["DryRunResults"].readIfPresent(with: OpenSearchClientTypes.DryRunResults.read(from:))
        return value
    }
}

extension UpdatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePackageOutput()
        value.packageDetails = try reader["PackageDetails"].readIfPresent(with: OpenSearchClientTypes.PackageDetails.read(from:))
        return value
    }
}

extension UpdateScheduledActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateScheduledActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateScheduledActionOutput()
        value.scheduledAction = try reader["ScheduledAction"].readIfPresent(with: OpenSearchClientTypes.ScheduledAction.read(from:))
        return value
    }
}

extension UpdateVpcEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcEndpointOutput()
        value.vpcEndpoint = try reader["VpcEndpoint"].readIfPresent(with: OpenSearchClientTypes.VpcEndpoint.read(from:))
        return value
    }
}

extension UpgradeDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpgradeDomainOutput()
        value.advancedOptions = try reader["AdvancedOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.changeProgressDetails = try reader["ChangeProgressDetails"].readIfPresent(with: OpenSearchClientTypes.ChangeProgressDetails.read(from:))
        value.domainName = try reader["DomainName"].readIfPresent()
        value.performCheckOnly = try reader["PerformCheckOnly"].readIfPresent()
        value.targetVersion = try reader["TargetVersion"].readIfPresent()
        value.upgradeId = try reader["UpgradeId"].readIfPresent()
        return value
    }
}

enum AcceptInboundConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AuthorizeVpcEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelDomainConfigChangeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelServiceSoftwareUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOutboundConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInboundConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOutboundConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainAutoTunesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainChangeProgressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainHealthOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDryRunProgressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInboundConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceTypeLimitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOutboundConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservedInstanceOfferingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReservedInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVpcEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DissociatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCompatibleVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDomainMaintenanceStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPackageVersionHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUpgradeHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUpgradeStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainMaintenancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainNamesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsForPackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceTypeDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPackagesForDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScheduledActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcEndpointsForDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PurchaseReservedInstanceOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectInboundConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeVpcEndpointAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDomainMaintenanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartServiceSoftwareUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DependencyFailureException": return try DependencyFailureException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateScheduledActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "SlotNotAvailableException": return try SlotNotAvailableException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BaseException": return try BaseException.makeError(baseError: baseError)
            case "DisabledOperationException": return try DisabledOperationException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DisabledOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DisabledOperationException {
        let reader = baseError.errorBodyReader
        var value = DisabledOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyFailureException {
        let reader = baseError.errorBodyReader
        var value = DependencyFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BaseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BaseException {
        let reader = baseError.errorBodyReader
        var value = BaseException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SlotNotAvailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SlotNotAvailableException {
        let reader = baseError.errorBodyReader
        var value = SlotNotAvailableException()
        value.properties.slotSuggestions = try reader["SlotSuggestions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OpenSearchClientTypes.InboundConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.InboundConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.InboundConnection()
        value.localDomainInfo = try reader["LocalDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        value.remoteDomainInfo = try reader["RemoteDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: OpenSearchClientTypes.InboundConnectionStatus.read(from:))
        value.connectionMode = try reader["ConnectionMode"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.InboundConnectionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.InboundConnectionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.InboundConnectionStatus()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DomainInformationContainer {

    static func write(value: OpenSearchClientTypes.DomainInformationContainer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSDomainInformation"].write(value.awsDomainInformation, with: OpenSearchClientTypes.AWSDomainInformation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainInformationContainer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainInformationContainer()
        value.awsDomainInformation = try reader["AWSDomainInformation"].readIfPresent(with: OpenSearchClientTypes.AWSDomainInformation.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AWSDomainInformation {

    static func write(value: OpenSearchClientTypes.AWSDomainInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OwnerId"].write(value.ownerId)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AWSDomainInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AWSDomainInformation()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DomainPackageDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainPackageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainPackageDetails()
        value.packageID = try reader["PackageID"].readIfPresent()
        value.packageName = try reader["PackageName"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.domainName = try reader["DomainName"].readIfPresent()
        value.domainPackageStatus = try reader["DomainPackageStatus"].readIfPresent()
        value.packageVersion = try reader["PackageVersion"].readIfPresent()
        value.referencePath = try reader["ReferencePath"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readIfPresent(with: OpenSearchClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ErrorDetails()
        value.errorType = try reader["ErrorType"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AuthorizedPrincipal {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AuthorizedPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AuthorizedPrincipal()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        value.principal = try reader["Principal"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.CancelledChangeProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.CancelledChangeProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.CancelledChangeProperty()
        value.propertyName = try reader["PropertyName"].readIfPresent()
        value.cancelledValue = try reader["CancelledValue"].readIfPresent()
        value.activeValue = try reader["ActiveValue"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ServiceSoftwareOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ServiceSoftwareOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ServiceSoftwareOptions()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent()
        value.newVersion = try reader["NewVersion"].readIfPresent()
        value.updateAvailable = try reader["UpdateAvailable"].readIfPresent()
        value.cancellable = try reader["Cancellable"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.automatedUpdateDate = try reader["AutomatedUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.optionalDeployment = try reader["OptionalDeployment"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DomainStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainStatus()
        value.domainId = try reader["DomainId"].readIfPresent() ?? ""
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.arn = try reader["ARN"].readIfPresent() ?? ""
        value.created = try reader["Created"].readIfPresent()
        value.deleted = try reader["Deleted"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.endpointV2 = try reader["EndpointV2"].readIfPresent()
        value.endpoints = try reader["Endpoints"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.domainEndpointV2HostedZoneId = try reader["DomainEndpointV2HostedZoneId"].readIfPresent()
        value.processing = try reader["Processing"].readIfPresent()
        value.upgradeProcessing = try reader["UpgradeProcessing"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.clusterConfig = try reader["ClusterConfig"].readIfPresent(with: OpenSearchClientTypes.ClusterConfig.read(from:))
        value.ebsOptions = try reader["EBSOptions"].readIfPresent(with: OpenSearchClientTypes.EBSOptions.read(from:))
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent()
        value.ipAddressType = try reader["IPAddressType"].readIfPresent()
        value.snapshotOptions = try reader["SnapshotOptions"].readIfPresent(with: OpenSearchClientTypes.SnapshotOptions.read(from:))
        value.vpcOptions = try reader["VPCOptions"].readIfPresent(with: OpenSearchClientTypes.VPCDerivedInfo.read(from:))
        value.cognitoOptions = try reader["CognitoOptions"].readIfPresent(with: OpenSearchClientTypes.CognitoOptions.read(from:))
        value.encryptionAtRestOptions = try reader["EncryptionAtRestOptions"].readIfPresent(with: OpenSearchClientTypes.EncryptionAtRestOptions.read(from:))
        value.nodeToNodeEncryptionOptions = try reader["NodeToNodeEncryptionOptions"].readIfPresent(with: OpenSearchClientTypes.NodeToNodeEncryptionOptions.read(from:))
        value.advancedOptions = try reader["AdvancedOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.logPublishingOptions = try reader["LogPublishingOptions"].readMapIfPresent(valueReadingClosure: OpenSearchClientTypes.LogPublishingOption.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.serviceSoftwareOptions = try reader["ServiceSoftwareOptions"].readIfPresent(with: OpenSearchClientTypes.ServiceSoftwareOptions.read(from:))
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: OpenSearchClientTypes.DomainEndpointOptions.read(from:))
        value.advancedSecurityOptions = try reader["AdvancedSecurityOptions"].readIfPresent(with: OpenSearchClientTypes.AdvancedSecurityOptions.read(from:))
        value.autoTuneOptions = try reader["AutoTuneOptions"].readIfPresent(with: OpenSearchClientTypes.AutoTuneOptionsOutput.read(from:))
        value.changeProgressDetails = try reader["ChangeProgressDetails"].readIfPresent(with: OpenSearchClientTypes.ChangeProgressDetails.read(from:))
        value.offPeakWindowOptions = try reader["OffPeakWindowOptions"].readIfPresent(with: OpenSearchClientTypes.OffPeakWindowOptions.read(from:))
        value.softwareUpdateOptions = try reader["SoftwareUpdateOptions"].readIfPresent(with: OpenSearchClientTypes.SoftwareUpdateOptions.read(from:))
        value.domainProcessingStatus = try reader["DomainProcessingStatus"].readIfPresent()
        value.modifyingProperties = try reader["ModifyingProperties"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ModifyingProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.aimlOptions = try reader["AIMLOptions"].readIfPresent(with: OpenSearchClientTypes.AIMLOptionsOutput.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AIMLOptionsOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AIMLOptionsOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AIMLOptionsOutput()
        value.naturalLanguageQueryGenerationOptions = try reader["NaturalLanguageQueryGenerationOptions"].readIfPresent(with: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsOutput()
        value.desiredState = try reader["DesiredState"].readIfPresent()
        value.currentState = try reader["CurrentState"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ModifyingProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ModifyingProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ModifyingProperties()
        value.name = try reader["Name"].readIfPresent()
        value.activeValue = try reader["ActiveValue"].readIfPresent()
        value.pendingValue = try reader["PendingValue"].readIfPresent()
        value.valueType = try reader["ValueType"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.SoftwareUpdateOptions {

    static func write(value: OpenSearchClientTypes.SoftwareUpdateOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoSoftwareUpdateEnabled"].write(value.autoSoftwareUpdateEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SoftwareUpdateOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SoftwareUpdateOptions()
        value.autoSoftwareUpdateEnabled = try reader["AutoSoftwareUpdateEnabled"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.OffPeakWindowOptions {

    static func write(value: OpenSearchClientTypes.OffPeakWindowOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["OffPeakWindow"].write(value.offPeakWindow, with: OpenSearchClientTypes.OffPeakWindow.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OffPeakWindowOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OffPeakWindowOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.offPeakWindow = try reader["OffPeakWindow"].readIfPresent(with: OpenSearchClientTypes.OffPeakWindow.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.OffPeakWindow {

    static func write(value: OpenSearchClientTypes.OffPeakWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WindowStartTime"].write(value.windowStartTime, with: OpenSearchClientTypes.WindowStartTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OffPeakWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OffPeakWindow()
        value.windowStartTime = try reader["WindowStartTime"].readIfPresent(with: OpenSearchClientTypes.WindowStartTime.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.WindowStartTime {

    static func write(value: OpenSearchClientTypes.WindowStartTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hours"].write(value.hours)
        try writer["Minutes"].write(value.minutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.WindowStartTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.WindowStartTime()
        value.hours = try reader["Hours"].readIfPresent() ?? 0
        value.minutes = try reader["Minutes"].readIfPresent() ?? 0
        return value
    }
}

extension OpenSearchClientTypes.ChangeProgressDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ChangeProgressDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ChangeProgressDetails()
        value.changeId = try reader["ChangeId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.configChangeStatus = try reader["ConfigChangeStatus"].readIfPresent()
        value.initiatedBy = try reader["InitiatedBy"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneOptionsOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneOptionsOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneOptionsOutput()
        value.state = try reader["State"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.useOffPeakWindow = try reader["UseOffPeakWindow"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AdvancedSecurityOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AdvancedSecurityOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AdvancedSecurityOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.internalUserDatabaseEnabled = try reader["InternalUserDatabaseEnabled"].readIfPresent()
        value.samlOptions = try reader["SAMLOptions"].readIfPresent(with: OpenSearchClientTypes.SAMLOptionsOutput.read(from:))
        value.jwtOptions = try reader["JWTOptions"].readIfPresent(with: OpenSearchClientTypes.JWTOptionsOutput.read(from:))
        value.anonymousAuthDisableDate = try reader["AnonymousAuthDisableDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.anonymousAuthEnabled = try reader["AnonymousAuthEnabled"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.JWTOptionsOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.JWTOptionsOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.JWTOptionsOutput()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.subjectKey = try reader["SubjectKey"].readIfPresent()
        value.rolesKey = try reader["RolesKey"].readIfPresent()
        value.publicKey = try reader["PublicKey"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.SAMLOptionsOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SAMLOptionsOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SAMLOptionsOutput()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.idp = try reader["Idp"].readIfPresent(with: OpenSearchClientTypes.SAMLIdp.read(from:))
        value.subjectKey = try reader["SubjectKey"].readIfPresent()
        value.rolesKey = try reader["RolesKey"].readIfPresent()
        value.sessionTimeoutMinutes = try reader["SessionTimeoutMinutes"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.SAMLIdp {

    static func write(value: OpenSearchClientTypes.SAMLIdp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["MetadataContent"].write(value.metadataContent)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SAMLIdp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SAMLIdp()
        value.metadataContent = try reader["MetadataContent"].readIfPresent() ?? ""
        value.entityId = try reader["EntityId"].readIfPresent() ?? ""
        return value
    }
}

extension OpenSearchClientTypes.DomainEndpointOptions {

    static func write(value: OpenSearchClientTypes.DomainEndpointOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomEndpoint"].write(value.customEndpoint)
        try writer["CustomEndpointCertificateArn"].write(value.customEndpointCertificateArn)
        try writer["CustomEndpointEnabled"].write(value.customEndpointEnabled)
        try writer["EnforceHTTPS"].write(value.enforceHTTPS)
        try writer["TLSSecurityPolicy"].write(value.tlsSecurityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainEndpointOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainEndpointOptions()
        value.enforceHTTPS = try reader["EnforceHTTPS"].readIfPresent()
        value.tlsSecurityPolicy = try reader["TLSSecurityPolicy"].readIfPresent()
        value.customEndpointEnabled = try reader["CustomEndpointEnabled"].readIfPresent()
        value.customEndpoint = try reader["CustomEndpoint"].readIfPresent()
        value.customEndpointCertificateArn = try reader["CustomEndpointCertificateArn"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.LogPublishingOption {

    static func write(value: OpenSearchClientTypes.LogPublishingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.LogPublishingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.LogPublishingOption()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.NodeToNodeEncryptionOptions {

    static func write(value: OpenSearchClientTypes.NodeToNodeEncryptionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.NodeToNodeEncryptionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.NodeToNodeEncryptionOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.EncryptionAtRestOptions {

    static func write(value: OpenSearchClientTypes.EncryptionAtRestOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.EncryptionAtRestOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.EncryptionAtRestOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.CognitoOptions {

    static func write(value: OpenSearchClientTypes.CognitoOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["IdentityPoolId"].write(value.identityPoolId)
        try writer["RoleArn"].write(value.roleArn)
        try writer["UserPoolId"].write(value.userPoolId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.CognitoOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.CognitoOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.userPoolId = try reader["UserPoolId"].readIfPresent()
        value.identityPoolId = try reader["IdentityPoolId"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.VPCDerivedInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VPCDerivedInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VPCDerivedInfo()
        value.vpcId = try reader["VPCId"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.SnapshotOptions {

    static func write(value: OpenSearchClientTypes.SnapshotOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomatedSnapshotStartHour"].write(value.automatedSnapshotStartHour)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SnapshotOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SnapshotOptions()
        value.automatedSnapshotStartHour = try reader["AutomatedSnapshotStartHour"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.EBSOptions {

    static func write(value: OpenSearchClientTypes.EBSOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EBSEnabled"].write(value.ebsEnabled)
        try writer["Iops"].write(value.iops)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.EBSOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.EBSOptions()
        value.ebsEnabled = try reader["EBSEnabled"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.volumeSize = try reader["VolumeSize"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.throughput = try reader["Throughput"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ClusterConfig {

    static func write(value: OpenSearchClientTypes.ClusterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ColdStorageOptions"].write(value.coldStorageOptions, with: OpenSearchClientTypes.ColdStorageOptions.write(value:to:))
        try writer["DedicatedMasterCount"].write(value.dedicatedMasterCount)
        try writer["DedicatedMasterEnabled"].write(value.dedicatedMasterEnabled)
        try writer["DedicatedMasterType"].write(value.dedicatedMasterType)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["InstanceType"].write(value.instanceType)
        try writer["MultiAZWithStandbyEnabled"].write(value.multiAZWithStandbyEnabled)
        try writer["WarmCount"].write(value.warmCount)
        try writer["WarmEnabled"].write(value.warmEnabled)
        try writer["WarmType"].write(value.warmType)
        try writer["ZoneAwarenessConfig"].write(value.zoneAwarenessConfig, with: OpenSearchClientTypes.ZoneAwarenessConfig.write(value:to:))
        try writer["ZoneAwarenessEnabled"].write(value.zoneAwarenessEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ClusterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ClusterConfig()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.dedicatedMasterEnabled = try reader["DedicatedMasterEnabled"].readIfPresent()
        value.zoneAwarenessEnabled = try reader["ZoneAwarenessEnabled"].readIfPresent()
        value.zoneAwarenessConfig = try reader["ZoneAwarenessConfig"].readIfPresent(with: OpenSearchClientTypes.ZoneAwarenessConfig.read(from:))
        value.dedicatedMasterType = try reader["DedicatedMasterType"].readIfPresent()
        value.dedicatedMasterCount = try reader["DedicatedMasterCount"].readIfPresent()
        value.warmEnabled = try reader["WarmEnabled"].readIfPresent()
        value.warmType = try reader["WarmType"].readIfPresent()
        value.warmCount = try reader["WarmCount"].readIfPresent()
        value.coldStorageOptions = try reader["ColdStorageOptions"].readIfPresent(with: OpenSearchClientTypes.ColdStorageOptions.read(from:))
        value.multiAZWithStandbyEnabled = try reader["MultiAZWithStandbyEnabled"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ColdStorageOptions {

    static func write(value: OpenSearchClientTypes.ColdStorageOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ColdStorageOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ColdStorageOptions()
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        return value
    }
}

extension OpenSearchClientTypes.ZoneAwarenessConfig {

    static func write(value: OpenSearchClientTypes.ZoneAwarenessConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZoneCount"].write(value.availabilityZoneCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ZoneAwarenessConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ZoneAwarenessConfig()
        value.availabilityZoneCount = try reader["AvailabilityZoneCount"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.OutboundConnectionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OutboundConnectionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OutboundConnectionStatus()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ConnectionProperties {

    static func write(value: OpenSearchClientTypes.ConnectionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CrossClusterSearch"].write(value.crossClusterSearch, with: OpenSearchClientTypes.CrossClusterSearchConnectionProperties.write(value:to:))
        try writer["Endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ConnectionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ConnectionProperties()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.crossClusterSearch = try reader["CrossClusterSearch"].readIfPresent(with: OpenSearchClientTypes.CrossClusterSearchConnectionProperties.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.CrossClusterSearchConnectionProperties {

    static func write(value: OpenSearchClientTypes.CrossClusterSearchConnectionProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SkipUnavailable"].write(value.skipUnavailable)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.CrossClusterSearchConnectionProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.CrossClusterSearchConnectionProperties()
        value.skipUnavailable = try reader["SkipUnavailable"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.PackageDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.PackageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.PackageDetails()
        value.packageID = try reader["PackageID"].readIfPresent()
        value.packageName = try reader["PackageName"].readIfPresent()
        value.packageType = try reader["PackageType"].readIfPresent()
        value.packageDescription = try reader["PackageDescription"].readIfPresent()
        value.packageStatus = try reader["PackageStatus"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.availablePackageVersion = try reader["AvailablePackageVersion"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readIfPresent(with: OpenSearchClientTypes.ErrorDetails.read(from:))
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.availablePluginProperties = try reader["AvailablePluginProperties"].readIfPresent(with: OpenSearchClientTypes.PluginProperties.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.PluginProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.PluginProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.PluginProperties()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.className = try reader["ClassName"].readIfPresent()
        value.uncompressedSizeInBytes = try reader["UncompressedSizeInBytes"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.VpcEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VpcEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VpcEndpoint()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        value.vpcEndpointOwner = try reader["VpcEndpointOwner"].readIfPresent()
        value.domainArn = try reader["DomainArn"].readIfPresent()
        value.vpcOptions = try reader["VpcOptions"].readIfPresent(with: OpenSearchClientTypes.VPCDerivedInfo.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.OutboundConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OutboundConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OutboundConnection()
        value.localDomainInfo = try reader["LocalDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        value.remoteDomainInfo = try reader["RemoteDomainInfo"].readIfPresent(with: OpenSearchClientTypes.DomainInformationContainer.read(from:))
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionAlias = try reader["ConnectionAlias"].readIfPresent()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent(with: OpenSearchClientTypes.OutboundConnectionStatus.read(from:))
        value.connectionMode = try reader["ConnectionMode"].readIfPresent()
        value.connectionProperties = try reader["ConnectionProperties"].readIfPresent(with: OpenSearchClientTypes.ConnectionProperties.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.VpcEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VpcEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VpcEndpointSummary()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        value.vpcEndpointOwner = try reader["VpcEndpointOwner"].readIfPresent()
        value.domainArn = try reader["DomainArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AutoTune {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTune {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTune()
        value.autoTuneType = try reader["AutoTuneType"].readIfPresent()
        value.autoTuneDetails = try reader["AutoTuneDetails"].readIfPresent(with: OpenSearchClientTypes.AutoTuneDetails.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneDetails()
        value.scheduledAutoTuneDetails = try reader["ScheduledAutoTuneDetails"].readIfPresent(with: OpenSearchClientTypes.ScheduledAutoTuneDetails.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.ScheduledAutoTuneDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ScheduledAutoTuneDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ScheduledAutoTuneDetails()
        value.date = try reader["Date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.actionType = try reader["ActionType"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ChangeProgressStatusDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ChangeProgressStatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ChangeProgressStatusDetails()
        value.changeId = try reader["ChangeId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.pendingProperties = try reader["PendingProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.completedProperties = try reader["CompletedProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalNumberOfStages = try reader["TotalNumberOfStages"].readIfPresent() ?? 0
        value.changeProgressStages = try reader["ChangeProgressStages"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ChangeProgressStage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configChangeStatus = try reader["ConfigChangeStatus"].readIfPresent()
        value.initiatedBy = try reader["InitiatedBy"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ChangeProgressStage {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ChangeProgressStage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ChangeProgressStage()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OpenSearchClientTypes.DomainConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainConfig()
        value.engineVersion = try reader["EngineVersion"].readIfPresent(with: OpenSearchClientTypes.VersionStatus.read(from:))
        value.clusterConfig = try reader["ClusterConfig"].readIfPresent(with: OpenSearchClientTypes.ClusterConfigStatus.read(from:))
        value.ebsOptions = try reader["EBSOptions"].readIfPresent(with: OpenSearchClientTypes.EBSOptionsStatus.read(from:))
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent(with: OpenSearchClientTypes.AccessPoliciesStatus.read(from:))
        value.ipAddressType = try reader["IPAddressType"].readIfPresent(with: OpenSearchClientTypes.IPAddressTypeStatus.read(from:))
        value.snapshotOptions = try reader["SnapshotOptions"].readIfPresent(with: OpenSearchClientTypes.SnapshotOptionsStatus.read(from:))
        value.vpcOptions = try reader["VPCOptions"].readIfPresent(with: OpenSearchClientTypes.VPCDerivedInfoStatus.read(from:))
        value.cognitoOptions = try reader["CognitoOptions"].readIfPresent(with: OpenSearchClientTypes.CognitoOptionsStatus.read(from:))
        value.encryptionAtRestOptions = try reader["EncryptionAtRestOptions"].readIfPresent(with: OpenSearchClientTypes.EncryptionAtRestOptionsStatus.read(from:))
        value.nodeToNodeEncryptionOptions = try reader["NodeToNodeEncryptionOptions"].readIfPresent(with: OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus.read(from:))
        value.advancedOptions = try reader["AdvancedOptions"].readIfPresent(with: OpenSearchClientTypes.AdvancedOptionsStatus.read(from:))
        value.logPublishingOptions = try reader["LogPublishingOptions"].readIfPresent(with: OpenSearchClientTypes.LogPublishingOptionsStatus.read(from:))
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: OpenSearchClientTypes.DomainEndpointOptionsStatus.read(from:))
        value.advancedSecurityOptions = try reader["AdvancedSecurityOptions"].readIfPresent(with: OpenSearchClientTypes.AdvancedSecurityOptionsStatus.read(from:))
        value.autoTuneOptions = try reader["AutoTuneOptions"].readIfPresent(with: OpenSearchClientTypes.AutoTuneOptionsStatus.read(from:))
        value.changeProgressDetails = try reader["ChangeProgressDetails"].readIfPresent(with: OpenSearchClientTypes.ChangeProgressDetails.read(from:))
        value.offPeakWindowOptions = try reader["OffPeakWindowOptions"].readIfPresent(with: OpenSearchClientTypes.OffPeakWindowOptionsStatus.read(from:))
        value.softwareUpdateOptions = try reader["SoftwareUpdateOptions"].readIfPresent(with: OpenSearchClientTypes.SoftwareUpdateOptionsStatus.read(from:))
        value.modifyingProperties = try reader["ModifyingProperties"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ModifyingProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.aimlOptions = try reader["AIMLOptions"].readIfPresent(with: OpenSearchClientTypes.AIMLOptionsStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AIMLOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AIMLOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AIMLOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.AIMLOptionsOutput.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.OptionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OptionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OptionStatus()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateVersion = try reader["UpdateVersion"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.pendingDeletion = try reader["PendingDeletion"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.SoftwareUpdateOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SoftwareUpdateOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SoftwareUpdateOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.SoftwareUpdateOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.OffPeakWindowOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.OffPeakWindowOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.OffPeakWindowOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.OffPeakWindowOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.AutoTuneOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.AutoTuneStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneStatus()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateVersion = try reader["UpdateVersion"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.pendingDeletion = try reader["PendingDeletion"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneOptions {

    static func write(value: OpenSearchClientTypes.AutoTuneOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredState"].write(value.desiredState)
        try writer["MaintenanceSchedules"].writeList(value.maintenanceSchedules, memberWritingClosure: OpenSearchClientTypes.AutoTuneMaintenanceSchedule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RollbackOnDisable"].write(value.rollbackOnDisable)
        try writer["UseOffPeakWindow"].write(value.useOffPeakWindow)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneOptions()
        value.desiredState = try reader["DesiredState"].readIfPresent()
        value.rollbackOnDisable = try reader["RollbackOnDisable"].readIfPresent()
        value.maintenanceSchedules = try reader["MaintenanceSchedules"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.AutoTuneMaintenanceSchedule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.useOffPeakWindow = try reader["UseOffPeakWindow"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AutoTuneMaintenanceSchedule {

    static func write(value: OpenSearchClientTypes.AutoTuneMaintenanceSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CronExpressionForRecurrence"].write(value.cronExpressionForRecurrence)
        try writer["Duration"].write(value.duration, with: OpenSearchClientTypes.Duration.write(value:to:))
        try writer["StartAt"].writeTimestamp(value.startAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AutoTuneMaintenanceSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AutoTuneMaintenanceSchedule()
        value.startAt = try reader["StartAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.duration = try reader["Duration"].readIfPresent(with: OpenSearchClientTypes.Duration.read(from:))
        value.cronExpressionForRecurrence = try reader["CronExpressionForRecurrence"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.Duration {

    static func write(value: OpenSearchClientTypes.Duration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.Duration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.Duration()
        value.value = try reader["Value"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.AdvancedSecurityOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AdvancedSecurityOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AdvancedSecurityOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.AdvancedSecurityOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.DomainEndpointOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainEndpointOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainEndpointOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.DomainEndpointOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.LogPublishingOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.LogPublishingOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.LogPublishingOptionsStatus()
        value.options = try reader["Options"].readMapIfPresent(valueReadingClosure: OpenSearchClientTypes.LogPublishingOption.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AdvancedOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AdvancedOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AdvancedOptionsStatus()
        value.options = try reader["Options"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.NodeToNodeEncryptionOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.NodeToNodeEncryptionOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.EncryptionAtRestOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.EncryptionAtRestOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.EncryptionAtRestOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.EncryptionAtRestOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.CognitoOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.CognitoOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.CognitoOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.CognitoOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.VPCDerivedInfoStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VPCDerivedInfoStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VPCDerivedInfoStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.VPCDerivedInfo.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.SnapshotOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.SnapshotOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.SnapshotOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.SnapshotOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.IPAddressTypeStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.IPAddressTypeStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.IPAddressTypeStatus()
        value.options = try reader["Options"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.AccessPoliciesStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AccessPoliciesStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AccessPoliciesStatus()
        value.options = try reader["Options"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.EBSOptionsStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.EBSOptionsStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.EBSOptionsStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.EBSOptions.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.ClusterConfigStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ClusterConfigStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ClusterConfigStatus()
        value.options = try reader["Options"].readIfPresent(with: OpenSearchClientTypes.ClusterConfig.read(from:))
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.VersionStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VersionStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VersionStatus()
        value.options = try reader["Options"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent(with: OpenSearchClientTypes.OptionStatus.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.EnvironmentInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.EnvironmentInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.EnvironmentInfo()
        value.availabilityZoneInformation = try reader["AvailabilityZoneInformation"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.AvailabilityZoneInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.AvailabilityZoneInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AvailabilityZoneInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AvailabilityZoneInfo()
        value.availabilityZoneName = try reader["AvailabilityZoneName"].readIfPresent()
        value.zoneStatus = try reader["ZoneStatus"].readIfPresent()
        value.configuredDataNodeCount = try reader["ConfiguredDataNodeCount"].readIfPresent()
        value.availableDataNodeCount = try reader["AvailableDataNodeCount"].readIfPresent()
        value.totalShards = try reader["TotalShards"].readIfPresent()
        value.totalUnAssignedShards = try reader["TotalUnAssignedShards"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DomainNodesStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainNodesStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainNodesStatus()
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.nodeStatus = try reader["NodeStatus"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        value.storageVolumeType = try reader["StorageVolumeType"].readIfPresent()
        value.storageSize = try reader["StorageSize"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DryRunProgressStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DryRunProgressStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DryRunProgressStatus()
        value.dryRunId = try reader["DryRunId"].readIfPresent() ?? ""
        value.dryRunStatus = try reader["DryRunStatus"].readIfPresent() ?? ""
        value.creationDate = try reader["CreationDate"].readIfPresent() ?? ""
        value.updateDate = try reader["UpdateDate"].readIfPresent() ?? ""
        value.validationFailures = try reader["ValidationFailures"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.ValidationFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.ValidationFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ValidationFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ValidationFailure()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DryRunResults {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DryRunResults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DryRunResults()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.Limits {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.Limits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.Limits()
        value.storageTypes = try reader["StorageTypes"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.StorageType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceLimits = try reader["InstanceLimits"].readIfPresent(with: OpenSearchClientTypes.InstanceLimits.read(from:))
        value.additionalLimits = try reader["AdditionalLimits"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.AdditionalLimit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.AdditionalLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.AdditionalLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.AdditionalLimit()
        value.limitName = try reader["LimitName"].readIfPresent()
        value.limitValues = try reader["LimitValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.InstanceLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.InstanceLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.InstanceLimits()
        value.instanceCountLimits = try reader["InstanceCountLimits"].readIfPresent(with: OpenSearchClientTypes.InstanceCountLimits.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.InstanceCountLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.InstanceCountLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.InstanceCountLimits()
        value.minimumInstanceCount = try reader["MinimumInstanceCount"].readIfPresent() ?? 0
        value.maximumInstanceCount = try reader["MaximumInstanceCount"].readIfPresent() ?? 0
        return value
    }
}

extension OpenSearchClientTypes.StorageType {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.StorageType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.StorageType()
        value.storageTypeName = try reader["StorageTypeName"].readIfPresent()
        value.storageSubTypeName = try reader["StorageSubTypeName"].readIfPresent()
        value.storageTypeLimits = try reader["StorageTypeLimits"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.StorageTypeLimit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.StorageTypeLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.StorageTypeLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.StorageTypeLimit()
        value.limitName = try reader["LimitName"].readIfPresent()
        value.limitValues = try reader["LimitValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.ReservedInstanceOffering {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ReservedInstanceOffering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ReservedInstanceOffering()
        value.reservedInstanceOfferingId = try reader["ReservedInstanceOfferingId"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.fixedPrice = try reader["FixedPrice"].readIfPresent()
        value.usagePrice = try reader["UsagePrice"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.recurringCharges = try reader["RecurringCharges"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.RecurringCharge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.RecurringCharge {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.RecurringCharge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.RecurringCharge()
        value.recurringChargeAmount = try reader["RecurringChargeAmount"].readIfPresent()
        value.recurringChargeFrequency = try reader["RecurringChargeFrequency"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.ReservedInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ReservedInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ReservedInstance()
        value.reservationName = try reader["ReservationName"].readIfPresent()
        value.reservedInstanceId = try reader["ReservedInstanceId"].readIfPresent()
        value.billingSubscriptionId = try reader["BillingSubscriptionId"].readIfPresent()
        value.reservedInstanceOfferingId = try reader["ReservedInstanceOfferingId"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        value.fixedPrice = try reader["FixedPrice"].readIfPresent()
        value.usagePrice = try reader["UsagePrice"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent()
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.recurringCharges = try reader["RecurringCharges"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.RecurringCharge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.VpcEndpointError {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.VpcEndpointError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.VpcEndpointError()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.CompatibleVersionsMap {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.CompatibleVersionsMap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.CompatibleVersionsMap()
        value.sourceVersion = try reader["SourceVersion"].readIfPresent()
        value.targetVersions = try reader["TargetVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.DataSourceType {

    static func write(value: OpenSearchClientTypes.DataSourceType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3gluedatacatalog(s3gluedatacatalog):
                try writer["S3GlueDataCatalog"].write(s3gluedatacatalog, with: OpenSearchClientTypes.S3GlueDataCatalog.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DataSourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "S3GlueDataCatalog":
                return .s3gluedatacatalog(try reader["S3GlueDataCatalog"].read(with: OpenSearchClientTypes.S3GlueDataCatalog.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension OpenSearchClientTypes.S3GlueDataCatalog {

    static func write(value: OpenSearchClientTypes.S3GlueDataCatalog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.S3GlueDataCatalog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.S3GlueDataCatalog()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.PackageVersionHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.PackageVersionHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.PackageVersionHistory()
        value.packageVersion = try reader["PackageVersion"].readIfPresent()
        value.commitMessage = try reader["CommitMessage"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pluginProperties = try reader["PluginProperties"].readIfPresent(with: OpenSearchClientTypes.PluginProperties.read(from:))
        return value
    }
}

extension OpenSearchClientTypes.UpgradeHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.UpgradeHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.UpgradeHistory()
        value.upgradeName = try reader["UpgradeName"].readIfPresent()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.upgradeStatus = try reader["UpgradeStatus"].readIfPresent()
        value.stepsList = try reader["StepsList"].readListIfPresent(memberReadingClosure: OpenSearchClientTypes.UpgradeStepItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.UpgradeStepItem {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.UpgradeStepItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.UpgradeStepItem()
        value.upgradeStep = try reader["UpgradeStep"].readIfPresent()
        value.upgradeStepStatus = try reader["UpgradeStepStatus"].readIfPresent()
        value.issues = try reader["Issues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.progressPercent = try reader["ProgressPercent"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DataSourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DataSourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DataSourceDetails()
        value.dataSourceType = try reader["DataSourceType"].readIfPresent(with: OpenSearchClientTypes.DataSourceType.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.DomainMaintenanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainMaintenanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainMaintenanceDetails()
        value.maintenanceId = try reader["MaintenanceId"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.action = try reader["Action"].readIfPresent()
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension OpenSearchClientTypes.DomainInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.DomainInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.DomainInfo()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.engineType = try reader["EngineType"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.InstanceTypeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.InstanceTypeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.InstanceTypeDetails()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.encryptionEnabled = try reader["EncryptionEnabled"].readIfPresent()
        value.cognitoEnabled = try reader["CognitoEnabled"].readIfPresent()
        value.appLogsEnabled = try reader["AppLogsEnabled"].readIfPresent()
        value.advancedSecurityEnabled = try reader["AdvancedSecurityEnabled"].readIfPresent()
        value.warmEnabled = try reader["WarmEnabled"].readIfPresent()
        value.instanceRole = try reader["InstanceRole"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OpenSearchClientTypes.ScheduledAction {

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.ScheduledAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.ScheduledAction()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.severity = try reader["Severity"].readIfPresent() ?? .sdkUnknown("")
        value.scheduledTime = try reader["ScheduledTime"].readIfPresent() ?? 0
        value.description = try reader["Description"].readIfPresent()
        value.scheduledBy = try reader["ScheduledBy"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.mandatory = try reader["Mandatory"].readIfPresent()
        value.cancellable = try reader["Cancellable"].readIfPresent()
        return value
    }
}

extension OpenSearchClientTypes.Tag {

    static func write(value: OpenSearchClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> OpenSearchClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = OpenSearchClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension OpenSearchClientTypes.VPCOptions {

    static func write(value: OpenSearchClientTypes.VPCOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension OpenSearchClientTypes.AdvancedSecurityOptionsInput {

    static func write(value: OpenSearchClientTypes.AdvancedSecurityOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnonymousAuthEnabled"].write(value.anonymousAuthEnabled)
        try writer["Enabled"].write(value.enabled)
        try writer["InternalUserDatabaseEnabled"].write(value.internalUserDatabaseEnabled)
        try writer["JWTOptions"].write(value.jwtOptions, with: OpenSearchClientTypes.JWTOptionsInput.write(value:to:))
        try writer["MasterUserOptions"].write(value.masterUserOptions, with: OpenSearchClientTypes.MasterUserOptions.write(value:to:))
        try writer["SAMLOptions"].write(value.samlOptions, with: OpenSearchClientTypes.SAMLOptionsInput.write(value:to:))
    }
}

extension OpenSearchClientTypes.JWTOptionsInput {

    static func write(value: OpenSearchClientTypes.JWTOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["PublicKey"].write(value.publicKey)
        try writer["RolesKey"].write(value.rolesKey)
        try writer["SubjectKey"].write(value.subjectKey)
    }
}

extension OpenSearchClientTypes.SAMLOptionsInput {

    static func write(value: OpenSearchClientTypes.SAMLOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Idp"].write(value.idp, with: OpenSearchClientTypes.SAMLIdp.write(value:to:))
        try writer["MasterBackendRole"].write(value.masterBackendRole)
        try writer["MasterUserName"].write(value.masterUserName)
        try writer["RolesKey"].write(value.rolesKey)
        try writer["SessionTimeoutMinutes"].write(value.sessionTimeoutMinutes)
        try writer["SubjectKey"].write(value.subjectKey)
    }
}

extension OpenSearchClientTypes.MasterUserOptions {

    static func write(value: OpenSearchClientTypes.MasterUserOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MasterUserARN"].write(value.masterUserARN)
        try writer["MasterUserName"].write(value.masterUserName)
        try writer["MasterUserPassword"].write(value.masterUserPassword)
    }
}

extension OpenSearchClientTypes.AutoTuneOptionsInput {

    static func write(value: OpenSearchClientTypes.AutoTuneOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredState"].write(value.desiredState)
        try writer["MaintenanceSchedules"].writeList(value.maintenanceSchedules, memberWritingClosure: OpenSearchClientTypes.AutoTuneMaintenanceSchedule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UseOffPeakWindow"].write(value.useOffPeakWindow)
    }
}

extension OpenSearchClientTypes.AIMLOptionsInput {

    static func write(value: OpenSearchClientTypes.AIMLOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NaturalLanguageQueryGenerationOptions"].write(value.naturalLanguageQueryGenerationOptions, with: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsInput.write(value:to:))
    }
}

extension OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsInput {

    static func write(value: OpenSearchClientTypes.NaturalLanguageQueryGenerationOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DesiredState"].write(value.desiredState)
    }
}

extension OpenSearchClientTypes.PackageSource {

    static func write(value: OpenSearchClientTypes.PackageSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3Key"].write(value.s3Key)
    }
}

extension OpenSearchClientTypes.Filter {

    static func write(value: OpenSearchClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension OpenSearchClientTypes.DescribePackagesFilter {

    static func write(value: OpenSearchClientTypes.DescribePackagesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum OpenSearchClientTypes {}
