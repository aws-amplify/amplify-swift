//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension Route53RecoveryReadinessClient {
    /// Paginate over `[GetCellReadinessSummaryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCellReadinessSummaryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCellReadinessSummaryOutput`
    public func getCellReadinessSummaryPaginated(input: GetCellReadinessSummaryInput) -> ClientRuntime.PaginatorSequence<GetCellReadinessSummaryInput, GetCellReadinessSummaryOutput> {
        return ClientRuntime.PaginatorSequence<GetCellReadinessSummaryInput, GetCellReadinessSummaryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCellReadinessSummary(input:))
    }
}

extension GetCellReadinessSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCellReadinessSummaryInput {
        return GetCellReadinessSummaryInput(
            cellName: self.cellName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetCellReadinessSummaryInput, OperationStackOutput == GetCellReadinessSummaryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getCellReadinessSummaryPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]`
    public func readinessChecks() async throws -> [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary] {
        return try await self.asyncCompactMap { item in item.readinessChecks }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[GetReadinessCheckResourceStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReadinessCheckResourceStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReadinessCheckResourceStatusOutput`
    public func getReadinessCheckResourceStatusPaginated(input: GetReadinessCheckResourceStatusInput) -> ClientRuntime.PaginatorSequence<GetReadinessCheckResourceStatusInput, GetReadinessCheckResourceStatusOutput> {
        return ClientRuntime.PaginatorSequence<GetReadinessCheckResourceStatusInput, GetReadinessCheckResourceStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getReadinessCheckResourceStatus(input:))
    }
}

extension GetReadinessCheckResourceStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReadinessCheckResourceStatusInput {
        return GetReadinessCheckResourceStatusInput(
            maxResults: self.maxResults,
            nextToken: token,
            readinessCheckName: self.readinessCheckName,
            resourceIdentifier: self.resourceIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == GetReadinessCheckResourceStatusInput, OperationStackOutput == GetReadinessCheckResourceStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getReadinessCheckResourceStatusPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.RuleResult]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.RuleResult]`
    public func rules() async throws -> [Route53RecoveryReadinessClientTypes.RuleResult] {
        return try await self.asyncCompactMap { item in item.rules }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[GetReadinessCheckStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReadinessCheckStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReadinessCheckStatusOutput`
    public func getReadinessCheckStatusPaginated(input: GetReadinessCheckStatusInput) -> ClientRuntime.PaginatorSequence<GetReadinessCheckStatusInput, GetReadinessCheckStatusOutput> {
        return ClientRuntime.PaginatorSequence<GetReadinessCheckStatusInput, GetReadinessCheckStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getReadinessCheckStatus(input:))
    }
}

extension GetReadinessCheckStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReadinessCheckStatusInput {
        return GetReadinessCheckStatusInput(
            maxResults: self.maxResults,
            nextToken: token,
            readinessCheckName: self.readinessCheckName
        )}
}

extension PaginatorSequence where OperationStackInput == GetReadinessCheckStatusInput, OperationStackOutput == GetReadinessCheckStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getReadinessCheckStatusPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ResourceResult]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ResourceResult]`
    public func resources() async throws -> [Route53RecoveryReadinessClientTypes.ResourceResult] {
        return try await self.asyncCompactMap { item in item.resources }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[GetRecoveryGroupReadinessSummaryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetRecoveryGroupReadinessSummaryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetRecoveryGroupReadinessSummaryOutput`
    public func getRecoveryGroupReadinessSummaryPaginated(input: GetRecoveryGroupReadinessSummaryInput) -> ClientRuntime.PaginatorSequence<GetRecoveryGroupReadinessSummaryInput, GetRecoveryGroupReadinessSummaryOutput> {
        return ClientRuntime.PaginatorSequence<GetRecoveryGroupReadinessSummaryInput, GetRecoveryGroupReadinessSummaryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getRecoveryGroupReadinessSummary(input:))
    }
}

extension GetRecoveryGroupReadinessSummaryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRecoveryGroupReadinessSummaryInput {
        return GetRecoveryGroupReadinessSummaryInput(
            maxResults: self.maxResults,
            nextToken: token,
            recoveryGroupName: self.recoveryGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == GetRecoveryGroupReadinessSummaryInput, OperationStackOutput == GetRecoveryGroupReadinessSummaryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getRecoveryGroupReadinessSummaryPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ReadinessCheckSummary]`
    public func readinessChecks() async throws -> [Route53RecoveryReadinessClientTypes.ReadinessCheckSummary] {
        return try await self.asyncCompactMap { item in item.readinessChecks }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListCellsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCellsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCellsOutput`
    public func listCellsPaginated(input: ListCellsInput) -> ClientRuntime.PaginatorSequence<ListCellsInput, ListCellsOutput> {
        return ClientRuntime.PaginatorSequence<ListCellsInput, ListCellsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCells(input:))
    }
}

extension ListCellsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCellsInput {
        return ListCellsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCellsInput, OperationStackOutput == ListCellsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCellsPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.CellOutput]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.CellOutput]`
    public func cells() async throws -> [Route53RecoveryReadinessClientTypes.CellOutput] {
        return try await self.asyncCompactMap { item in item.cells }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListCrossAccountAuthorizationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCrossAccountAuthorizationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCrossAccountAuthorizationsOutput`
    public func listCrossAccountAuthorizationsPaginated(input: ListCrossAccountAuthorizationsInput) -> ClientRuntime.PaginatorSequence<ListCrossAccountAuthorizationsInput, ListCrossAccountAuthorizationsOutput> {
        return ClientRuntime.PaginatorSequence<ListCrossAccountAuthorizationsInput, ListCrossAccountAuthorizationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCrossAccountAuthorizations(input:))
    }
}

extension ListCrossAccountAuthorizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCrossAccountAuthorizationsInput {
        return ListCrossAccountAuthorizationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCrossAccountAuthorizationsInput, OperationStackOutput == ListCrossAccountAuthorizationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCrossAccountAuthorizationsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func crossAccountAuthorizations() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.crossAccountAuthorizations }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListReadinessChecksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReadinessChecksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReadinessChecksOutput`
    public func listReadinessChecksPaginated(input: ListReadinessChecksInput) -> ClientRuntime.PaginatorSequence<ListReadinessChecksInput, ListReadinessChecksOutput> {
        return ClientRuntime.PaginatorSequence<ListReadinessChecksInput, ListReadinessChecksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReadinessChecks(input:))
    }
}

extension ListReadinessChecksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReadinessChecksInput {
        return ListReadinessChecksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListReadinessChecksInput, OperationStackOutput == ListReadinessChecksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listReadinessChecksPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ReadinessCheckOutput]`
    public func readinessChecks() async throws -> [Route53RecoveryReadinessClientTypes.ReadinessCheckOutput] {
        return try await self.asyncCompactMap { item in item.readinessChecks }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListRecoveryGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecoveryGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecoveryGroupsOutput`
    public func listRecoveryGroupsPaginated(input: ListRecoveryGroupsInput) -> ClientRuntime.PaginatorSequence<ListRecoveryGroupsInput, ListRecoveryGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListRecoveryGroupsInput, ListRecoveryGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecoveryGroups(input:))
    }
}

extension ListRecoveryGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecoveryGroupsInput {
        return ListRecoveryGroupsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecoveryGroupsInput, OperationStackOutput == ListRecoveryGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecoveryGroupsPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.RecoveryGroupOutput]`
    public func recoveryGroups() async throws -> [Route53RecoveryReadinessClientTypes.RecoveryGroupOutput] {
        return try await self.asyncCompactMap { item in item.recoveryGroups }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListResourceSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceSetsOutput`
    public func listResourceSetsPaginated(input: ListResourceSetsInput) -> ClientRuntime.PaginatorSequence<ListResourceSetsInput, ListResourceSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceSetsInput, ListResourceSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceSets(input:))
    }
}

extension ListResourceSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceSetsInput {
        return ListResourceSetsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceSetsInput, OperationStackOutput == ListResourceSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceSetsPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ResourceSetOutput]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ResourceSetOutput]`
    public func resourceSets() async throws -> [Route53RecoveryReadinessClientTypes.ResourceSetOutput] {
        return try await self.asyncCompactMap { item in item.resourceSets }
    }
}
extension Route53RecoveryReadinessClient {
    /// Paginate over `[ListRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRulesOutput`
    public func listRulesPaginated(input: ListRulesInput) -> ClientRuntime.PaginatorSequence<ListRulesInput, ListRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListRulesInput, ListRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRules(input:))
    }
}

extension ListRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRulesInput {
        return ListRulesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == ListRulesInput, OperationStackOutput == ListRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRulesPaginated`
    /// to access the nested member `[Route53RecoveryReadinessClientTypes.ListRulesOutput]`
    /// - Returns: `[Route53RecoveryReadinessClientTypes.ListRulesOutput]`
    public func rules() async throws -> [Route53RecoveryReadinessClientTypes.ListRulesOutput] {
        return try await self.asyncCompactMap { item in item.rules }
    }
}
