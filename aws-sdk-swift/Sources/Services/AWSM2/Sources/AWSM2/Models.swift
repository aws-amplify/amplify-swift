//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct GetSignedBluinsightsUrlInput {

    public init() { }
}

/// The account or role doesn't have the right permissions to make the request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension M2ClientTypes {
    /// Defines an alternate key. This value is optional. A legacy data set might not have any alternate key defined but if those alternate keys definitions exist, provide them, as some applications will make use of them.
    public struct AlternateKey {
        /// Indicates whether the alternate key values are supposed to be unique for the given data set.
        public var allowDuplicates: Swift.Bool
        /// A strictly positive integer value representing the length of the alternate key.
        /// This member is required.
        public var length: Swift.Int
        /// The name of the alternate key.
        public var name: Swift.String?
        /// A positive integer value representing the offset to mark the start of the alternate key part in the record byte array.
        /// This member is required.
        public var offset: Swift.Int

        public init(
            allowDuplicates: Swift.Bool = false,
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Int = 0
        )
        {
            self.allowDuplicates = allowDuplicates
            self.length = length
            self.name = name
            self.offset = offset
        }
    }

}

/// The parameters provided in the request conflict with existing resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the conflicting resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred during the processing of the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the missing resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the missing resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The number of requests made exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the throttled request.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The identifier of the service that the throttled request was made to.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension M2ClientTypes {
    /// Contains information about a validation exception field.
    public struct ValidationExceptionField {
        /// The message of the exception field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension M2ClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case featureNotAvailable
        case fieldValidationFailed
        case other
        case unknownOperation
        case unsupportedEngineVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .featureNotAvailable,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .unsupportedEngineVersion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .featureNotAvailable: return "featureNotAvailable"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case .unsupportedEngineVersion: return "unsupportedEngineVersion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// One or more parameters provided in the request is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that failed service validation.
        public internal(set) var fieldList: [M2ClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason why it failed service validation.
        public internal(set) var reason: M2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [M2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: M2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CancelBatchJobExecutionInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job execution.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.executionId = executionId
    }
}

public struct CancelBatchJobExecutionOutput {

    public init() { }
}

/// One or more quotas for Amazon Web Services Mainframe Modernization exceeds the limit.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the exceeded quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that is exceeding the quota limit.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that is exceeding the quota limit for Amazon Web Services Mainframe Modernization.
        public internal(set) var resourceType: Swift.String? = nil
        /// A code that identifies the service that the exceeded quota belongs to.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension M2ClientTypes {
    /// The application definition for a particular application.
    public enum Definition {
        /// The S3 bucket that contains the application definition.
        case s3location(Swift.String)
        /// The content of the application definition. This is a JSON object that contains the resource configuration/definitions that identify an application.
        case content(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {

    public enum EngineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bluage
        case microfocus
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineType] {
            return [
                .bluage,
                .microfocus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bluage: return "bluage"
            case .microfocus: return "microfocus"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateApplicationInput {
    /// Unique, case-sensitive identifier the service generates to ensure the idempotency of the request to create an application. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    /// This member is required.
    public var definition: M2ClientTypes.Definition?
    /// The description of the application.
    public var description: Swift.String?
    /// The type of the target platform for this application.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The unique identifier of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies a role that the application uses to access Amazon Web Services resources that are not part of the application or are in a different Amazon Web Services account.
    public var roleArn: Swift.String?
    /// A list of tags to apply to the application.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        definition: M2ClientTypes.Definition? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.definition = definition
        self.description = description
        self.engineType = engineType
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

public struct CreateApplicationOutput {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The unique application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The version number of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
    }
}

extension M2ClientTypes {
    /// The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see [Generation data sets](https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets).
    public struct GdgAttributes {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public var limit: Swift.Int
        /// The disposition of the data set in the catalog.
        public var rollDisposition: Swift.String?

        public init(
            limit: Swift.Int = 0,
            rollDisposition: Swift.String? = nil
        )
        {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }
    }

}

extension M2ClientTypes {
    /// The supported properties for a PO type data set.
    public struct PoAttributes {
        /// The character set encoding of the data set.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?
        /// An array containing one or more filename extensions, allowing you to specify which files to be included as PDS member.
        /// This member is required.
        public var memberFileExtensions: [Swift.String]?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil,
            memberFileExtensions: [Swift.String]? = nil
        )
        {
            self.encoding = encoding
            self.format = format
            self.memberFileExtensions = memberFileExtensions
        }
    }

}

extension M2ClientTypes {
    /// The supported properties for a PS type data set.
    public struct PsAttributes {
        /// The character set encoding of the data set.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes {
    /// The primary key for a KSDS data set.
    public struct PrimaryKey {
        /// A strictly positive integer value representing the length of the primary key.
        /// This member is required.
        public var length: Swift.Int
        /// A name for the Primary Key.
        public var name: Swift.String?
        /// A positive integer value representing the offset to mark the start of the primary key in the record byte array.
        /// This member is required.
        public var offset: Swift.Int

        public init(
            length: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Int = 0
        )
        {
            self.length = length
            self.name = name
            self.offset = offset
        }
    }

}

extension M2ClientTypes {
    /// The attributes of a VSAM type data set.
    public struct VsamAttributes {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public var alternateKeys: [M2ClientTypes.AlternateKey]?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically > 100 Mb), consider setting this flag to True.
        public var compressed: Swift.Bool
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public var encoding: Swift.String?
        /// The record format of the data set.
        /// This member is required.
        public var format: Swift.String?
        /// The primary key of the data set.
        public var primaryKey: M2ClientTypes.PrimaryKey?

        public init(
            alternateKeys: [M2ClientTypes.AlternateKey]? = nil,
            compressed: Swift.Bool = false,
            encoding: Swift.String? = nil,
            format: Swift.String? = nil,
            primaryKey: M2ClientTypes.PrimaryKey? = nil
        )
        {
            self.alternateKeys = alternateKeys
            self.compressed = compressed
            self.encoding = encoding
            self.format = format
            self.primaryKey = primaryKey
        }
    }

}

extension M2ClientTypes {
    /// Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).
    public enum DatasetOrgAttributes {
        /// The details of a VSAM data set.
        case vsam(M2ClientTypes.VsamAttributes)
        /// The generation data group of the data set.
        case gdg(M2ClientTypes.GdgAttributes)
        /// The details of a PO type data set.
        case po(M2ClientTypes.PoAttributes)
        /// The details of a PS type data set.
        case ps(M2ClientTypes.PsAttributes)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {
    /// The length of the records in the data set.
    public struct RecordLength {
        /// The maximum record length. In case of fixed, both minimum and maximum are the same.
        /// This member is required.
        public var max: Swift.Int
        /// The minimum record length of a record.
        /// This member is required.
        public var min: Swift.Int

        public init(
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension M2ClientTypes {
    /// Defines a data set.
    public struct DataSet {
        /// The logical identifier for a specific data set (in mainframe format).
        /// This member is required.
        public var datasetName: Swift.String?
        /// The type of dataset. The only supported value is VSAM.
        /// This member is required.
        public var datasetOrg: M2ClientTypes.DatasetOrgAttributes?
        /// The length of a record.
        /// This member is required.
        public var recordLength: M2ClientTypes.RecordLength?
        /// The relative location of the data set in the database or file system.
        public var relativePath: Swift.String?
        /// The storage type of the data set: database or file system. For Micro Focus, database corresponds to datastore and file system corresponds to EFS/FSX. For Blu Age, there is no support of file system and database corresponds to Blusam.
        public var storageType: Swift.String?

        public init(
            datasetName: Swift.String? = nil,
            datasetOrg: M2ClientTypes.DatasetOrgAttributes? = nil,
            recordLength: M2ClientTypes.RecordLength? = nil,
            relativePath: Swift.String? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.datasetName = datasetName
            self.datasetOrg = datasetOrg
            self.recordLength = recordLength
            self.relativePath = relativePath
            self.storageType = storageType
        }
    }

}

extension M2ClientTypes {
    /// Defines an external storage location.
    public enum ExternalLocation {
        /// The URI of the Amazon S3 bucket.
        case s3location(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {
    /// Identifies a specific data set to import from an external location.
    public struct DataSetImportItem {
        /// The data set.
        /// This member is required.
        public var dataSet: M2ClientTypes.DataSet?
        /// The location of the data set.
        /// This member is required.
        public var externalLocation: M2ClientTypes.ExternalLocation?

        public init(
            dataSet: M2ClientTypes.DataSet? = nil,
            externalLocation: M2ClientTypes.ExternalLocation? = nil
        )
        {
            self.dataSet = dataSet
            self.externalLocation = externalLocation
        }
    }

}

extension M2ClientTypes {
    /// Identifies one or more data sets you want to import with the [CreateDataSetImportTask] operation.
    public enum DataSetImportConfig {
        /// The Amazon S3 location of the data sets.
        case s3location(Swift.String)
        /// The data sets.
        case datasets([M2ClientTypes.DataSetImportItem])
        case sdkUnknown(Swift.String)
    }

}

public struct CreateDataSetImportTaskInput {
    /// The unique identifier of the application for which you want to import data sets.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a data set import. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The data set import task configuration.
    /// This member is required.
    public var importConfig: M2ClientTypes.DataSetImportConfig?

    public init(
        applicationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        importConfig: M2ClientTypes.DataSetImportConfig? = nil
    )
    {
        self.applicationId = applicationId
        self.clientToken = clientToken
        self.importConfig = importConfig
    }
}

public struct CreateDataSetImportTaskOutput {
    /// The task identifier. This operation is asynchronous. Use this identifier with the [GetDataSetImportTask] operation to obtain the status of this task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

public struct CreateDeploymentInput {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The version of the application to deploy.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create a deployment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The identifier of the runtime environment where you want to deploy this application.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

public struct CreateDeploymentOutput {
    /// The unique identifier of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

public struct DeleteApplicationInput {
    /// The unique identifier of the application you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct DeleteApplicationOutput {

    public init() { }
}

public struct DeleteApplicationFromEnvironmentInput {
    /// The unique identifier of the application you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the runtime environment where the application was previously deployed.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

public struct DeleteApplicationFromEnvironmentOutput {

    public init() { }
}

public struct GetApplicationInput {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

extension M2ClientTypes {

    public enum DeploymentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploying
        case deployUpdate
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentLifecycle] {
            return [
                .deploying,
                .deployUpdate,
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploying: return "Deploying"
            case .deployUpdate: return "Updating Deployment"
            case .failed: return "Failed"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension M2ClientTypes {
    /// Contains a summary of a deployed application.
    public struct DeployedVersionSummary {
        /// The version of the deployed application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The status of the deployment.
        /// This member is required.
        public var status: M2ClientTypes.DeploymentLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationVersion: Swift.Int? = nil,
            status: M2ClientTypes.DeploymentLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationVersion = applicationVersion
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension M2ClientTypes {

    public enum ApplicationVersionLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationVersionLifecycle] {
            return [
                .available,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension M2ClientTypes {
    /// Defines an application version summary.
    public struct ApplicationVersionSummary {
        /// The application version.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the application version was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The status of the application.
        /// This member is required.
        public var status: M2ClientTypes.ApplicationVersionLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationVersion: Swift.Int? = nil,
            creationTime: Foundation.Date? = nil,
            status: M2ClientTypes.ApplicationVersionLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension M2ClientTypes {
    /// A subset of the attributes that describe a log group. In CloudWatch a log group is a group of log streams that share the same retention, monitoring, and access control settings.
    public struct LogGroupSummary {
        /// The name of the log group.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The type of log.
        /// This member is required.
        public var logType: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            logType: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logType = logType
        }
    }

}

extension M2ClientTypes {

    public enum ApplicationLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case created
        case creating
        case deleting
        case deletingFromEnvironment
        case failed
        case ready
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLifecycle] {
            return [
                .available,
                .created,
                .creating,
                .deleting,
                .deletingFromEnvironment,
                .failed,
                .ready,
                .running,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .created: return "Created"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .deletingFromEnvironment: return "Deleting From Environment"
            case .failed: return "Failed"
            case .ready: return "Ready"
            case .running: return "Running"
            case .starting: return "Starting"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetApplicationOutput {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The timestamp when this application was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The version of the application that is deployed.
    public var deployedVersion: M2ClientTypes.DeployedVersionSummary?
    /// The description of the application.
    public var description: Swift.String?
    /// The type of the target platform for the application.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The identifier of the runtime environment where you want to deploy the application.
    public var environmentId: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The timestamp when you last started the application. Null until the application runs for the first time.
    public var lastStartTime: Foundation.Date?
    /// The latest version of the application.
    /// This member is required.
    public var latestVersion: M2ClientTypes.ApplicationVersionSummary?
    /// The Amazon Resource Name (ARN) for the network load balancer listener created in your Amazon Web Services account. Amazon Web Services Mainframe Modernization creates this listener for you the first time you deploy an application.
    public var listenerArns: [Swift.String]?
    /// The port associated with the network load balancer listener created in your Amazon Web Services account.
    public var listenerPorts: [Swift.Int]?
    /// The public DNS name of the load balancer created in your Amazon Web Services account.
    public var loadBalancerDnsName: Swift.String?
    /// The list of log summaries. Each log summary includes the log type as well as the log group identifier. These are CloudWatch logs. Amazon Web Services Mainframe Modernization pushes the application log to CloudWatch under the customer's account.
    public var logGroups: [M2ClientTypes.LogGroupSummary]?
    /// The unique identifier of the application.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the role associated with the application.
    public var roleArn: Swift.String?
    /// The status of the application.
    /// This member is required.
    public var status: M2ClientTypes.ApplicationLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?
    /// A list of tags associated with the application.
    public var tags: [Swift.String: Swift.String]?
    /// Returns the Amazon Resource Names (ARNs) of the target groups that are attached to the network load balancer.
    public var targetGroupArns: [Swift.String]?

    public init(
        applicationArn: Swift.String? = nil,
        applicationId: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        deployedVersion: M2ClientTypes.DeployedVersionSummary? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        environmentId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastStartTime: Foundation.Date? = nil,
        latestVersion: M2ClientTypes.ApplicationVersionSummary? = nil,
        listenerArns: [Swift.String]? = nil,
        listenerPorts: [Swift.Int]? = nil,
        loadBalancerDnsName: Swift.String? = nil,
        logGroups: [M2ClientTypes.LogGroupSummary]? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: M2ClientTypes.ApplicationLifecycle? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        targetGroupArns: [Swift.String]? = nil
    )
    {
        self.applicationArn = applicationArn
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.deployedVersion = deployedVersion
        self.description = description
        self.engineType = engineType
        self.environmentId = environmentId
        self.kmsKeyId = kmsKeyId
        self.lastStartTime = lastStartTime
        self.latestVersion = latestVersion
        self.listenerArns = listenerArns
        self.listenerPorts = listenerPorts
        self.loadBalancerDnsName = loadBalancerDnsName
        self.logGroups = logGroups
        self.name = name
        self.roleArn = roleArn
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
        self.targetGroupArns = targetGroupArns
    }
}

public struct GetApplicationVersionInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The specific version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
    }
}

public struct GetApplicationVersionOutput {
    /// The specific version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// The timestamp when the application version was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The content of the application definition. This is a JSON object that contains the resource configuration and definitions that identify an application.
    /// This member is required.
    public var definitionContent: Swift.String?
    /// The application description.
    public var description: Swift.String?
    /// The name of the application version.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the application version.
    /// This member is required.
    public var status: M2ClientTypes.ApplicationVersionLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationVersion: Swift.Int? = nil,
        creationTime: Foundation.Date? = nil,
        definitionContent: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        status: M2ClientTypes.ApplicationVersionLifecycle? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationVersion = applicationVersion
        self.creationTime = creationTime
        self.definitionContent = definitionContent
        self.description = description
        self.name = name
        self.status = status
        self.statusReason = statusReason
    }
}

public struct GetBatchJobExecutionInput {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job execution.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.executionId = executionId
    }
}

extension M2ClientTypes {
    /// A batch job identifier in which the batch job to run is identified by the file name and the relative path to the file name.
    public struct FileBatchJobIdentifier {
        /// The file name for the batch job identifier.
        /// This member is required.
        public var fileName: Swift.String?
        /// The relative path to the file name for the batch job identifier.
        public var folderPath: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            folderPath: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.folderPath = folderPath
        }
    }

}

extension M2ClientTypes {
    /// Provides restart step information for the most recent restart operation.
    public struct JobStepRestartMarker {
        /// The procedure step name that a job was restarted from.
        public var fromProcStep: Swift.String?
        /// The step name that a batch job restart was from.
        /// This member is required.
        public var fromStep: Swift.String?
        /// The procedure step name that a batch job was restarted to.
        public var toProcStep: Swift.String?
        /// The step name that a job was restarted to.
        public var toStep: Swift.String?

        public init(
            fromProcStep: Swift.String? = nil,
            fromStep: Swift.String? = nil,
            toProcStep: Swift.String? = nil,
            toStep: Swift.String? = nil
        )
        {
            self.fromProcStep = fromProcStep
            self.fromStep = fromStep
            self.toProcStep = toProcStep
            self.toStep = toStep
        }
    }

}

extension M2ClientTypes {
    /// An identifier for the StartBatchJob API to show that it is a restart operation.
    public struct RestartBatchJobIdentifier {
        /// The executionId from the StartBatchJob response when the job ran for the first time.
        /// This member is required.
        public var executionId: Swift.String?
        /// The restart step information for the most recent restart operation.
        /// This member is required.
        public var jobStepRestartMarker: M2ClientTypes.JobStepRestartMarker?

        public init(
            executionId: Swift.String? = nil,
            jobStepRestartMarker: M2ClientTypes.JobStepRestartMarker? = nil
        )
        {
            self.executionId = executionId
            self.jobStepRestartMarker = jobStepRestartMarker
        }
    }

}

extension M2ClientTypes {
    /// Identifies a specific batch job.
    public enum JobIdentifier {
        /// The name of the file that contains the batch job definition.
        case filename(Swift.String)
        /// The name of the script that contains the batch job definition.
        case scriptname(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {
    /// A batch job identifier in which the batch jobs to run are identified by an Amazon S3 location.
    public struct S3BatchJobIdentifier {
        /// The Amazon S3 bucket that contains the batch job definitions.
        /// This member is required.
        public var bucket: Swift.String?
        /// Identifies the batch job definition. This identifier can also point to any batch job definition that already exists in the application or to one of the batch job definitions within the directory that is specified in keyPrefix.
        /// This member is required.
        public var identifier: M2ClientTypes.JobIdentifier?
        /// The key prefix that specifies the path to the folder in the S3 bucket that has the batch job definitions.
        public var keyPrefix: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            identifier: M2ClientTypes.JobIdentifier? = nil,
            keyPrefix: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.identifier = identifier
            self.keyPrefix = keyPrefix
        }
    }

}

extension M2ClientTypes {
    /// A batch job identifier in which the batch job to run is identified by the script name.
    public struct ScriptBatchJobIdentifier {
        /// The name of the script containing the batch job definition.
        /// This member is required.
        public var scriptName: Swift.String?

        public init(
            scriptName: Swift.String? = nil
        )
        {
            self.scriptName = scriptName
        }
    }

}

extension M2ClientTypes {
    /// Identifies a specific batch job.
    public enum BatchJobIdentifier {
        /// Specifies a file associated with a specific batch job.
        case filebatchjobidentifier(M2ClientTypes.FileBatchJobIdentifier)
        /// A batch job identifier in which the batch job to run is identified by the script name.
        case scriptbatchjobidentifier(M2ClientTypes.ScriptBatchJobIdentifier)
        /// Specifies an Amazon S3 location that identifies the batch jobs that you want to run. Use this identifier to run ad hoc batch jobs.
        case s3batchjobidentifier(M2ClientTypes.S3BatchJobIdentifier)
        /// Specifies the required information for restart, including execution ID and jobsteprestartmarker.
        case restartbatchjobidentifier(M2ClientTypes.RestartBatchJobIdentifier)
        case sdkUnknown(Swift.String)
    }

}

extension M2ClientTypes {

    public enum BatchJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jes2
        case jes3
        case vse
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchJobType] {
            return [
                .jes2,
                .jes3,
                .vse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jes2: return "JES2"
            case .jes3: return "JES3"
            case .vse: return "VSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension M2ClientTypes {

    public enum BatchJobExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case dispatch
        case failed
        case holding
        case purged
        case running
        case submitting
        case succeeded
        case succeededWithWarning
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchJobExecutionStatus] {
            return [
                .cancelled,
                .cancelling,
                .dispatch,
                .failed,
                .holding,
                .purged,
                .running,
                .submitting,
                .succeeded,
                .succeededWithWarning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .cancelling: return "Cancelling"
            case .dispatch: return "Dispatching"
            case .failed: return "Failed"
            case .holding: return "Holding"
            case .purged: return "Purged"
            case .running: return "Running"
            case .submitting: return "Submitting"
            case .succeeded: return "Succeeded"
            case .succeededWithWarning: return "Succeeded With Warning"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetBatchJobExecutionOutput {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of this batch job.
    public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
    /// The timestamp when the batch job execution ended.
    public var endTime: Foundation.Date?
    /// The unique identifier for this batch job execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The unique identifier for this batch job.
    public var jobId: Swift.String?
    /// The name of this batch job.
    public var jobName: Swift.String?
    /// The restart steps information for the most recent restart operation.
    public var jobStepRestartMarker: M2ClientTypes.JobStepRestartMarker?
    /// The type of job.
    public var jobType: M2ClientTypes.BatchJobType?
    /// The user for the job.
    public var jobUser: Swift.String?
    /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see [Batch return codes](https://www.ibm.com/docs/en/was/8.5.5?topic=model-batch-return-codes) in the IBM WebSphere Application Server documentation.
    public var returnCode: Swift.String?
    /// The timestamp when the batch job execution started.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The status of the batch job execution.
    /// This member is required.
    public var status: M2ClientTypes.BatchJobExecutionStatus?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
        endTime: Foundation.Date? = nil,
        executionId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStepRestartMarker: M2ClientTypes.JobStepRestartMarker? = nil,
        jobType: M2ClientTypes.BatchJobType? = nil,
        jobUser: Swift.String? = nil,
        returnCode: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: M2ClientTypes.BatchJobExecutionStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.batchJobIdentifier = batchJobIdentifier
        self.endTime = endTime
        self.executionId = executionId
        self.jobId = jobId
        self.jobName = jobName
        self.jobStepRestartMarker = jobStepRestartMarker
        self.jobType = jobType
        self.jobUser = jobUser
        self.returnCode = returnCode
        self.startTime = startTime
        self.status = status
        self.statusReason = statusReason
    }
}

/// Failed to connect to server, or didnt receive response within expected time period.
public struct ExecutionTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecutionTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Server cannot process the request at the moment.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetDataSetDetailsInput {
    /// The unique identifier of the application that this data set is associated with.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the data set.
    /// This member is required.
    public var dataSetName: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        dataSetName: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.dataSetName = dataSetName
    }
}

extension M2ClientTypes {
    /// The required attributes for a generation data group data set. A generation data set is one of a collection of successive, historically related, catalogued data sets that together are known as a generation data group (GDG). Use this structure when you want to import a GDG. For more information on GDG, see [Generation data sets](https://www.ibm.com/docs/en/zos/2.3.0?topic=guide-generation-data-sets).
    public struct GdgDetailAttributes {
        /// The maximum number of generation data sets, up to 255, in a GDG.
        public var limit: Swift.Int
        /// The disposition of the data set in the catalog.
        public var rollDisposition: Swift.String?

        public init(
            limit: Swift.Int = 0,
            rollDisposition: Swift.String? = nil
        )
        {
            self.limit = limit
            self.rollDisposition = rollDisposition
        }
    }

}

extension M2ClientTypes {
    /// The supported properties for a PO type data set.
    public struct PoDetailAttributes {
        /// The character set encoding of the data set.
        /// This member is required.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes {
    /// The supported properties for a PS type data set.
    public struct PsDetailAttributes {
        /// The character set encoding of the data set.
        /// This member is required.
        public var encoding: Swift.String?
        /// The format of the data set records.
        /// This member is required.
        public var format: Swift.String?

        public init(
            encoding: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.encoding = encoding
            self.format = format
        }
    }

}

extension M2ClientTypes {
    /// The attributes of a VSAM type data set.
    public struct VsamDetailAttributes {
        /// The alternate key definitions, if any. A legacy dataset might not have any alternate key defined, but if those alternate keys definitions exist, provide them as some applications will make use of them.
        public var alternateKeys: [M2ClientTypes.AlternateKey]?
        /// If set to True, enforces loading the data set into cache before its used by the application.
        public var cacheAtStartup: Swift.Bool?
        /// Indicates whether indexes for this dataset are stored as compressed values. If you have a large data set (typically > 100 Mb), consider setting this flag to True.
        public var compressed: Swift.Bool?
        /// The character set used by the data set. Can be ASCII, EBCDIC, or unknown.
        public var encoding: Swift.String?
        /// The primary key of the data set.
        public var primaryKey: M2ClientTypes.PrimaryKey?
        /// The record format of the data set.
        public var recordFormat: Swift.String?

        public init(
            alternateKeys: [M2ClientTypes.AlternateKey]? = nil,
            cacheAtStartup: Swift.Bool? = false,
            compressed: Swift.Bool? = false,
            encoding: Swift.String? = nil,
            primaryKey: M2ClientTypes.PrimaryKey? = nil,
            recordFormat: Swift.String? = nil
        )
        {
            self.alternateKeys = alternateKeys
            self.cacheAtStartup = cacheAtStartup
            self.compressed = compressed
            self.encoding = encoding
            self.primaryKey = primaryKey
            self.recordFormat = recordFormat
        }
    }

}

extension M2ClientTypes {
    /// Additional details about the data set. Different attributes correspond to different data set organizations. The values are populated based on datasetOrg, storageType and backend (Blu Age or Micro Focus).
    public enum DatasetDetailOrgAttributes {
        /// The details of a VSAM data set.
        case vsam(M2ClientTypes.VsamDetailAttributes)
        /// The generation data group of the data set.
        case gdg(M2ClientTypes.GdgDetailAttributes)
        /// The details of a PO type data set.
        case po(M2ClientTypes.PoDetailAttributes)
        /// The details of a PS type data set.
        case ps(M2ClientTypes.PsDetailAttributes)
        case sdkUnknown(Swift.String)
    }

}

public struct GetDataSetDetailsOutput {
    /// The size of the block on disk.
    public var blocksize: Swift.Int?
    /// The timestamp when the data set was created.
    public var creationTime: Foundation.Date?
    /// The name of the data set.
    /// This member is required.
    public var dataSetName: Swift.String?
    /// The type of data set. The only supported value is VSAM.
    public var dataSetOrg: M2ClientTypes.DatasetDetailOrgAttributes?
    /// File size of the dataset.
    public var fileSize: Swift.Int?
    /// The last time the data set was referenced.
    public var lastReferencedTime: Foundation.Date?
    /// The last time the data set was updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The location where the data set is stored.
    public var location: Swift.String?
    /// The length of records in the data set.
    public var recordLength: Swift.Int?

    public init(
        blocksize: Swift.Int? = 0,
        creationTime: Foundation.Date? = nil,
        dataSetName: Swift.String? = nil,
        dataSetOrg: M2ClientTypes.DatasetDetailOrgAttributes? = nil,
        fileSize: Swift.Int? = nil,
        lastReferencedTime: Foundation.Date? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        recordLength: Swift.Int? = 0
    )
    {
        self.blocksize = blocksize
        self.creationTime = creationTime
        self.dataSetName = dataSetName
        self.dataSetOrg = dataSetOrg
        self.fileSize = fileSize
        self.lastReferencedTime = lastReferencedTime
        self.lastUpdatedTime = lastUpdatedTime
        self.location = location
        self.recordLength = recordLength
    }
}

public struct GetDataSetImportTaskInput {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The task identifier returned by the [CreateDataSetImportTask] operation.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.taskId = taskId
    }
}

extension M2ClientTypes {

    public enum DataSetTaskLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case creating
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSetTaskLifecycle] {
            return [
                .completed,
                .creating,
                .failed,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .creating: return "Creating"
            case .failed: return "Failed"
            case .running: return "Running"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension M2ClientTypes {
    /// Represents a summary of data set imports.
    public struct DataSetImportSummary {
        /// The number of data set imports that have failed.
        /// This member is required.
        public var failed: Swift.Int
        /// The number of data set imports that are in progress.
        /// This member is required.
        public var inProgress: Swift.Int
        /// The number of data set imports that are pending.
        /// This member is required.
        public var pending: Swift.Int
        /// The number of data set imports that have succeeded.
        /// This member is required.
        public var succeeded: Swift.Int
        /// The total number of data set imports.
        /// This member is required.
        public var total: Swift.Int

        public init(
            failed: Swift.Int = 0,
            inProgress: Swift.Int = 0,
            pending: Swift.Int = 0,
            succeeded: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.failed = failed
            self.inProgress = inProgress
            self.pending = pending
            self.succeeded = succeeded
            self.total = total
        }
    }

}

public struct GetDataSetImportTaskOutput {
    /// The status of the task.
    /// This member is required.
    public var status: M2ClientTypes.DataSetTaskLifecycle?
    /// A summary of the status of the task.
    public var summary: M2ClientTypes.DataSetImportSummary?
    /// The task identifier.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        status: M2ClientTypes.DataSetTaskLifecycle? = nil,
        summary: M2ClientTypes.DataSetImportSummary? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.status = status
        self.summary = summary
        self.taskId = taskId
    }
}

public struct GetDeploymentInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier for the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentId = deploymentId
    }
}

public struct GetDeploymentOutput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The application version.
    /// This member is required.
    public var applicationVersion: Swift.Int?
    /// The timestamp when the deployment was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The unique identifier of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The status of the deployment.
    /// This member is required.
    public var status: M2ClientTypes.DeploymentLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        applicationVersion: Swift.Int? = nil,
        creationTime: Foundation.Date? = nil,
        deploymentId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        status: M2ClientTypes.DeploymentLifecycle? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.applicationVersion = applicationVersion
        self.creationTime = creationTime
        self.deploymentId = deploymentId
        self.environmentId = environmentId
        self.status = status
        self.statusReason = statusReason
    }
}

public struct ListApplicationsInput {
    /// The unique identifier of the runtime environment where the applications are deployed.
    public var environmentId: Swift.String?
    /// The maximum number of applications to return.
    public var maxResults: Swift.Int?
    /// The names of the applications.
    public var names: [Swift.String]?
    /// A pagination token to control the number of applications displayed in the list.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

extension M2ClientTypes {

    public enum ApplicationDeploymentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case deploying
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationDeploymentLifecycle] {
            return [
                .deployed,
                .deploying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "Deployed"
            case .deploying: return "Deploying"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension M2ClientTypes {
    /// A subset of the possible application attributes. Used in the application list.
    public struct ApplicationSummary {
        /// The Amazon Resource Name (ARN) of the application.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The unique identifier of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the application was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Indicates either an ongoing deployment or if the application has ever deployed successfully.
        public var deploymentStatus: M2ClientTypes.ApplicationDeploymentLifecycle?
        /// The description of the application.
        public var description: Swift.String?
        /// The type of the target platform for this application.
        /// This member is required.
        public var engineType: M2ClientTypes.EngineType?
        /// The unique identifier of the runtime environment that hosts this application.
        public var environmentId: Swift.String?
        /// The timestamp when you last started the application. Null until the application runs for the first time.
        public var lastStartTime: Foundation.Date?
        /// The name of the application.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the role associated with the application.
        public var roleArn: Swift.String?
        /// The status of the application.
        /// This member is required.
        public var status: M2ClientTypes.ApplicationLifecycle?
        /// Indicates the status of the latest version of the application.
        public var versionStatus: M2ClientTypes.ApplicationVersionLifecycle?

        public init(
            applicationArn: Swift.String? = nil,
            applicationId: Swift.String? = nil,
            applicationVersion: Swift.Int? = nil,
            creationTime: Foundation.Date? = nil,
            deploymentStatus: M2ClientTypes.ApplicationDeploymentLifecycle? = nil,
            description: Swift.String? = nil,
            engineType: M2ClientTypes.EngineType? = nil,
            environmentId: Swift.String? = nil,
            lastStartTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: M2ClientTypes.ApplicationLifecycle? = nil,
            versionStatus: M2ClientTypes.ApplicationVersionLifecycle? = nil
        )
        {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentStatus = deploymentStatus
            self.description = description
            self.engineType = engineType
            self.environmentId = environmentId
            self.lastStartTime = lastStartTime
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.versionStatus = versionStatus
        }
    }

}

public struct ListApplicationsOutput {
    /// Returns a list of summary details for all the applications in a runtime environment.
    /// This member is required.
    public var applications: [M2ClientTypes.ApplicationSummary]?
    /// A pagination token that's returned when the response doesn't contain all applications.
    public var nextToken: Swift.String?

    public init(
        applications: [M2ClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct ListApplicationVersionsInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of application versions to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationVersionsOutput {
    /// The list of application versions.
    /// This member is required.
    public var applicationVersions: [M2ClientTypes.ApplicationVersionSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        applicationVersions: [M2ClientTypes.ApplicationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationVersions = applicationVersions
        self.nextToken = nextToken
    }
}

public struct ListBatchJobDefinitionsInput {
    /// The identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of batch job definitions to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// If the batch job definition is a FileBatchJobDefinition, the prefix allows you to search on the file names of FileBatchJobDefinitions.
    public var `prefix`: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.`prefix` = `prefix`
    }
}

extension M2ClientTypes {
    /// A file containing a batch job definition.
    public struct FileBatchJobDefinition {
        /// The name of the file containing the batch job definition.
        /// This member is required.
        public var fileName: Swift.String?
        /// The path to the file containing the batch job definition.
        public var folderPath: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            folderPath: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.folderPath = folderPath
        }
    }

}

extension M2ClientTypes {
    /// A batch job definition contained in a script.
    public struct ScriptBatchJobDefinition {
        /// The name of the script containing the batch job definition.
        /// This member is required.
        public var scriptName: Swift.String?

        public init(
            scriptName: Swift.String? = nil
        )
        {
            self.scriptName = scriptName
        }
    }

}

extension M2ClientTypes {
    /// Defines the details of a batch job.
    public enum BatchJobDefinition {
        /// Specifies a file containing a batch job definition.
        case filebatchjobdefinition(M2ClientTypes.FileBatchJobDefinition)
        /// A script containing a batch job definition.
        case scriptbatchjobdefinition(M2ClientTypes.ScriptBatchJobDefinition)
        case sdkUnknown(Swift.String)
    }

}

public struct ListBatchJobDefinitionsOutput {
    /// The list of batch job definitions.
    /// This member is required.
    public var batchJobDefinitions: [M2ClientTypes.BatchJobDefinition]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        batchJobDefinitions: [M2ClientTypes.BatchJobDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchJobDefinitions = batchJobDefinitions
        self.nextToken = nextToken
    }
}

public struct ListBatchJobExecutionsInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of each batch job execution.
    public var executionIds: [Swift.String]?
    /// The name of each batch job execution.
    public var jobName: Swift.String?
    /// The maximum number of batch job executions to return.
    public var maxResults: Swift.Int?
    /// A pagination token to control the number of batch job executions displayed in the list.
    public var nextToken: Swift.String?
    /// The time after which the batch job executions started.
    public var startedAfter: Foundation.Date?
    /// The time before the batch job executions started.
    public var startedBefore: Foundation.Date?
    /// The status of the batch job executions.
    public var status: M2ClientTypes.BatchJobExecutionStatus?

    public init(
        applicationId: Swift.String? = nil,
        executionIds: [Swift.String]? = nil,
        jobName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startedAfter: Foundation.Date? = nil,
        startedBefore: Foundation.Date? = nil,
        status: M2ClientTypes.BatchJobExecutionStatus? = nil
    )
    {
        self.applicationId = applicationId
        self.executionIds = executionIds
        self.jobName = jobName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startedAfter = startedAfter
        self.startedBefore = startedBefore
        self.status = status
    }
}

extension M2ClientTypes {
    /// A subset of the possible batch job attributes. Used in the batch job list.
    public struct BatchJobExecutionSummary {
        /// The unique identifier of the application that hosts this batch job.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The unique identifier of this batch job.
        public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
        /// The timestamp when this batch job execution ended.
        public var endTime: Foundation.Date?
        /// The unique identifier of this execution of the batch job.
        /// This member is required.
        public var executionId: Swift.String?
        /// The unique identifier of a particular batch job.
        public var jobId: Swift.String?
        /// The name of a particular batch job.
        public var jobName: Swift.String?
        /// The type of a particular batch job execution.
        public var jobType: M2ClientTypes.BatchJobType?
        /// The batch job return code from either the Blu Age or Micro Focus runtime engines. For more information, see [Batch return codes](https://www.ibm.com/docs/en/was/8.5.5?topic=model-batch-return-codes) in the IBM WebSphere Application Server documentation.
        public var returnCode: Swift.String?
        /// The timestamp when a particular batch job execution started.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The status of a particular batch job execution.
        /// This member is required.
        public var status: M2ClientTypes.BatchJobExecutionStatus?

        public init(
            applicationId: Swift.String? = nil,
            batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
            endTime: Foundation.Date? = nil,
            executionId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobType: M2ClientTypes.BatchJobType? = nil,
            returnCode: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: M2ClientTypes.BatchJobExecutionStatus? = nil
        )
        {
            self.applicationId = applicationId
            self.batchJobIdentifier = batchJobIdentifier
            self.endTime = endTime
            self.executionId = executionId
            self.jobId = jobId
            self.jobName = jobName
            self.jobType = jobType
            self.returnCode = returnCode
            self.startTime = startTime
            self.status = status
        }
    }

}

public struct ListBatchJobExecutionsOutput {
    /// Returns a list of batch job executions for an application.
    /// This member is required.
    public var batchJobExecutions: [M2ClientTypes.BatchJobExecutionSummary]?
    /// A pagination token that's returned when the response doesn't contain all batch job executions.
    public var nextToken: Swift.String?

    public init(
        batchJobExecutions: [M2ClientTypes.BatchJobExecutionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchJobExecutions = batchJobExecutions
        self.nextToken = nextToken
    }
}

public struct ListBatchJobRestartPointsInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of each batch job execution.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        executionId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.executionId = executionId
    }
}

extension M2ClientTypes {
    /// Provides information related to a job step.
    public struct JobStep {
        /// The name of a procedure step.
        public var procStepName: Swift.String?
        /// The number of a procedure step.
        public var procStepNumber: Swift.Int
        /// The condition code of a step.
        public var stepCondCode: Swift.String?
        /// The name of a step.
        public var stepName: Swift.String?
        /// The number of a step.
        public var stepNumber: Swift.Int
        /// Specifies if a step can be restarted or not.
        public var stepRestartable: Swift.Bool

        public init(
            procStepName: Swift.String? = nil,
            procStepNumber: Swift.Int = 0,
            stepCondCode: Swift.String? = nil,
            stepName: Swift.String? = nil,
            stepNumber: Swift.Int = 0,
            stepRestartable: Swift.Bool = false
        )
        {
            self.procStepName = procStepName
            self.procStepNumber = procStepNumber
            self.stepCondCode = stepCondCode
            self.stepName = stepName
            self.stepNumber = stepNumber
            self.stepRestartable = stepRestartable
        }
    }

}

public struct ListBatchJobRestartPointsOutput {
    /// Returns all the batch job steps and related information for a batch job that previously ran.
    public var batchJobSteps: [M2ClientTypes.JobStep]?

    public init(
        batchJobSteps: [M2ClientTypes.JobStep]? = nil
    )
    {
        self.batchJobSteps = batchJobSteps
    }
}

public struct ListDataSetImportHistoryInput {
    /// The unique identifier of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension M2ClientTypes {
    /// Contains information about a data set import task.
    public struct DataSetImportTask {
        /// The status of the data set import task.
        /// This member is required.
        public var status: M2ClientTypes.DataSetTaskLifecycle?
        /// If dataset import failed, the failure reason will show here.
        public var statusReason: Swift.String?
        /// A summary of the data set import task.
        /// This member is required.
        public var summary: M2ClientTypes.DataSetImportSummary?
        /// The identifier of the data set import task.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            status: M2ClientTypes.DataSetTaskLifecycle? = nil,
            statusReason: Swift.String? = nil,
            summary: M2ClientTypes.DataSetImportSummary? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
            self.summary = summary
            self.taskId = taskId
        }
    }

}

public struct ListDataSetImportHistoryOutput {
    /// The data set import tasks.
    /// This member is required.
    public var dataSetImportTasks: [M2ClientTypes.DataSetImportTask]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        dataSetImportTasks: [M2ClientTypes.DataSetImportTask]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSetImportTasks = dataSetImportTasks
        self.nextToken = nextToken
    }
}

public struct ListDataSetsInput {
    /// The unique identifier of the application for which you want to list the associated data sets.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// Filter dataset name matching the specified pattern. Can use * and % as wild cards.
    public var nameFilter: Swift.String?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?
    /// The prefix of the data set name, which you can use to filter the list of data sets.
    public var `prefix`: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nameFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nameFilter = nameFilter
        self.nextToken = nextToken
        self.`prefix` = `prefix`
    }
}

extension M2ClientTypes {
    /// A subset of the possible data set attributes.
    public struct DataSetSummary {
        /// The timestamp when the data set was created.
        public var creationTime: Foundation.Date?
        /// The name of the data set.
        /// This member is required.
        public var dataSetName: Swift.String?
        /// The type of data set. The only supported value is VSAM.
        public var dataSetOrg: Swift.String?
        /// The format of the data set.
        public var format: Swift.String?
        /// The last time the data set was referenced.
        public var lastReferencedTime: Foundation.Date?
        /// The last time the data set was updated.
        public var lastUpdatedTime: Foundation.Date?

        public init(
            creationTime: Foundation.Date? = nil,
            dataSetName: Swift.String? = nil,
            dataSetOrg: Swift.String? = nil,
            format: Swift.String? = nil,
            lastReferencedTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.dataSetName = dataSetName
            self.dataSetOrg = dataSetOrg
            self.format = format
            self.lastReferencedTime = lastReferencedTime
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

public struct ListDataSetsOutput {
    /// The list of data sets, containing information including the creation time, the data set name, the data set organization, the data set format, and the last time the data set was referenced or updated.
    /// This member is required.
    public var dataSets: [M2ClientTypes.DataSetSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        dataSets: [M2ClientTypes.DataSetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSets = dataSets
        self.nextToken = nextToken
    }
}

public struct ListDeploymentsInput {
    /// The application identifier.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension M2ClientTypes {
    /// A subset of information about a specific deployment.
    public struct DeploymentSummary {
        /// The unique identifier of the application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The version of the application.
        /// This member is required.
        public var applicationVersion: Swift.Int?
        /// The timestamp when the deployment was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The unique identifier of the deployment.
        /// This member is required.
        public var deploymentId: Swift.String?
        /// The unique identifier of the runtime environment.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The current status of the deployment.
        /// This member is required.
        public var status: M2ClientTypes.DeploymentLifecycle?
        /// The reason for the reported status.
        public var statusReason: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            applicationVersion: Swift.Int? = nil,
            creationTime: Foundation.Date? = nil,
            deploymentId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            status: M2ClientTypes.DeploymentLifecycle? = nil,
            statusReason: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.applicationVersion = applicationVersion
            self.creationTime = creationTime
            self.deploymentId = deploymentId
            self.environmentId = environmentId
            self.status = status
            self.statusReason = statusReason
        }
    }

}

public struct ListDeploymentsOutput {
    /// The list of deployments that is returned.
    /// This member is required.
    public var deployments: [M2ClientTypes.DeploymentSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        deployments: [M2ClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

public struct StartApplicationInput {
    /// The unique identifier of the application you want to start.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct StartApplicationOutput {

    public init() { }
}

public struct StartBatchJobInput {
    /// The unique identifier of the application associated with this batch job.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The unique identifier of the batch job.
    /// This member is required.
    public var batchJobIdentifier: M2ClientTypes.BatchJobIdentifier?
    /// The collection of batch job parameters. For details about limits for keys and values, see [Coding variables in JCL](https://www.ibm.com/docs/en/workload-automation/9.3.0?topic=zos-coding-variables-in-jcl).
    public var jobParams: [Swift.String: Swift.String]?

    public init(
        applicationId: Swift.String? = nil,
        batchJobIdentifier: M2ClientTypes.BatchJobIdentifier? = nil,
        jobParams: [Swift.String: Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.batchJobIdentifier = batchJobIdentifier
        self.jobParams = jobParams
    }
}

public struct StartBatchJobOutput {
    /// The unique identifier of this execution of the batch job.
    /// This member is required.
    public var executionId: Swift.String?

    public init(
        executionId: Swift.String? = nil
    )
    {
        self.executionId = executionId
    }
}

public struct StopApplicationInput {
    /// The unique identifier of the application you want to stop.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Stopping an application process can take a long time. Setting this parameter to true lets you force stop the application so you don't need to wait until the process finishes to apply another action on the application. The default value is false.
    public var forceStop: Swift.Bool

    public init(
        applicationId: Swift.String? = nil,
        forceStop: Swift.Bool = false
    )
    {
        self.applicationId = applicationId
        self.forceStop = forceStop
    }
}

public struct StopApplicationOutput {

    public init() { }
}

public struct UpdateApplicationInput {
    /// The unique identifier of the application you want to update.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The current version of the application to update.
    /// This member is required.
    public var currentApplicationVersion: Swift.Int?
    /// The application definition for this application. You can specify either inline JSON or an S3 bucket location.
    public var definition: M2ClientTypes.Definition?
    /// The description of the application to update.
    public var description: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        currentApplicationVersion: Swift.Int? = nil,
        definition: M2ClientTypes.Definition? = nil,
        description: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.currentApplicationVersion = currentApplicationVersion
        self.definition = definition
        self.description = description
    }
}

public struct UpdateApplicationOutput {
    /// The new version of the application.
    /// This member is required.
    public var applicationVersion: Swift.Int?

    public init(
        applicationVersion: Swift.Int? = nil
    )
    {
        self.applicationVersion = applicationVersion
    }
}

extension M2ClientTypes {
    /// Defines the details of a high availability configuration.
    public struct HighAvailabilityConfig {
        /// The number of instances in a high availability configuration. The minimum possible value is 1 and the maximum is 100.
        /// This member is required.
        public var desiredCapacity: Swift.Int?

        public init(
            desiredCapacity: Swift.Int? = nil
        )
        {
            self.desiredCapacity = desiredCapacity
        }
    }

}

extension M2ClientTypes {
    /// Defines the storage configuration for an Amazon EFS file system.
    public struct EfsStorageConfiguration {
        /// The file system identifier.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The mount point for the file system.
        /// This member is required.
        public var mountPoint: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            mountPoint: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }
    }

}

extension M2ClientTypes {
    /// Defines the storage configuration for an Amazon FSx file system.
    public struct FsxStorageConfiguration {
        /// The file system identifier.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The mount point for the file system.
        /// This member is required.
        public var mountPoint: Swift.String?

        public init(
            fileSystemId: Swift.String? = nil,
            mountPoint: Swift.String? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.mountPoint = mountPoint
        }
    }

}

extension M2ClientTypes {
    /// Defines the storage configuration for a runtime environment.
    public enum StorageConfiguration {
        /// Defines the storage configuration for an Amazon EFS file system.
        case efs(M2ClientTypes.EfsStorageConfiguration)
        /// Defines the storage configuration for an Amazon FSx file system.
        case fsx(M2ClientTypes.FsxStorageConfiguration)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateEnvironmentInput {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request to create an environment. The service generates the clientToken when the API call is triggered. The token expires after one hour, so if you retry the API within this timeframe with the same clientToken, you will get the same response. The service also handles deleting the clientToken after it expires.
    public var clientToken: Swift.String?
    /// The description of the runtime environment.
    public var description: Swift.String?
    /// The engine type for the runtime environment.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The version of the engine type for the runtime environment.
    public var engineVersion: Swift.String?
    /// The details of a high availability configuration for this runtime environment.
    public var highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    /// The type of instance for the runtime environment.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The name of the runtime environment. Must be unique within the account.
    /// This member is required.
    public var name: Swift.String?
    /// Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00. If you do not provide a value, a random system-generated value will be assigned.
    public var preferredMaintenanceWindow: Swift.String?
    /// Specifies whether the runtime environment is publicly accessible.
    public var publiclyAccessible: Swift.Bool
    /// The list of security groups for the VPC associated with this runtime environment.
    public var securityGroupIds: [Swift.String]?
    /// Optional. The storage configurations for this runtime environment.
    public var storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    /// The list of subnets associated with the VPC for this runtime environment.
    public var subnetIds: [Swift.String]?
    /// The tags for the runtime environment.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig? = nil,
        instanceType: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool = false,
        securityGroupIds: [Swift.String]? = nil,
        storageConfigurations: [M2ClientTypes.StorageConfiguration]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.highAvailabilityConfig = highAvailabilityConfig
        self.instanceType = instanceType
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.storageConfigurations = storageConfigurations
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

public struct CreateEnvironmentOutput {
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

public struct DeleteEnvironmentInput {
    /// The unique identifier of the runtime environment you want to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

public struct DeleteEnvironmentOutput {

    public init() { }
}

public struct GetEnvironmentInput {
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

extension M2ClientTypes {
    /// The information about the maintenance schedule.
    public struct MaintenanceSchedule {
        /// The time the scheduled maintenance is to end.
        public var endTime: Foundation.Date?
        /// The time the scheduled maintenance is to start.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension M2ClientTypes {
    /// The scheduled maintenance for a runtime engine.
    public struct PendingMaintenance {
        /// The specific runtime engine that the maintenance schedule applies to.
        public var engineVersion: Swift.String?
        /// The maintenance schedule for the runtime engine version.
        public var schedule: M2ClientTypes.MaintenanceSchedule?

        public init(
            engineVersion: Swift.String? = nil,
            schedule: M2ClientTypes.MaintenanceSchedule? = nil
        )
        {
            self.engineVersion = engineVersion
            self.schedule = schedule
        }
    }

}

extension M2ClientTypes {

    public enum EnvironmentLifecycle: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentLifecycle] {
            return [
                .available,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case .creating: return "Creating"
            case .deleting: return "Deleting"
            case .failed: return "Failed"
            case .updating: return "Updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetEnvironmentOutput {
    /// The number of instances included in the runtime environment. A standalone runtime environment has a maximum of one instance. Currently, a high availability runtime environment has a maximum of two instances.
    public var actualCapacity: Swift.Int?
    /// The timestamp when the runtime environment was created.
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The description of the runtime environment.
    public var description: Swift.String?
    /// The target platform for the runtime environment.
    /// This member is required.
    public var engineType: M2ClientTypes.EngineType?
    /// The version of the runtime engine.
    /// This member is required.
    public var engineVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the runtime environment.
    /// This member is required.
    public var environmentArn: Swift.String?
    /// The unique identifier of the runtime environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The desired capacity of the high availability configuration for the runtime environment.
    public var highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig?
    /// The type of instance underlying the runtime environment.
    /// This member is required.
    public var instanceType: Swift.String?
    /// The identifier of a customer managed key.
    public var kmsKeyId: Swift.String?
    /// The Amazon Resource Name (ARN) for the load balancer used with the runtime environment.
    public var loadBalancerArn: Swift.String?
    /// The name of the runtime environment. Must be unique within the account.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the pending maintenance scheduled on this environment.
    public var pendingMaintenance: M2ClientTypes.PendingMaintenance?
    /// The maintenance window for the runtime environment. If you don't provide a value for the maintenance window, the service assigns a random value.
    public var preferredMaintenanceWindow: Swift.String?
    /// Whether applications running in this runtime environment are publicly accessible.
    public var publiclyAccessible: Swift.Bool
    /// The unique identifiers of the security groups assigned to this runtime environment.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The status of the runtime environment.
    /// This member is required.
    public var status: M2ClientTypes.EnvironmentLifecycle?
    /// The reason for the reported status.
    public var statusReason: Swift.String?
    /// The storage configurations defined for the runtime environment.
    public var storageConfigurations: [M2ClientTypes.StorageConfiguration]?
    /// The unique identifiers of the subnets assigned to this runtime environment.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags defined for this runtime environment.
    public var tags: [Swift.String: Swift.String]?
    /// The unique identifier for the VPC used with this runtime environment.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        actualCapacity: Swift.Int? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        engineType: M2ClientTypes.EngineType? = nil,
        engineVersion: Swift.String? = nil,
        environmentArn: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        highAvailabilityConfig: M2ClientTypes.HighAvailabilityConfig? = nil,
        instanceType: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        loadBalancerArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pendingMaintenance: M2ClientTypes.PendingMaintenance? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        publiclyAccessible: Swift.Bool = false,
        securityGroupIds: [Swift.String]? = nil,
        status: M2ClientTypes.EnvironmentLifecycle? = nil,
        statusReason: Swift.String? = nil,
        storageConfigurations: [M2ClientTypes.StorageConfiguration]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.actualCapacity = actualCapacity
        self.creationTime = creationTime
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.environmentArn = environmentArn
        self.environmentId = environmentId
        self.highAvailabilityConfig = highAvailabilityConfig
        self.instanceType = instanceType
        self.kmsKeyId = kmsKeyId
        self.loadBalancerArn = loadBalancerArn
        self.name = name
        self.pendingMaintenance = pendingMaintenance
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.publiclyAccessible = publiclyAccessible
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.statusReason = statusReason
        self.storageConfigurations = storageConfigurations
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

public struct ListEnvironmentsInput {
    /// The engine type for the runtime environment.
    public var engineType: M2ClientTypes.EngineType?
    /// The maximum number of runtime environments to return.
    public var maxResults: Swift.Int?
    /// The names of the runtime environments. Must be unique within the account.
    public var names: [Swift.String]?
    /// A pagination token to control the number of runtime environments displayed in the list.
    public var nextToken: Swift.String?

    public init(
        engineType: M2ClientTypes.EngineType? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

extension M2ClientTypes {
    /// Contains a subset of the possible runtime environment attributes. Used in the environment list.
    public struct EnvironmentSummary {
        /// The timestamp when the runtime environment was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The target platform for the runtime environment.
        /// This member is required.
        public var engineType: M2ClientTypes.EngineType?
        /// The version of the runtime engine.
        /// This member is required.
        public var engineVersion: Swift.String?
        /// The Amazon Resource Name (ARN) of a particular runtime environment.
        /// This member is required.
        public var environmentArn: Swift.String?
        /// The unique identifier of a particular runtime environment.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The instance type of the runtime environment.
        /// This member is required.
        public var instanceType: Swift.String?
        /// The name of the runtime environment.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the runtime environment
        /// This member is required.
        public var status: M2ClientTypes.EnvironmentLifecycle?

        public init(
            creationTime: Foundation.Date? = nil,
            engineType: M2ClientTypes.EngineType? = nil,
            engineVersion: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            status: M2ClientTypes.EnvironmentLifecycle? = nil
        )
        {
            self.creationTime = creationTime
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.instanceType = instanceType
            self.name = name
            self.status = status
        }
    }

}

public struct ListEnvironmentsOutput {
    /// Returns a list of summary details for all the runtime environments in your account.
    /// This member is required.
    public var environments: [M2ClientTypes.EnvironmentSummary]?
    /// A pagination token that's returned when the response doesn't contain all the runtime environments.
    public var nextToken: Swift.String?

    public init(
        environments: [M2ClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

public struct UpdateEnvironmentInput {
    /// Indicates whether to update the runtime environment during the maintenance window. The default is false. Currently, Amazon Web Services Mainframe Modernization accepts the engineVersion parameter only if applyDuringMaintenanceWindow is true. If any parameter other than engineVersion is provided in UpdateEnvironmentRequest, it will fail if applyDuringMaintenanceWindow is set to true.
    public var applyDuringMaintenanceWindow: Swift.Bool
    /// The desired capacity for the runtime environment to update. The minimum possible value is 0 and the maximum is 100.
    public var desiredCapacity: Swift.Int?
    /// The version of the runtime engine for the runtime environment.
    public var engineVersion: Swift.String?
    /// The unique identifier of the runtime environment that you want to update.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Forces the updates on the environment. This option is needed if the applications in the environment are not stopped or if there are ongoing application-related activities in the environment. If you use this option, be aware that it could lead to data corruption in the applications, and that you might need to perform repair and recovery procedures for the applications. This option is not needed if the attribute being updated is preferredMaintenanceWindow.
    public var forceUpdate: Swift.Bool
    /// The instance type for the runtime environment to update.
    public var instanceType: Swift.String?
    /// Configures the maintenance window that you want for the runtime environment. The maintenance window must have the format ddd:hh24:mi-ddd:hh24:mi and must be less than 24 hours. The following two examples are valid maintenance windows: sun:23:45-mon:00:15 or sat:01:00-sat:03:00. If you do not provide a value, a random system-generated value will be assigned.
    public var preferredMaintenanceWindow: Swift.String?

    public init(
        applyDuringMaintenanceWindow: Swift.Bool = false,
        desiredCapacity: Swift.Int? = nil,
        engineVersion: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        forceUpdate: Swift.Bool = false,
        instanceType: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil
    )
    {
        self.applyDuringMaintenanceWindow = applyDuringMaintenanceWindow
        self.desiredCapacity = desiredCapacity
        self.engineVersion = engineVersion
        self.environmentId = environmentId
        self.forceUpdate = forceUpdate
        self.instanceType = instanceType
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
    }
}

public struct UpdateEnvironmentOutput {
    /// The unique identifier of the runtime environment that was updated.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

public struct GetSignedBluinsightsUrlOutput {
    /// Single sign-on AWS Blu Insights URL.
    /// This member is required.
    public var signedBiUrl: Swift.String?

    public init(
        signedBiUrl: Swift.String? = nil
    )
    {
        self.signedBiUrl = signedBiUrl
    }
}

public struct ListEngineVersionsInput {
    /// The type of target platform.
    public var engineType: M2ClientTypes.EngineType?
    /// The maximum number of objects to return.
    public var maxResults: Swift.Int?
    /// A pagination token returned from a previous call to this operation. This specifies the next item to return. To return to the beginning of the list, exclude this parameter.
    public var nextToken: Swift.String?

    public init(
        engineType: M2ClientTypes.EngineType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension M2ClientTypes {
    /// A subset of information about the engine version for a specific application.
    public struct EngineVersionsSummary {
        /// The type of target platform for the application.
        /// This member is required.
        public var engineType: Swift.String?
        /// The version of the engine type used by the application.
        /// This member is required.
        public var engineVersion: Swift.String?

        public init(
            engineType: Swift.String? = nil,
            engineVersion: Swift.String? = nil
        )
        {
            self.engineType = engineType
            self.engineVersion = engineVersion
        }
    }

}

public struct ListEngineVersionsOutput {
    /// Returns the engine versions.
    /// This member is required.
    public var engineVersions: [M2ClientTypes.EngineVersionsSummary]?
    /// If there are more items to return, this contains a token that is passed to a subsequent call to this operation to retrieve the next set of items.
    public var nextToken: Swift.String?

    public init(
        engineVersions: [M2ClientTypes.EngineVersionsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engineVersions = engineVersions
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension CancelBatchJobExecutionInput {

    static func urlPathProvider(_ value: CancelBatchJobExecutionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let executionId = value.executionId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions/\(executionId.urlPercentEncoding())/cancel"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateDataSetImportTaskInput {

    static func urlPathProvider(_ value: CreateDataSetImportTaskInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-task"
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments"
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/environments"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension DeleteApplicationFromEnvironmentInput {

    static func urlPathProvider(_ value: DeleteApplicationFromEnvironmentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environment/\(environmentId.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension GetApplicationVersionInput {

    static func urlPathProvider(_ value: GetApplicationVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let applicationVersion = value.applicationVersion else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions/\(applicationVersion)"
    }
}

extension GetBatchJobExecutionInput {

    static func urlPathProvider(_ value: GetBatchJobExecutionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let executionId = value.executionId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions/\(executionId.urlPercentEncoding())"
    }
}

extension GetDataSetDetailsInput {

    static func urlPathProvider(_ value: GetDataSetDetailsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let dataSetName = value.dataSetName else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/datasets/\(dataSetName.urlPercentEncoding())"
    }
}

extension GetDataSetImportTaskInput {

    static func urlPathProvider(_ value: GetDataSetImportTaskInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-tasks/\(taskId.urlPercentEncoding())"
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension GetSignedBluinsightsUrlInput {

    static func urlPathProvider(_ value: GetSignedBluinsightsUrlInput) -> Swift.String? {
        return "/signed-bi-url"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let names = value.names {
            names.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "names".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let environmentId = value.environmentId {
            let environmentIdQueryItem = Smithy.URIQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            items.append(environmentIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationVersionsInput {

    static func urlPathProvider(_ value: ListApplicationVersionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions"
    }
}

extension ListApplicationVersionsInput {

    static func queryItemProvider(_ value: ListApplicationVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBatchJobDefinitionsInput {

    static func urlPathProvider(_ value: ListBatchJobDefinitionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-definitions"
    }
}

extension ListBatchJobDefinitionsInput {

    static func queryItemProvider(_ value: ListBatchJobDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        return items
    }
}

extension ListBatchJobExecutionsInput {

    static func urlPathProvider(_ value: ListBatchJobExecutionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions"
    }
}

extension ListBatchJobExecutionsInput {

    static func queryItemProvider(_ value: ListBatchJobExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let jobName = value.jobName {
            let jobNameQueryItem = Smithy.URIQueryItem(name: "jobName".urlPercentEncoding(), value: Swift.String(jobName).urlPercentEncoding())
            items.append(jobNameQueryItem)
        }
        if let executionIds = value.executionIds {
            executionIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "executionIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let startedAfter = value.startedAfter {
            let startedAfterQueryItem = Smithy.URIQueryItem(name: "startedAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startedAfter)).urlPercentEncoding())
            items.append(startedAfterQueryItem)
        }
        if let startedBefore = value.startedBefore {
            let startedBeforeQueryItem = Smithy.URIQueryItem(name: "startedBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startedBefore)).urlPercentEncoding())
            items.append(startedBeforeQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListBatchJobRestartPointsInput {

    static func urlPathProvider(_ value: ListBatchJobRestartPointsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let executionId = value.executionId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job-executions/\(executionId.urlPercentEncoding())/steps"
    }
}

extension ListDataSetImportHistoryInput {

    static func urlPathProvider(_ value: ListDataSetImportHistoryInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dataset-import-tasks"
    }
}

extension ListDataSetImportHistoryInput {

    static func queryItemProvider(_ value: ListDataSetImportHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataSetsInput {

    static func urlPathProvider(_ value: ListDataSetsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/datasets"
    }
}

extension ListDataSetsInput {

    static func queryItemProvider(_ value: ListDataSetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let nameFilter = value.nameFilter {
            let nameFilterQueryItem = Smithy.URIQueryItem(name: "nameFilter".urlPercentEncoding(), value: Swift.String(nameFilter).urlPercentEncoding())
            items.append(nameFilterQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/deployments"
    }
}

extension ListDeploymentsInput {

    static func queryItemProvider(_ value: ListDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEngineVersionsInput {

    static func urlPathProvider(_ value: ListEngineVersionsInput) -> Swift.String? {
        return "/engine-versions"
    }
}

extension ListEngineVersionsInput {

    static func queryItemProvider(_ value: ListEngineVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = value.engineType {
            let engineTypeQueryItem = Smithy.URIQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/environments"
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let names = value.names {
            names.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "names".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let engineType = value.engineType {
            let engineTypeQueryItem = Smithy.URIQueryItem(name: "engineType".urlPercentEncoding(), value: Swift.String(engineType.rawValue).urlPercentEncoding())
            items.append(engineTypeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartApplicationInput {

    static func urlPathProvider(_ value: StartApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/start"
    }
}

extension StartBatchJobInput {

    static func urlPathProvider(_ value: StartBatchJobInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/batch-job"
    }
}

extension StopApplicationInput {

    static func urlPathProvider(_ value: StopApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let environmentId = value.environmentId else {
            return nil
        }
        return "/environments/\(environmentId.urlPercentEncoding())"
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["definition"].write(value.definition, with: M2ClientTypes.Definition.write(value:to:))
        try writer["description"].write(value.description)
        try writer["engineType"].write(value.engineType)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDataSetImportTaskInput {

    static func write(value: CreateDataSetImportTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["importConfig"].write(value.importConfig, with: M2ClientTypes.DataSetImportConfig.write(value:to:))
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationVersion"].write(value.applicationVersion)
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["engineType"].write(value.engineType)
        try writer["engineVersion"].write(value.engineVersion)
        try writer["highAvailabilityConfig"].write(value.highAvailabilityConfig, with: M2ClientTypes.HighAvailabilityConfig.write(value:to:))
        try writer["instanceType"].write(value.instanceType)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["name"].write(value.name)
        try writer["preferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["publiclyAccessible"].write(value.publiclyAccessible)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["storageConfigurations"].writeList(value.storageConfigurations, memberWritingClosure: M2ClientTypes.StorageConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartBatchJobInput {

    static func write(value: StartBatchJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["batchJobIdentifier"].write(value.batchJobIdentifier, with: M2ClientTypes.BatchJobIdentifier.write(value:to:))
        try writer["jobParams"].writeMap(value.jobParams, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopApplicationInput {

    static func write(value: StopApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["forceStop"].write(value.forceStop)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["currentApplicationVersion"].write(value.currentApplicationVersion)
        try writer["definition"].write(value.definition, with: M2ClientTypes.Definition.write(value:to:))
        try writer["description"].write(value.description)
    }
}

extension UpdateEnvironmentInput {

    static func write(value: UpdateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applyDuringMaintenanceWindow"].write(value.applyDuringMaintenanceWindow)
        try writer["desiredCapacity"].write(value.desiredCapacity)
        try writer["engineVersion"].write(value.engineVersion)
        try writer["forceUpdate"].write(value.forceUpdate)
        try writer["instanceType"].write(value.instanceType)
        try writer["preferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
    }
}

extension CancelBatchJobExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelBatchJobExecutionOutput {
        return CancelBatchJobExecutionOutput()
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent() ?? ""
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        return value
    }
}

extension CreateDataSetImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSetImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSetImportTaskOutput()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentId = try reader["deploymentId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteApplicationFromEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationFromEnvironmentOutput {
        return DeleteApplicationFromEnvironmentOutput()
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        return DeleteEnvironmentOutput()
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.applicationArn = try reader["applicationArn"].readIfPresent() ?? ""
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deployedVersion = try reader["deployedVersion"].readIfPresent(with: M2ClientTypes.DeployedVersionSummary.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.lastStartTime = try reader["lastStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestVersion = try reader["latestVersion"].readIfPresent(with: M2ClientTypes.ApplicationVersionSummary.read(from:))
        value.listenerArns = try reader["listenerArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.listenerPorts = try reader["listenerPorts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.loadBalancerDnsName = try reader["loadBalancerDnsName"].readIfPresent()
        value.logGroups = try reader["logGroups"].readListIfPresent(memberReadingClosure: M2ClientTypes.LogGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targetGroupArns = try reader["targetGroupArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetApplicationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationVersionOutput()
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.definitionContent = try reader["definitionContent"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetBatchJobExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBatchJobExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBatchJobExecutionOutput()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.batchJobIdentifier = try reader["batchJobIdentifier"].readIfPresent(with: M2ClientTypes.BatchJobIdentifier.read(from:))
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.jobStepRestartMarker = try reader["jobStepRestartMarker"].readIfPresent(with: M2ClientTypes.JobStepRestartMarker.read(from:))
        value.jobType = try reader["jobType"].readIfPresent()
        value.jobUser = try reader["jobUser"].readIfPresent()
        value.returnCode = try reader["returnCode"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetDataSetDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSetDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSetDetailsOutput()
        value.blocksize = try reader["blocksize"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataSetName = try reader["dataSetName"].readIfPresent() ?? ""
        value.dataSetOrg = try reader["dataSetOrg"].readIfPresent(with: M2ClientTypes.DatasetDetailOrgAttributes.read(from:))
        value.fileSize = try reader["fileSize"].readIfPresent()
        value.lastReferencedTime = try reader["lastReferencedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.recordLength = try reader["recordLength"].readIfPresent()
        return value
    }
}

extension GetDataSetImportTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSetImportTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSetImportTaskOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.summary = try reader["summary"].readIfPresent(with: M2ClientTypes.DataSetImportSummary.read(from:))
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deploymentId = try reader["deploymentId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.actualCapacity = try reader["actualCapacity"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.engineVersion = try reader["engineVersion"].readIfPresent() ?? ""
        value.environmentArn = try reader["environmentArn"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.highAvailabilityConfig = try reader["highAvailabilityConfig"].readIfPresent(with: M2ClientTypes.HighAvailabilityConfig.read(from:))
        value.instanceType = try reader["instanceType"].readIfPresent() ?? ""
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.loadBalancerArn = try reader["loadBalancerArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.pendingMaintenance = try reader["pendingMaintenance"].readIfPresent(with: M2ClientTypes.PendingMaintenance.read(from:))
        value.preferredMaintenanceWindow = try reader["preferredMaintenanceWindow"].readIfPresent()
        value.publiclyAccessible = try reader["publiclyAccessible"].readIfPresent() ?? false
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.storageConfigurations = try reader["storageConfigurations"].readListIfPresent(memberReadingClosure: M2ClientTypes.StorageConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension GetSignedBluinsightsUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSignedBluinsightsUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSignedBluinsightsUrlOutput()
        value.signedBiUrl = try reader["signedBiUrl"].readIfPresent() ?? ""
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["applications"].readListIfPresent(memberReadingClosure: M2ClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationVersionsOutput()
        value.applicationVersions = try reader["applicationVersions"].readListIfPresent(memberReadingClosure: M2ClientTypes.ApplicationVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBatchJobDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchJobDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchJobDefinitionsOutput()
        value.batchJobDefinitions = try reader["batchJobDefinitions"].readListIfPresent(memberReadingClosure: M2ClientTypes.BatchJobDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBatchJobExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchJobExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchJobExecutionsOutput()
        value.batchJobExecutions = try reader["batchJobExecutions"].readListIfPresent(memberReadingClosure: M2ClientTypes.BatchJobExecutionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBatchJobRestartPointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBatchJobRestartPointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBatchJobRestartPointsOutput()
        value.batchJobSteps = try reader["batchJobSteps"].readListIfPresent(memberReadingClosure: M2ClientTypes.JobStep.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDataSetImportHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSetImportHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSetImportHistoryOutput()
        value.dataSetImportTasks = try reader["dataSetImportTasks"].readListIfPresent(memberReadingClosure: M2ClientTypes.DataSetImportTask.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSetsOutput()
        value.dataSets = try reader["dataSets"].readListIfPresent(memberReadingClosure: M2ClientTypes.DataSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["deployments"].readListIfPresent(memberReadingClosure: M2ClientTypes.DeploymentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEngineVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngineVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngineVersionsOutput()
        value.engineVersions = try reader["engineVersions"].readListIfPresent(memberReadingClosure: M2ClientTypes.EngineVersionsSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: M2ClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension StartApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartApplicationOutput {
        return StartApplicationOutput()
    }
}

extension StartBatchJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBatchJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBatchJobOutput()
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        return value
    }
}

extension StopApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopApplicationOutput {
        return StopApplicationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentOutput()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

enum CancelBatchJobExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSetImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationFromEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBatchJobExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSetDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExecutionTimeoutException": return try ExecutionTimeoutException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSetImportTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSignedBluinsightsUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchJobDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchJobExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBatchJobRestartPointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSetImportHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ExecutionTimeoutException": return try ExecutionTimeoutException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngineVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBatchJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: M2ClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecutionTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ExecutionTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ExecutionTimeoutException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension M2ClientTypes.ApplicationVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.ApplicationVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.ApplicationVersionSummary()
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension M2ClientTypes.DeployedVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DeployedVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.DeployedVersionSummary()
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.LogGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.LogGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.LogGroupSummary()
        value.logType = try reader["logType"].readIfPresent() ?? ""
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.BatchJobIdentifier {

    static func write(value: M2ClientTypes.BatchJobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filebatchjobidentifier(filebatchjobidentifier):
                try writer["fileBatchJobIdentifier"].write(filebatchjobidentifier, with: M2ClientTypes.FileBatchJobIdentifier.write(value:to:))
            case let .restartbatchjobidentifier(restartbatchjobidentifier):
                try writer["restartBatchJobIdentifier"].write(restartbatchjobidentifier, with: M2ClientTypes.RestartBatchJobIdentifier.write(value:to:))
            case let .s3batchjobidentifier(s3batchjobidentifier):
                try writer["s3BatchJobIdentifier"].write(s3batchjobidentifier, with: M2ClientTypes.S3BatchJobIdentifier.write(value:to:))
            case let .scriptbatchjobidentifier(scriptbatchjobidentifier):
                try writer["scriptBatchJobIdentifier"].write(scriptbatchjobidentifier, with: M2ClientTypes.ScriptBatchJobIdentifier.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.BatchJobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fileBatchJobIdentifier":
                return .filebatchjobidentifier(try reader["fileBatchJobIdentifier"].read(with: M2ClientTypes.FileBatchJobIdentifier.read(from:)))
            case "scriptBatchJobIdentifier":
                return .scriptbatchjobidentifier(try reader["scriptBatchJobIdentifier"].read(with: M2ClientTypes.ScriptBatchJobIdentifier.read(from:)))
            case "s3BatchJobIdentifier":
                return .s3batchjobidentifier(try reader["s3BatchJobIdentifier"].read(with: M2ClientTypes.S3BatchJobIdentifier.read(from:)))
            case "restartBatchJobIdentifier":
                return .restartbatchjobidentifier(try reader["restartBatchJobIdentifier"].read(with: M2ClientTypes.RestartBatchJobIdentifier.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension M2ClientTypes.RestartBatchJobIdentifier {

    static func write(value: M2ClientTypes.RestartBatchJobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionId"].write(value.executionId)
        try writer["jobStepRestartMarker"].write(value.jobStepRestartMarker, with: M2ClientTypes.JobStepRestartMarker.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.RestartBatchJobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.RestartBatchJobIdentifier()
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.jobStepRestartMarker = try reader["jobStepRestartMarker"].readIfPresent(with: M2ClientTypes.JobStepRestartMarker.read(from:))
        return value
    }
}

extension M2ClientTypes.JobStepRestartMarker {

    static func write(value: M2ClientTypes.JobStepRestartMarker?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fromProcStep"].write(value.fromProcStep)
        try writer["fromStep"].write(value.fromStep)
        try writer["toProcStep"].write(value.toProcStep)
        try writer["toStep"].write(value.toStep)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.JobStepRestartMarker {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.JobStepRestartMarker()
        value.fromStep = try reader["fromStep"].readIfPresent() ?? ""
        value.fromProcStep = try reader["fromProcStep"].readIfPresent()
        value.toStep = try reader["toStep"].readIfPresent()
        value.toProcStep = try reader["toProcStep"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.S3BatchJobIdentifier {

    static func write(value: M2ClientTypes.S3BatchJobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["identifier"].write(value.identifier, with: M2ClientTypes.JobIdentifier.write(value:to:))
        try writer["keyPrefix"].write(value.keyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.S3BatchJobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.S3BatchJobIdentifier()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        value.identifier = try reader["identifier"].readIfPresent(with: M2ClientTypes.JobIdentifier.read(from:))
        return value
    }
}

extension M2ClientTypes.JobIdentifier {

    static func write(value: M2ClientTypes.JobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filename(filename):
                try writer["fileName"].write(filename)
            case let .scriptname(scriptname):
                try writer["scriptName"].write(scriptname)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.JobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fileName":
                return .filename(try reader["fileName"].read())
            case "scriptName":
                return .scriptname(try reader["scriptName"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension M2ClientTypes.ScriptBatchJobIdentifier {

    static func write(value: M2ClientTypes.ScriptBatchJobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scriptName"].write(value.scriptName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.ScriptBatchJobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.ScriptBatchJobIdentifier()
        value.scriptName = try reader["scriptName"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.FileBatchJobIdentifier {

    static func write(value: M2ClientTypes.FileBatchJobIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileName"].write(value.fileName)
        try writer["folderPath"].write(value.folderPath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.FileBatchJobIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.FileBatchJobIdentifier()
        value.fileName = try reader["fileName"].readIfPresent() ?? ""
        value.folderPath = try reader["folderPath"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.DatasetDetailOrgAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DatasetDetailOrgAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "vsam":
                return .vsam(try reader["vsam"].read(with: M2ClientTypes.VsamDetailAttributes.read(from:)))
            case "gdg":
                return .gdg(try reader["gdg"].read(with: M2ClientTypes.GdgDetailAttributes.read(from:)))
            case "po":
                return .po(try reader["po"].read(with: M2ClientTypes.PoDetailAttributes.read(from:)))
            case "ps":
                return .ps(try reader["ps"].read(with: M2ClientTypes.PsDetailAttributes.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension M2ClientTypes.PsDetailAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.PsDetailAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.PsDetailAttributes()
        value.format = try reader["format"].readIfPresent() ?? ""
        value.encoding = try reader["encoding"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.PoDetailAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.PoDetailAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.PoDetailAttributes()
        value.format = try reader["format"].readIfPresent() ?? ""
        value.encoding = try reader["encoding"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.GdgDetailAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.GdgDetailAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.GdgDetailAttributes()
        value.limit = try reader["limit"].readIfPresent() ?? 0
        value.rollDisposition = try reader["rollDisposition"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.VsamDetailAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.VsamDetailAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.VsamDetailAttributes()
        value.encoding = try reader["encoding"].readIfPresent()
        value.recordFormat = try reader["recordFormat"].readIfPresent()
        value.compressed = try reader["compressed"].readIfPresent()
        value.cacheAtStartup = try reader["cacheAtStartup"].readIfPresent()
        value.primaryKey = try reader["primaryKey"].readIfPresent(with: M2ClientTypes.PrimaryKey.read(from:))
        value.alternateKeys = try reader["alternateKeys"].readListIfPresent(memberReadingClosure: M2ClientTypes.AlternateKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension M2ClientTypes.AlternateKey {

    static func write(value: M2ClientTypes.AlternateKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowDuplicates"].write(value.allowDuplicates)
        try writer["length"].write(value.length)
        try writer["name"].write(value.name)
        try writer["offset"].write(value.offset)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.AlternateKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.AlternateKey()
        value.name = try reader["name"].readIfPresent()
        value.offset = try reader["offset"].readIfPresent() ?? 0
        value.length = try reader["length"].readIfPresent() ?? 0
        value.allowDuplicates = try reader["allowDuplicates"].readIfPresent() ?? false
        return value
    }
}

extension M2ClientTypes.PrimaryKey {

    static func write(value: M2ClientTypes.PrimaryKey?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["length"].write(value.length)
        try writer["name"].write(value.name)
        try writer["offset"].write(value.offset)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.PrimaryKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.PrimaryKey()
        value.name = try reader["name"].readIfPresent()
        value.offset = try reader["offset"].readIfPresent() ?? 0
        value.length = try reader["length"].readIfPresent() ?? 0
        return value
    }
}

extension M2ClientTypes.DataSetImportSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DataSetImportSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.DataSetImportSummary()
        value.total = try reader["total"].readIfPresent() ?? 0
        value.succeeded = try reader["succeeded"].readIfPresent() ?? 0
        value.failed = try reader["failed"].readIfPresent() ?? 0
        value.pending = try reader["pending"].readIfPresent() ?? 0
        value.inProgress = try reader["inProgress"].readIfPresent() ?? 0
        return value
    }
}

extension M2ClientTypes.StorageConfiguration {

    static func write(value: M2ClientTypes.StorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .efs(efs):
                try writer["efs"].write(efs, with: M2ClientTypes.EfsStorageConfiguration.write(value:to:))
            case let .fsx(fsx):
                try writer["fsx"].write(fsx, with: M2ClientTypes.FsxStorageConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "efs":
                return .efs(try reader["efs"].read(with: M2ClientTypes.EfsStorageConfiguration.read(from:)))
            case "fsx":
                return .fsx(try reader["fsx"].read(with: M2ClientTypes.FsxStorageConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension M2ClientTypes.FsxStorageConfiguration {

    static func write(value: M2ClientTypes.FsxStorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file-system-id"].write(value.fileSystemId)
        try writer["mount-point"].write(value.mountPoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.FsxStorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.FsxStorageConfiguration()
        value.fileSystemId = try reader["file-system-id"].readIfPresent() ?? ""
        value.mountPoint = try reader["mount-point"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.EfsStorageConfiguration {

    static func write(value: M2ClientTypes.EfsStorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file-system-id"].write(value.fileSystemId)
        try writer["mount-point"].write(value.mountPoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.EfsStorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.EfsStorageConfiguration()
        value.fileSystemId = try reader["file-system-id"].readIfPresent() ?? ""
        value.mountPoint = try reader["mount-point"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.HighAvailabilityConfig {

    static func write(value: M2ClientTypes.HighAvailabilityConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredCapacity"].write(value.desiredCapacity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.HighAvailabilityConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.HighAvailabilityConfig()
        value.desiredCapacity = try reader["desiredCapacity"].readIfPresent() ?? 0
        return value
    }
}

extension M2ClientTypes.PendingMaintenance {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.PendingMaintenance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.PendingMaintenance()
        value.schedule = try reader["schedule"].readIfPresent(with: M2ClientTypes.MaintenanceSchedule.read(from:))
        value.engineVersion = try reader["engineVersion"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.MaintenanceSchedule {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.MaintenanceSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.MaintenanceSchedule()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension M2ClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.ApplicationSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.applicationArn = try reader["applicationArn"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.lastStartTime = try reader["lastStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.versionStatus = try reader["versionStatus"].readIfPresent()
        value.deploymentStatus = try reader["deploymentStatus"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.BatchJobDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.BatchJobDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fileBatchJobDefinition":
                return .filebatchjobdefinition(try reader["fileBatchJobDefinition"].read(with: M2ClientTypes.FileBatchJobDefinition.read(from:)))
            case "scriptBatchJobDefinition":
                return .scriptbatchjobdefinition(try reader["scriptBatchJobDefinition"].read(with: M2ClientTypes.ScriptBatchJobDefinition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension M2ClientTypes.ScriptBatchJobDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.ScriptBatchJobDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.ScriptBatchJobDefinition()
        value.scriptName = try reader["scriptName"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.FileBatchJobDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.FileBatchJobDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.FileBatchJobDefinition()
        value.fileName = try reader["fileName"].readIfPresent() ?? ""
        value.folderPath = try reader["folderPath"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.BatchJobExecutionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.BatchJobExecutionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.BatchJobExecutionSummary()
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.jobType = try reader["jobType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.returnCode = try reader["returnCode"].readIfPresent()
        value.batchJobIdentifier = try reader["batchJobIdentifier"].readIfPresent(with: M2ClientTypes.BatchJobIdentifier.read(from:))
        return value
    }
}

extension M2ClientTypes.JobStep {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.JobStep {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.JobStep()
        value.stepNumber = try reader["stepNumber"].readIfPresent() ?? 0
        value.stepName = try reader["stepName"].readIfPresent()
        value.procStepNumber = try reader["procStepNumber"].readIfPresent() ?? 0
        value.procStepName = try reader["procStepName"].readIfPresent()
        value.stepCondCode = try reader["stepCondCode"].readIfPresent()
        value.stepRestartable = try reader["stepRestartable"].readIfPresent() ?? false
        return value
    }
}

extension M2ClientTypes.DataSetImportTask {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DataSetImportTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.DataSetImportTask()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.summary = try reader["summary"].readIfPresent(with: M2ClientTypes.DataSetImportSummary.read(from:))
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.DataSetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DataSetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.DataSetSummary()
        value.dataSetName = try reader["dataSetName"].readIfPresent() ?? ""
        value.dataSetOrg = try reader["dataSetOrg"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastReferencedTime = try reader["lastReferencedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension M2ClientTypes.DeploymentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.DeploymentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.DeploymentSummary()
        value.deploymentId = try reader["deploymentId"].readIfPresent() ?? ""
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.applicationVersion = try reader["applicationVersion"].readIfPresent() ?? 0
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension M2ClientTypes.EngineVersionsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.EngineVersionsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.EngineVersionsSummary()
        value.engineType = try reader["engineType"].readIfPresent() ?? ""
        value.engineVersion = try reader["engineVersion"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.EnvironmentSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.environmentArn = try reader["environmentArn"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.instanceType = try reader["instanceType"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.engineType = try reader["engineType"].readIfPresent() ?? .sdkUnknown("")
        value.engineVersion = try reader["engineVersion"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension M2ClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> M2ClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = M2ClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension M2ClientTypes.Definition {

    static func write(value: M2ClientTypes.Definition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .content(content):
                try writer["content"].write(content)
            case let .s3location(s3location):
                try writer["s3Location"].write(s3location)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension M2ClientTypes.DataSetImportConfig {

    static func write(value: M2ClientTypes.DataSetImportConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datasets(datasets):
                try writer["dataSets"].writeList(datasets, memberWritingClosure: M2ClientTypes.DataSetImportItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .s3location(s3location):
                try writer["s3Location"].write(s3location)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension M2ClientTypes.DataSetImportItem {

    static func write(value: M2ClientTypes.DataSetImportItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSet"].write(value.dataSet, with: M2ClientTypes.DataSet.write(value:to:))
        try writer["externalLocation"].write(value.externalLocation, with: M2ClientTypes.ExternalLocation.write(value:to:))
    }
}

extension M2ClientTypes.ExternalLocation {

    static func write(value: M2ClientTypes.ExternalLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3location(s3location):
                try writer["s3Location"].write(s3location)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension M2ClientTypes.DataSet {

    static func write(value: M2ClientTypes.DataSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetName"].write(value.datasetName)
        try writer["datasetOrg"].write(value.datasetOrg, with: M2ClientTypes.DatasetOrgAttributes.write(value:to:))
        try writer["recordLength"].write(value.recordLength, with: M2ClientTypes.RecordLength.write(value:to:))
        try writer["relativePath"].write(value.relativePath)
        try writer["storageType"].write(value.storageType)
    }
}

extension M2ClientTypes.RecordLength {

    static func write(value: M2ClientTypes.RecordLength?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
    }
}

extension M2ClientTypes.DatasetOrgAttributes {

    static func write(value: M2ClientTypes.DatasetOrgAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .gdg(gdg):
                try writer["gdg"].write(gdg, with: M2ClientTypes.GdgAttributes.write(value:to:))
            case let .po(po):
                try writer["po"].write(po, with: M2ClientTypes.PoAttributes.write(value:to:))
            case let .ps(ps):
                try writer["ps"].write(ps, with: M2ClientTypes.PsAttributes.write(value:to:))
            case let .vsam(vsam):
                try writer["vsam"].write(vsam, with: M2ClientTypes.VsamAttributes.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension M2ClientTypes.PsAttributes {

    static func write(value: M2ClientTypes.PsAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encoding"].write(value.encoding)
        try writer["format"].write(value.format)
    }
}

extension M2ClientTypes.PoAttributes {

    static func write(value: M2ClientTypes.PoAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encoding"].write(value.encoding)
        try writer["format"].write(value.format)
        try writer["memberFileExtensions"].writeList(value.memberFileExtensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension M2ClientTypes.GdgAttributes {

    static func write(value: M2ClientTypes.GdgAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["limit"].write(value.limit)
        try writer["rollDisposition"].write(value.rollDisposition)
    }
}

extension M2ClientTypes.VsamAttributes {

    static func write(value: M2ClientTypes.VsamAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alternateKeys"].writeList(value.alternateKeys, memberWritingClosure: M2ClientTypes.AlternateKey.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["compressed"].write(value.compressed)
        try writer["encoding"].write(value.encoding)
        try writer["format"].write(value.format)
        try writer["primaryKey"].write(value.primaryKey, with: M2ClientTypes.PrimaryKey.write(value:to:))
    }
}

public enum M2ClientTypes {}
