//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension FMSClient {
    /// Paginate over `[ListAdminAccountsForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAdminAccountsForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAdminAccountsForOrganizationOutput`
    public func listAdminAccountsForOrganizationPaginated(input: ListAdminAccountsForOrganizationInput) -> ClientRuntime.PaginatorSequence<ListAdminAccountsForOrganizationInput, ListAdminAccountsForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<ListAdminAccountsForOrganizationInput, ListAdminAccountsForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAdminAccountsForOrganization(input:))
    }
}

extension ListAdminAccountsForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAdminAccountsForOrganizationInput {
        return ListAdminAccountsForOrganizationInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAdminAccountsForOrganizationInput, OperationStackOutput == ListAdminAccountsForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAdminAccountsForOrganizationPaginated`
    /// to access the nested member `[FMSClientTypes.AdminAccountSummary]`
    /// - Returns: `[FMSClientTypes.AdminAccountSummary]`
    public func adminAccounts() async throws -> [FMSClientTypes.AdminAccountSummary] {
        return try await self.asyncCompactMap { item in item.adminAccounts }
    }
}
extension FMSClient {
    /// Paginate over `[ListAdminsManagingAccountOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAdminsManagingAccountInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAdminsManagingAccountOutput`
    public func listAdminsManagingAccountPaginated(input: ListAdminsManagingAccountInput) -> ClientRuntime.PaginatorSequence<ListAdminsManagingAccountInput, ListAdminsManagingAccountOutput> {
        return ClientRuntime.PaginatorSequence<ListAdminsManagingAccountInput, ListAdminsManagingAccountOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAdminsManagingAccount(input:))
    }
}

extension ListAdminsManagingAccountInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAdminsManagingAccountInput {
        return ListAdminsManagingAccountInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAdminsManagingAccountInput, OperationStackOutput == ListAdminsManagingAccountOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAdminsManagingAccountPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func adminAccounts() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.adminAccounts }
    }
}
extension FMSClient {
    /// Paginate over `[ListAppsListsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppsListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppsListsOutput`
    public func listAppsListsPaginated(input: ListAppsListsInput) -> ClientRuntime.PaginatorSequence<ListAppsListsInput, ListAppsListsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppsListsInput, ListAppsListsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAppsLists(input:))
    }
}

extension ListAppsListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppsListsInput {
        return ListAppsListsInput(
            defaultLists: self.defaultLists,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppsListsInput, OperationStackOutput == ListAppsListsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppsListsPaginated`
    /// to access the nested member `[FMSClientTypes.AppsListDataSummary]`
    /// - Returns: `[FMSClientTypes.AppsListDataSummary]`
    public func appsLists() async throws -> [FMSClientTypes.AppsListDataSummary] {
        return try await self.asyncCompactMap { item in item.appsLists }
    }
}
extension FMSClient {
    /// Paginate over `[ListComplianceStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComplianceStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComplianceStatusOutput`
    public func listComplianceStatusPaginated(input: ListComplianceStatusInput) -> ClientRuntime.PaginatorSequence<ListComplianceStatusInput, ListComplianceStatusOutput> {
        return ClientRuntime.PaginatorSequence<ListComplianceStatusInput, ListComplianceStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComplianceStatus(input:))
    }
}

extension ListComplianceStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComplianceStatusInput {
        return ListComplianceStatusInput(
            maxResults: self.maxResults,
            nextToken: token,
            policyId: self.policyId
        )}
}

extension PaginatorSequence where OperationStackInput == ListComplianceStatusInput, OperationStackOutput == ListComplianceStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComplianceStatusPaginated`
    /// to access the nested member `[FMSClientTypes.PolicyComplianceStatus]`
    /// - Returns: `[FMSClientTypes.PolicyComplianceStatus]`
    public func policyComplianceStatusList() async throws -> [FMSClientTypes.PolicyComplianceStatus] {
        return try await self.asyncCompactMap { item in item.policyComplianceStatusList }
    }
}
extension FMSClient {
    /// Paginate over `[ListMemberAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMemberAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMemberAccountsOutput`
    public func listMemberAccountsPaginated(input: ListMemberAccountsInput) -> ClientRuntime.PaginatorSequence<ListMemberAccountsInput, ListMemberAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListMemberAccountsInput, ListMemberAccountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMemberAccounts(input:))
    }
}

extension ListMemberAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMemberAccountsInput {
        return ListMemberAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMemberAccountsInput, OperationStackOutput == ListMemberAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMemberAccountsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func memberAccounts() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.memberAccounts }
    }
}
extension FMSClient {
    /// Paginate over `[ListPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutput`
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPoliciesInput, OperationStackOutput == ListPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
    /// to access the nested member `[FMSClientTypes.PolicySummary]`
    /// - Returns: `[FMSClientTypes.PolicySummary]`
    public func policyList() async throws -> [FMSClientTypes.PolicySummary] {
        return try await self.asyncCompactMap { item in item.policyList }
    }
}
extension FMSClient {
    /// Paginate over `[ListProtocolsListsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProtocolsListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProtocolsListsOutput`
    public func listProtocolsListsPaginated(input: ListProtocolsListsInput) -> ClientRuntime.PaginatorSequence<ListProtocolsListsInput, ListProtocolsListsOutput> {
        return ClientRuntime.PaginatorSequence<ListProtocolsListsInput, ListProtocolsListsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProtocolsLists(input:))
    }
}

extension ListProtocolsListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtocolsListsInput {
        return ListProtocolsListsInput(
            defaultLists: self.defaultLists,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListProtocolsListsInput, OperationStackOutput == ListProtocolsListsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProtocolsListsPaginated`
    /// to access the nested member `[FMSClientTypes.ProtocolsListDataSummary]`
    /// - Returns: `[FMSClientTypes.ProtocolsListDataSummary]`
    public func protocolsLists() async throws -> [FMSClientTypes.ProtocolsListDataSummary] {
        return try await self.asyncCompactMap { item in item.protocolsLists }
    }
}
extension FMSClient {
    /// Paginate over `[ListThirdPartyFirewallFirewallPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThirdPartyFirewallFirewallPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThirdPartyFirewallFirewallPoliciesOutput`
    public func listThirdPartyFirewallFirewallPoliciesPaginated(input: ListThirdPartyFirewallFirewallPoliciesInput) -> ClientRuntime.PaginatorSequence<ListThirdPartyFirewallFirewallPoliciesInput, ListThirdPartyFirewallFirewallPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListThirdPartyFirewallFirewallPoliciesInput, ListThirdPartyFirewallFirewallPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThirdPartyFirewallFirewallPolicies(input:))
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThirdPartyFirewallFirewallPoliciesInput {
        return ListThirdPartyFirewallFirewallPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            thirdPartyFirewall: self.thirdPartyFirewall
        )}
}

extension PaginatorSequence where OperationStackInput == ListThirdPartyFirewallFirewallPoliciesInput, OperationStackOutput == ListThirdPartyFirewallFirewallPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThirdPartyFirewallFirewallPoliciesPaginated`
    /// to access the nested member `[FMSClientTypes.ThirdPartyFirewallFirewallPolicy]`
    /// - Returns: `[FMSClientTypes.ThirdPartyFirewallFirewallPolicy]`
    public func thirdPartyFirewallFirewallPolicies() async throws -> [FMSClientTypes.ThirdPartyFirewallFirewallPolicy] {
        return try await self.asyncCompactMap { item in item.thirdPartyFirewallFirewallPolicies }
    }
}
